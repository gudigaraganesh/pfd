wxWindows 2.5.1: A portable C++ and Python GUI toolkit
Julian Smart, Robert Roebling, Vadim Zeitlin, Robin Dunn, et al February 2004

i


Contents
Chapter 1 Copyright notice ............................................................................. xvi Chapter 2 Introduction ....................................................................................... 1
What is wxWindows? ................................................................................................ 1 Why another cross-platform development tool? ........................................................ 1 wxWindows requirements ......................................................................................... 3 Availability and location of wxWindows ..................................................................... 3 Acknowledgements................................................................................................... 4

Chapter 3 Multi-platform development with wxWindows................................ 5
Include files............................................................................................................... 5 Libraries.................................................................................................................... 5 Configuration ............................................................................................................ 6 Makefiles .................................................................................................................. 6 Windows-specific files............................................................................................... 6 Allocating and deleting wxWindows objects .............................................................. 7 Architecture dependency .......................................................................................... 7 Conditional compilation............................................................................................. 8 C++ issues................................................................................................................ 8 File handling ............................................................................................................. 9

Chapter 4 Utilities and libraries supplied with wxWindows.......................... 10 Chapter 5 Programming strategies ................................................................. 12
Strategies for reducing programming errors............................................................ 12 Strategies for portability .......................................................................................... 12 Strategies for debugging......................................................................................... 13

Chapter 6 Libraries list ..................................................................................... 15 Chapter 7 Alphabetical class reference .......................................................... 18
wxAcceleratorEntry................................................................................................. 18 wxAcceleratorTable ................................................................................................ 19 wxAccessible .......................................................................................................... 22 wxActivateEvent ..................................................................................................... 29 wxApp..................................................................................................................... 31 wxArray .................................................................................................................. 42

i


CONTENTS
wxArrayString ......................................................................................................... 53 wxArtProvider ......................................................................................................... 59 wxAutomationObject............................................................................................... 63 wxBitmap ................................................................................................................ 67 wxBitmapButton...................................................................................................... 80 wxBitmapDataObject .............................................................................................. 84 wxBitmapHandler.................................................................................................... 85 wxBoxSizer............................................................................................................. 89 wxBrush.................................................................................................................. 90 wxBrushList ............................................................................................................ 96 wxBufferedDC ........................................................................................................ 98 wxBufferedPaintDC ................................................................................................ 99 wxBufferedInputStream ........................................................................................ 100 wxBufferedOutputStream...................................................................................... 100 wxBusyCursor ...................................................................................................... 101 wxBusyInfo ........................................................................................................... 102 wxButton............................................................................................................... 103 wxCalculateLayoutEvent....................................................................................... 107 wxCalendarCtrl ..................................................................................................... 108 wxCalendarDateAttr.............................................................................................. 114 wxCalendarEvent.................................................................................................. 117 wxCaret ................................................................................................................ 117 wxCheckBox......................................................................................................... 120 wxCheckListBox ................................................................................................... 124 wxChoice .............................................................................................................. 127 wxClassInfo .......................................................................................................... 130 wxClient ................................................................................................................ 131 wxClientDC........................................................................................................... 133 wxClientData ........................................................................................................ 134 wxClientDataContainer ......................................................................................... 134 wxClipboard.......................................................................................................... 136 wxCloseEvent....................................................................................................... 139 wxCmdLineParser ................................................................................................ 141 wxColour............................................................................................................... 150 wxColourData ....................................................................................................... 153 wxColourDatabase ............................................................................................... 155 wxColourDialog..................................................................................................... 156 wxComboBox ....................................................................................................... 158

ii


CONTENTS
wxCommand......................................................................................................... 163 wxCommandEvent................................................................................................ 164 wxCommandProcessor......................................................................................... 170 wxCondition .......................................................................................................... 173 wxConfigBase....................................................................................................... 177 wxConnection ....................................................................................................... 191 wxContextHelp ..................................................................................................... 195 wxContextHelpButton ........................................................................................... 196 wxControl.............................................................................................................. 198 wxControlWithItems.............................................................................................. 199 wxCountingOutputStream..................................................................................... 205 wxCriticalSection .................................................................................................. 206 wxCriticalSectionLocker........................................................................................ 207 wxCSConv............................................................................................................ 208 wxCursor .............................................................................................................. 209 wxCustomDataObject ........................................................................................... 215 wxDataFormat ...................................................................................................... 217 wxDataInputStream .............................................................................................. 219 wxDataObject ....................................................................................................... 222 wxDataObjectComposite ...................................................................................... 225 wxDataObjectSimple ............................................................................................ 226 wxDataOutputStream............................................................................................ 228 wxDateSpan ......................................................................................................... 230 wxDateTime.......................................................................................................... 236 wxDateTimeHolidayAuthority ................................................................................ 262 wxDateTimeWorkDays ......................................................................................... 262 wxDb .................................................................................................................... 263 wxDbColDataPtr ................................................................................................... 292 wxDbColDef.......................................................................................................... 292 wxDbColFor.......................................................................................................... 293 wxDbColInf ........................................................................................................... 293 wxDbConnectInf ................................................................................................... 294 wxDbIdxDef .......................................................................................................... 300 wxDbInf ................................................................................................................ 300 wxDbTable............................................................................................................ 301 wxDbTableInf........................................................................................................ 336 wxDbGridColInfo................................................................................................... 336 wxDbGridTableBase............................................................................................. 338

iii


CONTENTS
wxDebugContext .................................................................................................. 341 wxDebugStreamBuf .............................................................................................. 346 wxDelegateRendererNative .................................................................................. 346 wxDC.................................................................................................................... 347 wxDCClipper......................................................................................................... 367 wxDialog............................................................................................................... 367 wxDialUpEvent ..................................................................................................... 376 wxDialUpManager ................................................................................................ 377 wxDir .................................................................................................................... 380 wxDirDialog .......................................................................................................... 384 wxDirTraverser ..................................................................................................... 386 wxDisplay ............................................................................................................. 388 wxDllLoader.......................................................................................................... 390 wxDocChildFrame ................................................................................................ 392 wxDocManager..................................................................................................... 394 wxDocMDIChildFrame .......................................................................................... 403 wxDocMDIParentFrame........................................................................................ 405 wxDocParentFrame .............................................................................................. 406 wxDocTemplate .................................................................................................... 408 wxDocument......................................................................................................... 413 wxDragImage ....................................................................................................... 421 wxDropFilesEvent................................................................................................. 425 wxDropSource ...................................................................................................... 427 wxDropTarget ....................................................................................................... 429 wxDynamicLibrary ................................................................................................ 433 wxEncodingConverter........................................................................................... 435 wxEraseEvent....................................................................................................... 438 wxEvent ................................................................................................................ 439 wxEvtHandler ....................................................................................................... 443 wxFFile ................................................................................................................. 451 wxFFileInputStream.............................................................................................. 456 wxFFileOutputStream ........................................................................................... 457 wxFFileStream...................................................................................................... 458 wxFile ................................................................................................................... 458 wxFileDataObject.................................................................................................. 465 wxFileDialog ......................................................................................................... 466 wxFileDropTarget ................................................................................................. 470 wxFileHistory ........................................................................................................ 471

iv


CONTENTS
wxFileInputStream ................................................................................................ 474 wxFileName.......................................................................................................... 475 wxFileOutputStream ............................................................................................. 490 wxFileStream........................................................................................................ 491 wxFileSystem ....................................................................................................... 492 wxFileSystemHandler ........................................................................................... 494 wxFileType ........................................................................................................... 497 wxFilterInputStream.............................................................................................. 501 wxFilterOutputStream ........................................................................................... 502 wxFindDialogEvent ............................................................................................... 502 wxFindReplaceData.............................................................................................. 503 wxFindReplaceDialog ........................................................................................... 505 wxFlexGridSizer.................................................................................................... 506 wxFocusEvent ...................................................................................................... 509 wxFont.................................................................................................................. 510 wxFontData .......................................................................................................... 519 wxFontDialog........................................................................................................ 522 wxFontEnumerator ............................................................................................... 523 wxFontList ............................................................................................................ 525 wxFontMapper ...................................................................................................... 526 wxFrame............................................................................................................... 530 wxFSFile............................................................................................................... 543 wxFTP .................................................................................................................. 545 wxGauge .............................................................................................................. 551 wxGBPosition ....................................................................................................... 555 wxGBSizerItem ..................................................................................................... 557 wxGBSpan............................................................................................................ 558 wxGDIObject ........................................................................................................ 560 wxGenericDirCtrl................................................................................................... 560 wxGenericValidator............................................................................................... 564 wxGLCanvas ........................................................................................................ 566 wxGrid .................................................................................................................. 569 wxGridCellAttr....................................................................................................... 606 wxGridBagSizer .................................................................................................... 609 wxGridCellBoolEditor ............................................................................................ 612 wxGridCellChoiceEditor ........................................................................................ 612 wxGridCellEditor ................................................................................................... 613 wxGridCellFloatEditor ........................................................................................... 616

v


CONTENTS
wxGridCellNumberEditor ...................................................................................... 616 wxGridCellTextEditor ............................................................................................ 617 wxGridEditorCreatedEvent ................................................................................... 618 wxGridEvent ......................................................................................................... 619 wxGridRangeSelectEvent ..................................................................................... 622 wxGridSizeEvent .................................................................................................. 624 wxGridCellBoolRenderer ...................................................................................... 625 wxGridCellFloatRenderer...................................................................................... 626 wxGridCellNumberRenderer ................................................................................. 627 wxGridCellRenderer ............................................................................................. 627 wxGridCellStringRenderer .................................................................................... 628 wxGridTableBase ................................................................................................. 629 wxGridSizer .......................................................................................................... 633 wxGzipInputStream .............................................................................................. 635 wxGzipOutputStream............................................................................................ 636 wxHashMap.......................................................................................................... 637 wxHashTable........................................................................................................ 642 wxHelpController .................................................................................................. 644 wxHelpControllerHelpProvider .............................................................................. 649 wxHelpEvent......................................................................................................... 650 wxHelpProvider..................................................................................................... 652 wxHtmlCell............................................................................................................ 653 wxHtmlColourCell ................................................................................................. 659 wxHtmlContainerCell ............................................................................................ 659 wxHtmlDCRenderer.............................................................................................. 665 wxHtmlEasyPrinting.............................................................................................. 668 wxHtmlFilter.......................................................................................................... 671 wxHtmlHelpController ........................................................................................... 672 wxHtmlHelpData ................................................................................................... 677 wxHtmlHelpFrame ................................................................................................ 678 wxHtmlLinkInfo ..................................................................................................... 682 wxHtmlListBox ...................................................................................................... 683 wxHtmlParser ....................................................................................................... 685 wxHtmlPrintout...................................................................................................... 690 wxHtmlTag............................................................................................................ 692 wxHtmlTagHandler ............................................................................................... 696 wxHtmlTagsModule .............................................................................................. 697 wxHtmlWidgetCell................................................................................................. 698

vi


CONTENTS
wxHtmlWindow ..................................................................................................... 699 wxHtmlWinParser ................................................................................................. 708 wxHtmlWinTagHandler ......................................................................................... 714 wxHTTP................................................................................................................ 715 wxIcon .................................................................................................................. 716 wxIconBundle ....................................................................................................... 723 wxIconLocation..................................................................................................... 725 wxIconizeEvent..................................................................................................... 725 wxIdleEvent .......................................................................................................... 726 wxImage ............................................................................................................... 728 wxImageHandler................................................................................................... 750 wxImageList.......................................................................................................... 754 wxIndividualLayoutConstraint ............................................................................... 758 wxInitDialogEvent ................................................................................................. 761 wxInputStream...................................................................................................... 762 wxIPaddress ......................................................................................................... 764 wxIPV4address..................................................................................................... 766 wxJoystick ............................................................................................................ 768 wxJoystickEvent ................................................................................................... 774 wxKeyEvent.......................................................................................................... 777 wxLayoutAlgorithm ............................................................................................... 781 wxLayoutConstraints ............................................................................................ 784 wxList ................................................................................................................... 786 wxListbook............................................................................................................ 792 wxListBox ............................................................................................................. 793 wxListCtrl .............................................................................................................. 799 wxListEvent .......................................................................................................... 818 wxListItem............................................................................................................. 821 wxListView............................................................................................................ 825 wxLocale............................................................................................................... 828 wxLog ................................................................................................................... 843 wxLogChain.......................................................................................................... 850 wxLogGui.............................................................................................................. 851 wxLogNull ............................................................................................................. 852 wxLogPassThrough .............................................................................................. 853 wxLogStderr ......................................................................................................... 854 wxLogStream........................................................................................................ 854 wxLogTextCtrl....................................................................................................... 855

vii


CONTENTS
wxLogWindow ...................................................................................................... 855 wxLongLong ......................................................................................................... 857 wxMask ................................................................................................................ 860 wxMaximizeEvent ................................................................................................. 862 wxMBConv ........................................................................................................... 863 wxMBConvFile...................................................................................................... 865 wxMBConvUTF7................................................................................................... 866 wxMBConvUTF8................................................................................................... 867 wxMBConvUTF16................................................................................................. 868 wxMBConvUTF32................................................................................................. 869 wxMDIChildFrame ................................................................................................ 869 wxMDIClientWindow............................................................................................. 872 wxMDIParentFrame.............................................................................................. 874 wxMemoryDC ....................................................................................................... 881 wxMemoryFSHandler ........................................................................................... 882 wxMemoryInputStream ......................................................................................... 884 wxMemoryOutputStream ...................................................................................... 884 wxMenu ................................................................................................................ 885 wxMenuBar........................................................................................................... 898 wxMenuEvent ....................................................................................................... 907 wxMenuItem ......................................................................................................... 909 wxMessageDialog................................................................................................. 914 wxMetafile............................................................................................................. 916 wxMetafileDC ....................................................................................................... 917 wxMimeTypesManager......................................................................................... 918 wxMiniFrame ........................................................................................................ 922 wxMirrorDC........................................................................................................... 924 wxModule ............................................................................................................. 925 wxMouseCaptureChangedEvent .......................................................................... 927 wxMouseEvent ..................................................................................................... 928 wxMoveEvent ....................................................................................................... 937 wxMultipleChoiceDialog........................................................................................ 938 wxMutex ............................................................................................................... 938 wxMutexLocker..................................................................................................... 941 wxNode ................................................................................................................ 942 wxNotebook.......................................................................................................... 943 wxNotebookEvent................................................................................................. 950 wxNotebookSizer.................................................................................................. 952

viii


CONTENTS
wxNotifyEvent....................................................................................................... 953 wxObject............................................................................................................... 954 wxObjectRefData.................................................................................................. 958 wxOutputStream ................................................................................................... 958 wxPageSetupDialog ............................................................................................. 960 wxPageSetupDialogData ...................................................................................... 961 wxPaintDC............................................................................................................ 966 wxPaintEvent ........................................................................................................ 967 wxPalette .............................................................................................................. 968 wxPanel ................................................................................................................ 972 wxPathList ............................................................................................................ 975 wxPen................................................................................................................... 976 wxPenList ............................................................................................................. 983 wxPlotCurve ......................................................................................................... 985 wxPlotWindow ...................................................................................................... 987 wxPoint................................................................................................................. 991 wxPostScriptDC.................................................................................................... 991 wxPreviewCanvas ................................................................................................ 992 wxPreviewControlBar............................................................................................ 993 wxPreviewFrame .................................................................................................. 995 wxPrintData .......................................................................................................... 996 wxPrintDialog...................................................................................................... 1002 wxPrintDialogData .............................................................................................. 1003 wxPrinter............................................................................................................. 1007 wxPrinterDC ....................................................................................................... 1010 wxPrintout........................................................................................................... 1010 wxPrintPreview ................................................................................................... 1014 wxPrivateDropTarget .......................................................................................... 1018 wxProcess .......................................................................................................... 1019 wxProcessEvent ................................................................................................. 1024 wxProgressDialog............................................................................................... 1025 wxProtocol .......................................................................................................... 1027 wxQuantize......................................................................................................... 1029 wxQueryLayoutInfoEvent.................................................................................... 1030 wxRadioBox........................................................................................................ 1033 wxRadioButton ................................................................................................... 1039 wxRealPoint........................................................................................................ 1041 wxRect................................................................................................................ 1042

ix


CONTENTS
wxRecursionGuard ............................................................................................. 1047 wxRecursionGuardFlag ...................................................................................... 1048 wxRegEx ............................................................................................................ 1049 wxRegion............................................................................................................ 1052 wxRegionIterator................................................................................................. 1057 wxRendererNative .............................................................................................. 1059 wxRendererVersion ............................................................................................ 1062 wxSashEvent ...................................................................................................... 1063 wxSashLayoutWindow........................................................................................ 1065 wxSashWindow .................................................................................................. 1068 wxScreenDC....................................................................................................... 1072 wxScopedArray................................................................................................... 1074 wxScopedPtr ...................................................................................................... 1075 wxScopedTiedPtr................................................................................................ 1078 wxScrollBar......................................................................................................... 1079 wxScrolledWindow.............................................................................................. 1085 wxScrollEvent ..................................................................................................... 1094 wxScrollWinEvent ............................................................................................... 1097 wxSemaphore..................................................................................................... 1098 wxServer............................................................................................................. 1101 wxSimpleHelpProvider........................................................................................ 1102 wxSingleChoiceDialog ........................................................................................ 1102 wxSingleInstanceChecker................................................................................... 1104 wxSize ................................................................................................................ 1106 wxSizeEvent ....................................................................................................... 1108 wxSizer ............................................................................................................... 1109 wxSizerItem ........................................................................................................ 1116 wxSlider .............................................................................................................. 1121 wxSockAddress .................................................................................................. 1130 wxSocketBase .................................................................................................... 1131 wxSocketClient ................................................................................................... 1148 wxSocketEvent ................................................................................................... 1150 wxSocketInputStream ......................................................................................... 1151 wxSocketOutputStream ...................................................................................... 1152 wxSocketServer.................................................................................................. 1152 wxSpinButton...................................................................................................... 1154 wxSpinCtrl .......................................................................................................... 1158 wxSpinEvent....................................................................................................... 1161

x


CONTENTS
wxSplashScreen ................................................................................................. 1162 wxSplitterEvent ................................................................................................... 1164 wxSplitterWindow ............................................................................................... 1166 wxSplitterRenderParams .................................................................................... 1176 wxStaticBitmap ................................................................................................... 1176 wxStaticBox ........................................................................................................ 1178 wxStaticBoxSizer ................................................................................................ 1180 wxStaticLine ....................................................................................................... 1181 wxStaticText ....................................................................................................... 1183 wxStatusBar ....................................................................................................... 1185 wxStopWatch...................................................................................................... 1190 wxStreamBase.................................................................................................... 1191 wxStreamBuffer .................................................................................................. 1193 wxStreamToTextRedirector ................................................................................ 1198 wxString.............................................................................................................. 1200 wxStringBuffer .................................................................................................... 1221 wxStringClientData ............................................................................................. 1222 wxStringList ........................................................................................................ 1223 wxStringTokenizer .............................................................................................. 1225 wxSysColourChangedEvent ............................................................................... 1227 wxSystemOptions ............................................................................................... 1228 wxSystemSettings .............................................................................................. 1229 wxTabCtrl ........................................................................................................... 1234 wxTabEvent........................................................................................................ 1239 wxTaskBarIcon ................................................................................................... 1240 wxTempFile ........................................................................................................ 1242 wxTextAttr........................................................................................................... 1244 wxTextCtrl........................................................................................................... 1248 wxTextDataObject .............................................................................................. 1266 wxTextDropTarget .............................................................................................. 1268 wxTextEntryDialog.............................................................................................. 1269 wxTextFile .......................................................................................................... 1271 wxTextInputStream............................................................................................. 1276 wxTextOutputStream .......................................................................................... 1280 wxTextValidator .................................................................................................. 1281 wxThread............................................................................................................ 1284 wxThreadHelper ................................................................................................. 1291 wxThreadHelperThread ...................................................................................... 1293

xi


CONTENTS
wxTimer .............................................................................................................. 1294 wxTimerEvent..................................................................................................... 1297 wxTimeSpan....................................................................................................... 1298 wxTipProvider..................................................................................................... 1304 wxTipWindow ..................................................................................................... 1305 wxToggleButton .................................................................................................. 1307 wxToolBar........................................................................................................... 1309 wxToolTip ........................................................................................................... 1326 wxTreeCtrl .......................................................................................................... 1327 wxTreeEvent....................................................................................................... 1345 wxTreeItemData ................................................................................................. 1348 wxUpdateUIEvent ............................................................................................... 1350 wxURL................................................................................................................ 1355 wxValidator ......................................................................................................... 1358 wxVariant............................................................................................................ 1360 wxVariantData .................................................................................................... 1367 wxView ............................................................................................................... 1369 wxVListBox ......................................................................................................... 1373 wxVScrolledWindow ........................................................................................... 1379 wxSound............................................................................................................. 1384 wxWindow .......................................................................................................... 1386 wxWindowDC ..................................................................................................... 1436 wxWindowDisabler ............................................................................................. 1437 wxWizard ............................................................................................................ 1437 wxWizardEvent ................................................................................................... 1442 wxWizardPage.................................................................................................... 1444 wxWizardPageSimple......................................................................................... 1445 wxXmlResource.................................................................................................. 1447 wxXmlResourceHandler ..................................................................................... 1452 wxZipInputStream............................................................................................... 1457 wxZlibInputStream .............................................................................................. 1457 wxZlibOutputStream ........................................................................................... 1458

Chapter 8 Functions ..................................................................................... 1460
Alphabetical functions and macros list ................................................................ 1460 Version macros................................................................................................... 1464 Application initialization and termination ............................................................. 1465 Process control functions.................................................................................... 1468

xii


CONTENTS
Thread functions ................................................................................................. 1473 File functions ...................................................................................................... 1475 Network, user and OS functions ......................................................................... 1480 String functions................................................................................................... 1484 Dialog functions .................................................................................................. 1489 Math functions .................................................................................................... 1498 GDI functions...................................................................................................... 1498 Printer settings.................................................................................................... 1501 Clipboard functions ............................................................................................. 1503 Miscellaneous functions...................................................................................... 1505 Byte order macros .............................................................................................. 1513 RTTI functions .................................................................................................... 1515 Log functions ...................................................................................................... 1520 Time functions .................................................................................................... 1527 Debugging macros and functions........................................................................ 1529 Environment access functions ............................................................................ 1533

Chapter 9 Constants..................................................................................... 1534
Preprocesser symbols defined by wxWindows.................................................... 1534 Standard event identifiers ................................................................................... 1537 Keycodes............................................................................................................ 1539

Chapter 10 Classes by category.................................................................. 1541 Chapter 11 Topic overviews......................................................................... 1557
Notes on using the reference .............................................................................. 1557 Writing a wxWindows application: a rough guide ................................................ 1557 wxWindows Hello World sample ......................................................................... 1558 wxWindows samples .......................................................................................... 1560 wxApp overview.................................................................................................. 1570 Run time class information overview................................................................... 1572 wxString overview............................................................................................... 1574 Date and time classes overview.......................................................................... 1579 Unicode support in wxWindows .......................................................................... 1583 wxMBConv classes overview.............................................................................. 1586 Internationalization.............................................................................................. 1589 Writing non-English applications ......................................................................... 1590 Container classes overview ................................................................................ 1592 File classes and functions overview .................................................................... 1593

xiii


CONTENTS
wxStreams overview........................................................................................... 1593 wxLog classes overview ..................................................................................... 1595 Debugging overview ........................................................................................... 1598 wxConfig classes overview ................................................................................. 1600 wxFileSystem ..................................................................................................... 1601 Event handling overview ..................................................................................... 1602 C++ exceptions overview.................................................................................... 1610 Window styles..................................................................................................... 1611 Window deletion overview .................................................................................. 1612 wxDialog overview .............................................................................................. 1614 wxValidator overview .......................................................................................... 1614 Constraints overview .......................................................................................... 1616 Sizer overview .................................................................................................... 1620 XML-based resource system overview ............................................................... 1627 Scrolling overview............................................................................................... 1636 Bitmaps and icons overview................................................................................ 1638 Device context overview ..................................................................................... 1641 wxFont overview ................................................................................................. 1641 Font encoding overview ...................................................................................... 1643 wxSplitterWindow overview................................................................................. 1644 wxTreeCtrl overview ........................................................................................... 1646 wxListCtrl overview ............................................................................................. 1647 wxImageList overview......................................................................................... 1647 Common dialogs overview.................................................................................. 1647 Document/view overview .................................................................................... 1651 Toolbar overview ................................................................................................ 1657 wxGrid classes overview..................................................................................... 1662 wxTipProvider overview ...................................................................................... 1663 Printing overview ................................................................................................ 1664 Multithreading overview ...................................................................................... 1665 Drag and drop overview...................................................................................... 1666 wxDataObject overview ...................................................................................... 1667 Database classes overview ................................................................................ 1668 Interprocess communication overview ................................................................ 1688 wxHTML overview .............................................................................................. 1691 Environment variables ........................................................................................ 1700 wxPython overview ............................................................................................. 1701 Syntax of the builtin regular expression library.................................................... 1712

xiv


CONTENTS Chapter 12 Port notes................................................................................... 1726
wxGTK port......................................................................................................... 1726 wxMSW port ....................................................................................................... 1726 wxMac port ......................................................................................................... 1726 wxOS2 port......................................................................................................... 1727 wxMGL port ........................................................................................................ 1727 wxX11 port.......................................................................................................... 1727

Chapter 13 Index ........................................................................................... 1729

xv


Chapter 1 Copyright notice
Copyright (c) 1992-2002 Julian Smart, Robert Roebling, Vadim Zeitlin and other members of the wxWindows team Portions (c) 1996 Artificial Intelligence Applications Institute Please also see the wxWindows license files (preamble.txt, lgpl.txt, gpl.txt, license.txt, licendoc.txt) for conditions of software and documentation use.

wxWindows Library License, Version 3
Copyright (c) 1992-2004 Julian Smart, Robert Roebling, Vadim Zeitlin et al. Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. WXWINDOWS LIBRARY LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION This library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Library General Public License for more details. You should have received a copy of the GNU Library General Public License along with this software, usually in a file named COPYING.LIB. If not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA. EXCEPTION NOTICE 1. As a special exception, the copyright holders of this library give permission for additional uses of the text contained in this release of the library as licensed under the wxWindows Library License, applying either version 3 of the License, or (at your option) any later version of the License as published by the copyright holders of version 3 of the License document. 2. The exception is that you may create binary object code versions of any works using this library or based on this library, and use, copy, modify, link and distribute such binary object code files unrestricted under terms of your choice. 3. If you copy code from files distributed under the terms of the GNU General Public License or the GNU Library General Public License into a copy of this library, as this license permits, the exception does not apply to the code that you add in this way. To

xvi


COPYRIGHT
avoid misleading anyone as to the status of such modified files, you must delete this exception notice from such code and/or adjust the licensing conditions notice accordingly. 4. If you write modifications of your own for this library, it is your choice whether to permit this exception to apply to your modifications. If you do not wish that, you must delete the exception notice from such code and/or adjust the licensing conditions notice accordingly.

GNU Library General Public License, Version 2
Copyright (C) 1991 Free Software Foundation, Inc. 675 Mass Ave, Cambridge, MA 02139, USA Everyone is permitted to copy and distribute verbatim copies of this license document, but changing it is not allowed. [This is the first released version of the library GPL. It is numbered 2 because it goes with version 2 of the ordinary GPL.] Preamble The licenses for most software are designed to take away your freedom to share and change it. By contrast, the GNU General Public Licenses are intended to guarantee your freedom to share and change free software -- to make sure the software is free for all its users. This license, the Library General Public License, applies to some specially designated Free Software Foundation software, and to any other libraries whose authors decide to use it. You can use it for your libraries, too. When we speak of free software, we are referring to freedom, not price. Our General Public Licenses are designed to make sure that you have the freedom to distribute copies of free software (and charge for this service if you wish), that you receive source code or can get it if you want it, that you can change the software or use pieces of it in new free programs; and that you know you can do these things. To protect your rights, we need to make restrictions that forbid anyone to deny you these rights or to ask you to surrender the rights. These restrictions translate to certain responsibilities for you if you distribute copies of the library, or if you modify it. For example, if you distribute copies of the library, whether gratis or for a fee, you must give the recipients all the rights that we gave you. You must make sure that they, too, receive or can get the source code. If you link a program with the library, you must provide complete object files to the recipients so that they can relink them with the library, after making changes to the library and recompiling it. And you must show them these terms so they know their rights. Our method of protecting your rights has two steps: (1) copyright the library, and (2) offer you this license which gives you legal permission to copy, distribute and/or modify the library.

xvii


COPYRIGHT
Also, for each distributor's protection, we want to make certain that everyone understands that there is no warranty for this free library. If the library is modified by someone else and passed on, we want its recipients to know that what they have is not the original version, so that any problems introduced by others will not reflect on the original authors' reputations. Finally, any free program is threatened constantly by software patents. We wish to avoid the danger that companies distributing free software will individually obtain patent licenses, thus in effect transforming the program into proprietary software. To prevent this, we have made it clear that any patent must be licensed for everyone's free use or not licensed at all. Most GNU software, including some libraries, is covered by the ordinary GNU General Public License, which was designed for utility programs. This license, the GNU Library General Public License, applies to certain designated libraries. This license is quite different from the ordinary one; be sure to read it in full, and don't assume that anything in it is the same as in the ordinary license. The reason we have a separate public license for some libraries is that they blur the distinction we usually make between modifying or adding to a program and simply using it. Linking a program with a library, without changing the library, is in some sense simply using the library, and is analogous to running a utility program or application program. However, in a textual and legal sense, the linked executable is a combined work, a derivative of the original library, and the ordinary General Public License treats it as such. Because of this blurred distinction, using the ordinary General Public License for libraries did not effectively promote software sharing, because most developers did not use the libraries. We concluded that weaker conditions might promote sharing better. However, unrestricted linking of non-free programs would deprive the users of those programs of all benefit from the free status of the libraries themselves. This Library General Public License is intended to permit developers of non-free programs to use free libraries, while preserving your freedom as a user of such programs to change the free libraries that are incorporated in them. (We have not seen how to achieve this as regards changes in header files, but we have achieved it as regards changes in the actual functions of the Library.) The hope is that this will lead to faster development of free libraries. The precise terms and conditions for copying, distribution and modification follow. Pay close attention to the difference between a "work based on the library" and a "work that uses the library". The former contains code derived from the library, while the latter only works together with the library. Note that it is possible for a library to be covered by the ordinary General Public License rather than by this special one. GNU LIBRARY GENERAL PUBLIC LICENSE TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION 0. This License Agreement applies to any software library which contains a notice placed by the copyright holder or other authorized party saying it may be distributed under the terms of this Library General Public License (also called "this License"). Each licensee is

xviii


COPYRIGHT
addressed as "you". A "library" means a collection of software functions and/or data prepared so as to be conveniently linked with application programs (which use some of those functions and data) to form executables. The "Library", below, refers to any such software library or work which has been distributed under these terms. A "work based on the Library" means either the Library or any derivative work under copyright law: that is to say, a work containing the Library or a portion of it, either verbatim or with modifications and/or translated straightforwardly into another language. (Hereinafter, translation is included without limitation in the term "modification".) "Source code" for a work means the preferred form of the work for making modifications to it. For a library, complete source code means all the source code for all modules it contains, plus any associated interface definition files, plus the scripts used to control compilation and installation of the library. Activities other than copying, distribution and modification are not covered by this License; they are outside its scope. The act of running a program using the Library is not restricted, and output from such a program is covered only if its contents constitute a work based on the Library (independent of the use of the Library in a tool for writing it). Whether that is true depends on what the Library does and what the program that uses the Library does. 1. You may copy and distribute verbatim copies of the Library's complete source code as you receive it, in any medium, provided that you conspicuously and appropriately publish on each copy an appropriate copyright notice and disclaimer of warranty; keep intact all the notices that refer to this License and to the absence of any warranty; and distribute a copy of this License along with the Library. You may charge a fee for the physical act of transferring a copy, and you may at your option offer warranty protection in exchange for a fee. 2. You may modify your copy or copies of the Library or any portion of it, thus forming a work based on the Library, and copy and distribute such modifications or work under the terms of Section 1 above, provided that you also meet all of these conditions: a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices stating that you changed the files and the date of any change. c) You must cause the whole of the work to be licensed at no charge to all third parties under the terms of this License. d) If a facility in the modified Library refers to a function or a table of data to be supplied by an application program that uses the facility, other than as an argument passed when the facility is invoked, then you must make a good faith effort to ensure that, in the event an application does not supply such function or table, the facility still operates, and performs whatever part of its purpose remains meaningful.

xix


COPYRIGHT
(For example, a function in a library to compute square roots has a purpose that is entirely well-defined independent of the application. Therefore, Subsection 2d requires that any application-supplied function or table used by this function must be optional: if the application does not supply it, the square root function must still compute square roots.) These requirements apply to the modified work as a whole. If identifiable sections of that work are not derived from the Library, and can be reasonably considered independent and separate works in themselves, then this License, and its terms, do not apply to those sections when you distribute them as separate works. But when you distribute the same sections as part of a whole which is a work based on the Library, the distribution of the whole must be on the terms of this License, whose permissions for other licensees extend to the entire whole, and thus to each and every part regardless of who wrote it. Thus, it is not the intent of this section to claim rights or contest your rights to work written entirely by you; rather, the intent is to exercise the right to control the distribution of derivative or collective works based on the Library. In addition, mere aggregation of another work not based on the Library with the Library (or with a work based on the Library) on a volume of a storage or distribution medium does not bring the other work under the scope of this License. 3. You may opt to apply the terms of the ordinary GNU General Public License instead of this License to a given copy of the Library. To do this, you must alter all the notices that refer to this License, so that they refer to the ordinary GNU General Public License, version 2, instead of to this License. (If a newer version than version 2 of the ordinary GNU General Public License has appeared, then you can specify that version instead if you wish.) Do not make any other change in these notices. Once this change is made in a given copy, it is irreversible for that copy, so the ordinary GNU General Public License applies to all subsequent copies and derivative works made from that copy. This option is useful when you wish to copy part of the code of the Library into a program that is not a library. 4. You may copy and distribute the Library (or a portion or derivative of it, under Section 2) in object code or executable form under the terms of Sections 1 and 2 above provided that you accompany it with the complete corresponding machine-readable source code, which must be distributed under the terms of Sections 1 and 2 above on a medium customarily used for software interchange. If distribution of object code is made by offering access to copy from a designated place, then offering equivalent access to copy the source code from the same place satisfies the requirement to distribute the source code, even though third parties are not compelled to copy the source along with the object code. 5. A program that contains no derivative of any portion of the Library, but is designed to work with the Library by being compiled or linked with it, is called a "work that uses the Library". Such a work, in isolation, is not a derivative work of the Library, and therefore falls outside the scope of this License. However, linking a "work that uses the Library" with the Library creates an executable

xx


COPYRIGHT
that is a derivative of the Library (because it contains portions of the Library), rather than a "work that uses the library". The executable is therefore covered by this License. Section 6 states terms for distribution of such executables. When a "work that uses the Library" uses material from a header file that is part of the Library, the object code for the work may be a derivative work of the Library even though the source code is not. Whether this is true is especially significant if the work can be linked without the Library, or if the work is itself a library. The threshold for this to be true is not precisely defined by law. If such an object file uses only numerical parameters, data structure layouts and accessors, and small macros and small inline functions (ten lines or less in length), then the use of the object file is unrestricted, regardless of whether it is legally a derivative work. (Executables containing this object code plus portions of the Library will still fall under Section 6.) Otherwise, if the work is a derivative of the Library, you may distribute the object code for the work under the terms of Section 6. Any executables containing that work also fall under Section 6, whether or not they are linked directly with the Library itself. 6. As an exception to the Sections above, you may also compile or link a "work that uses the Library" with the Library to produce a work containing portions of the Library, and distribute that work under terms of your choice, provided that the terms permit modification of the work for the customer's own use and reverse engineering for debugging such modifications. You must give prominent notice with each copy of the work that the Library is used in it and that the Library and its use are covered by this License. You must supply a copy of this License. If the work during execution displays copyright notices, you must include the copyright notice for the Library among them, as well as a reference directing the user to the copy of this License. Also, you must do one of these things: a) Accompany the work with the complete corresponding machine-readable source code for the Library including whatever changes were used in the work (which must be distributed under Sections 1 and 2 above); and, if the work is an executable linked with the Library, with the complete machine-readable "work that uses the Library", as object code and/or source code, so that the user can modify the Library and then relink to produce a modified executable containing the modified Library. (It is understood that the user who changes the contents of definitions files in the Library will not necessarily be able to recompile the application to use the modified definitions.) b) Accompany the work with a written offer, valid for at least three years, to give the same user the materials specified in Subsection 6a, above, for a charge no more than the cost of performing this distribution. c) If distribution of the work is made by offering access to copy from a designated place, offer equivalent access to copy the above specified materials from the same place. d) Verify that the user has already received a copy of these materials or that you have already sent this user a copy.

xxi


COPYRIGHT
For an executable, the required form of the "work that uses the Library" must include any data and utility programs needed for reproducing the executable from it. However, as a special exception, the source code distributed need not include anything that is normally distributed (in either source or binary form) with the major components (compiler, kernel, and so on) of the operating system on which the executable runs, unless that component itself accompanies the executable. It may happen that this requirement contradicts the license restrictions of other proprietary libraries that do not normally accompany the operating system. Such a contradiction means you cannot use both them and the Library together in an executable that you distribute. 7. You may place library facilities that are a work based on the Library side-by-side in a single library together with other library facilities not covered by this License, and distribute such a combined library, provided that the separate distribution of the work based on the Library and of the other library facilities is otherwise permitted, and provided that you do these two things: a) Accompany the combined library with a copy of the same work based on the Library, uncombined with any other library facilities. This must be distributed under the terms of the Sections above. b) Give prominent notice with the combined library of the fact that part of it is a work based on the Library, and explaining where to find the accompanying uncombined form of the same work. 8. You may not copy, modify, sublicense, link with, or distribute the Library except as expressly provided under this License. Any attempt otherwise to copy, modify, sublicense, link with, or distribute the Library is void, and will automatically terminate your rights under this License. However, parties who have received copies, or rights, from you under this License will not have their licenses terminated so long as such parties remain in full compliance. 9. You are not required to accept this License, since you have not signed it. However, nothing else grants you permission to modify or distribute the Library or its derivative works. These actions are prohibited by law if you do not accept this License. Therefore, by modifying or distributing the Library (or any work based on the Library), you indicate your acceptance of this License to do so, and all its terms and conditions for copying, distributing or modifying the Library or works based on it. 10. Each time you redistribute the Library (or any work based on the Library), the recipient automatically receives a license from the original licensor to copy, distribute, link with or modify the Library subject to these terms and conditions. You may not impose any further restrictions on the recipients' exercise of the rights granted herein. You are not responsible for enforcing compliance by third parties to this License. 11. If, as a consequence of a court judgment or allegation of patent infringement or for any other reason (not limited to patent issues), conditions are imposed on you (whether by court order, agreement or otherwise) that contradict the conditions of this License, they do not excuse you from the conditions of this License. If you cannot distribute so as to satisfy simultaneously your obligations under this License and any other pertinent obligations, then as a consequence you may not distribute the Library at all. For

xxii


COPYRIGHT
example, if a patent license would not permit royalty-free redistribution of the Library by all those who receive copies directly or indirectly through you, then the only way you could satisfy both it and this License would be to refrain entirely from distribution of the Library. If any portion of this section is held invalid or unenforceable under any particular circumstance, the balance of the section is intended to apply, and the section as a whole is intended to apply in other circumstances. It is not the purpose of this section to induce you to infringe any patents or other property right claims or to contest validity of any such claims; this section has the sole purpose of protecting the integrity of the free software distribution system which is implemented by public license practices. Many people have made generous contributions to the wide range of software distributed through that system in reliance on consistent application of that system; it is up to the author/donor to decide if he or she is willing to distribute software through any other system and a licensee cannot impose that choice. This section is intended to make thoroughly clear what is believed to be a consequence of the rest of this License. 12. If the distribution and/or use of the Library is restricted in certain countries either by patents or by copyrighted interfaces, the original copyright holder who places the Library under this License may add an explicit geographical distribution limitation excluding those countries, so that distribution is permitted only in or among countries not thus excluded. In such case, this License incorporates the limitation as if written in the body of this License. 13. The Free Software Foundation may publish revised and/or new versions of the Library General Public License from time to time. Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns. Each version is given a distinguishing version number. If the Library specifies a version number of this License which applies to it and "any later version", you have the option of following the terms and conditions either of that version or of any later version published by the Free Software Foundation. If the Library does not specify a license version number, you may choose any version ever published by the Free Software Foundation. 14. If you wish to incorporate parts of the Library into other free programs whose distribution conditions are incompatible with these, write to the author to ask for permission. For software which is copyrighted by the Free Software Foundation, write to the Free Software Foundation; we sometimes make exceptions for this. Our decision will be guided by the two goals of preserving the free status of all derivatives of our free software and of promoting the sharing and reuse of software generally. NO WARRANTY 15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND

xxiii


COPYRIGHT
FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE LIBRARY IS WITH YOU. SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION. 16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. END OF TERMS AND CONDITIONS Appendix: How to Apply These Terms to Your New Libraries If you develop a new library, and you want it to be of the greatest possible use to the public, we recommend making it free software that everyone can redistribute and change. You can do so by permitting redistribution under these terms (or, alternatively, under the terms of the ordinary General Public License). To apply these terms, attach the following notices to the library. It is safest to attach them to the start of each source file to most effectively convey the exclusion of warranty; and each file should have at least the "copyright" line and a pointer to where the full notice is found.
<one line to give the library's name and a brief idea of what it does.> Copyright (C) <year> <name of author> This library is free software; you can redistribute it and/or modify it under the terms of the GNU Library General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version. This library is but WITHOUT ANY MERCHANTABILITY Library General distributed in the hope that it will be useful, WARRANTY; without even the implied warranty of or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Public License for more details.

You should have received a copy of the GNU Library General Public License along with this library; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

Also add information on how to contact you by electronic and paper mail. You should also get your employer (if you work as a programmer) or your school, if any, to sign a "copyright disclaimer" for the library, if necessary. Here is a sample; alter the names:
Yoyodyne, Inc., hereby disclaims all copyright interest in the library `Frob' (a library for tweaking knobs) written by James Random Hacker. <signature of Ty Coon>, 1 April 1990 Ty Coon, President of Vice

xxiv


COPYRIGHT

That's all there is to it!

xxv


Chapter 2 Introduction

What is wxWindows?
wxWindows is a C++ framework providing GUI (Graphical User Interface) and other facilities on more than one platform. Version 2 currently supports all desktop versions of MS Windows, Unix with GTK+, Unix with Motif, and MacOS. An OS/2 port is in progress. wxWindows was originally developed at the Artificial Intelligence Applications Institute, University of Edinburgh, for internal use, and was first made publicly available in 1992. Version 2 is a vastly improved version written and maintained by Julian Smart, Robert Roebling, Vadim Zeitlin, Vaclav Slavik and many others. This manual contains a class reference and topic overviews. For a selection of wxWindows tutorials, please see the documentation page on the wxWindows web site (http://www.wxwindows.org). Please note that in the following, "MS Windows" often refers to all platforms related to Microsoft Windows, including 16-bit and 32-bit variants, unless otherwise stated. All trademarks are acknowledged.

Why another cross-platform development tool?
wxWindows was developed to provide a cheap and flexible way to maximize investment in GUI application development. While a number of commercial class libraries already existed for cross-platform development, none met all of the following criteria: 1. 2. 3. 4. low price; source availability; simplicity of programming; support for a wide range of compilers.

Since wxWindows was started, several other free or almost-free GUI frameworks have emerged. However, none has the range of features, flexibility, documentation and the well-established development team that wxWindows has. As open source software, wxWindows has benefited from comments, ideas, bug fixes, enhancements and the sheer enthusiasm of users. This gives wxWindows a certain advantage over its commercial competitors (and over free libraries without an independent development team), plus a robustness against the transience of one individual or company. This openness and availability of source code is especially important when the future of thousands of lines of application code may depend upon the longevity of the underlying class library.

1


CHAPTER 2
Version 2 goes much further than previous versions in terms of generality and features, allowing applications to be produced that are often indistinguishable from those produced using single-platform toolkits such as Motif, GTK+ and MFC. The importance of using a platform-independent class library cannot be overstated, since GUI application development is very time-consuming, and sustained popularity of particular GUIs cannot be guaranteed. Code can very quickly become obsolete if it addresses the wrong platform or audience. wxWindows helps to insulate the programmer from these winds of change. Although wxWindows may not be suitable for every application (such as an OLE-intensive program), it provides access to most of the functionality a GUI program normally requires, plus many extras such as network programming, PostScript output, and HTML rendering; and it can of course be extended as needs dictate. As a bonus, it provides a far cleaner and easier programming interface than the native APIs. Programmers may find it worthwhile to use wxWindows even if they are developing on only one platform. It is impossible to sum up the functionality of wxWindows in a few paragraphs, but here are some of the benefits:                  Low cost (free, in fact!) You get the source. Available on a variety of popular platforms. Works with almost all popular C++ compilers and Python. Over 50 example programs. Over 1000 pages of printable and on-line documentation. Includes Tex2RTF, to allow you to produce your own documentation in Windows Help, HTML and Word RTF formats. Simple-to-use, object-oriented API. Flexible event system. Graphics calls include lines, rounded rectangles, splines, polylines, etc. Constraint-based and sizer-based layouts. Print/preview and document/view architectures. Toolbar, notebook, tree control, advanced list control classes. PostScript generation under Unix, normal MS Windows printing on the PC. MDI (Multiple Document Interface) support. Can be used to create DLLs under Windows, dynamic libraries on Unix. Common dialogs for file browsing, printing, colour selection, etc.

2


CHAPTER 2
      Under MS Windows, support for creating metafiles and copying them to the clipboard. An API for invoking help from applications. Ready-to-use HTML window (supporting a subset of HTML). Network support via a family of socket and protocol classes. Support for platform independent image processing. Built-in support for many file formats (BMP, PNG, JPEG, GIF, XPM, PNM, PCX).

wxWindows requirements
To make use of wxWindows, you currently need one of the following setups. (a) MS-Windows: 1. 2. A 486 or higher PC running MS Windows. A Windows compiler: most are supported, but please see install.txt for details. Supported compilers include Microsoft Visual C++ 4.0 or higher, Borland C++, Cygwin, MinGW, Metrowerks CodeWarrior. At least 60 MB of disk space.

3.

(b) Unix: 1. 2. 3. Almost any C++ compiler, including GNU C++ (EGCS 1.1.1 or above). Almost any Unix workstation, and one of: GTK+ 1.2, GTK+ 2.0, Motif 1.2 or higher, Lesstif. If using the wxX11 port, no such widget set is required. At least 60 MB of disk space.

(c) Mac OS/Mac OS X: 1. 2. 3. 4. A PowerPC Mac running Mac OS 8.6/9.x (eg. Classic) or Mac OS X 10.x. CodeWarrior 5.3, 6 or 7 for Classic Mac OS. The Apple Developer Tools (eg. GNU C++) or CodeWarrior 7 for Mac OS X. At least 60 MB of disk space.

Availability and location of wxWindows
wxWindows is available by anonymous FTP and World Wide Web from ftp://biolpc22.york.ac.uk/pub (ftp://biolpc22.york.ac.uk/pub) and/or http://www.wxwindows.org (http://www.wxwindows.org).

3


CHAPTER 2
You can also buy a CD-ROM using the form on the Web site.

Acknowledgements
Thanks are due to AIAI for being willing to release the original version of wxWindows into the public domain, and to our patient partners. We would particularly like to thank the following for their contributions to wxWindows, and the many others who have been involved in the project over the years. Apologies for any unintentional omissions from this list. Yiorgos Adamopoulos, Jamshid Afshar, Alejandro Aguilar-Sierra, AIAI, Patrick Albert, Karsten Ballueder, Michael Bedward, Kai Bendorf, Yura Bidus, Keith Gary Boyce, Chris Breeze, Pete Britton, Ian Brown, C. Buckley, Dmitri Chubraev, Robin Corbet, Cecil Coupe, Andrew Davison, Neil Dudman, Robin Dunn, Hermann Dunkel, Jos van Eijndhoven, Tom Felici, Thomas Fettig, Matthew Flatt, Pasquale Foggia, Josep Fortiana, Todd Fries, Dominic Gallagher, Guillermo Rodriguez Garcia, Wolfram Gloger, Norbert Grotz, Stefan Gunter, Bill Hale, Patrick Halke, Stefan Hammes, Guillaume Helle, Harco de Hilster, Cord Hockemeyer, Markus Holzem, Olaf Klein, Leif Jensen, Bart Jourquin, Guilhem Lavaux, Jan Lessner, Nicholas Liebmann, Torsten Liermann, Per Lindqvist, Thomas Runge, Tatu Mnnist, Scott Maxwell, Thomas Myers, Oliver Niedung, Stefan Neis, Hernan Otero, Ian Perrigo, Timothy Peters, Giordano Pezzoli, Harri Pasanen, Thomaso Paoletti, Garrett Potts, Marcel Rasche, Robert Roebling, Dino Scaringella, Jobst Schmalenbach, Arthur Seaton, Paul Shirley, Vaclav Slavik, Stein Somers, Petr Smilauer, Neil Smith, Kari Syst, Arthur Tetzlaff-Deas, Jonathan Tonberg, Jyrki Tuomi, David Webster, Janos Vegh, Andrea Venturoli, Vadim Zeitlin, Xiaokun Zhu, Edward Zimmermann. 'Graphplace', the basis for the wxGraphLayout library, is copyright Dr. Jos T.J. van Eijndhoven of Eindhoven University of Technology. The code has been used in wxGraphLayout with his permission. We also acknowledge the author of XFIG, the excellent Unix drawing tool, from the source of which we have borrowed some spline drawing code. His copyright is included below. XFig2.1 is copyright (c) 1985 by Supoj Sutanthavibul. Permission to use, copy, modify, distribute, and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of M.I.T. not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission. M.I.T. makes no representations about the suitability of this software for any purpose. It is provided "as is'' without express or implied warranty.

4


Chapter 3 Multi-platform development with wxWindows
This chapter describes the practical details of using wxWindows. Please see the file install.txt for up-to-date installation instructions, and changes.txt for differences between versions.

Include files
The main include file is "wx/wx.h"; this includes the most commonly used modules of wxWindows. To save on compilation time, include only those header files relevant to the source file. If you are using precompiled headers, you should include the following section before any other includes:
// For compilers that support precompilation, includes "wx.h". #include <wx/wxprec.h> #ifdef __BORLANDC__ #pragma hdrstop #endif #ifndef WX_PRECOMP // Include your minimal set of headers here, or wx.h #include <wx/wx.h> #endif ... now your other include files ...

The file "wx/wxprec.h" includes "wx/wx.h". Although this incantation may seem quirky, it is in fact the end result of a lot of experimentation, and several Windows compilers to use precompilation (those tested are Microsoft Visual C++, Borland C++ and Watcom C++). Borland precompilation is largely automatic. Visual C++ requires specification of "wx/wxprec.h" as the file to use for precompilation. Watcom C++ is automatic apart from the specification of the .pch file. Watcom C++ is strange in requiring the precompiled header to be used only for object files compiled in the same directory as that in which the precompiled header was created. Therefore, the wxWindows Watcom C++ makefiles go through hoops deleting and recreating a single precompiled header file for each module, thus preventing an accumulation of many multi-megabyte .pch files.

Libraries
Most ports of wxWindows can create either a static library or a shared library. wxWindows can also be built in multilib and monolithic variants. See the libraries list (p. 15) for more information on these.

5


CHAPTER 3

Configuration
When using project files and makefiles directly to build wxWindows, options are configurable in the file "wx/XXX/setup.h" where XXX is the required platform (such as msw, motif, gtk, mac). Some settings are a matter of taste, some help with platformspecific problems, and others can be set to minimize the size of the library. Please see the setup.h file and install.txt files for details on configuration. When using the 'configure' script to configure wxWindows (on Unix and other platforms where configure is available), the corresponding setup.h files are generated automatically along with suitable makefiles. When using the RPM packages for installing wxWindows on Linux, a correct setup.h is shipped in the package and this must not be changed.

Makefiles
On Microsoft Windows, wxWindows has a different set of makefiles for each compiler, because each compiler's 'make' tool is slightly different. Popular Windows compilers that we cater for, and the corresponding makefile extensions, include: Microsoft Visual C++ (.vc), Borland C++ (.bcc), OpenWatcom C++ (.wat) and MinGW/Cygwin (.gcc). Makefiles are provided for the wxWindows library itself, samples, demos, and utilities. On Linux, Mac and OS/2, you use the 'configure' command to generate the necessary makefiles. You should also use this method when building with MinGW/Cygwin on Windows. We also provide project files for some compilers, such as Microsoft VC++. However, we recommend using makefiles to build the wxWindows library itself, because makefiles can be more powerful and less manual intervention is required. On Windows using a compiler other than MinGW/Cygwin, you would build the wxWindows library from the build/msw directory which contains the relevant makefiles. On Windows using MinGW/Cygwin, and on Unix, MacOS X and OS/2, you invoke 'configure' (found in the top-level of the wxWindows source hierarchy), from within a suitable empty directory for containing makefiles, object files and libraries. For details on using makefiles, configure, and project files, please see docs/xxx/install.txt in your distribution, where xxx is the platform of interest, such as msw, gtk, x11, mac.

Windows-specific files
wxWindows application compilation under MS Windows requires at least two extra files, resource and module definition files.

Resource file
The least that must be defined in the Windows resource file (extension RC) is the

6


CHAPTER 3
following statement:
#include "wx/msw/wx.rc"

which includes essential internal wxWindows definitions. The resource script may also contain references to icons, cursors, etc., for example:
wxicon icon wx.ico

The icon can then be referenced by name when creating a frame icon. See the MS Windows SDK documentation. Note: include wx.rc after any ICON statements so programs that search your executable for icons (such as the Program Manager) find your application icon first.

Allocating and deleting wxWindows objects
In general, classes derived from wxWindow must dynamically allocated with new and deleted with delete. If you delete a window, all of its children and descendants will be automatically deleted, so you don't need to delete these descendants explicitly. When deleting a frame or dialog, use Destroy rather than delete so that the wxWindows delayed deletion can take effect. This waits until idle time (when all messages have been processed) to actually delete the window, to avoid problems associated with the GUI sending events to deleted windows. Don't create a window on the stack, because this will interfere with delayed deletion. If you decide to allocate a C++ array of objects (such as wxBitmap) that may be cleaned up by wxWindows, make sure you delete the array explicitly before wxWindows has a chance to do so on exit, since calling delete on array members will cause memory problems. wxColour can be created statically: it is not automatically cleaned up and is unlikely to be shared between other objects; it is lightweight enough for copies to be made. Beware of deleting objects such as a wxPen or wxBitmap if they are still in use. Windows is particularly sensitive to this: so make sure you make calls like wxDC::SetPen(wxNullPen) or wxDC::SelectObject(wxNullBitmap) before deleting a drawing object that may be in use. Code that doesn't do this will probably work fine on some platforms, and then fail under Windows.

Architecture dependency
A problem which sometimes arises from writing multi-platform programs is that the basic C types are not defined the same on all platforms. This holds true for both the length in bits of the standard types (such as int and long) as well as their byte order, which might be little endian (typically on Intel computers) or big endian (typically on some Unix workstations). wxWindows defines types and macros that make it easy to write architecture independent code. The types are:

7


CHAPTER 3
wxInt32, wxInt16, wxInt8, wxUint32, wxUint16 = wxWord, wxUint8 = wxByte where wxInt32 stands for a 32-bit signed integer type etc. You can also check which architecture the program is compiled on using the wxBYTE_ORDER define which is either wxBIG_ENDIAN or wxLITTLE_ENDIAN (in the future maybe wxPDP_ENDIAN as well). The macros handling bit-swapping with respect to the applications endianness are described in the Byte order macros (p. 1513) section.

Conditional compilation
One of the purposes of wxWindows is to reduce the need for conditional compilation in source code, which can be messy and confusing to follow. However, sometimes it is necessary to incorporate platform-specific features (such as metafile use under MS Windows). The symbols listed in the file symbols.txt may be used for this purpose, along with any user-supplied ones.

C++ issues
The following documents some miscellaneous C++ issues.

Templates
wxWindows does not use templates (except for some advanced features that are switched off by default) since it is a notoriously unportable feature.

RTTI
wxWindows does not use C++ run-time type information since wxWindows provides its own run-time type information system, implemented using macros.

Type of NULL
Some compilers (e.g. the native IRIX cc) define NULL to be 0L so that no conversion to pointers is allowed. Because of that, all these occurrences of NULL in the GTK+ port use an explicit conversion such as
wxWindow *my_window = (wxWindow*) NULL;

It is recommended to adhere to this in all code using wxWindows as this make the code (a bit) more portable.

Precompiled headers

8


CHAPTER 3
Some compilers, such as Borland C++ and Microsoft C++, support precompiled headers. This can save a great deal of compiling time. The recommended approach is to precompile "wx.h", using this precompiled header for compiling both wxWindows itself and any wxWindows applications. For Windows compilers, two dummy source files are provided (one for normal applications and one for creating DLLs) to allow initial creation of the precompiled header. However, there are several downsides to using precompiled headers. One is that to take advantage of the facility, you often need to include more header files than would normally be the case. This means that changing a header file will cause more recompilations (in the case of wxWindows, everything needs to be recompiled since everything includes "wx.h"!) A related problem is that for compilers that don't have precompiled headers, including a lot of header files slows down compilation considerably. For this reason, you will find (in the common X and Windows parts of the library) conditional compilation that under Unix, includes a minimal set of headers; and when using Visual C++, includes wx.h. This should help provide the optimal compilation for each compiler, although it is biased towards the precompiled headers facility available in Microsoft C++.

File handling
When building an application which may be used under different environments, one difficulty is coping with documents which may be moved to different directories on other machines. Saving a file which has pointers to full pathnames is going to be inherently unportable. One approach is to store filenames on their own, with no directory information. The application searches through a number of locally defined directories to find the file. To support this, the class wxPathList makes adding directories and searching for files easy, and the global function wxFileNameFromPath allows the application to strip off the filename from the path if the filename must be stored. This has undesirable ramifications for people who have documents of the same name in different directories. As regards the limitations of DOS 8+3 single-case filenames versus unrestricted Unix filenames, the best solution is to use DOS filenames for your application, and also for document filenames if the user is likely to be switching platforms regularly. Obviously this latter choice is up to the application user to decide. Some programs (such as YACC and LEX) generate filenames incompatible with DOS; the best solution here is to have your Unix makefile rename the generated files to something more compatible before transferring the source to DOS. Transferring DOS files to Unix is no problem, of course, apart from EOL conversion for which there should be a utility available (such as dos2unix). See also the File Functions section of the reference manual for descriptions of miscellaneous file handling functions.

9


Chapter 4 Utilities and libraries supplied with wxWindows
In addition to the core wxWindows library, a number of further libraries and utilities are supplied with each distribution. Some are under the 'contrib' hierarchy which mirrors the structure of the main wxWindows hierarchy. See also the 'utils' hierarchy. The first place to look for documentation about these tools and libraries is under the wxWindows 'docs' hierarchy, for example docs/htmlhelp/fl.chm. For other user-contributed packages, please see the Contributions page on the wxWindows Web site (http://www.wxwindows.org). Helpview Helpview is a program for displaying wxWindows HTML Help files. In many cases, you may wish to use the wxWindows HTML Help classes from within your application, but this provides a handy stand-alone viewer. See wxHTML Notes (p. 1691) for more details. You can find it in samples/html/helpview. Tex2RTF Supplied with wxWindows is a utility called Tex2RTF for converting LaTeX manuals HTML, MS HTML Help, wxHTML Help, RTF, and Windows Help RTF formats. Tex2RTF is used for the wxWindows manuals and can be used independently by authors wishing to create on-line and printed manuals from the same LaTeX source. Please see the separate documentation for Tex2RTF. You can find it under utils/tex2rtf. Helpgen Helpgen takes C++ header files and generates a Tex2RTF-compatible documentation file for each class it finds, using comments as appropriate. This is a good way to start a reference for a set of classes. Helpgen can be found in utils/HelpGen. Emulator Xnest-based display emulator for X11-based PDA applications. On some systems, the Xnest window does not synchronise with the 'skin' window. This program can be found in utils/emulator. Configuration Tool The wxWindows Configuration Tool is a work in progress intended to make it easier to configure wxWindows features in detail. It exports setup.h configurations and will eventually generate makefile config files. Invoking compilers is also on the cards. Since configurations are handled one at a time, the tool is of limited used until further development can be done. The program can be found in utils/configtool. XRC resource system This is the sizer-aware resource system, and uses XMLbased resource specifications that can be generated by tools such as wxDesigner (http://www.roebling.de) and XRC's own wxrcedit. You can find this in contrib/src/xrc, contrib/include/wx/xrc, contrib/samples/xrc, and contrib/utils/wxrcedit. For more

10


CHAPTER 4
information, see the XML-based resource system overview (p. 1627). Object Graphics Library OGL defines an API for applications that need to display objects connected by lines. The objects can be moved around and interacted with. You can find this in contrib/src/ogl, contrib/include/wx/ogl, and contrib/samples/ogl. Frame Layout library FL provides sophisticated pane dragging and docking facilities. You can find this in contrib/src/fl, contrib/include/wx/fl, and contrib/samples/fl. Gizmos library Gizmos is a collection of useful widgets and other classes. Classes include wxLEDNumberCtrl, wxEditableListBox, wxMultiCellCanvas. You can find this in contrib/src/gizmos, contrib/include/wx/gizmos, and contrib/samples/gizmos. Net library Net is a collection of very simple mail and web related classes. Currently there is only wxEmail, which makes it easy to send email messages via MAPI on Windows or sendmail on Unix. You can find this in contrib/src/net and contrib/include/wx/net. Animate library Animate allows you to load animated GIFs and play them on a window. The library can be extended to use other animation formats. You can find this in contrib/src/animate, contrib/include/wx/animate, and contrib/samples/animate. MMedia library Mmedia supports a variety of multimedia functionality. The status of this library is currently unclear. You can find this in contrib/src/mmedia, contrib/include/wx/mmedia, and contrib/samples/mmedia. Styled Text Control library STC is a wrapper around Scintilla, a syntax-highlighting text editor. You can find this in contrib/src/stc, contrib/include/wx/stc, and contrib/samples/stc. Plot Plot is a simple curve plotting library. You can find this in contrib/src/plot, contrib/include/wx/plot, and contrib/samples/plot.

11


Chapter 5 Programming strategies
This chapter is intended to list strategies that may be useful when writing and debugging wxWindows programs. If you have any good tips, please submit them for inclusion here.

Strategies for reducing programming errors
Use ASSERT
Although I haven't done this myself within wxWindows, it is good practice to use ASSERT statements liberally, that check for conditions that should or should not hold, and print out appropriate error messages. These can be compiled out of a nondebugging version of wxWindows and your application. Using ASSERT is an example of 'defensive programming': it can alert you to problems later on.

Use wxString in preference to character arrays
Using wxString can be much safer and more convenient than using char *. Again, I haven't practiced what I'm preaching, but I'm now trying to use wxString wherever possible. You can reduce the possibility of memory leaks substantially, and it is much more convenient to use the overloaded operators than functions such as strcmp. wxString won't add a significant overhead to your program; the overhead is compensated for by easier manipulation (which means less code). The same goes for other data types: use classes wherever possible.

Strategies for portability
Use relative positioning or constraints
Don't use absolute panel item positioning if you can avoid it. Different GUIs have very differently sized panel items. Consider using the constraint system, although this can be complex to program. Alternatively, you could use alternative .wrc (wxWindows resource files) on different platforms, with slightly different dimensions in each. Or space your panel items out to avoid problems.

Use wxWindows resource files

12


CHAPTER 5
Use .xrc (wxWindows resource files) where possible, because they can be easily changed independently of source code.

Strategies for debugging
Positive thinking
It is common to blow up the problem in one's imagination, so that it seems to threaten weeks, months or even years of work. The problem you face may seem insurmountable: but almost never is. Once you have been programming for some time, you will be able to remember similar incidents that threw you into the depths of despair. But remember, you always solved the problem, somehow! Perseverance is often the key, even though a seemingly trivial problem can take an apparently inordinate amount of time to solve. In the end, you will probably wonder why you worried so much. That's not to say it isn't painful at the time. Try not to worry -- there are many more important things in life.

Simplify the problem
Reduce the code exhibiting the problem to the smallest program possible that exhibits the problem. If it is not possible to reduce a large and complex program to a very small program, then try to ensure your code doesn't hide the problem (you may have attempted to minimize the problem in some way: but now you want to expose it). With luck, you can add a small amount of code that causes the program to go from functioning to non-functioning state. This should give a clue to the problem. In some cases though, such as memory leaks or wrong deallocation, this can still give totally spurious results!

Use a debugger
This sounds like facetious advice, but it is surprising how often people don't use a debugger. Often it is an overhead to install or learn how to use a debugger, but it really is essential for anything but the most trivial programs.

Use logging functions
There is a variety of logging functions that you can use in your program: see Logging functions (p. 1520). Using tracing statements may be more convenient than using the debugger in some circumstances (such as when your debugger doesn't support a lot of debugging code, or you wish to print a bunch of variables).

13


CHAPTER 5 Use the wxWindows debugging facilities
You can use wxDebugContext to check for memory leaks and corrupt memory: in fact in debugging mode, wxWindows will automatically check for memory leaks at the end of the program if wxWindows is suitably configured. Depending on the operating system and compiler, more or less specific information about the problem will be logged. You should also use debug macros (p. 1529) as part of a 'defensive programming' strategy, scattering wxASSERTs liberally to test for problems in your code as early as possible. Forward thinking will save a surprising amount of time in the long run. See the debugging overview (p. 1598) for further information.

14


Chapter 6 Libraries list
Starting from version 2.5.0 wxWindows can be built either as a single large library (this is called the monolithic build) or as several smaller libraries (multilib build). Multilib build is the default. wxWindows library is divided into libraries briefly described below. This diagram show dependencies between them:

wxBase
Every wxWindows application must link against this library. It contains mandatory classes that any wxWindows code depends on (e.g. wxString (p. 1200)) and portability classes that abstract differences between platforms. wxBase can be used to develop console mode applications, it does not require any GUI libraries or running X Window System on Unix.

wxNet
Classes for network access:   wxSocket classes (wxSocketClient (p. 1148), wxSocketServer (p. 1152) and related classes) wxSocketOutputStream (p. 1152) and wxSocketInputStream (p. 1151)

15


CHAPTER 6
   sockets-based IPC classes (wxTCPServer (p. 1101), wxTCPClient (p. 131) and wxTCPConnection (p. 191)) wxURL (p. 1355) wxInternetFSHandler (a wxFileSystem handler (p. 1601)) Requires wxBase.

wxXML
This library contains simple classes for parsing XML documents. Note that their API will change in the future and backward compatibility will not be preserved. Use of this library in your applications is not recommended, it is only meant for use by XML resources system. Future versions of wxWindows will contain new XML handling classes with DOM-like API. Requires wxBase.

wxCore
Basic GUI classes such as GDI classes or controls are in this library. All wxWindows GUI applications must link against this library, only console mode applications don't.

wxAdvanced
More advanced or rarely used GUI classes:              wxBufferedDC wxCalendarCtrl (p. 108) wxDragImage (p. 421) wxGrid classes (p. 1662) wxJoystick (p. 768) wxLayoutAlgorithm (p. 781) wxSplashScreen (p. 1162) wxTaskBarIcon (p. 1240) wxTipDialog wxSound (p. 1384) wxWizard (p. 1437) wxSashLayoutWindow (p. 1065) wxSashWindow (p. 1068)

Requires wxCore and wxBase.

wxGL

16


CHAPTER 6
This library contains wxGLCanvas (p. 566) class for integrating OpenGL library with wxWindows. Unlike all others, this library is not part of the monolithic library, it is always built as separate library. Requires wxCore and wxBase.

wxHTML
Simple HTML renderer and other HTML rendering classes (p. 1691) are contained in this library, as well as wxHtmlHelpController (p. 672), wxBestHelpController (p. 644) and wxHtmlListBox (p. 683). Requires wxCore and wxBase.

wxODBC
Database classes (p. 1668). Requires wxBase.

wxDbGrid
wxDbGridTableBase (p. 338) class which combines wxGrid (p. 569) and wxDbTable (p. 301). Requires wxODBC and wxAdvanced.

17


Chapter 7 Alphabetical class reference

wxAcceleratorEntry
An object used by an application wishing to create an accelerator table (p. 19). Derived from None Include files <wx/accel.h> See also wxAcceleratorTable (p. 19), wxWindow::SetAcceleratorTable (p. 1419)

wxAcceleratorEntry::wxAcceleratorEntry
wxAcceleratorEntry() Default constructor. wxAcceleratorEntry(int flags, int keyCode, int cmd) Constructor. Parameters flags One of wxACCEL_ALT, wxACCEL_SHIFT, wxACCEL_CTRL and wxACCEL_NORMAL. Indicates which modifier key is held down. keyCode The keycode to be detected. See Keycodes (p. 1539) for a full list of keycodes. cmd The menu or control command identifier.

wxAcceleratorEntry::GetCommand

18


CHAPTER 7
int GetCommand() const Returns the command identifier for the accelerator table entry.

wxAcceleratorEntry::GetFlags
int GetFlags() const Returns the flags for the accelerator table entry.

wxAcceleratorEntry::GetKeyCode
int GetKeyCode() const Returns the keycode for the accelerator table entry.

wxAcceleratorEntry::Set
void Set(int flags, int keyCode, int cmd) Sets the accelerator entry parameters. Parameters flags One of wxACCEL_ALT, wxACCEL_SHIFT, wxACCEL_CTRL and wxACCEL_NORMAL. Indicates which modifier key is held down. keyCode The keycode to be detected. See Keycodes (p. 1539) for a full list of keycodes. cmd The menu or control command identifier.

wxAcceleratorTable
An accelerator table allows the application to specify a table of keyboard shortcuts for menus or other commands. On Windows, menu or button commands are supported; on GTK, only menu commands are supported. The object wxNullAcceleratorTable is defined to be a table with no data, and is the initial accelerator table for a window. Derived from wxObject (p. 954)

19


CHAPTER 7
Include files <wx/accel.h> Example
wxAcceleratorEntry entries[4]; entries[0].Set(wxACCEL_CTRL, (int) 'N', entries[1].Set(wxACCEL_CTRL, (int) 'X', entries[2].Set(wxACCEL_SHIFT, (int) 'A', entries[3].Set(wxACCEL_NORMAL, WXK_DELETE, wxAcceleratorTable accel(4, entries); frame->SetAcceleratorTable(accel); ID_NEW_WINDOW); wxID_EXIT); ID_ABOUT); wxID_CUT);

Remarks An accelerator takes precedence over normal processing and can be a convenient way to program some event handling. For example, you can use an accelerator table to enable a dialog with a multi-line text control to accept CTRL-Enter as meaning 'OK' (but not in GTK+ at present). See also wxAcceleratorEntry (p. 18), wxWindow::SetAcceleratorTable (p. 1419)

wxAcceleratorTable::wxAcceleratorTable
wxAcceleratorTable() Default constructor. wxAcceleratorTable(const wxAcceleratorTable& bitmap) Copy constructor. wxAcceleratorTable(int n, wxAcceleratorEntry entries[]) Creates from an array of wxAcceleratorEntry (p. 18) objects. wxAcceleratorTable(const wxString& resource) Loads the accelerator table from a Windows resource (Windows only). Parameters n Number of accelerator entries. entries The array of entries. resource

20


CHAPTER 7
Name of a Windows accelerator. wxPython note: The wxPython constructor accepts a list of wxAcceleratorEntry objects, or 3-tuples consisting of flags, keyCode, and cmd values like you would construct wxAcceleratorEntry objects with. wxPerl note: The wxPerl constructor accepts a list of either Wx::AcceleratorEntry objects or references to 3-element arrays ( flags, keyCode, cmd ), like the parameters of Wx::AcceleratorEntry::new.

wxAcceleratorTable::~wxAcceleratorTable
~wxAcceleratorTable() Destroys the wxAcceleratorTable object.

wxAcceleratorTable::Ok
bool Ok() const Returns true if the accelerator table is valid.

wxAcceleratorTable::operator =
wxAcceleratorTable& operator =(const wxAcceleratorTable& accel) Assignment operator. This operator does not copy any data, but instead passes a pointer to the data in accel and increments a reference counter. It is a fast operation. Parameters accel Accelerator table to assign. Return value Returns reference to this object.

wxAcceleratorTable::operator ==
bool operator ==(const wxAcceleratorTable& accel) Equality operator. This operator tests whether the internal data pointers are equal (a fast test). Parameters accel

21


CHAPTER 7
Accelerator table to compare with Return value Returns true if the accelerator tables were effectively equal, false otherwise.

wxAcceleratorTable::operator !=
bool operator !=(const wxAcceleratorTable& accel) Inequality operator. This operator tests whether the internal data pointers are unequal (a fast test). Parameters accel Accelerator table to compare with Return value Returns true if the accelerator tables were unequal, false otherwise.

wxAccessible
The wxAccessible class allows wxWindows applications, and wxWindows itself, to return extended information about user interface elements to client applications such as screen readers. This is the main way in which wxWindows implements accessibility features. At present, only Microsoft Active Accessibility is supported by this class. To use this class, derive from wxAccessible, implement appropriate functions, and associate an object of the class with a window using wxWindow::SetAccessible (p. 1419). All functions return an indication of success, failure, or not implemented using values of the wxAccStatus enum type. If you return wxACC_NOT_IMPLEMENTED from any functioon, the system will try to implement the appropriate functionality. However this will not work with all functions. Most functions work with an object id, which can be zero to refer to 'this' UI element, or greater than zero to refer to the nth child element. This allows you to specify elements that don't have a corresponding wxWindow or wxAccessible; for example, the sash of a splitter window. For details on the semantics of functions and types, please refer to the Microsoft Active Accessibility 1.2 documentation. This class is compiled into wxWindows only if the wxUSE_ACCESSIBILITY setup symbol is set to 1.

22


CHAPTER 7
Derived from wxObject (p. 954) Include files <wx/access.h> Data structures Functions return a wxAccStatus error code, which may be one of the following:
typedef enum wxACC_FAIL, // The function failed wxACC_FALSE, // The function returned false wxACC_OK, // The function completed successfully wxACC_NOT_IMPLEMENTED, // The function is not implemented wxACC_NOT_SUPPORTED // The function is not supported wxAccStatus

Directions of navigation are represented by the following:
typedef enum wxNAVDIR_DOWN, wxNAVDIR_FIRSTCHILD, wxNAVDIR_LASTCHILD, wxNAVDIR_LEFT, wxNAVDIR_NEXT, wxNAVDIR_PREVIOUS, wxNAVDIR_RIGHT, wxNAVDIR_UP wxNavDir

The role of a user interface element is represented by the following type:
typedef enum wxROLE_NONE, wxROLE_SYSTEM_ALERT, wxROLE_SYSTEM_ANIMATION, wxROLE_SYSTEM_APPLICATION, wxROLE_SYSTEM_BORDER, wxROLE_SYSTEM_BUTTONDROPDOWN, wxROLE_SYSTEM_BUTTONDROPDOWNGRID, wxROLE_SYSTEM_BUTTONMENU, wxROLE_SYSTEM_CARET, wxROLE_SYSTEM_CELL, wxROLE_SYSTEM_CHARACTER, wxROLE_SYSTEM_CHART, wxROLE_SYSTEM_CHECKBUTTON, wxROLE_SYSTEM_CLIENT, wxROLE_SYSTEM_CLOCK, wxROLE_SYSTEM_COLUMN, wxROLE_SYSTEM_COLUMNHEADER, wxROLE_SYSTEM_COMBOBOX, wxROLE_SYSTEM_CURSOR, wxROLE_SYSTEM_DIAGRAM, wxROLE_SYSTEM_DIAL, wxROLE_SYSTEM_DIALOG, wxROLE_SYSTEM_DOCUMENT,

23


CHAPTER 7
wxROLE_SYSTEM_DROPLIST, wxROLE_SYSTEM_EQUATION, wxROLE_SYSTEM_GRAPHIC, wxROLE_SYSTEM_GRIP, wxROLE_SYSTEM_GROUPING, wxROLE_SYSTEM_HELPBALLOON, wxROLE_SYSTEM_HOTKEYFIELD, wxROLE_SYSTEM_INDICATOR, wxROLE_SYSTEM_LINK, wxROLE_SYSTEM_LIST, wxROLE_SYSTEM_LISTITEM, wxROLE_SYSTEM_MENUBAR, wxROLE_SYSTEM_MENUITEM, wxROLE_SYSTEM_MENUPOPUP, wxROLE_SYSTEM_OUTLINE, wxROLE_SYSTEM_OUTLINEITEM, wxROLE_SYSTEM_PAGETAB, wxROLE_SYSTEM_PAGETABLIST, wxROLE_SYSTEM_PANE, wxROLE_SYSTEM_PROGRESSBAR, wxROLE_SYSTEM_PROPERTYPAGE, wxROLE_SYSTEM_PUSHBUTTON, wxROLE_SYSTEM_RADIOBUTTON, wxROLE_SYSTEM_ROW, wxROLE_SYSTEM_ROWHEADER, wxROLE_SYSTEM_SCROLLBAR, wxROLE_SYSTEM_SEPARATOR, wxROLE_SYSTEM_SLIDER, wxROLE_SYSTEM_SOUND, wxROLE_SYSTEM_SPINBUTTON, wxROLE_SYSTEM_STATICTEXT, wxROLE_SYSTEM_STATUSBAR, wxROLE_SYSTEM_TABLE, wxROLE_SYSTEM_TEXT, wxROLE_SYSTEM_TITLEBAR, wxROLE_SYSTEM_TOOLBAR, wxROLE_SYSTEM_TOOLTIP, wxROLE_SYSTEM_WHITESPACE, wxROLE_SYSTEM_WINDOW wxAccRole

Objects are represented by the following type:
typedef enum wxOBJID_WINDOW = wxOBJID_SYSMENU = wxOBJID_TITLEBAR = wxOBJID_MENU = wxOBJID_CLIENT = wxOBJID_VSCROLL = wxOBJID_HSCROLL = wxOBJID_SIZEGRIP = wxOBJID_CARET = wxOBJID_CURSOR = wxOBJID_ALERT = wxOBJID_SOUND = wxAccObject

0x00000000, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFD, 0xFFFFFFFC, 0xFFFFFFFB, 0xFFFFFFFA, 0xFFFFFFF9, 0xFFFFFFF8, 0xFFFFFFF7, 0xFFFFFFF6, 0xFFFFFFF5

Selection actions are identified by this type:
typedef enum wxACC_SEL_NONE wxACC_SEL_TAKEFOCUS wxACC_SEL_TAKESELECTION = 0, = 1, = 2,

24


CHAPTER 7
wxACC_SEL_EXTENDSELECTION = 4, wxACC_SEL_ADDSELECTION = 8, wxACC_SEL_REMOVESELECTION = 16 wxAccSelectionFlags

States are represented by the following:
define define define define define define define define define define define define define define define define define define define define define define define define define define wxACC_STATE_SYSTEM_ALERT_HIGH wxACC_STATE_SYSTEM_ALERT_MEDIUM wxACC_STATE_SYSTEM_ALERT_LOW wxACC_STATE_SYSTEM_ANIMATED wxACC_STATE_SYSTEM_BUSY wxACC_STATE_SYSTEM_CHECKED wxACC_STATE_SYSTEM_COLLAPSED wxACC_STATE_SYSTEM_DEFAULT wxACC_STATE_SYSTEM_EXPANDED wxACC_STATE_SYSTEM_EXTSELECTABLE wxACC_STATE_SYSTEM_FLOATING wxACC_STATE_SYSTEM_FOCUSABLE wxACC_STATE_SYSTEM_FOCUSED wxACC_STATE_SYSTEM_HOTTRACKED wxACC_STATE_SYSTEM_INVISIBLE wxACC_STATE_SYSTEM_MARQUEED wxACC_STATE_SYSTEM_MIXED wxACC_STATE_SYSTEM_MULTISELECTABLE wxACC_STATE_SYSTEM_OFFSCREEN wxACC_STATE_SYSTEM_PRESSED wxACC_STATE_SYSTEM_PROTECTED wxACC_STATE_SYSTEM_READONLY wxACC_STATE_SYSTEM_SELECTABLE wxACC_STATE_SYSTEM_SELECTED wxACC_STATE_SYSTEM_SELFVOICING wxACC_STATE_SYSTEM_UNAVAILABLE 0x00000001 0x00000002 0x00000004 0x00000008 0x00000010 0x00000020 0x00000040 0x00000080 0x00000100 0x00000200 0x00000400 0x00000800 0x00001000 0x00002000 0x00004000 0x00008000 0x00010000 0x00020000 0x00040000 0x00080000 0x00100000 0x00200000 0x00400000 0x00800000 0x01000000 0x02000000

Event identifiers that can be sent via wxAccessible::NotifyEvent (p. 29) are as follows:
define define define define define define define define define define define define define define define define define define define define define define define define define define define define define wxACC_EVENT_SYSTEM_SOUND wxACC_EVENT_SYSTEM_ALERT wxACC_EVENT_SYSTEM_FOREGROUND wxACC_EVENT_SYSTEM_MENUSTART wxACC_EVENT_SYSTEM_MENUEND wxACC_EVENT_SYSTEM_MENUPOPUPSTART wxACC_EVENT_SYSTEM_MENUPOPUPEND wxACC_EVENT_SYSTEM_CAPTURESTART wxACC_EVENT_SYSTEM_CAPTUREEND wxACC_EVENT_SYSTEM_MOVESIZESTART wxACC_EVENT_SYSTEM_MOVESIZEEND wxACC_EVENT_SYSTEM_CONTEXTHELPSTART wxACC_EVENT_SYSTEM_CONTEXTHELPEND wxACC_EVENT_SYSTEM_DRAGDROPSTART wxACC_EVENT_SYSTEM_DRAGDROPEND wxACC_EVENT_SYSTEM_DIALOGSTART wxACC_EVENT_SYSTEM_DIALOGEND wxACC_EVENT_SYSTEM_SCROLLINGSTART wxACC_EVENT_SYSTEM_SCROLLINGEND wxACC_EVENT_SYSTEM_SWITCHSTART wxACC_EVENT_SYSTEM_SWITCHEND wxACC_EVENT_SYSTEM_MINIMIZESTART wxACC_EVENT_SYSTEM_MINIMIZEEND wxACC_EVENT_OBJECT_CREATE wxACC_EVENT_OBJECT_DESTROY wxACC_EVENT_OBJECT_SHOW wxACC_EVENT_OBJECT_HIDE wxACC_EVENT_OBJECT_REORDER wxACC_EVENT_OBJECT_FOCUS 0x0001 0x0002 0x0003 0x0004 0x0005 0x0006 0x0007 0x0008 0x0009 0x000A 0x000B 0x000C 0x000D 0x000E 0x000F 0x0010 0x0011 0x0012 0x0013 0x0014 0x0015 0x0016 0x0017 0x8000 0x8001 0x8002 0x8003 0x8004 0x8005

25


CHAPTER 7
define define define define define define define define define define define define define wxACC_EVENT_OBJECT_SELECTION wxACC_EVENT_OBJECT_SELECTIONADD wxACC_EVENT_OBJECT_SELECTIONREMOVE wxACC_EVENT_OBJECT_SELECTIONWITHIN wxACC_EVENT_OBJECT_STATECHANGE wxACC_EVENT_OBJECT_LOCATIONCHANGE wxACC_EVENT_OBJECT_NAMECHANGE wxACC_EVENT_OBJECT_DESCRIPTIONCHANGE wxACC_EVENT_OBJECT_VALUECHANGE wxACC_EVENT_OBJECT_PARENTCHANGE wxACC_EVENT_OBJECT_HELPCHANGE wxACC_EVENT_OBJECT_DEFACTIONCHANGE wxACC_EVENT_OBJECT_ACCELERATORCHANGE 0x8006 0x8007 0x8008 0x8009 0x800A 0x800B 0x800C 0x800D 0x800E 0x800F 0x8010 0x8011 0x8012

wxAccessible::wxAccessible
wxAccessible(wxWindow* win = NULL) Constructor, taking an optional window. The object can be associated with a window later.

wxAccessible::~wxAccessible
~wxAccessible() Destructor.

wxAccessible::DoDefaultAction
virtual wxAccStatus DoDefaultAction(int childId) Performs the default action for the object. childId is 0 (the action for this object) or greater than 0 (the action for a child). Return wxACC_NOT_SUPPORTED if there is no default action for this window (e.g. an edit control).

wxAccessible::GetChild
virtual wxAccStatus GetChild(int childId, wxAccessible** child) Gets the specified child (starting from 1). If child is NULL and the return value is wxACC_OK, this means that the child is a simple element and not an accessible object.

wxAccessible::GetChildCount
virtual wxAccStatus GetChildCount(int* childCount) Returns the number of children in childCount.

26


CHAPTER 7 wxAccessible::GetDefaultAction
virtual wxAccStatus GetDefaultAction(int childId, wxString* actionName) Gets the default action for this object (0) or a child (greater than 0). Return wxACC_OK even if there is no action. actionName is the action, or the empty string if there is no action. The retrieved string describes the action that is performed on an object, not what the object does as a result. For example, a toolbar button that prints a document has a default action of "Press" rather than "Prints the current document."

wxAccessible::GetDescription
virtual wxAccStatus GetDescription(int childId, wxString* description) Returns the description for this object or a child.

wxAccessible::GetFocus
virtual wxAccStatus GetFocus(int* childId, wxAccessible** child) Gets the window with the keyboard focus. If childId is 0 and child is NULL, no object in this subhierarchy has the focus. If this object has the focus, child should be 'this'.

wxAccessible::GetHelpText
virtual wxAccStatus GetHelpText(int childId, wxString* helpText) Returns help text for this object or a child, similar to tooltip text.

wxAccessible::GetKeyboardShortcut
virtual wxAccStatus GetKeyboardShortcut(int childId, wxString* shortcut) Returns the keyboard shortcut for this object or child. Return e.g. ALT+K.

wxAccessible::GetLocation
virtual wxAccStatus GetLocation(wxRect& rect, int elementId) Returns the rectangle for this object (id is 0) or a child element (id is greater than 0).rect is in screen coordinates.

wxAccessible::GetName
virtual wxAccStatus GetName(int childId, wxString* name)

27


CHAPTER 7
Gets the name of the specified object.

wxAccessible::GetParent
virtual wxAccStatus GetParent(wxAccessible** parent) Returns the parent of this object, or NULL.

wxAccessible::GetRole
virtual wxAccStatus GetRole(int childId, wxAccRole* role) Returns a role constant describing this object. See wxAccessible (p. 22) for a list of these roles.

wxAccessible::GetSelections
virtual wxAccStatus GetSelections(wxVariant* selections) Gets a variant representing the selected children of this object. Acceptable values are:     a null variant (IsNull() returns TRUE) a list variant (GetType() == wxT("list")) an integer representing the selected child element, or 0 if this object is selected (GetType() == wxT("long")) a "void*" pointer to a wxAccessible child object

wxAccessible::GetState
virtual wxAccStatus GetState(int childId, long* state) Returns a state constant. See wxAccessible (p. 22) for a list of these states.

wxAccessible::GetValue
virtual wxAccStatus GetValue(int childId, wxString* strValue) Returns a localized string representing the value for the object or child.

wxAccessible::GetWindow

28


CHAPTER 7
wxWindow* GetWindow() Returns the window associated with this object.

wxAccessible::HitTest
virtual wxAccStatus HitTest(const wxPoint& pt, int* childId, wxAccessible** childObject) Returns a status value and object id to indicate whether the given point was on this or a child object. Can return either a child object, or an integer representing the child element, starting from 1. pt is in screen coordinates.

wxAccessible::Navigate
virtual wxAccStatus Navigate(wxNavDir navDir, int fromId, int* toId, wxAccessible** toObject) Navigates from fromId to toId/toObject.

wxAccessible::NotifyEvent
virtual static void NotifyEvent(int eventType, wxWindow* window, wxAccObjectt objectType, int objectType) Allows the application to send an event when something changes in an accessible object.

wxAccessible::Select
virtual wxAccStatus Select(int childId, wxAccSelectionFlags selectFlags) Selects the object or child. See wxAccessible (p. 22) for a list of the selection actions.

wxAccessible::SetWindow
void SetWindow(wxWindow* window) Sets the window associated with this object.

wxActivateEvent
An activate event is sent when a window or application is being activated or deactivated.

29


CHAPTER 7
Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process an activate event, use these event handler macros to direct input to a member function that takes a wxActivateEvent argument. EVT_ACTIVATE(func) EVT_ACTIVATE_APP(func) Process a wxEVT_ACTIVATE event. Process a wxEVT_ACTIVATE_APP event.

Remarks A top-level window (a dialog or frame) receives an activate event when is being activated or deactivated. This is indicated visually by the title bar changing colour, and a subwindow gaining the keyboard focus. An application is activated or deactivated when one of its frames becomes activated, or a frame becomes inactivate resulting in all application frames being inactive. (Windows only) See also Event handling overview (p. 1602)

wxActivateEvent::wxActivateEvent
wxActivateEvent(WXTYPE eventType = 0, bool active = true, int id = 0) Constructor.

wxActivateEvent::m_active
bool m_active true if the window or application was activated.

wxActivateEvent::GetActive
bool GetActive() const Returns true if the application or window is being activated, false otherwise.

30


CHAPTER 7

wxApp
The wxApp class represents the application itself. It is used to:     set and get application-wide properties; implement the windowing system message or event loop; initiate application processing via wxApp::OnInit (p. 36); allow default processing of events not handled by other objects in the application.

You should use the macro IMPLEMENT_APP(appClass) in your application implementation file to tell wxWindows how to create an instance of your application class. Use DECLARE_APP(appClass) in a header file if you want the wxGetApp function (which returns a reference to your application object) to be visible to other files. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/app.h> See also wxApp overview (p. 1570)

wxApp::wxApp
void wxApp() Constructor. Called implicitly with a definition of a wxApp object.

wxApp::~wxApp
void ~wxApp() Destructor. Will be called implicitly on program exit if the wxApp object is created on the stack.

wxApp::argc

31


CHAPTER 7
int argc Number of command line arguments (after environment-specific processing).

wxApp::argv
char ** argv Command line arguments (after environment-specific processing).

wxApp::CreateLogTarget
virtual wxLog* CreateLogTarget() Creates a wxLog class for the application to use for logging errors. The default implementation returns a new wxLogGui class. See also wxLog (p. 843)

wxApp::Dispatch
void Dispatch() Dispatches the next event in the windowing system event queue. This can be used for programming event loops, e.g.
while (app.Pending()) Dispatch();

See also wxApp::Pending (p. 38)

wxApp::FilterEvent
int FilterEvent(wxEvent& event) This function is called before processing any event and allows the application to preempt the processing of some events. If this method returns -1 the event is processed normally, otherwise either true or false should be returned and the event processing stops immediately considering that the event had been already processed (for the former return value) or that it is not going to be processed at all (for the latter one).

wxApp::GetAppName

32


CHAPTER 7
wxString GetAppName() const Returns the application name. Remarks wxWindows sets this to a reasonable default before calling wxApp::OnInit (p. 36), but the application can reset it at will.

wxApp::GetAuto3D
bool GetAuto3D() const Returns true if 3D control mode is on, false otherwise. See also wxApp::SetAuto3D (p. 39)

wxApp::GetClassName
wxString GetClassName() const Gets the class name of the application. The class name may be used in a platform specific manner to refer to the application. See also wxApp::SetClassName (p. 39)

wxApp::GetExitOnFrameDelete
bool GetExitOnFrameDelete() const Returns true if the application will exit when the top-level window is deleted, false otherwise. See also wxApp::SetExitOnFrameDelete (p. 40), wxApp shutdown overview (p. 1571)

wxApp::GetTopWindow
virtual wxWindow * GetTopWindow() const Returns a pointer to the top window. Remarks

33


CHAPTER 7
If the top window hasn't been set using wxApp::SetTopWindow (p. 40), this function will find the first top-level window (frame or dialog) and return that. See also SetTopWindow (p. 40)

wxApp::GetUseBestVisual
bool GetUseBestVisual() const Returns true if the application will use the best visual on systems that support different visuals, false otherwise. See also SetUseBestVisual (p. 41)

wxApp::GetVendorName
wxString GetVendorName() const Returns the application's vendor name.

wxApp::ExitMainLoop
void ExitMainLoop() Call this to explicitly exit the main message (event) loop. You should normally exit the main loop (and the application) by deleting the top window.

wxApp::MainLoop
int MainLoop() Called by wxWindows on creation of the application. Override this if you wish to provide your own (environment-dependent) main loop. Return value Returns 0 under X, and the wParam of the WM_QUIT message under Windows.

wxApp::OnAssert
void OnAssert(const wxChar *file, int line, const wxChar *cond, const wxChar *msg) This function is called when an assert failure occurs, i.e. the condition specified in wxASSERT (p. 1529) macro evaluated to false. It is only called in debug mode (when

34


CHAPTER 7
__WXDEBUG__ is defined) as asserts are not left in the release code at all. The base class version show the default assert failure dialog box proposing to the user to stop the program, continue or ignore all subsequent asserts. Parameters file the name of the source file where the assert occured line the line number in this file where the assert occured cond the condition of the failed assert in string form msg the message specified as argument to wxASSERT_MSG (p. 1530) or wxFAIL_MSG (p. 1531), will be NULL if just wxASSERT (p. 1529) or wxFAIL (p. 1531) was used

wxApp::OnCmdLineError
bool OnCmdLineError(wxCmdLineParser& parser) Called when command line parsing fails (i.e. an incorrect command line option was specified by the user). The default behaviour is to show the program usage text and abort the program. Return true to continue normal execution or false to return false from OnInit (p. 36) thus terminating the program. See also OnInitCmdLine (p. 37)

wxApp::OnCmdLineHelp
bool OnCmdLineHelp(wxCmdLineParser& parser) Called when the help option (--help) was specified on the command line. The default behaviour is to show the program usage text and abort the program. Return true to continue normal execution or false to return false from OnInit (p. 36) thus terminating the program. See also

35


CHAPTER 7
OnInitCmdLine (p. 37)

wxApp::OnCmdLineParsed
bool OnCmdLineParsed(wxCmdLineParser& parser) Called after the command line had been successfully parsed. You may override this method to test for the values of the various parameters which could be set from the command line. Don't forget to call the base class version unless you want to suppress processing of the standard command line options. Return true to continue normal execution or false to return false from OnInit (p. 36) thus terminating the program. See also OnInitCmdLine (p. 37)

wxApp::OnExit
int OnExit() Provide this member function for any processing which needs to be done as the application is about to exit. OnExit is called after destroying all application windows and controls, but before wxWindows cleanup.

wxApp::OnFatalException
void OnFatalException() This function may be called if something fatal happens: an unhandled exception under Win32 or a a fatal signal under Unix, for example. However, this will not happen by default: you have to explicitly call wxHandleFatalExceptions (p. 1467) to enable this. Generally speaking, this function should only show a message to the user and return. You may attempt to save unsaved data but this is not guaranteed to work and, in fact, probably won't. See also wxHandleFatalExceptions (p. 1467)

wxApp::OnInit
bool OnInit() This must be provided by the application, and will usually create the application's main

36


CHAPTER 7
window, optionally calling wxApp::SetTopWindow (p. 40). Notice that if you want to to use the command line processing provided by wxWindows you have to call the base class version in the derived class OnInit(). Return true to continue processing, false to exit the application.

wxApp::OnInitCmdLine
void OnInitCmdLine(wxCmdLineParser& parser) Called from OnInit (p. 36) and may be used to initialize the parser with the command line options for this application. The base class versions adds support for a few standard options only.

wxApp::OnQueryEndSession
void OnQueryEndSession(wxCloseEvent& event) This is an event handler function called when the operating system or GUI session is about to close down. Typically, an application will try to save unsaved documents at this point. If wxCloseEvent::CanVeto (p. 140) returns true, the application is allowed to veto the shutdown by calling wxCloseEvent::Veto (p. 141). The application might veto the shutdown after prompting for documents to be saved, and the user has cancelled the save. Use the EVT_QUERY_END_SESSION event table macro to handle query end session events. You should check whether the application is forcing the deletion of the window using wxCloseEvent::GetForce (p. 140). If this is true, destroy the window using wxWindow::Destroy (p. 1395). If not, it is up to you whether you respond by destroying the window. The default handler calls wxWindow::Close (p. 1393) on the top-level window, and vetoes the shutdown if Close returns false. This will be sufficient for many applications. Remarks Under X, OnQueryEndSession is called in response to the 'save session' event. Under Windows, OnQueryEndSession is called in response to the WM_QUERYENDSESSION message. See also wxWindow::Close (p. 1393), wxCloseEvent (p. 139)

37


CHAPTER 7 wxApp::OnRun
virtual int OnRun() This virtual function is where the execution of a program written in wxWindows starts. The default implementation just enters the main loop and starts handling the events until it terminates, either because ExitMainLoop (p. 34) has been explicitly called or because the last frame has been deleted and GetExitOnFrameDelete (p. 33) flag is true (this is the default).

wxApp::OnUnhandledException
virtual void OnUnhandledException() This function is called when an unhandled C++ exception occurs inside OnRun() (p. 38) (the exceptions which occur during the program startup and shutdown might not be caught at all). Note that the exception type is lost by now, so if you want to really handle the exception you should override OnRun() (p. 38) and put a try/catch clause around the call to the base class version there.

wxApp::ProcessMessage
bool ProcessMessage(WXMSG *msg) Windows-only function for processing a message. This function is called from the main message loop, checking for windows that may wish to process it. The function returns true if the message was processed, false otherwise. If you use wxWindows with another class library with its own message loop, you should make sure that this function is called to allow wxWindows to receive messages. For example, to allow co-existence with the Microsoft Foundation Classes, override the PreTranslateMessage function:
// Provide wxWindows message loop compatibility BOOL CTheApp::PreTranslateMessage(MSG *msg) { if (wxTheApp && wxTheApp->ProcessMessage((WXMSW *)msg)) return true; else return CWinApp::PreTranslateMessage(msg); }

wxApp::Pending
bool Pending() Returns true if unprocessed events are in the window system event queue. See also wxApp::Dispatch (p. 32)

38


CHAPTER 7 wxApp::SendIdleEvents
bool SendIdleEvents(wxWindow* win, wxIdleEvent& event) Sends idle events to a window and its children. Please note that this function is internal to wxWindows and shouldn't be used by user code. Remarks These functions poll the top-level windows, and their children, for idle event processing. If true is returned, more OnIdle processing is requested by one or more window. See also wxIdleEvent (p. 726)

wxApp::SetAppName
void SetAppName(const wxString& name) Sets the name of the application. The name may be used in dialogs (for example by the document/view framework). A default name is set by wxWindows. See also wxApp::GetAppName (p. 32)

wxApp::SetAuto3D
void SetAuto3D(const bool auto3D) Switches automatic 3D controls on or off. Parameters auto3D If true, all controls will be created with 3D appearances unless overridden for a control or dialog. The default is true Remarks This has an effect on Windows only. See also wxApp::GetAuto3D (p. 33)

wxApp::SetClassName 39


CHAPTER 7
void SetClassName(const wxString& name) Sets the class name of the application. This may be used in a platform specific manner to refer to the application. See also wxApp::GetClassName (p. 33)

wxApp::SetExitOnFrameDelete
void SetExitOnFrameDelete(bool flag) Allows the programmer to specify whether the application will exit when the top-level frame is deleted. Parameters flag If true (the default), the application will exit when the top-level frame is deleted. If false, the application will continue to run. See also wxApp::GetExitOnFrameDelete (p. 33), wxApp shutdown overview (p. 1571)

wxApp::SetTopWindow
void SetTopWindow(wxWindow* window) Sets the 'top' window. You can call this from within wxApp::OnInit (p. 36) to let wxWindows know which is the main window. You don't have to set the top window; it is only a convenience so that (for example) certain dialogs without parents can use a specific window as the top window. If no top window is specified by the application, wxWindows just uses the first frame or dialog in its top-level window list, when it needs to use the top window. Parameters window The new top window. See also wxApp::GetTopWindow (p. 33), wxApp::OnInit (p. 36)

wxApp::SetVendorName

40


CHAPTER 7
void SetVendorName(const wxString& name) Sets the name of application's vendor. The name will be used in registry access. A default name is set by wxWindows. See also wxApp::GetVendorName (p. 34)

wxApp::SetUseBestVisual
void SetUseBestVisual(bool flag) Allows the programmer to specify whether the application will use the best visual on systems that support several visual on the same display. This is typically the case under Solaris and IRIX, where the default visual is only 8-bit whereas certain applications are supposed to run in TrueColour mode. Note that this function has to be called in the constructor of the wxApp instance and won't have any effect when called later on. This function currently only has effect under GTK. Parameters flag If true, the app will use the best visual.

wxApp::HandleEvent
virtual void HandleEvent(wxEvtHandler *handler, wxEventFunction func, wxEvent& event) const This function simply invokes the given method func of the specified event handler handler with the event as parameter. It exists solely to allow to catch the C++ exceptions which could be thrown by all event handlers in the application in one place: if you want to do this, override this function in your wxApp-derived class and add try/catch clause(s) to it.

wxApp::Yield
bool Yield(bool onlyIfNeeded = false) Yields control to pending messages in the windowing system. This can be useful, for example, when a time-consuming process writes to a text window. Without an occasional yield, the text window will not be updated properly, and on systems with cooperative multitasking, such as Windows 3.1 other processes will not respond. Caution should be exercised, however, since yielding may allow the user to perform

41


CHAPTER 7
actions which are not compatible with the current task. Disabling menu items or whole menus during processing can avoid unwanted reentrance of code: see ::wxSafeYield (p. 1467) for a better function. Note that Yield() will not flush the message logs. This is intentional as calling Yield() is usually done to quickly update the screen and popping up a message box dialog may be undesirable. If you do wish to flush the log messages immediately (otherwise it will be done during the next idle loop iteration), call wxLog::FlushActive (p. 848). Calling Yield() recursively is normally an error and an assert failure is raised in debug build if such situation is detected. However if the the onlyIfNeeded parameter is true, the method will just silently return false instead.

wxArray
This section describes the so called dynamic arrays. This is a C array-like data structure i.e. the member access time is constant (and not linear according to the number of container elements as for linked lists). However, these arrays are dynamic in the sense that they will automatically allocate more memory if there is not enough of it for adding a new element. They also perform range checking on the index values but in debug mode only, so please be sure to compile your application in debug mode to use it (see debugging overview (p. 1598) for details). So, unlike the arrays in some other languages, attempt to access an element beyond the arrays bound doesn't automatically expand the array but provokes an assertion failure instead in debug build and does nothing (except possibly crashing your program) in the release build. The array classes were designed to be reasonably efficient, both in terms of run-time speed and memory consumption and the executable size. The speed of array item access is, of course, constant (independent of the number of elements) making them much more efficient than linked lists (wxList (p. 786)). Adding items to the arrays is also implemented in more or less constant time - but the price is preallocating the memory in advance. In the memory management (p. 45) section you may find some useful hints about optimizing wxArray memory usage. As for executable size, all wxArray functions are inline, so they do not take any space at all. wxW indows has three different kinds of array. All of them derive from wxBaseArray class which works with untyped data and can not be used directly. The standard macros WX_DEFINE_ARRAY(), WX_DEFINE_SORTED_ARRAY() and WX_DEFINE_OBJARRAY() are used to define a new class deriving from it. The classes declared will be called in this documentation wxArray, wxSortedArray and wxObjArray but you should keep in mind that no classes with such names actually exist, each time you use one of WX_DEFINE_XXXARRAY macro you define a class with a new name. In fact, these names are "template" names and each usage of one of the macros mentioned above creates a template specialization for the given element type. wxArray is suitable for storing integer types and pointers which it does not treat as objects in any way, i.e. the element pointed to by the pointer is not deleted when the element is removed from the array. It should be noted that all of wxArray's functions are inline, so it costs strictly nothing to define as many array types as you want (either in terms of the executable size or the speed) as long as at least one of them is defined and

42


CHAPTER 7
this is always the case because wxArrays are used by wxWindows internally. This class has one serious limitation: it can only be used for storing integral types (bool, char, short, int, long and their unsigned variants) or pointers (of any kind). An attempt to use with objects of sizeof() greater than sizeof(long) will provoke a runtime assertion failure, however declaring a wxArray of floats will not (on the machines where sizeof(float) <= sizeof(long)), yet it will not work, please use wxObjArray for storing floats and doubles (NB: a more efficient wxArrayDouble class is scheduled for the next release of wxWindows). wxSortedArray is a wxArray variant which should be used when searching in the array is a frequently used operation. It requires you to define an additional function for comparing two elements of the array element type and always stores its items in the sorted order (according to this function). Thus, it is Index() (p. 51) function execution time is O(log(N)) instead ofO(N) for the usual arrays but the Add() (p. 49) method is slower: it is O(log(N)) instead of constant time (neglecting time spent in memory allocation routine). However, in a usual situation elements are added to an array much less often than searched inside it, so wxSortedArray may lead to huge performance improvements compared to wxArray. Finally, it should be noticed that, as wxArray, wxSortedArray can be only used for storing integral types or pointers. wxObjArray class treats its elements like "objects". It may delete them when they are removed from the array (invoking the correct destructor) and copies them using the objects copy constructor. In order to implement this behaviour the definition of the wxObjArray arrays is split in two parts: first, you should declare the new wxObjArray class using WX_DECLARE_OBJARRAY() macro and then you must include the file defining the implementation of template type: <wx/arrimpl.cpp> and define the array class with WX_DEFINE_OBJARRAY() macro from a point where the full (as opposed to 'forward') declaration of the array elements class is in scope. As it probably sounds very complicated here is an example:
#include <wx/dynarray.h> // we must forward declare the array because it is used inside the class // declaration class MyDirectory; class MyFile; // this defines two new types: ArrayOfDirectories and ArrayOfFiles which can be // now used as shown below WX_DECLARE_OBJARRAY(MyDirectory, ArrayOfDirectories); WX_DECLARE_OBJARRAY(MyFile, ArrayOfFiles); class MyDirectory { ... ArrayOfDirectories m_subdirectories; // all subdirectories ArrayOfFiles m_files; // all files in this directory }; ... // now that we have MyDirectory declaration in scope we may finish the // definition of ArrayOfDirectories -- note that this expands into some C++ // code and so should only be compiled once (i.e., don't put this in the // header, but into a source file or you will get linking errors) #include <wx/arrimpl.cpp> // this is a magic incantation which must be done! WX_DEFINE_OBJARRAY(ArrayOfDirectories);

43


CHAPTER 7

// that's all!

It is not as elegant as writing
typedef std::vector<MyDirectory> ArrayOfDirectories;

but is not that complicated and allows the code to be compiled with any, however dumb, C++ compiler in the world. Things are much simpler for wxArray and wxSortedArray however: it is enough just to write
WX_DEFINE_ARRAY(int, ArrayOfDirectories); WX_DEFINE_SORTED_ARRAY(int, ArrayOfFiles);

i.e. there is only one DEFINE macro and no need for separate DECLARE one. See also: Container classes overview (p. 1592), wxList (p. 786) Include files <wx/dynarray.h> for wxArray and wxSortedArray and additionally <wx/arrimpl.cpp> for wxObjArray.

Macros for template array definition
To use an array you must first define the array class. This is done with the help of the macros in this section. The class of array elements must be (at least) forward declared for WX_DEFINE_ARRAY, WX_DEFINE_SORTED_ARRAY and WX_DECLARE_OBJARRAY macros and must be fully declared before you use WX_DEFINE_OBJARRAY macro. WX_DEFINE_ARRAY (p. 46) WX_DEFINE_EXPORTED_ARRAY (p. 46) WX_DEFINE_USER_EXPORTED_ARRAY (p. 46) WX_DEFINE_SORTED_ARRAY (p. 46) WX_DEFINE_SORTED_EXPORTED_ARRAY (p. 46) WX_DEFINE_SORTED_USER_EXPORTED_ARRAY (p. 46) WX_DECLARE_EXPORTED_OBJARRAY (p. 47) WX_DECLARE_USER_EXPORTED_OBJARRAY (p. 47) WX_DEFINE_OBJARRAY (p. 47) WX_DEFINE_EXPORTED_OBJARRAY (p. 47) WX_DEFINE_USER_EXPORTED_OBJARRAY (p. 47) To slightly complicate the matters even further, the operator -> defined by default for the array iterators by these macros only makes sense if the array element type is not a pointer itself and, although it still works, this provokes warnings from some compilers and to avoid them you should use the _PTR versions of the macros above. For example,

44


CHAPTER 7
to define an array of pointers to double you should use
WX_DEFINE_ARRAY_PTR(double *, MyArrayOfDoublePointers);

Constructors and destructors
Array classes are 100% C++ objects and as such they have the appropriate copy constructors and assignment operators. Copying wxArray just copies the elements but copying wxObjArray copies the arrays items. However, for memory-efficiency sake, neither of these classes has virtual destructor. It is not very important for wxArray which has trivial destructor anyhow, but it does mean that you should avoid deleting wxObjArray through a wxBaseArray pointer (as you would never use wxBaseArray anyhow it shouldn't be a problem) and that you should not derive your own classes from the array classes. wxArray default constructor (p. 48) wxArray copy constructors and assignment operators (p. 49) ~wxArray (p. 49)

Memory management
Automatic array memory management is quite trivial: the array starts by preallocating some minimal amount of memory (defined by WX_ARRAY_DEFAULT_INITIAL_SIZE) and when further new items exhaust already allocated memory it reallocates it adding 50% of the currently allocated amount, but no more than some maximal number which is defined by ARRAY_MAXSIZE_INCREMENT constant. Of course, this may lead to some memory being wasted (ARRAY_MAXSIZE_INCREMENT in the worst case, i.e. 4Kb in the current implementation), so the Shrink() (p. 53) function is provided to deallocate the extra memory. The Alloc() (p. 50) function can also be quite useful if you know in advance how many items you are going to put in the array and will prevent the array code from reallocating the memory more times than needed. Alloc (p. 50) Shrink (p. 53)

Number of elements and simple item access
Functions in this section return the total number of array elements and allow to retrieve them - possibly using just the C array indexing [] operator which does exactly the same as Item() (p. 52) method. Count (p. 50) GetCount (p. 51) IsEmpty (p. 51) Item (p. 52) Last (p. 52)

45


CHAPTER 7 Adding items
Add (p. 49) Insert (p. 51) SetCount (p. 53) WX_APPEND_ARRAY (p. 48)

Removing items
WX_CLEAR_ARRAY (p. 48) Empty (p. 50) Clear (p. 50) RemoveAt (p. 52) Remove (p. 52)

Searching and sorting
Index (p. 51) Sort (p. 53)

WX_DEFINE_ARRAY
WX_DEFINE_ARRAY(T, name) WX_DEFINE_EXPORTED_ARRAY(T, name) WX_DEFINE_USER_EXPORTED_ARRAY(T, name, exportspec) This macro defines a new array class named name and containing the elements of type T. The second form is used when compiling wxWindows as a DLL under Windows and array needs to be visible outside the DLL. The third is needed for exporting an array from a user DLL. Example:
WX_DEFINE_ARRAY(int, wxArrayInt); class MyClass; WX_DEFINE_ARRAY(MyClass *, wxArrayOfMyClass);

Note that wxWindows predefines the following standard array classes: wxArrayInt, wxArrayLong and wxArrayPtrVoid.

WX_DEFINE_SORTED_ARRAY
WX_DEFINE_SORTED_ARRAY(T, name)

46


CHAPTER 7
WX_DEFINE_SORTED_EXPORTED_ARRAY(T, name) WX_DEFINE_SORTED_USER_EXPORTED_ARRAY(T, name) This macro defines a new sorted array class named name and containing the elements of type T. The second form is used when compiling wxWindows as a DLL under Windows and array needs to be visible outside the DLL. The third is needed for exporting an array from a user DLL. Example:
WX_DEFINE_SORTED_ARRAY(int, wxSortedArrayInt); class MyClass; WX_DEFINE_SORTED_ARRAY(MyClass *, wxArrayOfMyClass);

You will have to initialize the objects of this class by passing a comparison function to the array object constructor like this:
int CompareInts(int n1, int n2) { return n1 - n2; } wxSortedArrayInt sorted(CompareInts); int CompareMyClassObjects(MyClass *item1, MyClass *item2) { // sort the items by their address... return Stricmp(item1->GetAddress(), item2->GetAddress()); } wxArrayOfMyClass another(CompareMyClassObjects);

WX_DECLARE_OBJARRAY
WX_DECLARE_OBJARRAY(T, name) WX_DECLARE_EXPORTED_OBJARRAY(T, name) WX_DECLARE_USER_EXPORTED_OBJARRAY(T, name) This macro declares a new object array class named name and containing the elements of type T. The second form is used when compiling wxWindows as a DLL under Windows and array needs to be visible outside the DLL. The third is needed for exporting an array from a user DLL. Example:
class MyClass; WX_DECLARE_OBJARRAY(MyClass, wxArrayOfMyClass); // note: not "MyClass *"!

You must use WX_DEFINE_OBJARRAY() (p. 47) macro to define the array class otherwise you would get link errors.

WX_DEFINE_OBJARRAY

47


CHAPTER 7
WX_DEFINE_OBJARRAY(name) WX_DEFINE_EXPORTED_OBJARRAY(name) WX_DEFINE_USER_EXPORTED_OBJARRAY(name) This macro defines the methods of the array class name not defined by the WX_DECLARE_OBJARRAY() (p. 47) macro. You must include the file <wx/arrimpl.cpp> before using this macro and you must have the full declaration of the class of array elements in scope! If you forget to do the first, the error will be caught by the compiler, but, unfortunately, many compilers will not give any warnings if you forget to do the second - but the objects of the class will not be copied correctly and their real destructor will not be called. The latter two forms are merely aliases of the first to satisfy some people's sense of symmetry when using the exported declarations. Example of usage:
// first declare the class! class MyClass { public: MyClass(const MyClass&); ... virtual ~MyClass(); }; #include <wx/arrimpl.cpp> WX_DEFINE_OBJARRAY(wxArrayOfMyClass);

WX_APPEND_ARRAY
void WX_APPEND_ARRAY(wxArray& array, wxArray& other) This macro may be used to append all elements of the other array to the array. The two arrays must be of the same type.

WX_CLEAR_ARRAY
void WX_CLEAR_ARRAY(wxArray& array) This macro may be used to delete all elements of the array before emptying it. It can not be used with wxObjArrays - but they will delete their elements anyhow when you call Empty().

Default constructors
wxArray() wxObjArray() Default constructor initializes an empty array object.

48


CHAPTER 7
wxSortedArray(int (*)(T first, T second)compareFunction) There is no default constructor for wxSortedArray classes - you must initialize it with a function to use for item comparison. It is a function which is passed two arguments of type T where T is the array element type and which should return a negative, zero or positive value according to whether the first element passed to it is less than, equal to or greater than the second one.

wxArray copy constructor and assignment operator
wxArray(const wxArray& array) wxSortedArray(const wxSortedArray& array) wxObjArray(const wxObjArray& array) wxArray& operator=(const wxArray& array) wxSortedArray& operator=(const wxSortedArray& array) wxObjArray& operator=(const wxObjArray& array) The copy constructors and assignment operators perform a shallow array copy (i.e. they don't copy the objects pointed to even if the source array contains the items of pointer type) for wxArray and wxSortedArray and a deep copy (i.e. the array element are copied too) for wxObjArray.

wxArray::~wxArray
~wxArray() ~wxSortedArray() ~wxObjArray() The wxObjArray destructor deletes all the items owned by the array. This is not done by wxArray and wxSortedArray versions - you may use WX_CLEAR_ARRAY (p. 48) macro for this.

wxArray::Add
void Add(T item, size_t copies = 1) void Add(T *item) void Add(T &item, size_t copies = 1) Appends the given number of copies of the item to the array consisting of the elements of type T.

49


CHAPTER 7
The first version is used with wxArray and wxSortedArray. The second and the third are used with wxObjArray. There is an important difference between them: if you give a pointer to the array, it will take ownership of it, i.e. will delete it when the item is deleted from the array. If you give a reference to the array, however, the array will make a copy of the item and will not take ownership of the original item. Once again, it only makes sense for wxObjArrays because the other array types never take ownership of their elements. Also note that you cannot append more than one pointer as reusing it would lead to deleting it twice (or more) and hence to a crash. You may also use WX_APPEND_ARRAY (p. 48) macro to append all elements of one array to another one but it is more efficient to use copies parameter and modify the elements in place later if you plan to append a lot of items.

wxArray::Alloc
void Alloc(size_t count) Preallocates memory for a given number of array elements. It is worth calling when the number of items which are going to be added to the array is known in advance because it will save unneeded memory reallocation. If the array already has enough memory for the given number of items, nothing happens.

wxArray::Clear
void Clear() This function does the same as Empty() (p. 50) and additionally frees the memory allocated to the array.

wxArray::Count
size_t Count() const Same as GetCount() (p. 51). This function is deprecated - it exists only for compatibility.

wxObjArray::Detach
T * Detach(size_t index) Removes the element from the array, but, unlike, Remove() (p. 52) doesn't delete it. The function returns the pointer to the removed element.

wxArray::Empty
void Empty() Empties the array. For wxObjArray classes, this destroys all of the array elements. For

50


CHAPTER 7
wxArray and wxSortedArray this does nothing except marking the array of being empty this function does not free the allocated memory, use Clear() (p. 50) for this.

wxArray::GetCount
size_t GetCount() const Return the number of items in the array.

wxArray::Index
int Index(T& item, bool searchFromEnd = false) int Index(T& item) The first version of the function is for wxArray and wxObjArray, the second is for wxSortedArray only. Searches the element in the array, starting from either beginning or the end depending on the value of searchFromEnd parameter. wxNOT_FOUND is returned if the element is not found, otherwise the index of the element is returned. Linear search is used for the wxArray and wxObjArray classes but binary search in the sorted array is used for wxSortedArray (this is why searchFromEnd parameter doesn't make sense for it). NB: even for wxObjArray classes, the operator==() of the elements in the array is not used by this function. It searches exactly the given element in the array and so will only succeed if this element had been previously added to the array, but fail even if another, identical, element is in the array.

wxArray::Insert
void Insert(T item, size_t n, size_t copies = 1) void Insert(T *item, size_t n) void Insert(T &item, size_t n, size_t copies = 1) Insert the given number of copies of the item into the array before the existing item n thus, Insert(something, 0u) will insert an item in such way that it will become the first array element. Please see Add() (p. 49) for explanation of the differences between the overloaded versions of this function.

wxArray::IsEmpty
bool IsEmpty() const

51


CHAPTER 7
Returns true if the array is empty, false otherwise.

wxArray::Item
T& Item(size_t index) const Returns the item at the given position in the array. If index is out of bounds, an assert failure is raised in the debug builds but nothing special is done in the release build. The returned value is of type "reference to the array element type" for all of the array classes.

wxArray::Last
T& Last() const Returns the last element in the array, i.e. is the same as Item(GetCount() - 1). An assert failure is raised in the debug mode if the array is empty. The returned value is of type "reference to the array element type" for all of the array classes.

wxArray::Remove
Remove(T item) Removes an element from the array by value: the first item of the array equal to item is removed, an assert failure will result from an attempt to remove an item which doesn't exist in the array. When an element is removed from wxObjArray it is deleted by the array - use Detach() (p. 50) if you don't want this to happen. On the other hand, when an object is removed from a wxArray nothing happens - you should delete it manually if required:
T *item = array[n]; delete item; array.Remove(n)

See also WX_CLEAR_ARRAY (p. 48) macro which deletes all elements of a wxArray (supposed to contain pointers).

wxArray::RemoveAt
RemoveAt(size_t index, size_t count = 1) Removes count elements starting at index from the array. When an element is removed from wxObjArray it is deleted by the array - useDetach() (p. 50) if you don't want this to happen. On the other hand, when an object is removed from a wxArray nothing happens - you should delete it manually if required:

52


CHAPTER 7
T *item = array[n]; delete item; array.RemoveAt(n)

See also WX_CLEAR_ARRAY (p. 48) macro which deletes all elements of a wxArray (supposed to contain pointers).

wxArray::SetCount
void SetCount(size_t count, T defval = T(0)) This function ensures that the number of array elements is at least count. If the array has already count or mroe items, nothing is done. Otherwise, count - GetCount() elements are added and initialized to the value defval. See also GetCount (p. 51)

wxArray::Shrink
void Shrink() Frees all memory unused by the array. If the program knows that no new items will be added to the array it may call Shrink() to reduce its memory usage. However, if a new item is added to the array, some extra memory will be allocated again.

wxArray::Sort
void Sort(CMPFUNC<T> compareFunction) The notation CMPFUNC<T> should be read as if we had the following declaration:
template int CMPFUNC(T *first, T *second);

where T is the type of the array elements. I.e. it is a function returning int which is passed two arguments of type T *. Sorts the array using the specified compare function: this function should return a negative, zero or positive value according to whether the first element passed to it is less than, equal to or greater than the second one. wxSortedArray doesn't have this function because it is always sorted.

wxArrayString
wxArrayString is an efficient container for storing wxString (p. 1200) objects. It has the same features as all wxArray (p. 42) classes, i.e. it dynamically expands when new items are added to it (so it is as easy to use as a linked list), but the access time to the

53


CHAPTER 7
elements is constant, instead of being linear in number of elements as in the case of linked lists. It is also very size efficient and doesn't take more space than a C array wxString[] type (wxArrayString uses its knowledge of internals of wxString class to achieve this). This class is used in the same way as other dynamic arrays (p. 42), except that no WX_DEFINE_ARRAY declaration is needed for it. When a string is added or inserted in the array, a copy of the string is created, so the original string may be safely deleted (e.g. if it was a char * pointer the memory it was using can be freed immediately after this). In general, there is no need to worry about string memory deallocation when using this class - it will always free the memory it uses itself. The references returned by Item (p. 57), Last (p. 57) or operator[] (p. 55) are not constant, so the array elements may be modified in place like this
array.Last().MakeUpper();

There is also a variant of wxArrayString called wxSortedArrayString which has exactly the same methods as wxArrayString, but which always keeps the string in it in (alphabetical) order. wxSortedArrayString uses binary search in its Index (p. 56) function (instead of linear search for wxArrayString::Index) which makes it much more efficient if you add strings to the array rarely (because, of course, you have to pay for Index() efficiency by having Add() be slower) but search for them often. Several methods should not be used with sorted array (basically, all which break the order of items) which is mentioned in their description. Final word: none of the methods of wxArrayString is virtual including its destructor, so this class should not be used as a base class. Derived from Although this is not true strictly speaking, this class may be considered as a specialization of wxArray (p. 42) class for the wxString member data: it is not implemented like this, but it does have all of the wxArray functions. Include files <wx/arrstr.h> See also wxArray (p. 42), wxString (p. 1200), wxString overview (p. 1574)

wxArrayString::wxArrayString
wxArrayString() wxArrayString(const wxArrayString& array) Default and copy constructors.

54


CHAPTER 7
Note that when an array is assigned to a sorted array, its contents is automatically sorted during construction.

wxArrayString::~wxArrayString
~wxArrayString() Destructor frees memory occupied by the array strings. For the performance reasons it is not virtual, so this class should not be derived from.

wxArrayString::operator=
wxArrayString & operator =(const wxArrayString& array) Assignment operator.

wxArrayString::operator==
bool operator ==(const wxArrayString& array) const Compares 2 arrays respecting the case. Returns true only if the arrays have the same number of elements and the same strings in the same order.

wxArrayString::operator!=
bool operator !=(const wxArrayString& array) const Compares 2 arrays respecting the case. Returns true if the arrays have different number of elements or if the elements don't match pairwise.

wxArrayString::operator[]
wxString& operator[](size_t nIndex) Return the array element at position nIndex. An assert failure will result from an attempt to access an element beyond the end of array in debug mode, but no check is done in release mode. This is the operator version of Item (p. 57) method.

wxArrayString::Add
size_t Add(const wxString& str, size_t copies = 1) Appends the given number of copies of the new item str to the array and returns the index of the first new item in the array.

55


CHAPTER 7
Warning: For sorted arrays, the index of the inserted item will not be, in general, equal to GetCount() (p. 56) - 1 because the item is inserted at the correct position to keep the array sorted and not appended. See also: Insert (p. 57)

wxArrayString::Alloc
void Alloc(size_t nCount) Preallocates enough memory to store nCount items. This function may be used to improve array class performance before adding a known number of items consecutively. See also: Dynamic array memory management (p. 45)

wxArrayString::Clear
void Clear() Clears the array contents and frees memory. See also: Empty (p. 56)

wxArrayString::Count
size_t Count() const Returns the number of items in the array. This function is deprecated and is for backwards compatibility only, please use GetCount (p. 56) instead.

wxArrayString::Empty
void Empty() Empties the array: after a call to this function GetCount (p. 56) will return 0. However, this function does not free the memory used by the array and so should be used when the array is going to be reused for storing other strings. Otherwise, you should use Clear (p. 56) to empty the array and free memory.

wxArrayString::GetCount
size_t GetCount() const Returns the number of items in the array.

wxArrayString::Index 56


CHAPTER 7
int Index(const char * sz, bool bCase = true, bool bFromEnd = false) Search the element in the array, starting from the beginning ifbFromEnd is false or from end otherwise. If bCase, comparison is case sensitive (default), otherwise the case is ignored. This function uses linear search for wxArrayString and binary search for wxSortedArrayString, but it ignores the bCase and bFromEnd parameters in the latter case. Returns index of the first item matched or wxNOT_FOUND if there is no match.

wxArrayString::Insert
void Insert(const wxString& str, size_t nIndex, size_t copies = 1) Insert the given number of copies of the new element in the array before the position nIndex. Thus, for example, to insert the string in the beginning of the array you would write
Insert("foo", 0);

If nIndex is equal to GetCount() this function behaves as Add (p. 55). Warning: this function should not be used with sorted arrays because it could break the order of items and, for example, subsequent calls to Index() (p. 56) would then not work!

wxArrayString::IsEmpty
IsEmpty() Returns true if the array is empty, false otherwise. This function returns the same result as GetCount() == 0 but is probably easier to read.

wxArrayString::Item
wxString& Item(size_t nIndex) const Return the array element at position nIndex. An assert failure will result from an attempt to access an element beyond the end of array in debug mode, but no check is done in release mode. See also operator[] (p. 55) for the operator version.

wxArrayString::Last
Last() Returns the last element of the array. Attempt to access the last element of an empty

57


CHAPTER 7
array will result in assert failure in debug build, however no checks are done in release mode.

wxArrayString::Remove
void Remove(const char * sz) Removes the first item matching this value. An assert failure is provoked by an attempt to remove an element which does not exist in debug build. See also: Index (p. 56)

wxArrayString::RemoveAt
void RemoveAt(size_t nIndex, size_t count = 1) Removes count items starting at position nIndex from the array.

wxArrayString::Shrink
void Shrink() Releases the extra memory allocated by the array. This function is useful to minimize the array memory consumption. See also: Alloc (p. 56), Dynamic array memory management (p. 45)

wxArrayString::Sort
void Sort(bool reverseOrder = false) Sorts the array in alphabetical order or in reverse alphabetical order if reverseOrder is true. The sort is case-sensitive. Warning: this function should not be used with sorted array because it could break the order of items and, for example, subsequent calls to Index() (p. 56) would then not work! void Sort(CompareFunction compareFunction) Sorts the array using the specified compareFunction for item comparison.CompareFunction is defined as a function taking two const wxString& parameters and returning an int value less than, equal to or greater than 0 if the first string is less than, equal to or greater than the second one. Example The following example sorts strings by their length.
static int CompareStringLen(const wxString& first, const wxString& second) {

58


CHAPTER 7
return first.length() - second.length(); } ... wxArrayString array; array.Add("one"); array.Add("two"); array.Add("three"); array.Add("four"); array.Sort(CompareStringLen);

Warning: this function should not be used with sorted array because it could break the order of items and, for example, subsequent calls to Index() (p. 56) would then not work!

wxArtProvider
wxArtProvider class is used to customize the look of wxWindows application. When wxWindows need to display an icon or a bitmap (e.g. in the standard file dialog), it does not use hard-coded resource but asks wxArtProvider for it instead. This way the users can plug in own wxArtProvider class and easily replace standard art with his/her own version. It is easy thing to do: all that is needed is to derive a class from wxArtProvider, override it'sCreateBitmap (p. 61) method and register the provider withwxArtProvider::PushProvider (p. 63):
class MyProvider : public wxArtProvider { protected: wxBitmap CreateBitmap(const wxArtID& id, const wxArtClient& client, const wxSize size) { ... } }; ... wxArtProvider::PushProvider(new MyProvider);

There's another way of taking advantage of this class: you can use it in your code and use platform native icons as provided bywxArtProvider::GetBitmap (p. 62) or wxArtProvider::GetIcon (p. 62) (NB: this is not yet really possible as of wxWindows 2.3.3, the set of wxArtProvider bitmaps is too small).

Identifying art resources
Every bitmap is known to wxArtProvider under an unique ID that is used by when requesting a resource from it. The ID is represented by wxArtID type and can have one of these predefined values (you can see bitmaps represented by these constants in the artprov (p. 1561) sample):    wxART_ADD_BOOKMARK wxART_DEL_BOOKMARK wxART_HELP_SIDE_PANEL

59


CHAPTER 7
                            wxART_HELP_SETTINGS wxART_HELP_BOOK wxART_HELP_FOLDER wxART_HELP_PAGE wxART_GO_BACK wxART_GO_FORWARD wxART_GO_UP wxART_GO_DOWN wxART_GO_TO_PARENT wxART_GO_HOME wxART_FILE_OPEN wxART_PRINT wxART_HELP wxART_TIP wxART_REPORT_VIEW wxART_LIST_VIEW wxART_NEW_DIR wxART_FOLDER wxART_GO_DIR_UP wxART_EXECUTABLE_FILE wxART_NORMAL_FILE wxART_TICK_MARK wxART_CROSS_MARK wxART_ERROR wxART_QUESTION wxART_WARNING wxART_INFORMATION wxART_MISSING_IMAGE

60


CHAPTER 7 Clients
Client is the entity that calls wxArtProvider's GetBitmap or GetIcon function. It is represented by wxClientID type and can have one of these values:        wxART_TOOLBAR wxART_MENU wxART_FRAME_ICON wxART_CMN_DIALOG wxART_HELP_BROWSER wxART_MESSAGE_BOX wxART_OTHER (used for all requests that don't fit into any of the categories above)Client ID servers as a hint to wxArtProvider that is supposed to help it to choose the best looking bitmap. For example it is often desirable to use slightly different icons in menus and toolbars even though they represent the same action (e.g. wx_ART_FILE_OPEN). Remember that this is really only a hint for wxArtProvider -- it is common thatwxArtProvider::GetBitmap (p. 62) returns identical bitmap for different client values!

See also See the artprov (p. 1561) sample for an example of wxArtProvider usage. Derived from wxObject (p. 954) Include files <wx/artprov.h>

wxArtProvider::CreateBitmap
wxBitmap CreateBitmap(const wxArtID& id, const wxArtClient& client, const wxSize& size) Derived art provider classes must override this method to create requested art resource. Note that returned bitmaps are cached by wxArtProvider and it is therefore not neccessary to optimize CreateBitmap for speed (e.g. you may create wxBitmap objects from XPMs here). Parameters id

61


CHAPTER 7
wxArtID unique identifier of the bitmap. client wxArtClient identifier of the client (i.e. who is asking for the bitmap). This only servers as a hint. size Prefered size of the bitmap. The function may return a bitmap of different dimensions, it will be automatically rescaled to meet client's request. Note This is not part of wxArtProvider's public API, usewxArtProvider::GetBitmap (p. 62) or wxArtProvider::GetIcon (p. 62)to query wxArtProvider for a resource.

wxArtProvider::GetBitmap
static wxBitmap GetBitmap(const wxArtID& id, const wxArtClient& client = wxART_OTHER, const wxSize& size = wxDefaultSize) Query registered providers for bitmap with given ID. Parameters id wxArtID unique identifier of the bitmap. client wxArtClient identifier of the client (i.e. who is asking for the bitmap). size Size of the returned bitmap or wxDefaultSize if size doesn't matter. Return value The bitmap if one of registered providers recognizes the ID or wxNullBitmap otherwise.

wxArtProvider::GetIcon
static wxIcon GetIcon(const wxArtID& id, const wxArtClient& client = wxART_OTHER, const wxSize& size = wxDefaultSize) Same as wxArtProvider::GetBitmap (p. 62), but return a wxIcon object (or wxNullIcon on failure).

wxArtProvider::PopProvider 62


CHAPTER 7
static bool PopProvider() Remove latest added provider and delete it.

wxArtProvider::PushProvider
static void PushProvider(wxArtProvider* provider) Register new art provider (add it to the top of providers stack).

wxArtProvider::RemoveProvider
static bool RemoveProvider(wxArtProvider* provider) Remove a provider from the stack. The provider must have been added previously and is not deleted.

wxAutomationObject
The wxAutomationObject class represents an OLE automation object containing a single data member, an IDispatch pointer. It contains a number of functions that make it easy to perform automation operations, and set and get properties. The class makes heavy use of the wxVariant (p. 1360) class. The usage of these classes is quite close to OLE automation usage in Visual Basic. The API is high-level, and the application can specify multiple properties in a single string. The following example gets the current Excel instance, and if it exists, makes the active cell bold.
wxAutomationObject excelObject; if (excelObject.GetInstance("Excel.Application")) excelObject.PutProperty("ActiveCell.Font.Bold", true);

Note that this class obviously works under Windows only. Derived from wxObject (p. 954) Include files <wx/msw/ole/automtn.h> See also wxVariant (p. 1360)

63


CHAPTER 7 wxAutomationObject::wxAutomationObject
wxAutomationObject(WXIDISPATCH* dispatchPtr = NULL) Constructor, taking an optional IDispatch pointer which will be released when the object is deleted.

wxAutomationObject::~wxAutomationObject
~wxAutomationObject() Destructor. If the internal IDispatch pointer is non-null, it will be released.

wxAutomationObject::CallMethod
wxVariant CallMethod(const wxString& method, int noArgs, wxVariant args[]) const wxVariant CallMethod(const wxString& method, ...) const Calls an automation method for this object. The first form takes a method name, number of arguments, and an array of variants. The second form takes a method name and zero to six constant references to variants. Since the variant class has constructors for the basic data types, and C++ provides temporary objects automatically, both of the following lines are syntactically valid:
wxVariant res = obj.CallMethod("Sum", wxVariant(1.2), wxVariant(3.4)); wxVariant res = obj.CallMethod("Sum", 1.2, 3.4);

Note that method can contain dot-separated property names, to save the application needing to call GetProperty several times using several temporary objects. For example:
object.CallMethod("ActiveCell.Font.ShowDialog", "My caption");

wxAutomationObject::CreateInstance
bool CreateInstance(const wxString& classId) const Creates a new object based on the class id, returning true if the object was successfully created, or false if not.

wxAutomationObject::GetDispatchPtr
IDispatch* GetDispatchPtr() const Gets the IDispatch pointer.

64


CHAPTER 7 wxAutomationObject::GetInstance
bool GetInstance(const wxString& classId) const Retrieves the current object associated with a class id, and attaches the IDispatch pointer to this object. Returns true if a pointer was successfully retrieved, false otherwise. Note that this cannot cope with two instances of a given OLE object being active simultaneously, such as two copies of Excel running. Which object is referenced cannot currently be specified.

wxAutomationObject::GetObject
bool GetObject(wxAutomationObject&obj const wxString& property, int noArgs = 0, wxVariant args[] = NULL) const Retrieves a property from this object, assumed to be a dispatch pointer, and initialises obj with it. To avoid having to deal with IDispatch pointers directly, use this function in preference to wxAutomationObject::GetProperty (p. 65) when retrieving objects from other objects. Note that an IDispatch pointer is stored as a void* pointer in wxVariant objects. See also wxAutomationObject::GetProperty (p. 65)

wxAutomationObject::GetProperty
wxVariant GetProperty(const wxString& property, int noArgs, wxVariant args[]) const wxVariant GetProperty(const wxString& property, ...) const Gets a property value from this object. The first form takes a property name, number of arguments, and an array of variants. The second form takes a property name and zero to six constant references to variants. Since the variant class has constructors for the basic data types, and C++ provides temporary objects automatically, both of the following lines are syntactically valid:
wxVariant res = obj.GetProperty("Range", wxVariant("A1")); wxVariant res = obj.GetProperty("Range", "A1");

Note that property can contain dot-separated property names, to save the application needing to call GetProperty several times using several temporary objects.

wxAutomationObject::Invoke

65


CHAPTER 7
bool Invoke(const wxString& member, int action, wxVariant& retValue, int noArgs, wxVariant args[], const wxVariant* ptrArgs[] = 0) const This function is a low-level implementation that allows access to the IDispatch Invoke function. It is not meant to be called directly by the application, but is used by other convenience functions. Parameters member The member function or property name. action Bitlist: may contain DISPATCH_PROPERTYPUT, DISPATCH_PROPERTYPUTREF, DISPATCH_METHOD. retValue Return value (ignored if there is no return value) . noArgs Number of arguments in args or ptrArgs. args If non-null, contains an array of variants. ptrArgs If non-null, contains an array of constant pointers to variants. Return value true if the operation was successful, false otherwise. Remarks Two types of argument array are provided, so that when possible pointers are used for efficiency.

wxAutomationObject::PutProperty
bool PutProperty(const wxString& property, int noArgs, wxVariant args[]) const bool PutProperty(const wxString& property, ...) Puts a property value into this object. The first form takes a property name, number of arguments, and an array of variants. The second form takes a property name and zero to six constant references to variants. Since the variant class has constructors for the

66


CHAPTER 7
basic data types, and C++ provides temporary objects automatically, both of the following lines are syntactically valid:
obj.PutProperty("Value", wxVariant(23)); obj.PutProperty("Value", 23);

Note that property can contain dot-separated property names, to save the application needing to call GetProperty several times using several temporary objects.

wxAutomationObject::SetDispatchPtr
void SetDispatchPtr(WXIDISPATCH* dispatchPtr) Sets the IDispatch pointer. This function does not check if there is already an IDispatch pointer. You may need to cast from IDispatch* to WXIDISPATCH* when calling this function.

wxBitmap
This class encapsulates the concept of a platform-dependent bitmap, either monochrome or colour. Derived from wxGDIObject (p. 560) wxObject (p. 954) Include file <wx/bitmap.h> Predefined objects Objects: wxNullBitmap See also wxBitmap overview (p. 1638),supported bitmap file formats (p. 1639),wxDC::Blit (p. 348),wxIcon (p. 716), wxCursor (p. 209), wxBitmap (p. 67),wxMemoryDC (p. 881)

wxBitmap::wxBitmap
wxBitmap()

67


CHAPTER 7
Default constructor. wxBitmap(const wxBitmap& bitmap) Copy constructor. wxBitmap(void* data, int type, int width, int height, int depth = -1) Creates a bitmap from the given data which is interpreted in platform-dependent manner. wxBitmap(const char bits[], int width, int height int depth = 1) Creates a bitmap from an array of bits. You should only use this function for monochrome bitmaps (depth 1) in portable programs: in this case the bits parameter should contain an XBM image. For other bit depths, the behaviour is platform dependent: under Windows, the data is passed without any changes to the underlying CreateBitmap() API. Under other platforms, only monochrome bitmaps may be created using this constructor and wxImage (p. 728) should be used for creating colour bitmaps from static data. wxBitmap(int width, int height, int depth = -1) Creates a new bitmap. A depth of -1 indicates the depth of the current screen or visual. Some platforms only support 1 for monochrome and -1 for the current colour setting. wxBitmap(const char** bits) Creates a bitmap from XPM data. wxBitmap(const wxString& name, long type) Loads a bitmap from a file or resource. wxBitmap(const wxImage& img, int depth = -1) Creates bitmap object from the image. This has to be done to actually display an image as you cannot draw an image directly on a window. The resulting bitmap will use the provided colour depth (or that of the current system if depth is -1) which entails that a colour reduction has to take place. When in 8-bit mode (PseudoColour mode), the GTK port will use a color cube created on program start-up to look up colors. This ensures a very fast conversion, but the image quality won't be perfect (and could be better for photo images using more sophisticated dithering algorithms). On Windows, if there is a palette present (set with SetPalette), it will be used when creating the wxBitmap (most useful in 8-bit display mode). On other platforms, the palette is currently ignored. Parameters

68


CHAPTER 7
bits Specifies an array of pixel values. width Specifies the width of the bitmap. height Specifies the height of the bitmap. depth Specifies the depth of the bitmap. If this is omitted, the display depth of the screen is used. name This can refer to a resource name under MS Windows, or a filename under MS Windows and X. Its meaning is determined by the type parameter. type May be one of the following: wxBITMAP_TYPE_BMP Load a Windows bitmap file.

wxBITMAP_TYPE_BMP_RESOURCELoad a Windows bitmap from the resource database. wxBITMAP_TYPE_GIF wxBITMAP_TYPE_XBM wxBITMAP_TYPE_XPM Load a GIF bitmap file. Load an X bitmap file. Load an XPM bitmap file. Load a Windows resource name.

wxBITMAP_TYPE_RESOURCE

The validity of these flags depends on the platform and wxWindows configuration. If all possible wxWindows settings are used, the Windows platform supports BMP file, BMP resource, XPM data, and XPM. Under wxGTK, the available formats are BMP file, XPM data, XPM file, and PNG file. Under wxMotif, the available formats are XBM data, XBM file, XPM data, XPM file. In addition, wxBitmap can read all formats that wxImage (p. 728) can, which currently include wxBITMAP_TYPE_JPEG, wxBITMAP_TYPE_TIF, wxBITMAP_TYPE_PNG, wxBITMAP_TYPE_GIF, wxBITMAP_TYPE_PCX, and wxBITMAP_TYPE_PNM. Of course, you must have wxImage handlers loaded. img Platform-independent wxImage object. Remarks

69


CHAPTER 7
The first form constructs a bitmap object with no data; an assignment or another member function such as Create or LoadFile must be called subsequently. The second and third forms provide copy constructors. Note that these do not copy the bitmap data, but instead a pointer to the data, keeping a reference count. They are therefore very efficient operations. The fourth form constructs a bitmap from data whose type and value depends on the value of the type argument. The fifth form constructs a (usually monochrome) bitmap from an array of pixel values, under both X and Windows. The sixth form constructs a new bitmap. The seventh form constructs a bitmap from pixmap (XPM) data, if wxWindows has been configured to incorporate this feature. To use this constructor, you must first include an XPM file. For example, assuming that the file mybitmap.xpm contains an XPM array of character pointers called mybitmap:
#include "mybitmap.xpm" ... wxBitmap *bitmap = new wxBitmap(mybitmap);

The eighth form constructs a bitmap from a file or resource. name can refer to a resource name under MS Windows, or a filename under MS Windows and X. Under Windows, type defaults to wxBITMAP_TYPE_BMP_RESOURCE. Under X, type defaults to wxBITMAP_TYPE_XPM. See also wxBitmap::LoadFile (p. 75) wxPython note: Constructors supported by wxPython are: wxBitmap(name, flag) Loads a bitmap from a file

wxEmptyBitmap(width, height, depth = -1) Creates an empty bitmap with the given specifications wxBitmapFromXPMData(listOfStrings) Create a bitmap from a Python list of strings whose contents are XPM data. wxBitmapFromBits(bits, width, height, depth=-1) Create a bitmap from an array of bits contained in a string. wxBitmapFromImage(image, depth=-1) wxBitmap. wxPerl note: Constructors supported by wxPerl are: Convert a wxImage to a

70


CHAPTER 7
::Bitmap->new( width, height, depth = -1 ) ::Bitmap->new( name, type ) ::Bitmap->new( icon ) ::Bitmap->newFromBits( bits, width, height, depth = 1 ) ::Bitmap->newFromXPM( data )

wxBitmap::~wxBitmap
~wxBitmap() Destroys the wxBitmap object and possibly the underlying bitmap data. Because reference counting is used, the bitmap may not actually be destroyed at this point - only when the reference count is zero will the data be deleted. If the application omits to delete the bitmap explicitly, the bitmap will be destroyed automatically by wxWindows when the application exits. Do not delete a bitmap that is selected into a memory device context.

wxBitmap::AddHandler
static void AddHandler(wxBitmapHandler* handler) Adds a handler to the end of the static list of format handlers. handler A new bitmap format handler object. There is usually only one instance of a given handler class in an application session. See also wxBitmapHandler (p. 85)

wxBitmap::CleanUpHandlers
static void CleanUpHandlers() Deletes all bitmap handlers. This function is called by wxWindows on exit.

wxBitmap::ConvertToImage
wxImage ConvertToImage()

71


CHAPTER 7
Creates an image from a platform-dependent bitmap. This preserves mask information so that bitmaps and images can be converted back and forth without loss in that respect.

wxBitmap::CopyFromIcon
bool CopyFromIcon(const wxIcon& icon) Creates the bitmap from an icon.

wxBitmap::Create
virtual bool Create(int width, int height, int depth = -1) Creates a fresh bitmap. If the final argument is omitted, the display depth of the screen is used. virtual bool Create(void* data, int type, int width, int height, int depth = -1) Creates a bitmap from the given data, which can be of arbitrary type. Parameters width The width of the bitmap in pixels. height The height of the bitmap in pixels. depth The depth of the bitmap in pixels. If this is -1, the screen depth is used. data Data whose type depends on the value of type. ty p e A bitmap type identifier - see wxBitmap::wxBitmap (p. 67) for a list of possible values. Return value true if the call succeeded, false otherwise. Remarks The first form works on all platforms. The portability of the second form depends on the type of data. See also

72


CHAPTER 7
wxBitmap::wxBitmap (p. 67)

wxBitmap::FindHandler
static wxBitmapHandler* FindHandler(const wxString& name) Finds the handler with the given name. static wxBitmapHandler* FindHandler(const wxString& extension, long bitmapType) Finds the handler associated with the given extension and type. static wxBitmapHandler* FindHandler(long bitmapType) Finds the handler associated with the given bitmap type. name The handler name. extension The file extension, such as "bmp". bitmapType The bitmap type, such as wxBITMAP_TYPE_BMP. Return value A pointer to the handler if found, NULL otherwise. See also wxBitmapHandler (p. 85)

wxBitmap::GetDepth
int GetDepth() const Gets the colour depth of the bitmap. A value of 1 indicates a monochrome bitmap.

wxBitmap::GetHandlers
static wxList& GetHandlers() Returns the static list of bitmap format handlers. See also wxBitmapHandler (p. 85)

73


CHAPTER 7 wxBitmap::GetHeight
int GetHeight() const Gets the height of the bitmap in pixels.

wxBitmap::GetPalette
wxPalette* GetPalette() const Gets the associated palette (if any) which may have been loaded from a file or set for the bitmap. See also wxPalette (p. 968)

wxBitmap::GetMask
wxMask* GetMask() const Gets the associated mask (if any) which may have been loaded from a file or set for the bitmap. See also wxBitmap::SetMask (p. 78), wxMask (p. 860)

wxBitmap::GetWidth
int GetWidth() const Gets the width of the bitmap in pixels. See also wxBitmap::GetHeight (p. 74)

wxBitmap::GetSubBitmap
wxBitmap GetSubBitmap(const wxRect&rect) const Returns a sub bitmap of the current one as long as the rect belongs entirely to the bitmap. This function preserves bit depth and mask information.

wxBitmap::InitStandardHandlers
static void InitStandardHandlers()

74


CHAPTER 7
Adds the standard bitmap format handlers, which, depending on wxWindows configuration, can be handlers for Windows bitmap, Windows bitmap resource, and XPM. This function is called by wxWindows on startup. See also wxBitmapHandler (p. 85)

wxBitmap::InsertHandler
static void InsertHandler(wxBitmapHandler* handler) Adds a handler at the start of the static list of format handlers. handler A new bitmap format handler object. There is usually only one instance of a given handler class in an application session. See also wxBitmapHandler (p. 85)

wxBitmap::LoadFile
bool LoadFile(const wxString& name, long type) Loads a bitmap from a file or resource. Parameters name Either a filename or a Windows resource name. The meaning of name is determined by the type parameter. type One of the following values: wxBITMAP_TYPE_BMP Load a Windows bitmap file.

wxBITMAP_TYPE_BMP_RESOURCE Load a Windows bitmap from the resource database. wxBITMAP_TYPE_GIF wxBITMAP_TYPE_XBM wxBITMAP_TYPE_XPM Load a GIF bitmap file. Load an X bitmap file. Load an XPM bitmap file.

75


CHAPTER 7
The validity of these flags depends on the platform and wxWindows configuration. In addition, wxBitmap can read all formats that wxImage (p. 728) can (wxBITMAP_TYPE_JPEG, wxBITMAP_TYPE_PNG, wxBITMAP_TYPE_GIF, wxBITMAP_TYPE_PCX, wxBITMAP_TYPE_PNM). (Of course you must have wxImage handlers loaded.) Return value true if the operation succeeded, false otherwise. Remarks A palette may be associated with the bitmap if one exists (especially for colour Windows bitmaps), and if the code supports it. You can check if one has been created by using the GetPalette (p. 74) member. See also wxBitmap::SaveFile (p. 76)

wxBitmap::Ok
bool Ok() const Returns true if bitmap data is present.

wxBitmap::RemoveHandler
static bool RemoveHandler(const wxString& name) Finds the handler with the given name, and removes it. The handler is not deleted. name The handler name. Return value true if the handler was found and removed, false otherwise. See also wxBitmapHandler (p. 85)

wxBitmap::SaveFile
bool SaveFile(const wxString& name, int type, wxPalette* palette = NULL) Saves a bitmap in the named file.

76


CHAPTER 7
Parameters name A filename. The meaning of name is determined by the type parameter. type One of the following values: wxBITMAP_TYPE_BMP wxBITMAP_TYPE_GIF wxBITMAP_TYPE_XBM wxBITMAP_TYPE_XPM Save a Windows bitmap file. Save a GIF bitmap file. Save an X bitmap file. Save an XPM bitmap file.

The validity of these flags depends on the platform and wxWindows configuration. In addition, wxBitmap can save all formats that wxImage (p. 728) can (wxBITMAP_TYPE_JPEG, wxBITMAP_TYPE_PNG). (Of course you must have wxImage handlers loaded.) palette An optional palette used for saving the bitmap. Return value true if the operation succeeded, false otherwise. Remarks Depending on how wxWindows has been configured, not all formats may be available. See also wxBitmap::LoadFile (p. 75)

wxBitmap::SetDepth
void SetDepth(int depth) Sets the depth member (does not affect the bitmap data). Parameters depth Bitmap depth.

wxBitmap::SetHeight

77


CHAPTER 7
void SetHeight(int height) Sets the height member (does not affect the bitmap data). Parameters height Bitmap height in pixels.

wxBitmap::SetMask
void SetMask(wxMask* mask) Sets the mask for this bitmap. Remarks The bitmap object owns the mask once this has been called. See also wxBitmap::GetMask (p. 74), wxMask (p. 860)

wxBitmap::SetPalette
void SetPalette(const wxPalette& palette) Sets the associated palette. Parameters palette The palette to set. See also wxPalette (p. 968)

wxBitmap::SetWidth
void SetWidth(int width) Sets the width member (does not affect the bitmap data). Parameters width Bitmap width in pixels.

78


CHAPTER 7 wxBitmap::operator =
wxBitmap& operator =(const wxBitmap& bitmap) Assignment operator. This operator does not copy any data, but instead passes a pointer to the data in bitmap and increments a reference counter. It is a fast operation. Parameters bitmap Bitmap to assign. Return value Returns 'this' object.

wxBitmap::operator ==
bool operator ==(const wxBitmap& bitmap) Equality operator. This operator tests whether the internal data pointers are equal (a fast test). Parameters bitmap Bitmap to compare with 'this' Return value Returns true if the bitmaps were effectively equal, false otherwise.

wxBitmap::operator !=
bool operator !=(const wxBitmap& bitmap) Inequality operator. This operator tests whether the internal data pointers are unequal (a fast test). Parameters bitmap Bitmap to compare with 'this' Return value Returns true if the bitmaps were unequal, false otherwise.

79


CHAPTER 7

wxBitmapButton
A bitmap button is a control that contains a bitmap. It may be placed on a dialog box (p. 367) or panel (p. 972), or indeed almost any other window. Derived from wxButton (p. 103) wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/bmpbuttn.h> Remarks A bitmap button can be supplied with a single bitmap, and wxWindows will draw all button states using this bitmap. If the application needs more control, additional bitmaps for the selected state, unpressed focused state, and greyed-out state may be supplied. Window styles wxBU_AUTODRAW If this is specified, the button will be drawn automatically using the label bitmap only, providing a 3D-look border. If this style is not specified, the button will be drawn without borders and using all provided bitmaps. WIN32 only. Left-justifies the bitmap label. WIN32 only. Aligns the bitmap label to the top of the button. WIN32 only. Right-justifies the bitmap label. WIN32 only. Aligns the bitmap label to the bottom of the button. WIN32 only.

wxBU_LEFT wxBU_TOP wxBU_RIGHT wxBU_BOTTOM

See also window styles overview (p. 1611). Event handling EVT_BUTTON(id, func) Process a wxEVT_COMMAND_BUTTON_CLICKED event, when the button is clicked.

See also wxButton (p. 103)

80


CHAPTER 7 wxBitmapButton::wxBitmapButton
wxBitmapButton() Default constructor. wxBitmapButton(wxWindow* parent, wxWindowID id, const wxBitmap& bitmap, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxBU_AUTODRAW, const wxValidator& validator = wxDefaultValidator, const wxString& name = "button") Constructor, creating and showing a button. Parameters parent Parent window. Must not be NULL. id Button identifier. A value of -1 indicates a default value. bitmap Bitmap to be displayed. pos Button position. size Button size. If the default size (-1, -1) is specified then the button is sized appropriately for the bitmap. style Window style. See wxBitmapButton (p. 80). validator Window validator. name Window name. Remarks The bitmap parameter is normally the only bitmap you need to provide, and wxWindows will draw the button correctly in its different states. If you want more control, call any of the functions wxBitmapButton::SetBitmapSelected (p. 84), wxBitmapButton::SetBitmapFocus (p. 83), wxBitmapButton::SetBitmapDisabled (p. 83). Note that the bitmap passed is smaller than the actual button created.

81


CHAPTER 7
See also wxBitmapButton::Create (p. 82), wxValidator (p. 1358)

wxBitmapButton::~wxBitmapButton
~wxBitmapButton() Destructor, destroying the button.

wxBitmapButton::Create
bool Create(wxWindow* parent, wxWindowID id, const wxBitmap& bitmap, const wxPoint& pos, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator, const wxString& name = "button") Button creation function for two-step creation. For more details, see wxBitmapButton::wxBitmapButton (p. 81).

wxBitmapButton::GetBitmapDisabled
wxBitmap& GetBitmapDisabled() const Returns the bitmap for the disabled state. Return value A reference to the disabled state bitmap. See also wxBitmapButton::SetBitmapDisabled (p. 83)

wxBitmapButton::GetBitmapFocus
wxBitmap& GetBitmapFocus() const Returns the bitmap for the focused state. Return value A reference to the focused state bitmap. See also wxBitmapButton::SetBitmapFocus (p. 83)

wxBitmapButton::GetBitmapLabel 82


CHAPTER 7
wxBitmap& GetBitmapLabel() const Returns the label bitmap (the one passed to the constructor). Return value A reference to the button's label bitmap. See also wxBitmapButton::SetBitmapLabel (p. 84)

wxBitmapButton::GetBitmapSelected
wxBitmap& GetBitmapSelected() const Returns the bitmap for the selected state. Return value A reference to the selected state bitmap. See also wxBitmapButton::SetBitmapSelected (p. 84)

wxBitmapButton::SetBitmapDisabled
void SetBitmapDisabled(const wxBitmap& bitmap) Sets the bitmap for the disabled button appearance. Parameters bitmap The bitmap to set. See also wxBitmapButton::GetBitmapDisabled (p. 82), wxBitmapButton::SetBitmapLabel (p. 84), wxBitmapButton::SetBitmapSelected (p. 84), wxBitmapButton::SetBitmapFocus (p. 83)

wxBitmapButton::SetBitmapFocus
void SetBitmapFocus(const wxBitmap& bitmap) Sets the bitmap for the button appearance when it has the keyboard focus. Parameters bitmap

83


CHAPTER 7
The bitmap to set. See also wxBitmapButton::GetBitmapFocus (p. 82), wxBitmapButton::SetBitmapLabel (p. 84), wxBitmapButton::SetBitmapSelected (p. 84), wxBitmapButton::SetBitmapDisabled (p. 83)

wxBitmapButton::SetBitmapLabel
void SetBitmapLabel(const wxBitmap& bitmap) Sets the bitmap label for the button. Parameters bitmap The bitmap label to set. Remarks This is the bitmap used for the unselected state, and for all other states if no other bitmaps are provided. See also wxBitmapButton::GetBitmapLabel (p. 82)

wxBitmapButton::SetBitmapSelected
void SetBitmapSelected(const wxBitmap& bitmap) Sets the bitmap for the selected (depressed) button appearance. Parameters bitmap The bitmap to set. See also wxBitmapButton::GetBitmapSelected (p. 83), wxBitmapButton::SetBitmapLabel (p. 84), wxBitmapButton::SetBitmapFocus (p. 83), wxBitmapButton::SetBitmapDisabled (p. 83)

wxBitmapDataObject
wxBitmapDataObject is a specialization of wxDataObject for bitmap data. It can be used without change to paste data into the wxClipboard (p. 136) or a wxDropSource (p. 427). A user may wish to derive a new class from this class for providing a bitmap on-demand

84


CHAPTER 7
in order to minimize memory consumption when offering data in several formats, such as a bitmap and GIF. wxPython note: If you wish to create a derived wxBitmapDataObject class in wxPython you should derive the class from wxPyBitmapDataObject in order to get Python-aware capabilities for the various virtual methods. Virtual functions to override This class may be used as is, but GetBitmap (p. 85) may be overridden to increase efficiency. Derived from wxDataObjectSimple (p. 226) wxDataObject (p. 222) Include files <wx/dataobj.h> See also Clipboard and drag and drop overview (p. 1666), wxDataObject (p. 222), wxDataObjectSimple (p. 226), wxFileDataObject (p. 465), wxTextDataObject (p. 1266), wxDataObject (p. 222) wxBitmapDataObject(const wxBitmap& bitmap = wxNullBitmap) Constructor, optionally passing a bitmap (otherwise use SetBitmap (p. 85) later).

wxBitmapDataObject::GetBitmap
virtual wxBitmap GetBitmap() const Returns the bitmap associated with the data object. You may wish to override this method when offering data on-demand, but this is not required by wxWindows' internals. Use this method to get data in bitmap form from the wxClipboard (p. 136).

wxBitmapDataObject::SetBitmap
virtual void SetBitmap(const wxBitmap& bitmap) Sets the bitmap associated with the data object. This method is called when the data object receives data. Usually there will be no reason to override this function.

wxBitmapHandler
Overview (p. 1638)

85


CHAPTER 7
This is the base class for implementing bitmap file loading/saving, and bitmap creation from data. It is used within wxBitmap and is not normally seen by the application. If you wish to extend the capabilities of wxBitmap, derive a class from wxBitmapHandler and add the handler using wxBitmap::AddHandler (p. 71) in your application initialisation. Derived from wxObject (p. 954) Include files <wx/bitmap.h> See also wxBitmap (p. 67), wxIcon (p. 716), wxCursor (p. 209)

wxBitmapHandler::wxBitmapHandler
wxBitmapHandler() Default constructor. In your own default constructor, initialise the members m_name, m_extension and m_type.

wxBitmapHandler::~wxBitmapHandler
~wxBitmapHandler() Destroys the wxBitmapHandler object.

wxBitmapHandler::Create
virtual bool Create(wxBitmap* bitmap, void* data, int type, int width, int height, int depth = -1) Creates a bitmap from the given data, which can be of arbitrary type. The wxBitmap object bitmap is manipulated by this function. Parameters bitmap The wxBitmap object. width The width of the bitmap in pixels.

86


CHAPTER 7
height The height of the bitmap in pixels. depth The depth of the bitmap in pixels. If this is -1, the screen depth is used. data Data whose type depends on the value of type. ty p e A bitmap type identifier - see wxBitmapHandler::wxBitmapHandler (p. 67) for a list of possible values. Return value true if the call succeeded, false otherwise (the default).

wxBitmapHandler::GetName
wxString GetName() const Gets the name of this handler.

wxBitmapHandler::GetExtension
wxString GetExtension() const Gets the file extension associated with this handler.

wxBitmapHandler::GetType
long GetType() const Gets the bitmap type associated with this handler.

wxBitmapHandler::LoadFile
bool LoadFile(wxBitmap* bitmap, const wxString& name, long type) Loads a bitmap from a file or resource, putting the resulting data into bitmap. Parameters bitmap The bitmap object which is to be affected by this operation.

87


CHAPTER 7
name Either a filename or a Windows resource name. The meaning of name is determined by the type parameter. type See wxBitmap::wxBitmap (p. 67) for values this can take. Return value true if the operation succeeded, false otherwise. See also wxBitmap::LoadFile (p. 75) wxBitmap::SaveFile (p. 76) wxBitmapHandler::SaveFile (p. 88)

wxBitmapHandler::SaveFile
bool SaveFile(wxBitmap* bitmap, const wxString& name, int type, wxPalette* palette = NULL) Saves a bitmap in the named file. Parameters bitmap The bitmap object which is to be affected by this operation. name A filename. The meaning of name is determined by the type parameter. type See wxBitmap::wxBitmap (p. 67) for values this can take. palette An optional palette used for saving the bitmap. Return value true if the operation succeeded, false otherwise. See also wxBitmap::LoadFile (p. 75) wxBitmap::SaveFile (p. 76) wxBitmapHandler::LoadFile (p. 87)

88


CHAPTER 7 wxBitmapHandler::SetName
void SetName(const wxString& name) Sets the handler name. Parameters name Handler name.

wxBitmapHandler::SetExtension
void SetExtension(const wxString& extension) Sets the handler extension. Parameters extension Handler extension.

wxBitmapHandler::SetType
void SetType(long type) Sets the handler type. Parameters name Handler type.

wxBoxSizer
The basic idea behind a box sizer is that windows will most often be laid out in rather simple basic geometry, typically in a row or a column or several hierarchies of either. For more information, please see Programming with wxBoxSizer (p. 1624). Derived from wxSizer (p. 1109) wxObject (p. 954) See also wxSizer (p. 1109), Sizer overview (p. 1620)

89


CHAPTER 7 wxBoxSizer::wxBoxSizer
wxBoxSizer(int orient) Constructor for a wxBoxSizer. orient may be either of wxVERTICAL or wxHORIZONTAL for creating either a column sizer or a row sizer.

wxBoxSizer::RecalcSizes
void RecalcSizes() Implements the calculation of a box sizer's dimensions and then sets the size of its its children (calling wxWindow::SetSize (p. 1427) if the child is a window). It is used internally only and must not be called by the user. Documented for information.

wxBoxSizer::CalcMin
wxSize CalcMin() Implements the calculation of a box sizer's minimal. It is used internally only and must not be called by the user. Documented for information.

wxBoxSizer::GetOrientation
int GetOrientation() Returns the orientation of the box sizer, either wxVERTICAL or wxHORIZONTAL.

wxBrush
A brush is a drawing tool for filling in areas. It is used for painting the background of rectangles, ellipses, etc. It has a colour and a style. Derived from wxGDIObject (p. 560) wxObject (p. 954) Include files <wx/brush.h> Predefined objects Objects: wxNullBrush Pointers:

90


CHAPTER 7
wxBLUE_BRUSH wxGREEN_BRUSH wxWHITE_BRUSH wxBLACK_BRUSH wxGREY_BRUSH wxMEDIUM_GREY_BRUSH wxLIGHT_GREY_BRUSH wxTRANSPARENT_BRUSH wxCYAN_BRUSH wxRED_BRUSH Remarks On a monochrome display, wxWindows shows all brushes as white unless the colour is really black. Do not initialize objects on the stack before the program commences, since other required structures may not have been set up yet. Instead, define global pointers to objects and create them in wxApp::OnInit (p. 36) or when required. An application may wish to create brushes with different characteristics dynamically, and there is the consequent danger that a large number of duplicate brushes will be created. Therefore an application may wish to get a pointer to a brush by using the global list of brushes wxTheBrushList, and calling the member function FindOrCreateBrush. wxBrush uses a reference counting system, so assignments between brushes are very cheap. You can therefore use actual wxBrush objects instead of pointers without efficiency problems. Once one wxBrush object changes its data it will create its own brush data internally so that other brushes, which previously shared the data using the reference counting, are not affected. See also wxBrushList (p. 96), wxDC (p. 347), wxDC::SetBrush (p. 364)

wxBrush::wxBrush
wxBrush() Default constructor. The brush will be uninitialised, and wxBrush::Ok (p. 94) will return false. wxBrush(const wxColour& colour, int style = wxSOLID) Constructs a brush from a colour object and style. wxBrush(const wxString& colourName, int style) Constructs a brush from a colour name and style. wxBrush(const wxBitmap& stippleBitmap)

91


CHAPTER 7
Constructs a stippled brush using a bitmap. wxBrush(const wxBrush& brush) Copy constructor. This uses reference counting so is a cheap operation. Parameters colour Colour object. colourName Colour name. The name will be looked up in the colour database. style One of: wxTRANSPARENT wxSOLID wxBDIAGONAL_HATCH wxCROSSDIAG_HATCH wxFDIAGONAL_HATCH wxCROSS_HATCH wxHORIZONTAL_HATCH wxVERTICAL_HATCH brush Pointer or reference to a brush to copy. stippleBitmap A bitmap to use for stippling. Remarks If a stipple brush is created, the brush style will be set to wxSTIPPLE. See also wxBrushList (p. 96), wxColour (p. 150), wxColourDatabase (p. 155) Transparent (no fill). Solid. Backward diagonal hatch. Cross-diagonal hatch. Forward diagonal hatch. Cross hatch. Horizontal hatch. Vertical hatch.

wxBrush::~wxBrush

92


CHAPTER 7
void ~wxBrush() Destructor. Remarks The destructor may not delete the underlying brush object of the native windowing system, since wxBrush uses a reference counting system for efficiency. Although all remaining brushes are deleted when the application exits, the application should try to clean up all brushes itself. This is because wxWindows cannot know if a pointer to the brush object is stored in an application data structure, and there is a risk of double deletion.

wxBrush::GetColour
wxColour& GetColour() const Returns a reference to the brush colour. See also wxBrush::SetColour (p. 94)

wxBrush::GetStipple
wxBitmap * GetStipple() const Gets a pointer to the stipple bitmap. If the brush does not have a wxSTIPPLE style, this bitmap may be non-NULL but uninitialised (wxBitmap::Ok (p. 76) returns false). See also wxBrush::SetStipple (p. 94)

wxBrush::GetStyle
int GetStyle() const Returns the brush style, one of: wxTRANSPARENT wxSOLID wxBDIAGONAL_HATCH wxCROSSDIAG_HATCH wxFDIAGONAL_HATCH Transparent (no fill). Solid. Backward diagonal hatch. Cross-diagonal hatch. Forward diagonal hatch.

93


CHAPTER 7
wxCROSS_HATCH wxHORIZONTAL_HATCH wxVERTICAL_HATCH wxSTIPPLE wxSTIPPLE_MASK_OPAQUE See also wxBrush::SetStyle (p. 95), wxBrush::SetColour (p. 94), wxBrush::SetStipple (p. 94) Cross hatch. Horizontal hatch. Vertical hatch. Stippled using a bitmap. Stippled using a bitmap's mask.

wxBrush::Ok
bool Ok() const Returns true if the brush is initialised. It will return false if the default constructor has been used (for example, the brush is a member of a class, or NULL has been assigned to it).

wxBrush::SetColour
void SetColour(wxColour& colour) Sets the brush colour using a reference to a colour object. void SetColour(const wxString& colourName) Sets the brush colour using a colour name from the colour database. void SetColour(const unsigned char red, const unsigned char green, const unsigned char blue) Sets the brush colour using red, green and blue values. See also wxBrush::GetColour (p. 93)

wxBrush::SetStipple
void SetStipple(const wxBitmap& bitmap) Sets the stipple bitmap. Parameters bitmap

94


CHAPTER 7
The bitmap to use for stippling. Remarks The style will be set to wxSTIPPLE, unless the bitmap has a mask associated to it, in which case the style will be set to wxSTIPPLE_MASK_OPAQUE. If the wxSTIPPLE variant is used, the bitmap will be used to fill out the area to be drawn. If the wxSTIPPLE_MASK_OPAQUE is used, the current text foreground and text background determine what colours are used for displaying and the bits in the mask (which is a mono-bitmap actually) determine where to draw what. Note that under Windows 95, only 8x8 pixel large stipple bitmaps are supported, Windows 98 and NT as well as GTK support arbitrary bitmaps. See also wxBitmap (p. 67)

wxBrush::SetStyle
void SetStyle(int style) Sets the brush style. style One of: wxTRANSPARENT wxSOLID wxBDIAGONAL_HATCH wxCROSSDIAG_HATCH wxFDIAGONAL_HATCH wxCROSS_HATCH wxHORIZONTAL_HATCH wxVERTICAL_HATCH wxSTIPPLE wxSTIPPLE_MASK_OPAQUE See also wxBrush::GetStyle (p. 93) Transparent (no fill). Solid. Backward diagonal hatch. Cross-diagonal hatch. Forward diagonal hatch. Cross hatch. Horizontal hatch. Vertical hatch. Stippled using a bitmap. Stippled using a bitmap's mask.

95


CHAPTER 7 wxBrush::operator =
wxBrush& operator =(const wxBrush& brush) Assignment operator, using reference counting. Returns a reference to 'this'.

wxBrush::operator ==
bool operator ==(const wxBrush& brush) Equality operator. Two brushes are equal if they contain pointers to the same underlying brush data. It does not compare each attribute, so two independently-created brushes using the same parameters will fail the test.

wxBrush::operator !=
bool operator !=(const wxBrush& brush) Inequality operator. Two brushes are not equal if they contain pointers to different underlying brush data. It does not compare each attribute.

wxBrushList
A brush list is a list containing all brushes which have been created. Derived from wxList (p. 786) wxObject (p. 954) Include files <wx/gdicmn.h> Remarks There is only one instance of this class: wxTheBrushList. Use this object to search for a previously created brush of the desired type and create it if not already found. In some windowing systems, the brush may be a scarce resource, so it can pay to reuse old resources if possible. When an application finishes, all brushes will be deleted and their resources freed, eliminating the possibility of 'memory leaks'. However, it is best not to rely on this automatic cleanup because it can lead to double deletion in some circumstances. There are two mechanisms in recent versions of wxWindows which make the brush list less useful than it once was. Under Windows, scarce resources are cleaned up internally if they are not being used. Also, a referencing counting mechanism applied to all GDI objects means that some sharing of underlying resources is possible. You don't have to keep track of pointers, working out when it is safe delete a brush, because the

96


CHAPTER 7
referencing counting does it for you. For example, you can set a brush in a device context, and then immediately delete the brush you passed, because the brush is 'copied'. So you may find it easier to ignore the brush list, and instead create and copy brushes as you see fit. If your Windows resource meter suggests your application is using too many resources, you can resort to using GDI lists to share objects explicitly. The only compelling use for the brush list is for wxWindows to keep track of brushes in order to clean them up on exit. It is also kept for backward compatibility with earlier versions of wxWindows. See also wxBrush (p. 90)

wxBrushList::wxBrushList
void wxBrushList() Constructor. The application should not construct its own brush list: use the object pointer wxTheBrushList.

wxBrushList::AddBrush
void AddBrush(wxBrush *brush) Used internally by wxWindows to add a brush to the list.

wxBrushList::FindOrCreateBrush
wxBrush * FindOrCreateBrush(const wxColour& colour, int style) Finds a brush with the specified attributes and returns it, else creates a new brush, adds it to the brush list, and returns it. wxBrush * FindOrCreateBrush(const wxString& colourName, int style) Finds a brush with the specified attributes and returns it, else creates a new brush, adds it to the brush list, and returns it. Finds a brush of the given specification, or creates one and adds it to the list. Parameters colour Colour object.

97


CHAPTER 7
colourName Colour name, which should be in the colour database. style Brush style. See wxBrush::SetStyle (p. 95) for a list of styles.

wxBrushList::RemoveBrush
void RemoveBrush(wxBrush *brush) Used by wxWindows to remove a brush from the list.

wxBufferedDC
This simple class provides a simple way to avoid flicker: when drawing on it, everything is in fact drawn on an in-memory buffer (a wxBitmap (p. 67)) and copied to the screen only once, when this object is destroyed. It can be used in the same way as any other device context. wxBufferedDC itself typically replaces wxClientDC (p. 133), if you want to use it in your OnPaint() handler, you should look atwxBufferedPaintDC (p. 99). Derived from wxMemoryDC (p. 881) wxDC (p. 347) wxObject (p. 954) Include files <wx/dcbuffer.h> See also wxDC (p. 347)

wxBufferedDC::wxBufferedDC
wxBufferedDC() wxBufferedDC(wxDC *dc, const wxSize& area, int flags) wxBufferedDC(wxDC *dc, const wxBitmap& buffer) If you use the first, default, constructor, you must call one of the Init (p. 99) methods later in order to use the object.

98


CHAPTER 7
The other constructors initialize the object immediately and Init() must not be called after using them. Parameters dc The underlying DC: everything drawn to this object will be flushed to this DC when this object is destroyed. area The size of the bitmap to be used for buffering (this bitmap is created internally when it is not given explicitely). flags Can currently only include the flag wxBUFFER_DC_PRESERVE_BG which means that the existing background of dc must be copied to this object before doing anything else, otherwise the background is overwritten (which is more efficient). buffer Explicitly provided bitmap to be used for buffering: this is the most efficient solution as the bitmap doesn't have to be recreated each time but it also requires more memory as the bitmap is never freed. The bitmap should have appropriate size, anything drawn outside of its bounds is clipped.

wxBufferedDC::Init
void Init(wxDC *dc, const wxSize& area, int flags) void Init(wxDC *dc, const wxBitmap& buffer) These functions initialize the object created using the default constructor. Please see constructors documentation (p. 98) for details.

wxBufferedDC::~wxBufferedDC
Copies everything drawn on the DC so far to the underlying DC associated with this object.

wxBufferedPaintDC
This is a subclass of wxBufferedDC (p. 98) which can be used inside OnPaint() handler. Just create an object of this class instead of wxPaintDC (p. 966) and that's all you have to do to (mostly) avoid flicker. The only thing to watch out for is that if you are using this class together with wxScrolledWindow (p. 1085), you probably do not want to call PrepareDC (p. 1091) on it as it already does this internally for the real underlying

99


CHAPTER 7
wxPaintDC. Derived from wxMemoryDC (p. 881) wxDC (p. 347) wxObject (p. 954) Include files <wx/dcbuffer.h>

wxBufferedPaintDC::wxBufferedPaintDC
wxBufferedPaintDC(wxWindow *window, int flags) wxBufferedPaintDC(wxWindow *window, const wxBitmap& buffer) As with wxBufferedDC (p. 98), you may either provide the bitmap to be used for buffering or let this object create one internally (in the latter case, the size of the client part of the window is used).

wxBufferedPaintDC::~wxBufferedPaintDC
Copies everything drawn on the DC so far to the window associated with this object.

wxBufferedInputStream
This stream acts as a cache. It caches the bytes read from the specified input stream (See wxFilterInputStream (p. 501)). It uses wxStreamBuffer and sets the default in-buffer size to 1024 bytes. This class may not be used without some other stream to read the data from (such as a file stream or a memory stream). Derived from wxFilterInputStream (p. 501) Include files <wx/stream.h> See also wxStreamBuffer (p. 1193), wxInputStream (p. 762),wxBufferedOutputStream (p. 100)

wxBufferedOutputStream

100


CHAPTER 7
This stream acts as a cache. It caches the bytes to be written to the specified output stream (See wxFilterOutputStream (p. 502)). The data is only written when the cache is full, when the buffered stream is destroyed or when calling SeekO(). This class may not be used without some other stream to write the data to (such as a file stream or a memory stream). Derived from wxFilterOutputStream (p. 502) Include files <wx/stream.h> See also wxStreamBuffer (p. 1193), wxOutputStream (p. 958)

wxBufferedOutputStream::wxBufferedOutputStream
wxBufferedOutputStream(const wxOutputStream& parent) Creates a buffered stream using a buffer of a default size of 1024 bytes for cashing the stream parent.

wxBufferedOutputStream::~wxBufferedOutputStream
~wxBufferedOutputStream() Destructor. Calls Sync() and destroys the internal buffer.

wxBufferedOutputStream::SeekO
off_t SeekO(off_t pos, wxSeekMode mode) Calls Sync() and changes the stream position.

wxBufferedOutputStream::Sync
void Sync() Flushes the buffer and calls Sync() on the parent stream.

wxBusyCursor

101


CHAPTER 7
This class makes it easy to tell your user that the program is temporarily busy. Just create a wxBusyCursor object on the stack, and within the current scope, the hourglass will be shown. For example:
wxBusyCursor wait; for (int i = 0; i < 100000; i++) DoACalulation(); c

It works by calling wxBeginBusyCursor (p. 1489) in the constructor, and wxEndBusyCursor (p. 1491) in the destructor. Derived from None Include files <wx/utils.h> See also wxBeginBusyCursor (p. 1489), wxEndBusyCursor (p. 1491), wxWindowDisabler (p. 1437)

wxBusyCursor::wxBusyCursor
wxBusyCursor(wxCursor* cursor = wxHOURGLASS_CURSOR) Constructs a busy cursor object, calling wxBeginBusyCursor (p. 1489).

wxBusyCursor::~wxBusyCursor
~wxBusyCursor() Destroys the busy cursor object, calling wxEndBusyCursor (p. 1491).

wxBusyInfo
This class makes it easy to tell your user that the program is temporarily busy. Just create a wxBusyInfo object on the stack, and within the current scope, a message window will be shown. For example:
wxBusyInfo wait("Please wait, working..."); for (int i = 0; i < 100000; i++)

102


CHAPTER 7
{ DoACalculation(); }

It works by creating a window in the constructor, and deleting it in the destructor. You may also want to call wxTheApp->Yield() to refresh the window periodically (in case it had been obscured by other windows, for example) like this:
wxWindowDisabler disableAll; wxBusyInfo wait("Please wait, working..."); for (int i = 0; i < 100000; i++) { DoACalculation(); if ( !(i % 1000) ) wxTheApp->Yield(); }

but take care to not cause undesirable reentrancies when doing it (see wxApp::Yield() (p. 41) for more details). The simplest way to do it is to use wxWindowDisabler (p. 1437) class as illustrated in the above example. Derived from None Include files <wx/busyinfo.h>

wxBusyInfo::wxBusyInfo
wxBusyInfo(const wxString& msg, wxParent *parent = NULL) Constructs a busy info window as child of parent and displays msgin it. NB: If parent is not NULL you must ensure that it is not closed while the busy info is shown.

wxBusyInfo::~wxBusyInfo
~wxBusyInfo() Hides and closes the window containing the information text.

wxButton
A button is a control that contains a text string, and is one of the commonest elements of

103


CHAPTER 7
a GUI. It may be placed on a dialog box (p. 367) or panel (p. 972), or indeed almost any other window. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/button.h> Window styles wxBU_LEFT wxBU_TOP wxBU_RIGHT wxBU_BOTTOM wxBU_EXACTFIT wxNO_BORDER Left-justifies the label. Windows only. Aligns the label to the top of the button. Windows only. Right-justifies the bitmap label. Windows only. Aligns the label to the bottom of the button. Windows only. Creates the button as small as possible instead of making it of the standard size (which is the default behaviour ). Creates a flat button. Windows and GTK+ only.

See also window styles overview (p. 1611). Event handling EVT_BUTTON(id, func) Process a wxEVT_COMMAND_BUTTON_CLICKED event, when the button is clicked.

See also wxBitmapButton (p. 80)

wxButton::wxButton
wxButton() Default constructor. wxButton(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator, const wxString& name = "button") Constructor, creating and showing a button.

104


CHAPTER 7
Parameters parent Parent window. Must not be NULL. id Button identifier. A value of -1 indicates a default value. label Text to be displayed on the button. pos Button position. size Button size. If the default size (-1, -1) is specified then the button is sized appropriately for the text. style Window style. See wxButton (p. 103). validator Window validator. name Window name. See also wxButton::Create (p. 105), wxValidator (p. 1358)

wxButton::~wxButton
~wxButton() Destructor, destroying the button.

wxButton::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator, const wxString& name = "button") Button creation function for two-step creation. For more details, see wxButton::wxButton (p. 104).

105


CHAPTER 7 wxButton::GetLabel
wxString GetLabel() const Returns the string label for the button. Return value The button's label. See also wxButton::SetLabel (p. 106)

wxButton::GetDefaultSize
wxSize GetDefaultSize() Returns the default size for the buttons. It is advised to make all the dialog buttons of the same size and this function allows to retrieve the (platform and current font dependent size) which should be the best suited for this.

wxButton::SetDefault
void SetDefault() This sets the button to be the default item for the panel or dialog box. Remarks Under Windows, only dialog box buttons respond to this function. As normal under Windows and Motif, pressing return causes the default button to be depressed when the return key is pressed. See also wxWindow::SetFocus (p. 1424) which sets the keyboard focus for windows and text panel items, and wxPanel::SetDefaultItem (p. 975). Note that under Motif, calling this function immediately after creation of a button and before the creation of other buttons will cause misalignment of the row of buttons, since default buttons are larger. To get around this, call SetDefault after you have created a row of buttons: wxWindows will then set the size of all buttons currently on the panel to the same size.

wxButton::SetLabel
void SetLabel(const wxString& label) Sets the string label for the button. Parameters label

106


CHAPTER 7
The label to set. See also wxButton::GetLabel (p. 106)

wxCalculateLayoutEvent
This event is sent by wxLayoutAlgorithm (p. 781) to calculate the amount of the remaining client area that the window should occupy. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/laywin.h> Event table macros EVT_CALCULATE_LAYOUT(func) Process a wxEVT_CALCULATE_LAYOUT event, which asks the window to take a 'bite' out of a rectangle provided by the algorithm.

See also wxQueryLayoutInfoEvent (p. 1030), wxSashLayoutWindow (p. 1065), wxLayoutAlgorithm (p. 781).

wxCalculateLayoutEvent::wxCalculateLayoutEvent
wxCalculateLayoutEvent(wxWindowID id = 0) Constructor.

wxCalculateLayoutEvent::GetFlags
int GetFlags() const Returns the flags associated with this event. Not currently used.

wxCalculateLayoutEvent::GetRect
wxRect GetRect() const

107


CHAPTER 7
Before the event handler is entered, returns the remaining parent client area that the window could occupy. When the event handler returns, this should contain the remaining parent client rectangle, after the event handler has subtracted the area that its window occupies.

wxCalculateLayoutEvent::SetFlags
void SetFlags(int flags) Sets the flags associated with this event. Not currently used.

wxCalculateLayoutEvent::SetRect
void SetRect(const wxRect& rect) Call this to specify the new remaining parent client area, after the space occupied by the window has been subtracted.

wxCalendarCtrl
The calendar control allows the user to pick a date interactively. For this, it displays a window containing several parts: the control to pick the month and the year at the top (either or both of them may be disabled) and a month area below them which shows all the days in the month. The user can move the current selection using the keyboard and select the date (generating EVT_CALENDAR event) by pressing <Return> or double clicking it. It has advanced possibilities for the customization of its display. All global settings (such as colours and fonts used) can, of course, be changed. But also, the display style for each day in the month can be set independently using wxCalendarDateAttr (p. 114) class. An item without custom attributes is drawn with the default colours and font and without border, but setting custom attributes with SetAttr (p. 113) allows to modify its appearance. Just create a custom attribute object and set it for the day you want to be displayed specially (note that the control will take ownership of the pointer, i.e. it will delete it itself). A day may be marked as being a holiday, even if it is not recognized as one by wxDateTime (p. 1582) using SetHoliday (p. 115) method. As the attributes are specified for each day, they may change when the month is changed, so you will often want to update them in EVT_CALENDAR_MONTH event handler. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954)

108


CHAPTER 7
Include files <wx/calctrl.h> Window styles wxCAL_SUNDAY_FIRST wxCAL_MONDAY_FIRST Show Sunday as the first day in the week Show Monday as the first day in the week

wxCAL_SHOW_HOLIDAYS Highlight holidays in the calendar wxCAL_NO_YEAR_CHANGE Disable the year changing

Disable the month (and, implicitly, the year) wxCAL_NO_MONTH_CHANGE changing wxCAL_SHOW_SURROUNDING_WEEKS Show the neighbouring weeks in the previous and next months wxCAL_SEQUENTIAL_MONTH_SELECTION Use alternative, more compact, style for the month and year selection controls. The default calendar style is wxCAL_SHOW_HOLIDAYS. Event table macros To process input from a calendar control, use these event handler macros to direct input to member functions that take a wxCalendarEvent (p. 117) argument. EVT_CALENDAR(id, func) A day was double clicked in the calendar. The selected date changed.

EVT_CALENDAR_SEL_CHANGED(id, func) EVT_CALENDAR_DAY(id, func) EVT_CALENDAR_MONTH(id, func) EVT_CALENDAR_YEAR(id, func)

The selected day changed. The selected month changed. The selected year changed. User clicked on the week day

EVT_CALENDAR_WEEKDAY_CLICKED(id, func) header

Note that changing the selected date will result in either of EVT_CALENDAR_DAY, MONTH or YEAR events and EVT_CALENDAR_SEL_CHANGED one. Constants The following are the possible return values for HitTest (p. 113) method:
enum wxCalendarHitTestResult { wxCAL_HITTEST_NOWHERE, wxCAL_HITTEST_HEADER, wxCAL_HITTEST_DAY }

// outside of anything // on the header (weekdays) // on a day in the calendar

109


CHAPTER 7
See also Calendar sample (p. 1561) wxCalendarDateAttr (p. 114) wxCalendarEvent (p. 117)

wxCalendarCtrl::wxCalendarCtrl
wxCalendarCtrl() Default constructor, use Create (p. 110) after it.

wxCalendarCtrl::wxCalendarCtrl
wxCalendarCtrl(wxWindow* parent, wxWindowID id, const wxDateTime& date = wxDefaultDateTime, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxCAL_SHOW_HOLIDAYS, const wxString& name = wxCalendarNameStr) Does the same as Create (p. 110) method.

wxCalendarCtrl::Create
bool Create(wxWindow* parent, wxWindowID id, const wxDateTime& date = wxDefaultDateTime, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxCAL_SHOW_HOLIDAYS, const wxString& name = wxCalendarNameStr) Creates the control. See wxWindow (p. 1389) for the meaning of the parameters and the control overview for the possible styles.

wxCalendarCtrl::~wxCalendarCtrl
~wxCalendarCtrl() Destroys the control.

wxCalendarCtrl::SetDate
void SetDate(const wxDateTime& date) Sets the current date.

wxCalendarCtrl::GetDate
const wxDateTime& GetDate() const

110


CHAPTER 7
Gets the currently selected date.

wxCalendarCtrl::EnableYearChange
void EnableYearChange(bool enable = true) This function should be used instead of changing wxCAL_NO_YEAR_CHANGEstyle bit directly. It allows or disallows the user to change the year interactively.

wxCalendarCtrl::EnableMonthChange
void EnableMonthChange(bool enable = true) This function should be used instead of changing wxCAL_NO_MONTH_CHANGE style bit. It allows or disallows the user to change the month interactively. Note that if the month can not be changed, the year can not be changed neither.

wxCalendarCtrl::EnableHolidayDisplay
void EnableHolidayDisplay(bool display = true) This function should be used instead of changing wxCAL_SHOW_HOLIDAYSstyle bit directly. It enables or disables the special highlighting of the holidays.

wxCalendarCtrl::SetHeaderColours
void SetHeaderColours(const wxColour& colFg, const wxColour& colBg) Set the colours used for painting the weekdays at the top of the control.

wxCalendarCtrl::GetHeaderColourFg
const wxColour& GetHeaderColourFg() const Gets the foreground colour of the header part of the calendar window. See also SetHeaderColours (p. 111)

wxCalendarCtrl::GetHeaderColourBg
const wxColour& GetHeaderColourBg() const Gets the background colour of the header part of the calendar window.

111


CHAPTER 7
See also SetHeaderColours (p. 111)

wxCalendarCtrl::SetHighlightColours
void SetHighlightColours(const wxColour& colFg, const wxColour& colBg) Set the colours to be used for highlighting the currently selected date.

wxCalendarCtrl::GetHighlightColourFg
const wxColour& GetHighlightColourFg() const Gets the foreground highlight colour. See also SetHighlightColours (p. 112)

wxCalendarCtrl::GetHighlightColourBg
const wxColour& GetHighlightColourBg() const Gets the background highlight colour. See also SetHighlightColours (p. 112)

wxCalendarCtrl::SetHolidayColours
void SetHolidayColours(const wxColour& colFg, const wxColour& colBg) Sets the colours to be used for the holidays highlighting (only used if the window style includes wxCAL_SHOW_HOLIDAYS flag).

wxCalendarCtrl::GetHolidayColourFg
const wxColour& GetHolidayColourFg() const Return the foreground colour currently used for holiday highlighting. See also SetHolidayColours (p. 112)

112


CHAPTER 7 wxCalendarCtrl::GetHolidayColourBg
const wxColour& GetHolidayColourBg() const Return the background colour currently used for holiday highlighting. See also SetHolidayColours (p. 112)

wxCalendarCtrl::GetAttr
wxCalendarDateAttr * GetAttr(size_t day) const Returns the attribute for the given date (should be in the range 1...31). The returned pointer may be NULL.

wxCalendarCtrl::SetAttr
void SetAttr(size_t day, wxCalendarDateAttr* attr) Associates the attribute with the specified date (in the range 1...31). If the pointer is NULL, the items attribute is cleared.

wxCalendarCtrl::SetHoliday
void SetHoliday(size_t day) Marks the specified day as being a holiday in the current month.

wxCalendarCtrl::ResetAttr
void ResetAttr(size_t day) Clears any attributes associated with the given day (in the range1...31).

wxCalendarCtrl::HitTest
wxCalendarHitTestResult HitTest(const wxPoint& pos, wxDateTime* date = NULL, wxDateTime::WeekDay* wd = NULL) Returns one of wxCAL_HITTEST_XXX constants (p. 108) and fills either date or wd pointer with the corresponding value depending on the hit test code.

113


CHAPTER 7

wxCalendarDateAttr
wxCalendarDateAttr is a custom attributes for a calendar date. The objects of this class are used with wxCalendarCtrl (p. 108). Derived from No base class Constants Here are the possible kinds of borders which may be used to decorate a date:
enum wxCalendarDateBorder { wxCAL_BORDER_NONE, wxCAL_BORDER_SQUARE, wxCAL_BORDER_ROUND }

// no border (default) // a rectangular border // a round border

See also wxCalendarCtrl (p. 108)

wxCalendarDateAttr::wxCalendarDateAttr
wxCalendarDateAttr() wxCalendarDateAttr(const wxColour& colText, const wxColour& colBack = wxNullColour, const wxColour& colBorder = wxNullColour, const wxFont& font = wxNullFont, wxCalendarDateBorder border = wxCAL_BORDER_NONE) wxCalendarDateAttr(wxCalendarDateBorder border, const wxColour& colBorder = wxNullColour) The constructors.

wxCalendarDateAttr::SetTextColour
void SetTextColour(const wxColour& colText) Sets the text (foreground) colour to use.

wxCalendarDateAttr::SetBackgroundColour
void SetBackgroundColour(const wxColour& colBack) Sets the text background colour to use.

114


CHAPTER 7 wxCalendarDateAttr::SetBorderColour
void SetBorderColour(const wxColour& col) Sets the border colour to use.

wxCalendarDateAttr::SetFont
void SetFont(const wxFont& font) Sets the font to use.

wxCalendarDateAttr::SetBorder
void SetBorder(wxCalendarDateBorder border) Sets the border kind (p. 114)

wxCalendarDateAttr::SetHoliday
void SetHoliday(bool holiday) Display the date with this attribute as a holiday.

wxCalendarDateAttr::HasTextColour
bool HasTextColour() const Returns true if this item has a non default text foreground colour.

wxCalendarDateAttr::HasBackgroundColour
bool HasBackgroundColour() const Returns true if this attribute specifies a non default text background colour.

wxCalendarDateAttr::HasBorderColour
bool HasBorderColour() const Returns true if this attribute specifies a non default border colour.

wxCalendarDateAttr::HasFont
bool HasFont() const

115


CHAPTER 7
Returns true if this attribute specifies a non default font.

wxCalendarDateAttr::HasBorder
bool HasBorder() const Returns true if this attribute specifies a non default (i.e. any) border.

wxCalendarDateAttr::IsHoliday
bool IsHoliday() const Returns true if this attribute specifies that this item should be displayed as a holiday.

wxCalendarDateAttr::GetTextColour
const wxColour& GetTextColour() const Returns the text colour to use for the item with this attribute.

wxCalendarDateAttr::GetBackgroundColour
const wxColour& GetBackgroundColour() const Returns the background colour to use for the item with this attribute.

wxCalendarDateAttr::GetBorderColour
const wxColour& GetBorderColour() const Returns the border colour to use for the item with this attribute.

wxCalendarDateAttr::GetFont
const wxFont& GetFont() const Returns the font to use for the item with this attribute.

wxCalendarDateAttr::GetBorder
wxCalendarDateBorder GetBorder() const Returns the border (p. 114) to use for the item with this attribute.

116


CHAPTER 7

wxCalendarEvent
The wxCalendarEvent class is used together with wxCalendarCtrl (p. 108). See also wxCalendarCtrl (p. 108)

wxCalendarEvent::GetDate
wxcalendareventgetdate const wxDateTime& GetDate() const Returns the date. This function may be called for all event types except EVT_CALENDAR_WEEKDAY_CLICKED one for which it doesn't make sense.

wxCalendarEvent::GetWeekDay
wxcalendareventgetweekday wxDateTime::WeekDay GetWeekDay() const Returns the week day on which the user clicked in EVT_CALENDAR_WEEKDAY_CLICKED handler. It doesn't make sense to call this function in other handlers.

wxCalendarEvent::SetDate
wxcalendareventsetdate void SetDate(const wxDateTime& date) Sets the date.

wxCalendarEvent::SetWeekDay
wxcalendareventsetweekday void SetWeekDay(wxDateTime::WeekDay day) Sets the week day.

wxCaret
A caret is a blinking cursor showing the position where the typed text will appear. The

117


CHAPTER 7
text controls usually have a caret but wxCaret class also allows to use a caret in other windows. Currently, the caret appears as a rectangle of the given size. In the future, it will be possible to specify a bitmap to be used for the caret shape. A caret is always associated with a window and the current caret can be retrieved using wxWindow::GetCaret (p. 1400). The same caret can't be reused in two different windows. Derived from No base class Include files <wx/caret.h> Data structures

wxCaret::wxCaret
wxCaret() Default constructor: you must use one of Create() functions later. wxCaret(wxWindow* window, int width, int height) wxCaret(wxWindowBase* window, const wxSize& size) Create the caret of given (in pixels) width and height and associates it with the given window.

wxCaret::Create
bool Create(wxWindowBase* window, int width, int height) bool Create(wxWindowBase* window, const wxSize& size) Create the caret of given (in pixels) width and height and associates it with the given window (same as constructor).

wxCaret::GetBlinkTime
static int GetBlinkTime() Returns the blink time which is measured in milliseconds and is the time elapsed between 2 inversions of the caret (blink time of the caret is the same for all carets, so this functions is static).

118


CHAPTER 7 wxCaret::GetPosition
void GetPosition(int* x, int* y) const wxPoint GetPosition() const Get the caret position (in pixels). wxPerl note: In wxPerl there are two methods instead of a single overloaded method: GetPosition() GetPositionXY() Returns a Wx::Point Returns a 2-element list ( x, y )

wxCaret::GetSize
void GetSize(int* width, int* height) const wxSize GetSize() const Get the caret size. wxPerl note: In wxPerl there are two methods instead of a single overloaded method: GetSize() GetSizeWH() Returns a Wx::Size Returns a 2-element list ( width, height )

wxCaret::GetWindow
wxWindow* GetWindow() const Get the window the caret is associated with.

wxCaret::Hide
void Hide() Same as wxCaret::Show(false) (p. 120).

wxCaret::IsOk
bool IsOk() const Returns true if the caret was created successfully.

119


CHAPTER 7 wxCaret::IsVisible
bool IsVisible() const Returns true if the caret is visible and false if it is permanently hidden (if it is is blinking and not shown currently but will be after the next blink, this method still returns true).

wxCaret::Move
void Move(int x, int y) void Move(const wxPoint& pt) Move the caret to given position (in logical coordinates).

wxCaret::SetBlinkTime
static void SetBlinkTime(int milliseconds) Sets the blink time for all the carets. Remarks Under Windows, this function will change the blink time for all carets permanently (until the next time it is called), even for the carets in other applications. See also GetBlinkTime (p. 118)

wxCaret::SetSize
void SetSize(int width, int height) void SetSize(const wxSize& size) Changes the size of the caret.

wxCaret::Show
void Show(bool show = true) Shows or hides the caret. Notice that if the caret was hidden N times, it must be shown N times as well to reappear on the screen.

wxCheckBox

120


CHAPTER 7
A checkbox is a labelled box which by default is either on (checkmark is visible) or off (no checkmark). Optionally (When the wxCHK_3STATE style flag is set) it can have a third state, called the mixed or undetermined state. Often this is used as a "Does Not Apply" state. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/checkbox.h> Window styles wxCHK_2STATE wxCHK_3STATE Create a 2-state checkbox. This is the default. Create a 3-state checkbox.

wxCHK_ALLOW_3RD_STATE_FOR_USER By default a user can't set a 3-state checkbox to the third state. It can only be done from code. Using this flags allows the user to set the checkbox to the third state by clicking. wxALIGN_RIGHT Makes the text appear on the left of the checkbox.

See also window styles overview (p. 1611). Event handling EVT_CHECKBOX(id, func) Process a wxEVT_COMMAND_CHECKBOX_CLICKED event, when the checkbox is clicked.

See also wxRadioButton (p. 1039), wxCommandEvent (p. 164)

wxCheckBox::wxCheckBox
wxCheckBox() Default constructor. wxCheckBox(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& val, const wxString& name = "checkBox")

121


CHAPTER 7
Constructor, creating and showing a checkbox. Parameters parent Parent window. Must not be NULL. id Checkbox identifier. A value of -1 indicates a default value. label Text to be displayed next to the checkbox. pos Checkbox position. If the position (-1, -1) is specified then a default position is chosen. size Checkbox size. If the default size (-1, -1) is specified then a default size is chosen. style Window style. See wxCheckBox (p. 120). validator Window validator. name Window name. See also wxCheckBox::Create (p. 122), wxValidator (p. 1358)

wxCheckBox::~wxCheckBox
~wxCheckBox() Destructor, destroying the checkbox.

wxCheckBox::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& val, const wxString& name = "checkBox")

122


CHAPTER 7
Creates the checkbox for two-step construction. See wxCheckBox::wxCheckBox (p. 121) for details.

wxCheckBox::GetValue
bool GetValue() const Gets the state of a 2-state checkbox. Return value Returns true if it is checked, false otherwise.

wxCheckBox::Get3StateValue
wxCheckBoxState Get3StateValue() const Gets the state of a 3-state checkbox. Return value Returns wxCHK_UNCHECKED when the checkbox is unchecked, wxCHK_CHECKED when it is checked and wxCHK_UNDETERMINED when it's in the undetermined state. Asserts when the function is used with a 2-state checkbox.

wxCheckBox::Is3rdStateAllowedForUser
bool Is3rdStateAllowedForUser() const Returns whether or not the user can set the checkbox to the third state. Return value Returns true if the user can set the third state of this checkbox, false if it can only be set programmatically or if it's a 2-state checkbox.

wxCheckBox::Is3State
bool Is3State() const Returns whether or not the checkbox is a 3-state checkbox. Return value Returns true if this checkbox is a 3-state checkbox, false if it's a 2-state checkbox.

wxCheckBox::IsChecked

123


CHAPTER 7
bool IsChecked() const This is just a maybe more readable synonym for GetValue (p. 123): just as the latter, it returns true if the checkbox is checked and false otherwise.

wxCheckBox::SetValue
void SetValue(bool state) Sets the checkbox to the given state. This does not cause a wxEVT_COMMAND_CHECKBOX_CLICKED event to get emitted. Parameters state If true, the check is on, otherwise it is off.

wxCheckBox::Set3StateValue
void Set3StateValue(const wxCheckBoxState state) Sets the checkbox to the given state. This does not cause a wxEVT_COMMAND_CHECKBOX_CLICKED event to get emitted. Parameters state Can be one of: wxCHK_UNCHECKED (Check is off), wxCHK_CHECKED (Check is on) or wxCHK_UNDETERMINED (Check is mixed). Asserts when the checkbox is a 2-state checkbox and setting the state to wxCHK_UNDETERMINED.

wxCheckListBox
A checklistbox is like a listbox, but allows items to be checked or unchecked. This class is currently implemented under Windows and GTK. When using this class under Windows wxWindows must be compiled with USE_OWNER_DRAWN set to 1. Only the new functions for this class are documented; see also wxListBox (p. 793). Derived from wxListBox (p. 793) wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954)

124


CHAPTER 7
Include files <wx/checklst.h> Window styles See wxListBox (p. 793). Event handling EVT_CHECKLISTBOX(id, func) Process a wxEVT_COMMAND_CHECKLISTBOX_TOGG LED event, when an item in the check list box is checked or unchecked.

See also wxListBox (p. 793), wxChoice (p. 127), wxComboBox (p. 158), wxListCtrl (p. 799), wxCommandEvent (p. 164)

wxCheckListBox::wxCheckListBox
wxCheckListBox() Default constructor. wxCheckListBox(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, int n, const wxString choices[] = NULL, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listBox") wxCheckListBox(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, const wxArrayString& choices, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listBox") Constructor, creating and showing a list box. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. pos Window position. size

125


CHAPTER 7
Window size. If the default size (-1, -1) is specified then the window is sized appropriately. n Number of strings with which to initialise the control. choices An array of strings with which to initialise the control. style Window style. See wxCheckListBox (p. 124). validator Window validator. name Window name. wxPython note: The wxCheckListBox constructor in wxPython reduces the nand choices arguments are to a single argument, which is a list of strings. wxPerl note: In wxPerl there is just an array reference in place of nand choices.

wxCheckListBox::~wxCheckListBox
void ~wxCheckListBox() Destructor, destroying the list box.

wxCheckListBox::Check
void Check(int item, bool check = true) Checks the given item. Note that calling this method doesn't result in wxEVT_COMMAND_CHECKLISTBOX_TOGGLE being emitted. Parameters item Index of item to check. check true if the item is to be checked, false otherwise.

126


CHAPTER 7 wxCheckListBox::IsChecked
bool IsChecked(int item) const Returns true if the given item is checked, false otherwise. Parameters item Index of item whose check status is to be returned.

wxChoice
A choice item is used to select one of a list of strings. Unlike a listbox, only the selection is visible until the user pulls down the menu of choices. Derived from wxControlWithItems (p. 199) wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/choice.h> Window styles There are no special styles for wxChoice. See also window styles overview (p. 1611). Event handling EVT_CHOICE(id, func) Process a wxEVT_COMMAND_CHOICE_SELECTED event, when an item on the list is selected.

See also wxListBox (p. 793), wxComboBox (p. 158), wxCommandEvent (p. 164)

wxChoice::wxChoice
wxChoice() Default constructor.

127


CHAPTER 7
wxChoice(wxWindow *parent, wxWindowID id, const wxPoint& pos, const wxSize& size, int n, const wxString choices[], long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "choice") wxChoice(wxWindow *parent, wxWindowID id, const wxPoint& pos, const wxSize& size, const wxArrayString& choices, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "choice") Constructor, creating and showing a choice. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. pos Window position. size Window size. If the default size (-1, -1) is specified then the choice is sized appropriately. n Number of strings with which to initialise the choice control. choices An array of strings with which to initialise the choice control. style Window style. See wxChoice (p. 127). validator Window validator. name Window name. See also wxChoice::Create (p. 129), wxValidator (p. 1358) wxPython note: The wxChoice constructor in wxPython reduces the nand choices arguments are to a single argument, which is a list of strings.

128


CHAPTER 7
wxPerl note: In wxPerl there is just an array reference in place of nand choices.

wxChoice::~wxChoice
~wxChoice() Destructor, destroying the choice item.

wxChoice::Create
bool Create(wxWindow *parent, wxWindowID id, const wxPoint& pos, const wxSize& size, int n, const wxString choices[], long style = 0, const wxString& name = "choice") bool Create(wxWindow *parent, wxWindowID id, const wxPoint& pos, const wxSize& size, const wxArrayString& choices, long style = 0, const wxString& name = "choice") Creates the choice for two-step construction. See wxChoice::wxChoice (p. 127).

wxChoice::Delete
void Delete(int n) Deletes the item with the given index from the control. Parameters n The item to delete.

wxChoice::GetColumns
int GetColumns() const Gets the number of columns in this choice item. Remarks This is implemented for Motif only and always returns 1 for the other platforms.

wxChoice::SetColumns
void SetColumns(int n = 1) Sets the number of columns in this choice item.

129


CHAPTER 7
Parameters n Number of columns. Remarks This is implemented for Motif only and doesn't do anything under other platforms.

wxClassInfo
This class stores meta-information about classes. Instances of this class are not generally defined directly by an application, but indirectly through use of macros such as DECLARE_DYNAMIC_CLASS and IMPLEMENT_DYNAMIC_CLASS. Derived from No parent class. Include files <wx/object.h> See also Overview (p. 1573), wxObject (p. 954)

wxClassInfo::wxClassInfo
wxClassInfo(char* className, char* baseClass1, char* baseClass2, int size, wxObjectConstructorFn fn) Constructs a wxClassInfo object. The supplied macros implicitly construct objects of this class, so there is no need to create such objects explicitly in an application.

wxClassInfo::CreateObject
wxObject* CreateObject() Creates an object of the appropriate kind. Returns NULL if the class has not been declared dynamically creatable (typically, it is an abstract class).

wxClassInfo::FindClass
static wxClassInfo * FindClass(char* name)

130


CHAPTER 7
Finds the wxClassInfo object for a class of the given string name.

wxClassInfo::GetBaseClassName1
char* GetBaseClassName1() const Returns the name of the first base class (NULL if none).

wxClassInfo::GetBaseClassName2
char* GetBaseClassName2() const Returns the name of the second base class (NULL if none).

wxClassInfo::GetClassName
char * GetClassName() const Returns the string form of the class name.

wxClassInfo::GetSize
int GetSize() const Returns the size of the class.

wxClassInfo::InitializeClasses
static void InitializeClasses() Initializes pointers in the wxClassInfo objects for fast execution of IsKindOf. Called in base wxWindows library initialization.

wxClassInfo::IsKindOf
bool IsKindOf(wxClassInfo* info) Returns true if this class is a kind of (inherits from) the given class.

wxClient
A wxClient object represents the client part of a client-server DDE-like (Dynamic Data Exchange) conversation. The actual DDE-based implementation using wxDDEClient is available on Windows only, but a platform-independent, socket-based version of this API

131


CHAPTER 7
is available using wxTCPClient, which has the same API. To create a client which can communicate with a suitable server, you need to derive a class from wxConnection and another from wxClient. The custom wxConnection class will intercept communications in a 'conversation' with a server, and the custom wxClient is required so that a user-overriddenwxClient::OnMakeConnection (p. 133) member can return a wxConnection of the required class, when a connection is made. Look at the IPC sample and the Interprocess communications overview (p. 1688) for an example of how to do this. Derived from wxClientBase wxObject (p. 954) Include files <wx/ipc.h> See also wxServer (p. 1101), wxConnection (p. 191), Interprocess communications overview (p. 1688)

wxClient::wxClient
wxClient() Constructs a client object.

wxClient::MakeConnection
wxConnectionBase * MakeConnection(const wxString& host, const wxString& service, const wxString& topic) Tries to make a connection with a server by host (machine name under UNIX - use 'localhost' for same machine; ignored when using native DDE in Windows), service name and topic string. If the server allows a connection, a wxConnection object will be returned. The type of wxConnection returned can be altered by overriding the wxClient::OnMakeConnection (p. 133) member to return your own derived connection object. Under Unix, the service name may be either an integer port identifier in which case an Internet domain socket will be used for the communications, or a valid file name (which shouldn't exist and will be deleted afterwards) in which case a Unix domain socket is created. SECURITY NOTE: Using Internet domain sockets if extremely insecure for IPC as there is absolutely no access control for them, use Unix domain sockets whenever possible!

132


CHAPTER 7 wxClient::OnMakeConnection
wxConnectionBase * OnMakeConnection() Called by wxClient::MakeConnection (p. 132), by default this simply returns a new wxConnection object. Override this method to return a wxConnection descendant customised for the application. The advantage of deriving your own connection class is that it will enable you to intercept messages initiated by the server, such as wxConnection::OnAdvise (p. 193). You may also want to store application-specific data in instances of the new class.

wxClient::ValidHost
bool ValidHost(const wxString& host) Returns true if this is a valid host name, false otherwise. This always returns true under MS Windows.

wxClientDC
A wxClientDC must be constructed if an application wishes to paint on the client area of a window from outside an OnPaint event. This should normally be constructed as a temporary stack object; don't store a wxClientDC object. To draw on a window from within OnPaint, construct a wxPaintDC (p. 966) object. To draw on the whole window including decorations, construct a wxWindowDC (p. 1436) object (Windows only). Derived from wxWindowDC (p. 1436) wxDC (p. 347) Include files <wx/dcclient.h> See also wxDC (p. 347), wxMemoryDC (p. 881), wxPaintDC (p. 966), wxWindowDC (p. 1436), wxScreenDC (p. 1072)

wxClientDC::wxClientDC
wxClientDC(wxWindow* window)

133


CHAPTER 7
Constructor. Pass a pointer to the window on which you wish to paint.

wxClientData
All classes deriving from wxEvtHandler (p. 443)(such as all controls and wxApp (p. 31)) can hold arbitrary data which is here referred to as "client data". This is useful e.g. for scripting languages which need to handle shadow objects for most of wxWindows' classes and which store a handle to such a shadow class as client data in that class. This data can either be of type void - in which case the datacontainer does not take care of freeing the data again or it is of type wxClientData or its derivates. In that case the container (e.g. a control) will free the memory itself later. Note that you must not assign both void data and data derived from the wxClientData class to a container. Some controls can hold various items and these controls can additionally hold client data for each item. This is the case forwxChoice (p. 127), wxComboBox (p. 158)and wxListBox (p. 793). wxTreeCtrl (p. 1327)has a specialized class wxTreeItemData (p. 1348)for each item in the tree. If you want to add client data to your own classes, you may use the mix-in class wxClientDataContainer (p. 134). Include files <wx/clntdata.h> See also wxEvtHandler (p. 443), wxTreeItemData (p. 1348),wxStringClientData (p. 1222), wxClientDataContainer (p. 134)

wxClientData::wxClientData
wxClientData() Constructor.

wxClientData::~wxClientData
~wxClientData() Virtual destructor.

wxClientDataContainer
This class is a mixin that provides storage and management of "client data." This data can either be of type void - in which case the datacontainer does not take care of freeing

134


CHAPTER 7
the data again or it is of type wxClientData or its derivates. In that case the container will free the memory itself later. Note that you must not assign both void data and data derived from the wxClientData class to a container. NOTE: This functionality is currently duplicated in wxEvtHandler in order to avoid having more than one vtable in that class heirachy. See also wxEvtHandler (p. 443), wxClientData (p. 134) Derived from No base class Include files <clntdata.h> Data structures

wxClientDataContainer::wxClientDataContainer
wxClientDataContainer()

wxClientDataContainer::~wxClientDataContainer
~wxClientDataContainer()

wxClientDataContainer::GetClientData
void* GetClientData() const Get the untyped client data.

wxClientDataContainer::GetClientObject
wxClientData* GetClientObject() const Get a pointer to the client data object.

wxClientDataContainer::SetClientData
void SetClientData(void* data) Set the untyped client data.

135


CHAPTER 7 wxClientDataContainer::SetClientObject
void SetClientObject(wxClientData* data) Set the client data object. Any previous object will be deleted.

wxClipboard
A class for manipulating the clipboard. Note that this is not compatible with the clipboard class from wxWindows 1.xx, which has the same name but a different implementation. To use the clipboard, you call member functions of the global wxTheClipboard object. See also the wxDataObject overview (p. 1667) for further information. Call wxClipboard::Open (p. 138) to get ownership of the clipboard. If this operation returns true, you now own the clipboard. Call wxClipboard::SetData (p. 138) to put data on the clipboard, or wxClipboard::GetData (p. 138) to retrieve data from the clipboard. Call wxClipboard::Close (p. 137) to close the clipboard and relinquish ownership. You should keep the clipboard open only momentarily. For example:
// Write some text to the clipboard if (wxTheClipboard->Open()) { // This data objects are held by the clipboard, // so do not delete them in the app. wxTheClipboard->SetData( new wxTextDataObject("Some text") ); wxTheClipboard->Close(); } // Read some text if (wxTheClipboard->Open()) { if (wxTheClipboard->IsSupported( wxDF_TEXT )) { wxTextDataObject data; wxTheClipboard->GetData( data ); wxMessageBox( data.GetText() ); } wxTheClipboard->Close(); }

Derived from wxObject (p. 954) Include files <wx/clipbrd.h> See also Drag and drop overview (p. 1666), wxDataObject (p. 222)

136


CHAPTER 7 wxClipboard::wxClipboard
wxClipboard() Constructor.

wxClipboard::~wxClipboard
~wxClipboard() Destructor.

wxClipboard::AddData
bool AddData(wxDataObject* data) Call this function to add the data object to the clipboard. You may call this function repeatedly after having cleared the clipboard using wxClipboard::Clear (p. 137). After this function has been called, the clipboard owns the data, so do not delete the data explicitly. See also wxClipboard::SetData (p. 138)

wxClipboard::Clear
void Clear() Clears the global clipboard object and the system's clipboard if possible.

wxClipboard::Close
void Close() Call this function to close the clipboard, having opened it with wxClipboard::Open (p. 138).

wxClipboard::Flush
bool Flush() Flushes the clipboard: this means that the data which is currently on clipboard will stay available even after the application exits (possibly eating memory), otherwise the clipboard will be emptied on exit. Returns false if the operation is unsuccesful for any reason.

137


CHAPTER 7 wxClipboard::GetData
bool GetData(wxDataObject& data) Call this function to fill data with data on the clipboard, if available in the required format. Returns true on success.

wxClipboard::IsOpened
bool IsOpened() const Returns true if the clipboard has been opened.

wxClipboard::IsSupported
bool IsSupported(const wxDataFormat& format) Returns true if the format of the given data object is available on the clipboard.

wxClipboard::Open
bool Open() Call this function to open the clipboard before calling wxClipboard::SetData (p. 138) and wxClipboard::GetData (p. 138). Call wxClipboard::Close (p. 137) when you have finished with the clipboard. You should keep the clipboard open for only a very short time. Returns true on success. This should be tested (as in the sample shown above).

wxClipboard::SetData
bool SetData(wxDataObject* data) Call this function to set the data object to the clipboard. This function will clear all previous contents in the clipboard, so calling it several times does not make any sense. After this function has been called, the clipboard owns the data, so do not delete the data explicitly. See also wxClipboard::AddData (p. 137)

wxClipboard::UsePrimarySelection
void UsePrimarySelection(bool primary = true)

138


CHAPTER 7
On platforms supporting it (currently only GTK), selects the so called PRIMARY SELECTION as the clipboard as opposed to the normal clipboard, if primary is true.

wxCloseEvent
This event class contains information about window and session close events. The handler function for EVT_CLOSE is called when the user has tried to close a a frame or dialog box using the window manager (X) or system menu (Windows). It can also be invoked by the application itself programmatically, for example by calling the wxWindow::Close (p. 1393) function. You should check whether the application is forcing the deletion of the window using wxCloseEvent::CanVeto (p. 140). If this is false, you must destroy the window using wxWindow::Destroy (p. 1395). If the return value is true, it is up to you whether you respond by destroying the window. If you don't destroy the window, you should call wxCloseEvent::Veto (p. 141) to let the calling code know that you did not destroy the window. This allows the wxWindow::Close (p. 1393) function to return true or false depending on whether the close instruction was honoured or not. Derived from wxEvent (p. 439) Include files <wx/event.h> Event table macros To process a close event, use these event handler macros to direct input to member functions that take a wxCloseEvent argument. EVT_CLOSE(func) Process a close event, supplying the member function. This event applies to wxFrame and wxDialog classes. Process a query end session event, supplying the member function. This event applies to wxApp only. Process an end session event, supplying the member function. This event applies to wxApp only.

EVT_QUERY_END_SESSION(func)

EVT_END_SESSION(func)

See also wxWindow::Close (p. 1393), wxApp::OnQueryEndSession (p. 37), Window deletion overview (p. 1612)

139


CHAPTER 7 wxCloseEvent::wxCloseEvent
wxCloseEvent(WXTYPE commandEventType = 0, int id = 0) Constructor.

wxCloseEvent::CanVeto
bool CanVeto() Returns true if you can veto a system shutdown or a window close event. Vetoing a window close event is not possible if the calling code wishes to force the application to exit, and so this function must be called to check this.

wxCloseEvent::GetLoggingOff
bool GetLoggingOff() const Returns true if the user is logging off.

wxCloseEvent::GetSessionEnding
bool GetSessionEnding() const Returns true if the session is ending.

wxCloseEvent::GetForce
bool GetForce() const Returns true if the application wishes to force the window to close. This will shortly be obsolete, replaced by CanVeto.

wxCloseEvent::SetCanVeto
void SetCanVeto(bool canVeto) Sets the 'can veto' flag.

wxCloseEvent::SetForce
void SetForce(bool force) const Sets the 'force' flag.

140


CHAPTER 7 wxCloseEvent::SetLoggingOff
void SetLoggingOff(bool loggingOff) const Sets the 'logging off' flag.

wxCloseEvent::Veto
void Veto(bool veto = true) Call this from your event handler to veto a system shutdown or to signal to the calling application that a window close did not happen. You can only veto a shutdown if wxCloseEvent::CanVeto (p. 140) returns true.

wxCmdLineParser
wxCmdLineParser is a class for parsing command line. It has the following features: 1. 2. 3. 4. distinguishes options, switches and parameters; allows option grouping allows both short and long options automatically generates the usage message from the command line description does type checks on the options values (number, date, ...).

To use it you should follow these steps: 1. 2. 3. construct (p. 143) an object of this class giving it the command line to parse and optionally its description or use AddXXX() functions later call Parse() use Found() to retrieve the results

In the documentation below the following terminology is used: switch This is a boolean option which can be given or not, but which doesn't have any value. We use the word switch to distinguish such boolean options from more generic options like those described below. For example, -v might be a switch meaning "enable verbose mode". Option for us here is something which comes with a value 0 unlike a switch. For example, o:filename might be an option which allows to specify the name of the output file.

option

141


CHAPTER 7
parameter Derived from No base class Include files <wx/cmdline.h> Constants The structure wxCmdLineEntryDesc is used to describe the one command line switch, option or parameter. An array of such structures should be passed to SetDesc() (p. 147). Also, the meanings of parameters of the AddXXX() functions are the same as of the corresponding fields in this structure:
struct wxCmdLineEntryDesc { wxCmdLineEntryType kind; const wxChar *shortName; const wxChar *longName; const wxChar *description; wxCmdLineParamType type; int flags; };

This is a required program argument.

The type of a command line entity is in the kind field and may be one of the following constants:
enum wxCmdLineEntryType { wxCMD_LINE_SWITCH, wxCMD_LINE_OPTION, wxCMD_LINE_PARAM, wxCMD_LINE_NONE }

// use this to terminate the list

The field shortName is the usual, short, name of the switch or the option.longName is the corresponding long name or NULL if the option has no long name. Both of these fields are unused for the parameters. Both the short and long option names can contain only letters, digits and the underscores. description is used by the Usage() (p. 148) method to construct a help message explaining the syntax of the program. The possible values of type which specifies the type of the value accepted by an option or parameter are:
enum wxCmdLineParamType { wxCMD_LINE_VAL_STRING, wxCMD_LINE_VAL_NUMBER, wxCMD_LINE_VAL_DATE, wxCMD_LINE_VAL_NONE }

// default

142


CHAPTER 7
Finally, the flags field is a combination of the following bit masks:
enum { wxCMD_LINE_OPTION_MANDATORY wxCMD_LINE_PARAM_OPTIONAL wxCMD_LINE_PARAM_MULTIPLE wxCMD_LINE_OPTION_HELP wxCMD_LINE_NEEDS_SEPARATOR } = = = = = 0x01, 0x02, 0x04, 0x08, 0x10, // // // // // this option must be given the parameter may be omitted the parameter may be repeated this option is a help request must have sep before the value

Notice that by default (i.e. if flags are just 0), options are optional (sic) and each call to AddParam() (p. 148) allows one more parameter - this may be changed by giving nondefault flags to it, i.e. use wxCMD_LINE_OPTION_MANDATORY to require that the option is given and wxCMD_LINE_PARAM_OPTIONAL to make a parameter optional. Also, wxCMD_LINE_PARAM_MULTIPLE may be specified if the programs accepts a variable number of parameters - but it only can be given for the last parameter in the command line description. If you use this flag, you will probably need to use GetParamCount (p. 149) to retrieve the number of parameters effectively specified after calling Parse (p. 148). The last flag wxCMD_LINE_NEEDS_SEPARATOR can be specified to require a separator (either a colon, an equal sign or white space) between the option name and its value. By default, no separator is required. See also wxApp::argc (p. 31) and wxApp::argv (p. 32) console sample

Construction
Before Parse (p. 148) can be called, the command line parser object must have the command line to parse and also the rules saying which switches, options and parameters are valid - this is called command line description in what follows. You have complete freedom of choice as to when specify the required information, the only restriction is that it must be done before calling Parse (p. 148). To specify the command line to parse you may use either one of constructors accepting it (wxCmdLineParser(argc, argv) (p. 145) or wxCmdLineParser (p. 145) usually) or, if you use the default constructor (p. 144), you can do it later by calling SetCmdLine (p. 146). The same holds for command line description: it can be specified either in the constructor (without command line (p. 145) or together with it (p. 145)) or constructed later using either SetDesc (p. 147) or combination of AddSwitch (p. 148), AddOption (p. 148) and AddParam (p. 148) methods. Using constructors or SetDesc (p. 147) uses a (usually const static) table containing

143


CHAPTER 7
the command line description. If you want to decide which options to accept during the run-time, using one of the AddXXX() functions above might be preferable.

Customization
wxCmdLineParser has several global options which may be changed by the application. All of the functions described in this section should be called before Parse (p. 148). First global option is the support for long (also known as GNU-style) options. The long options are the ones which start with two dashes ("--") and look like this: --verbose, i.e. they generally are complete words and not some abbreviations of them. As long options are used by more and more applications, they are enabled by default, but may be disabled with DisableLongOptions (p. 147). Another global option is the set of characters which may be used to start an option (otherwise, the word on the command line is assumed to be a parameter). Under Unix, '-' is always used, but Windows has at least two common choices for this: '-' and '/'. Some programs also use '+'. The default is to use what suits most the current platform, but may be changed with SetSwitchChars (p. 146) method. Finally, SetLogo (p. 147) can be used to show some application-specific text before the explanation given by Usage (p. 148) function.

Parsing command line
After the command line description was constructed and the desired options were set, you can finally call Parse (p. 148) method. It returns 0 if the command line was correct and was parsed, -1 if the help option was specified (this is a separate case as, normally, the program will terminate after this) or a positive number if there was an error during the command line parsing. In the latter case, the appropriate error message and usage information are logged by wxCmdLineParser itself using the standard wxWindows logging functions.

Getting results
After calling Parse (p. 148) (and if it returned 0), you may access the results of parsing using one of overloaded Found()methods. For a simple switch, you will simply call Found (p. 149) to determine if the switch was given or not, for an option or a parameter, you will call a version of Found() which also returns the associated value in the provided variable. All Found() functions return true if the switch or option were found in the command line or false if they were not specified.

wxCmdLineParser::wxCmdLineParser

144


CHAPTER 7
wxCmdLineParser() Default constructor. You must use SetCmdLine (p. 146) later.

wxCmdLineParser::wxCmdLineParser
wxCmdLineParser(int argc, char** argv) Constructor specifies the command line to parse. This is the traditional (Unix) command line format. The parameters argc and argv have the same meaning as for main() function.

wxCmdLineParser::wxCmdLineParser
wxCmdLineParser(const wxString& cmdline) Constructor specifies the command line to parse in Windows format. The parameter cmdline has the same meaning as the corresponding parameter of WinMain().

wxCmdLineParser::wxCmdLineParser
wxCmdLineParser(const wxCmdLineEntryDesc* desc) Same as wxCmdLineParser (p. 144), but also specifies the command line description (p. 147).

wxCmdLineParser::wxCmdLineParser
wxCmdLineParser(const wxCmdLineEntryDesc* desc, int argc, char** argv) Same as wxCmdLineParser (p. 145), but also specifies the command line description (p. 147).

wxCmdLineParser::wxCmdLineParser
wxCmdLineParser(const wxCmdLineEntryDesc* desc, const wxString& cmdline) Same as wxCmdLineParser (p. 145), but also specifies the command line description (p. 147).

wxCmdLineParser::ConvertStringToArgs
static wxArrayString ConvertStringToArgs(const wxChar *cmdline) Breaks down the string containing the full command line in words. The words are separated by whitespace. The quotes can be used in the input string to quote the white

145


CHAPTER 7
space and the back slashes can be used to quote the quotes.

wxCmdLineParser::SetCmdLine
void SetCmdLine(int argc, char** argv) Set command line to parse after using one of the constructors which don't do it. See also wxCmdLineParser (p. 145)

wxCmdLineParser::SetCmdLine
void SetCmdLine(const wxString& cmdline) Set command line to parse after using one of the constructors which don't do it. See also wxCmdLineParser (p. 145)

wxCmdLineParser::~wxCmdLineParser
~wxCmdLineParser() Frees resources allocated by the object. NB: destructor is not virtual, don't use this class polymorphically.

wxCmdLineParser::SetSwitchChars
void SetSwitchChars(const wxString& switchChars) switchChars contains all characters with which an option or switch may start. Default is "-" for Unix, "-/" for Windows.

wxCmdLineParser::EnableLongOptions
void EnableLongOptions(bool enable = true) Enable or disable support for the long options. As long options are not (yet) POSIX-compliant, this option allows to disable them. See also Customization (p. 144) and AreLongOptionsEnabled (p. 147)

146


CHAPTER 7 wxCmdLineParser::DisableLongOptions
void DisableLongOptions() Identical to EnableLongOptions(false) (p. 146).

wxCmdLineParser::AreLongOptionsEnabled
bool AreLongOptionsEnabled() Returns true if long options are enabled, otherwise false. See also EnableLongOptions (p. 146)

wxCmdLineParser::SetLogo
void SetLogo(const wxString& logo) logo is some extra text which will be shown by Usage (p. 148) method.

wxCmdLineParser::SetDesc
void SetDesc(const wxCmdLineEntryDesc* desc) Construct the command line description Take the command line description from the wxCMD_LINE_NONE terminated table. Example of usage:
static const wxCmdLineEntryDesc cmdLineDesc[] = { { wxCMD_LINE_SWITCH, "v", "verbose", "be verbose" }, { wxCMD_LINE_SWITCH, "q", "quiet", "be quiet" }, { wxCMD_LINE_OPTION, { wxCMD_LINE_OPTION, { wxCMD_LINE_OPTION, wxCMD_LINE_VAL_NUMBER }, { wxCMD_LINE_OPTION, wxCMD_LINE_VAL_DATE }, "o", "output", "i", "input", "s", "size", "d", "date", "output file" }, "input dir" }, "output block size", "output file date",

{ wxCMD_LINE_PARAM, NULL, NULL, "input file", wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_MULTIPLE }, { wxCMD_LINE_NONE } }; wxCmdLineParser parser; parser.SetDesc(cmdLineDesc);

147


CHAPTER 7 wxCmdLineParser::AddSwitch
void AddSwitch(const wxString& name, const wxString& lng = wxEmptyString, const wxString& desc = wxEmptyString, int flags = 0) Add a switch name with an optional long name lng (no long name if it is empty, which is default), description desc and flags flags to the command line description.

wxCmdLineParser::AddOption
void AddOption(const wxString& name, const wxString& lng = wxEmptyString, const wxString& desc = wxEmptyString, wxCmdLineParamType type = wxCMD_LINE_VAL_STRING, int flags = 0) Add an option name with an optional long name lng (no long name if it is empty, which is default) taking a value of the given type (string by default) to the command line description.

wxCmdLineParser::AddParam
void AddParam(const wxString& desc = wxEmptyString, wxCmdLineParamType type = wxCMD_LINE_VAL_STRING, int flags = 0) Add a parameter of the given type to the command line description.

wxCmdLineParser::Parse
int Parse(bool giveUsage = true) Parse the command line, return 0 if ok, -1 if "-h" or "--help" option was encountered and the help message was given or a positive value if a syntax error occured. Parameters giveUsage If true (default), the usage message is given if a syntax error was encountered while parsing the command line or if help was requested. If false, only error messages about possible syntax errors are given, use Usage (p. 148) to show the usage message from the caller if needed.

wxCmdLineParser::Usage
void Usage() Give the standard usage message describing all program options. It will use the options and parameters descriptions specified earlier, so the resulting message will not be helpful to the user unless the descriptions were indeed specified.

148


CHAPTER 7
See also SetLogo (p. 147)

wxCmdLineParser::Found
bool Found(const wxString& name) const Returns true if the given switch was found, false otherwise.

wxCmdLineParser::Found
bool Found(const wxString& name, wxString* value) const Returns true if an option taking a string value was found and stores the value in the provided pointer (which should not be NULL).

wxCmdLineParser::Found
bool Found(const wxString& name, long* value) const Returns true if an option taking an integer value was found and stores the value in the provided pointer (which should not be NULL).

wxCmdLineParser::Found
bool Found(const wxString& name, wxDateTime* value) const Returns true if an option taking a date value was found and stores the value in the provided pointer (which should not be NULL).

wxCmdLineParser::GetParamCount
size_t GetParamCount() const Returns the number of parameters found. This function makes sense mostly if you had used wxCMD_LINE_PARAM_MULTIPLE flag.

wxCmdLineParser::GetParam
wxString GetParam(size_t n = 0u) const Returns the value of Nth parameter (as string only for now). See also

149


CHAPTER 7
GetParamCount (p. 149)

wxColour
A colour is an object representing a combination of Red, Green, and Blue (RGB) intensity values, and is used to determine drawing colours. See the entry for wxColourDatabase (p. 155) for how a pointer to a predefined, named colour may be returned instead of creating a new colour. Valid RGB values are in the range 0 to 255. You can retrieve the current system colour settings with wxSystemSettings (p. 1229). Derived from wxObject (p. 954) Include files <wx/colour.h> Predefined objects Objects: wxNullColour Pointers: wxBLACK wxWHITE wxRED wxBLUE wxGREEN wxCYAN wxLIGHT_GREY See also wxColourDatabase (p. 155), wxPen (p. 976), wxBrush (p. 90), wxColourDialog (p. 156), wxSystemSettings (p. 1229)

wxColour::wxColour
wxColour() Default constructor. wxColour(const unsigned char red, const unsigned char green, const unsigned char blue)

150


CHAPTER 7
Constructs a colour from red, green and blue values. wxColour(const wxString& colourNname) Constructs a colour object using a colour name listed in wxTheColourDatabase. wxColour(const wxColour& colour) Copy constructor. Parameters red The red value. green The green value. blue The blue value. colourName The colour name. colour The colour to copy. See also wxColourDatabase (p. 155) wxPython note: Constructors supported by wxPython are: wxColour(red=0, green=0, blue=0) wxNamedColour(name)

wxColour::Blue
unsigned char Blue() const Returns the blue intensity.

wxColour::GetPixel
long GetPixel() const

151


CHAPTER 7
Returns a pixel value which is platform-dependent. On Windows, a COLORREF is returned. On X, an allocated pixel value is returned. -1 is returned if the pixel is invalid (on X, unallocated).

wxColour::Green
unsigned char Green() const Returns the green intensity.

wxColour::Ok
bool Ok() const Returns true if the colour object is valid (the colour has been initialised with RGB values).

wxColour::Red
unsigned char Red() const Returns the red intensity.

wxColour::Set
void Set(const unsigned char red, const unsigned char green, const unsigned char blue) Sets the RGB intensity values.

wxColour::operator =
wxColour& operator =(const wxColour& colour) Assignment operator, taking another colour object. wxColour& operator =(const wxString& colourName) Assignment operator, using a colour name to be found in the colour database. See also wxColourDatabase (p. 155)

wxColour::operator ==

152


CHAPTER 7
bool operator ==(const wxColour& colour) Tests the equality of two colours by comparing individual red, green blue colours.

wxColour::operator !=
bool operator !=(const wxColour& colour) Tests the inequality of two colours by comparing individual red, green blue colours.

wxColourData
This class holds a variety of information related to colour dialogs. Derived from wxObject (p. 954) Include files <wx/cmndata.h> See also wxColour (p. 150), wxColourDialog (p. 156), wxColourDialog overview (p. 1648)

wxColourData::wxColourData
wxColourData() Constructor. Initializes the custom colours to white, the data colour setting to black, and the choose full setting to true.

wxColourData::~wxColourData
~wxColourData() Destructor.

wxColourData::GetChooseFull
bool GetChooseFull() const Under Windows, determines whether the Windows colour dialog will display the full dialog with custom colour selection controls. Has no meaning under other platforms.

153


CHAPTER 7
The default value is true.

wxColourData::GetColour
wxColour& GetColour() const Gets the current colour associated with the colour dialog. The default colour is black.

wxColourData::GetCustomColour
wxColour& GetCustomColour(int i) const Gets the ith custom colour associated with the colour dialog. i should be an integer between 0 and 15. The default custom colours are all white.

wxColourData::SetChooseFull
void SetChooseFull(const bool flag) Under Windows, tells the Windows colour dialog to display the full dialog with custom colour selection controls. Under other platforms, has no effect. The default value is true.

wxColourData::SetColour
void SetColour(const wxColour& colour) Sets the default colour for the colour dialog. The default colour is black.

wxColourData::SetCustomColour
void SetCustomColour(int i, const wxColour& colour) Sets the ith custom colour for the colour dialog. i should be an integer between 0 and 15. The default custom colours are all white.

wxColourData::operator =

154


CHAPTER 7
void operator =(const wxColourData& data) Assignment operator for the colour data.

wxColourDatabase
wxWindows maintains a database of standard RGB colours for a predefined set of named colours (such as "BLACK'', "LIGHT GREY''). The application may add to this set if desired by using AddColour (p. 156) and may use it to look up colours by names using Find (p. 156) or find the names for the standard colour suing FindName (p. 156). There is one predefined instance of this class called wxTheColourDatabase. Derived from None Include files <wx/gdicmn.h> Remarks The standard database contains at least the following colours: AQUAMARINE, BLACK, BLUE, BLUE VIOLET, BROWN, CADET BLUE, CORAL, CORNFLOWER BLUE, CYAN, DARK GREY, DARK GREEN, DARK OLIVE GREEN, DARK ORCHID, DARK SLATE BLUE, DARK SLATE GREY DARK TURQUOISE, DIM GREY, FIREBRICK, FOREST GREEN, GOLD, GOLDENROD, GREY, GREEN, GREEN YELLOW, INDIAN RED, KHAKI, LIGHT BLUE, LIGHT GREY, LIGHT STEEL BLUE, LIME GREEN, MAGENTA, MAROON, MEDIUM AQUAMARINE, MEDIUM BLUE, MEDIUM FOREST GREEN, MEDIUM GOLDENROD, MEDIUM ORCHID, MEDIUM SEA GREEN, MEDIUM SLATE BLUE, MEDIUM SPRING GREEN, MEDIUM TURQUOISE, MEDIUM VIOLET RED, MIDNIGHT BLUE, NAVY, ORANGE, ORANGE RED, ORCHID, PALE GREEN, PINK, PLUM, PURPLE, RED, SALMON, SEA GREEN, SIENNA, SKY BLUE, SLATE BLUE, SPRING GREEN, STEEL BLUE, TAN, THISTLE, TURQUOISE, VIOLET, VIOLET RED, WHEAT, WHITE, YELLOW, YELLOW GREEN. See also wxColour (p. 150)

wxColourDatabase::wxColourDatabase
wxColourDatabase() Constructs the colour database. It will be initialized at the first use.

155


CHAPTER 7 wxColourDatabase::AddColour
void AddColour(const wxString& colourName, const wxColour&colour) void AddColour(const wxString& colourName, wxColour* colour) Adds a colour to the database. If a colour with the same name already exists, it is replaced. Please note that the overload taking a pointer is deprecated and will be removed in the next wxWindows version, please don't use it.

wxColourDatabase::Find
wxColour FindColour(const wxString& colourName) Finds a colour given the name. Returns an invalid colour object (that is, such that its Ok() (p. 152) method returns false) if the colour wasn't found in the database.

wxColourDatabase::FindColour
wxColour* FindColour(const wxString& colourName) Finds a colour given the name. Returns NULL if not found or a pointer which must be deleted by the caller otherwise. Please note that this method is deprecated and will be removed in the next wxWindows version, please use Find (p. 156) instead of it.

wxColourDatabase::FindName
wxString FindName(const wxColour& colour) const Finds a colour name given the colour. Returns an empty string if the colour is not found in the database.

wxColourDialog
This class represents the colour chooser dialog. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files

156


CHAPTER 7
<wx/colordlg.h> See also wxColourDialog Overview (p. 1648), wxColour (p. 150), wxColourData (p. 153), wxGetColourFromUser (p. 1491)

wxColourDialog::wxColourDialog
wxColourDialog(wxWindow* parent, wxColourData* data = NULL) Constructor. Pass a parent window, and optionally a pointer to a block of colour data, which will be copied to the colour dialog's colour data. See also wxColourData (p. 153)

wxColourDialog::~wxColourDialog
~wxColourDialog() Destructor.

wxColourDialog::Create
bool Create(wxWindow* parent, wxColourData* data = NULL) Same as constructor (p. 157).

wxColourDialog::GetColourData
wxColourData& GetColourData() Returns the colour data (p. 153) associated with the colour dialog.

wxColourDialog::ShowModal
int ShowModal() Shows the dialog, returning wxID_OK if the user pressed OK, and wxOK_CANCEL otherwise.

157


CHAPTER 7

wxComboBox
A combobox is like a combination of an edit control and a listbox. It can be displayed as static list with editable or read-only text field; or a drop-down list with text field; or a dropdown list without a text field. A combobox permits a single selection only. Combobox items are numbered from zero. Derived from wxControlWithItems (p. 199) wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/combobox.h> Window styles wxCB_SIMPLE wxCB_DROPDOWN wxCB_READONLY Creates a combobox with a permanently displayed list. Windows only. Creates a combobox with a drop-down list. Same as wxCB_DROPDOWN but only the strings specified as the combobox choices can be selected, it is impossible to select (even from a program) a string which is not in the choices list. Sorts the entries in the list alphabetically.

wxCB_SORT

See also window styles overview (p. 1611). Event handling EVT_COMBOBOX(id, func) Process a wxEVT_COMMAND_COMBOBOX_SELECTE D event, when an item on the list is selected. Process a wxEVT_COMMAND_TEXT_UPDATED event, when the combobox text changes.

EVT_TEXT(id, func)

See also wxListBox (p. 793), wxTextCtrl (p. 1248), wxChoice (p. 127), wxCommandEvent (p. 164)

158


CHAPTER 7 wxComboBox::wxComboBox
wxComboBox() Default constructor. wxComboBox(wxWindow* parent, wxWindowID id, const wxString& value = "", const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, int n, const wxString choices[], long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "comboBox") wxComboBox(wxWindow* parent, wxWindowID id, const wxString& value, const wxPoint& pos, const wxSize& size, const wxArrayString& choices, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "comboBox") Constructor, creating and showing a combobox. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. value Initial selection string. An empty string indicates no selection. pos Window position. size Window size. If the default size (-1, -1) is specified then the window is sized appropriately. n Number of strings with which to initialise the control. choices An array of strings with which to initialise the control. style Window style. See wxComboBox (p. 158). validator Window validator.

159


CHAPTER 7
name Window name. See also wxComboBox::Create (p. 160), wxValidator (p. 1358) wxPython note: The wxComboBox constructor in wxPython reduces the nand choices arguments are to a single argument, which is a list of strings. wxPerl note: In wxPerl there is just an array reference in place of nand choices.

wxComboBox::~wxComboBox
~wxComboBox() Destructor, destroying the combobox.

wxComboBox::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& value = "", const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, int n, const wxString choices[], long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "comboBox") bool Create(wxWindow* parent, wxWindowID id, const wxString& value, const wxPoint& pos, const wxSize& size, const wxArrayString& choices, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "comboBox") Creates the combobox for two-step construction. Derived classes should call or replace this function. See wxComboBox::wxComboBox (p. 159) for further details.

wxComboBox::Copy
void Copy() Copies the selected text to the clipboard.

wxComboBox::Cut
void Cut() Copies the selected text to the clipboard and removes the selection.

wxComboBox::GetInsertionPoint

160


CHAPTER 7
long GetInsertionPoint() const Returns the insertion point for the combobox's text field.

wxComboBox::GetLastPosition
long GetLastPosition() const Returns the last position in the combobox text field.

wxComboBox::GetValue
wxString GetValue() const Returns the current value in the combobox text field.

wxComboBox::Paste
void Paste() Pastes text from the clipboard to the text field.

wxComboBox::Replace
void Replace(long from, long to, const wxString& text) Replaces the text between two positions with the given text, in the combobox text field. Parameters from The first position. to The second position. text The text to insert.

wxComboBox::Remove
void Remove(long from, long to) Removes the text between the two positions in the combobox text field.

161


CHAPTER 7
Parameters from The first position. to The last position.

wxComboBox::SetInsertionPoint
void SetInsertionPoint(long pos) Sets the insertion point in the combobox text field. Parameters pos The new insertion point.

wxComboBox::SetInsertionPointEnd
void SetInsertionPointEnd() Sets the insertion point at the end of the combobox text field.

wxComboBox::SetSelection
void SetSelection(long from, long to) Selects the text between the two positions, in the combobox text field. Parameters from The first position. to The second position. wxPython note: This method is called SetMark in wxPython, SetSelectionname is kept for wxControlWithItems::SetSelection (p. 204).

wxComboBox::SetValue
void SetValue(const wxString& text)

162


CHAPTER 7
Sets the text for the combobox text field. NB: For a combobox with wxCB_READONLY style the string must be in the combobox choices list, otherwise the call to SetValue() is ignored. Parameters text The text to set.

wxCommand
wxCommand is a base class for modelling an application command, which is an action usually performed by selecting a menu item, pressing a toolbar button or any other means provided by the application to change the data or view. Derived from wxObject (p. 954) Include files <wx/cmdproc.h> See also Overview (p. 1655)

wxCommand::wxCommand
wxCommand(bool canUndo = false, const wxString& name = NULL) Constructor. wxCommand is an abstract class, so you will need to derive a new class and call this constructor from your own constructor. canUndo tells the command processor whether this command is undo-able. You can achieve the same functionality by overriding the CanUndo member function (if for example the criteria for undoability is context-dependent). name must be supplied for the command processor to display the command name in the application's edit menu.

wxCommand::~wxCommand
~wxCommand() Destructor.

163


CHAPTER 7 wxCommand::CanUndo
bool CanUndo() Returns true if the command can be undone, false otherwise.

wxCommand::Do
bool Do() Override this member function to execute the appropriate action when called. Return true to indicate that the action has taken place, false otherwise. Returning false will indicate to the command processor that the action is not undoable and should not be added to the command history.

wxCommand::GetName
wxString GetName() Returns the command name.

wxCommand::Undo
bool Undo() Override this member function to un-execute a previous Do. Return true to indicate that the action has taken place, false otherwise. Returning false will indicate to the command processor that the action is not redoable and no change should be made to the command history. How you implement this command is totally application dependent, but typical strategies include:  Perform an inverse operation on the last modified piece of data in the document. When redone, a copy of data stored in command is pasted back or some operation reapplied. This relies on the fact that you know the ordering of Undos; the user can never Undo at an arbitrary position in the command history. Restore the entire document state (perhaps using document transactioning). Potentially very inefficient, but possibly easier to code if the user interface and data are complex, and an 'inverse execute' operation is hard to write.



The docview sample uses the first method, to remove or restore segments in the drawing.

wxCommandEvent
This event class contains information about command events, which originate from a

164


CHAPTER 7
variety of simple controls. More complex controls, such as wxTreeCtrl (p. 1327), have separate command event classes. Derived from wxEvent (p. 439) Include files <wx/event.h> Event table macros To process a menu command event, use these event handler macros to direct input to member functions that take a wxCommandEvent argument. EVT_COMMAND(id, event, func) Process a command, supplying the window identifier, command event identifier, and member function.

EVT_COMMAND_RANGE(id1, id2, event, func) Process a command for a range of window identifiers, supplying the minimum and maximum window identifiers, command event identifier, and member function. EVT_BUTTON(id, func) Process a wxEVT_COMMAND_BUTTON_CLICKED command, which is generated by a wxButton control. Process a wxEVT_COMMAND_CHECKBOX_CLICKED command, which is generated by a wxCheckBox control. Process a wxEVT_COMMAND_CHOICE_SELECTED command, which is generated by a wxChoice control. Process a wxEVT_COMMAND_LISTBOX_SELECTED command, which is generated by a wxListBox control. Process a wxEVT_COMMAND_LISTBOX_DOUBLECLIC KED command, which is generated by a wxListBox control. Process a wxEVT_COMMAND_TEXT_UPDATED command, which is generated by a wxTextCtrl control.

EVT_CHECKBOX(id, func)

EVT_CHOICE(id, func)

EVT_LISTBOX(id, func)

EVT_LISTBOX_DCLICK(id, func)

EVT_TEXT(id, func)

165


CHAPTER 7
EVT_TEXT_ENTER(id, func) Process a wxEVT_COMMAND_TEXT_ENTER command, which is generated by a wxTextCtrl control. Note that you must use wxTE_PROCESS_ENTER flag when creating the control if you want it to generate such events. Process a wxEVT_COMMAND_TEXT_MAXLEN command, which is generated by a wxTextCtrl control when the user tries to enter more characters into it than the limit previously set with SetMaxLength (p. 1263). Process a wxEVT_COMMAND_MENU_SELECTED command, which is generated by a menu item. Process a wxEVT_COMMAND_MENU_RANGE command, which is generated by a range of menu items. Process the event generated when the user has requested a popup menu to appear by pressing a special keyboard key (under Windows) or by right clicking the mouse. Process a wxEVT_COMMAND_SLIDER_UPDATED command, which is generated by a wxSlider control. Process a wxEVT_COMMAND_RADIOBOX_SELECTED command, which is generated by a wxRadioBox control. Process a wxEVT_COMMAND_RADIOBUTTON_SELEC TED command, which is generated by a wxRadioButton control. Process a wxEVT_COMMAND_SCROLLBAR_UPDATED command, which is generated by a wxScrollBar control. This is provided for compatibility only; more specific scrollbar event macros should be used instead (see wxScrollEvent (p. 1094)). Process a wxEVT_COMMAND_COMBOBOX_SELECTE D command, which is generated by a

EVT_TEXT_MAXLEN(id, func)

EVT_MENU(id, func)

EVT_MENU_RANGE(id1, id2, func)

EVT_CONTEXT_MENU(func)

EVT_SLIDER(id, func)

EVT_RADIOBOX(id, func)

EVT_RADIOBUTTON(id, func)

EVT_SCROLLBAR(id, func)

EVT_COMBOBOX(id, func)

166


CHAPTER 7
wxComboBox control. EVT_TOOL(id, func) Process a wxEVT_COMMAND_TOOL_CLICKED event (a synonym for wxEVT_COMMAND_MENU_SELECTED). Pass the id of the tool. Process a wxEVT_COMMAND_TOOL_CLICKED event for a range of identifiers. Pass the ids of the tools. Process a wxEVT_COMMAND_TOOL_RCLICKED event. Pass the id of the tool.

EVT_TOOL_RANGE(id1, id2, func)

EVT_TOOL_RCLICKED(id, func)

EVT_TOOL_RCLICKED_RANGE(id1, id2, func) Process a wxEVT_COMMAND_TOOL_RCLICKED event for a range of ids. Pass the ids of the tools. EVT_TOOL_ENTER(id, func) Process a wxEVT_COMMAND_TOOL_ENTER event. Pass the id of the toolbar itself. The value of wxCommandEvent::GetSelection is the tool id, or -1 if the mouse cursor has moved off a tool.

EVT_COMMAND_LEFT_CLICK(id, func) Process a wxEVT_COMMAND_LEFT_CLICK command, which is generated by a control (Windows 95 and NT only). EVT_COMMAND_LEFT_DCLICK(id, func) Process a wxEVT_COMMAND_LEFT_DCLICK command, which is generated by a control (Windows 95 and NT only). EVT_COMMAND_RIGHT_CLICK(id, func) Process a wxEVT_COMMAND_RIGHT_CLICK command, which is generated by a control (Windows 95 and NT only). EVT_COMMAND_SET_FOCUS(id, func) Process a wxEVT_COMMAND_SET_FOCUS command, which is generated by a control (Windows 95 and NT only). EVT_COMMAND_KILL_FOCUS(id, func) Process a wxEVT_COMMAND_KILL_FOCUS command, which is generated by a control (Windows 95 and NT only). EVT_COMMAND_ENTER(id, func) Process a wxEVT_COMMAND_ENTER

167


CHAPTER 7
command, which is generated by a control.

wxCommandEvent::m_clientData
void* m_clientData Contains a pointer to client data for listboxes and choices, if the event was a selection. Beware, this is not implemented anyway...

wxCommandEvent::m_commandInt
int m_commandInt Contains an integer identifier corresponding to a listbox, choice or radiobox selection (only if the event was a selection, not a deselection), or a boolean value representing the value of a checkbox.

wxCommandEvent::m_commandString
wxString m_commandString Contains a string corresponding to a listbox or choice selection.

wxCommandEvent::m_extraLong
long m_extraLong Extra information. If the event comes from a listbox selection, it is a boolean determining whether the event was a selection (true) or a deselection (false). A listbox deselection only occurs for multiple-selection boxes, and in this case the index and string values are indeterminate and the listbox must be examined by the application.

wxCommandEvent::wxCommandEvent
wxCommandEvent(WXTYPE commandEventType = 0, int id = 0) Constructor.

wxCommandEvent::Checked
bool Checked() const Deprecated, use IsChecked (p. 169) instead.

168


CHAPTER 7 wxCommandEvent::GetClientData
void* GetClientData() Returns client data pointer for a listbox or choice selection event (not valid for a deselection).

wxCommandEvent::GetExtraLong
long GetExtraLong() Returns the m_extraLong member.

wxCommandEvent::GetInt
int GetInt() Returns the m_commandInt member.

wxCommandEvent::GetSelection
int GetSelection() Returns item index for a listbox or choice selection event (not valid for a deselection).

wxCommandEvent::GetString
wxString GetString() Returns item string for a listbox or choice selection event (not valid for a deselection).

wxCommandEvent::IsChecked
bool IsChecked() const This method can be used with checkbox and menu events: for the checkboxes, the method returns true for a selection event and false for a deselection one. For the menu events, this method indicates if the menu item just has become checked or unchecked (and thus only makes sense for checkable menu items).

wxCommandEvent::IsSelection
bool IsSelection() For a listbox or choice event, returns true if it is a selection, false if it is a deselection.

169


CHAPTER 7 wxCommandEvent::SetClientData
void SetClientData(void* clientData) Sets the client data for this event.

wxCommandEvent::SetExtraLong
void SetExtraLong(int extraLong) Sets the m_extraLong member.

wxCommandEvent::SetInt
void SetInt(int intCommand) Sets the m_commandInt member.

wxCommandEvent::SetString
void SetString(const wxString& string) Sets the m_commandString member.

wxCommandProcessor
wxCommandProcessor is a class that maintains a history of wxCommands, with undo/redo functionality built-in. Derive a new class from this if you want different behaviour. Derived from wxObject (p. 954) Include files <wx/cmdproc.h> See also wxCommandProcessor overview (p. 1656), wxCommand (p. 163)

wxCommandProcessor::wxCommandProcessor
wxCommandProcessor(int maxCommands = -1)

170


CHAPTER 7
Constructor. maxCommands may be set to a positive integer to limit the number of commands stored to it, otherwise (and by default) the list of commands can grow arbitrarily.

wxCommandProcessor::~wxCommandProcessor
~wxCommandProcessor() Destructor.

wxCommandProcessor::CanUndo
virtual bool CanUndo() Returns true if the currently-active command can be undone, false otherwise.

wxCommandProcessor::ClearCommands
virtual void ClearCommands() Deletes all the commands in the list and sets the current command pointer to NULL.

wxCommandProcessor::Redo
virtual bool Redo() Executes (redoes) the current command (the command that has just been undone if any).

wxCommandProcessor::GetCommands
wxList& GetCommands() const Returns the list of commands.

wxCommandProcessor::GetMaxCommands
int GetMaxCommands() const Returns the maximum number of commands that the command processor stores.

wxCommandProcessor::GetEditMenu
wxMenu* GetEditMenu() const

171


CHAPTER 7
Returns the edit menu associated with the command processor.

wxCommandProcessor::GetRedoAccelerator
const wxString& GetRedoAccelerator() const Returns the string that will be appended to the Redo menu item.

wxCommandProcessor::GetRedoMenuLabel
wxString GetRedoMenuLabel() const Returns the string that will be shown for the redo menu item.

wxCommandProcessor::GetUndoAccelerator
const wxString& GetUndoAccelerator() const Returns the string that will be appended to the Undo menu item.

wxCommandProcessor::GetUndoMenuLabel
wxString GetUndoMenuLabel() const Returns the string that will be shown for the undo menu item.

wxCommandProcessor::Initialize
virtual void Initialize() Initializes the command processor, setting the current command to the last in the list (if any), and updating the edit menu (if one has been specified).

wxCommandProcessor::SetEditMenu
void SetEditMenu(wxMenu* menu) Tells the command processor to update the Undo and Redo items on this menu as appropriate. Set this to NULL if the menu is about to be destroyed and command operations may still be performed, or the command processor may try to access an invalid pointer.

wxCommandProcessor::SetMenuStrings
void SetMenuStrings()

172


CHAPTER 7
Sets the menu labels according to the currently set menu and the current command state.

wxCommandProcessor::SetRedoAccelerator
void SetRedoAccelerator(const wxString&accel) Sets the string that will be appended to the Redo menu item.

wxCommandProcessor::SetUndoAccelerator
void SetUndoAccelerator(const wxString&accel) Sets the string that will be appended to the Undo menu item.

wxCommandProcessor::Submit
virtual bool Submit(wxCommand *command, bool storeIt = true) Submits a new command to the command processor. The command processor calls wxCommand::Do to execute the command; if it succeeds, the command is stored in the history list, and the associated edit menu (if any) updated appropriately. If it fails, the command is deleted immediately. Once Submit has been called, the passed command should not be deleted directly by the application. storeIt indicates whether the successful command should be stored in the history list.

wxCommandProcessor::Undo
virtual bool Undo() Undoes the command just executed.

wxCondition
wxCondition variables correspond to pthread conditions or to Win32 event objects. They may be used in a multithreaded application to wait until the given condition becomes true which happens when the condition becomes signaled. For example, if a worker thread is doing some long task and another thread has to wait until it is finished, the latter thread will wait on the condition object and the worker thread will signal it on exit (this example is not perfect because in this particular case it would be much better to just Wait() (p. 1291) for the worker thread, but if there are several worker threads it already makes much more sense). Note that a call to Signal() (p. 176) may happen before the other thread calls Wait() (p. 176) and, just as with the pthread conditions, the signal is then lost and so if you want to

173


CHAPTER 7
be sure that you don't miss it you must keep the mutex associated with the condition initially locked and lock it again before calling Signal() (p. 176). Of course, this means that this call is going to block until Wait() (p. 176) is called by another thread. Example This example shows how a main thread may launch a worker thread which starts running and then waits until the main thread signals it to continue:
class MySignallingThread : public wxThread { public: MySignallingThread(wxMutex *mutex, wxCondition *condition) { m_mutex = mutex; m_condition = condition; Create(); } virtual ExitCode Entry() { ... do our job ... // tell the other(s) thread(s) that we're about to terminate: we must // lock the mutex first or we might signal the condition before the // waiting threads start waiting on it! wxMutexLocker lock(m_mutex); m_condition.Broadcast(); // same as Signal() here -- one waiter only return 0; } private: wxCondition *m_condition; wxMutex *m_mutex; }; int main() { wxMutex mutex; wxCondition condition(mutex); // the mutex should be initially locked mutex.Lock(); // create and run the thread but notice that it won't be able to // exit (and signal its exit) before we unlock the mutex below MySignallingThread *thread = new MySignallingThread(&mutex, &condition); thread->Run(); // wait for the thread termination: Wait() atomically unlocks the mutex // which allows the thread to continue and starts waiting condition.Wait(); // now we can exit return 0; }

Of course, here it would be much better to simply use a joinable thread and call wxThread::Wait (p. 1291) on it, but this example does illustrate the importance of

174


CHAPTER 7
properly locking the mutex when using wxCondition. Constants The following return codes are returned by wxCondition member functions:
enum wxCondError { wxCOND_NO_ERROR = 0, wxCOND_INVALID, wxCOND_TIMEOUT, wxCOND_MISC_ERROR };

// // // //

successful completion object hasn't been initialized successfully WaitTimeout() has timed out some other error

Derived from None. Include files <wx/thread.h> See also wxThread (p. 1284), wxMutex (p. 938)

wxCondition::wxCondition
wxCondition(wxMutex& mutex) Default and only constructor. The mutex must be locked by the caller before calling Wait (p. 176) function. Use IsOk (p. 176) to check if the object was successfully intiialized.

wxCondition::~wxCondition
~wxCondition() Destroys the wxCondition object. The destructor is not virtual so this class should not be used polymorphically.

wxCondition::Broadcast
void Broadcast() Broadcasts to all waiting threads, waking all of them up. Note that this method may be called whether the mutex associated with this condition is locked or not. See also

175


CHAPTER 7
wxCondition::Signal (p. 176)

wxCondition::IsOk
bool IsOk() const Returns true if the object had been initialized successfully, false if an error occured.

wxCondition::Signal
void Signal() Signals the object waking up at most one thread. If several threads are waiting on the same condition, the exact thread which is woken up is undefined. If no threads are waiting, the signal is lost and the condition would have to be signalled again to wake up any thread which may start waiting on it later. Note that this method may be called whether the mutex associated with this condition is locked or not. See also wxCondition::Broadcast (p. 175)

wxCondition::Wait
wxCondError Wait() Waits until the condition is signalled. This method atomically releases the lock on the mutex associated with this condition (this is why it must be locked prior to calling Wait) and puts the thread to sleep until Signal (p. 176) or Broadcast (p. 175) is called. Note that even if Signal (p. 176) had been called before Wait without waking up any thread, the thread would still wait for another one and so it is important to ensure that the condition will be signalled after Wait or the thread may sleep forever. Return value Returns wxCOND_NO_ERROR on success, another value if an error occured. See also WaitTimeout (p. 176)

wxCondition::WaitTimeout
wxCondError Wait(unsigned long milliseconds)

176


CHAPTER 7
Waits until the condition is signalled or the timeout has elapsed. This method is identical to Wait (p. 176) except that it returns, with the return code of wxCOND_TIMEOUT as soon as the given timeout expires. Parameters milliseconds Timeout in milliseconds Return value Returns wxCOND_NO_ERROR if the condition was signalled, wxCOND_TIMEOUT if the timeout elapsed ebfore this happened or another error code from wxCondError enum.

wxConfigBase
wxConfigBase class defines the basic interface of all config classes. It can not be used by itself (it is an abstract base class) and you will always use one of its derivations: wxIniConfig, wxFileConfig, wxRegConfig or any other. However, usually you don't even need to know the precise nature of the class you're working with but you would just use the wxConfigBase methods. This allows you to write the same code regardless of whether you're working with the registry under Win32 or text-based config files under Unix (or even Windows 3.1 .INI files if you're really unlucky). To make writing the portable code even easier, wxWindows provides a typedef wxConfig which is mapped onto the native wxConfigBase implementation on the given platform: i.e. wxRegConfig under Win32, wxIniConfig under Win16 and wxFileConfig otherwise. See config overview (p. 1600) for the descriptions of all features of this class. It is highly recommended to use static functions Get() and/or Set(), so please have a look at them. (p. 178) Derived from No base class Include files <wx/config.h> (to let wxWindows choose a wxConfig class for your platform) <wx/confbase.h> (base config class) <wx/fileconf.h> (wxFileConfig class) <wx/msw/regconf.h> (wxRegConfig class) <wx/msw/iniconf.h> (wxIniConfig class) Example Here is how you would typically use this class:
// using wxConfig instead of writing wxFileConfig or wxRegConfig

177


CHAPTER 7
enhances // portability of the code wxConfig *config = new wxConfig("MyAppName"); wxString str; if ( config->Read("LastPrompt", &str) ) { // last prompt was found in the config file/registry and its value is now // in str ... } else { // no last prompt... } // another example: using default values and the full path instead of just // key name: if the key is not found , the value 17 is returned long value = config->Read("/LastRun/CalculatedValues/MaxValue", 17); ... ... ... // at the end of the program we would save everything back config->Write("LastPrompt", str); config->Write("/LastRun/CalculatedValues/MaxValue", value); // the changes will be written back automatically delete config;

This basic example, of course, doesn't show all wxConfig features, such as enumerating, testing for existence and deleting the entries and groups of entries in the config file, its abilities to automatically store the default values or expand the environment variables on the fly. However, the main idea is that using this class is easy and that it should normally do what you expect it to. NB: in the documentation of this class, the words "config file" also mean "registry hive" for wxRegConfig and, generally speaking, might mean any physical storage where a wxConfigBase-derived class stores its data.

Static functions
These functions deal with the "default" config object. Although its usage is not at all mandatory it may be convenient to use a global config object instead of creating and deleting the local config objects each time you need one (especially because creating a wxFileConfig object might be a time consuming operation). In this case, you may create this global config object in the very start of the program and Set() it as the default. Then, from anywhere in your program, you may access it using the Get() function. Note that you must delete this object (usually in wxApp::OnExit (p. 36)) in order to avoid memory leaks, wxWindows won't do it automatically. As it happens, you may even further simplify the procedure described above: you may forget about calling Set(). W hen Get() is called and there is no current object, it will create one using Create() function. To disable this behaviour DontCreateOnDemand() is provided. Note: You should use either Set() or Get() because wxWindows library itself would take advantage of it and could save various information in it. For example wxFontMapper (p.

178


CHAPTER 7
526) or Unix version of wxFileDialog (p. 466) have ability to use wxConfig class. Set (p. 189) Get (p. 185) Create (p. 184) DontCreateOnDemand (p. 184)

Constructor and destructor
wxConfigBase (p. 182) ~wxConfigBase (p. 184)

Path management
As explained in config overview (p. 1600), the config classes support a file system-like hierarchy of keys (files) and groups (directories). As in the file system case, to specify a key in the config class you must use a path to it. Config classes also support the notion of the current group, which makes it possible to use the relative paths. To clarify all this, here is an example (it is only for the sake of demonstration, it doesn't do anything sensible!):
wxConfig *config = new wxConfig("FooBarApp"); // right now the current path is '/' conf->Write("RootEntry", 1); // go to some other place: if the group(s) don't exist, they will be created conf->SetPath("/Group/Subgroup"); // create an entry in subgroup conf->Write("SubgroupEntry", 3); // '..' is understood conf->Write("../GroupEntry", 2); conf->SetPath(".."); wxASSERT( con- >Read("Subgroup/SubgroupEntry", 0l) == 3 ); f // use absolute path: it is allowed, too wxASSERT( conf->Read("/RootEntry", 0l) == 1 );

Warning: it is probably a good idea to always restore the path to its old value on function exit:
void foo(wxConfigBase *config) { wxString strOldPath = config->GetPath(); config >SetPath("/Foo/Data"); ... config >SetPath(strOldPath); }

because otherwise the assert in the following example will surely fail (we suppose here that foo() function is the same as above except that it doesn't save and restore the path):

179


CHAPTER 7
void bar(wxConfigBase *config) { config >Write("Test", 17); foo(config); // we're reading "/Foo/Data/Test" here! -1 will probably be returned... wxASSERT( config->Read("Test", -1) == 17 ); }

Finally, the path separator in wxConfigBase and derived classes is always '/', regardless of the platform (i.e. it is not '\\' under Windows). SetPath (p. 190) GetPath (p. 187)

Enumeration
The functions in this section allow to enumerate all entries and groups in the config file. All functions here return false when there are no more items. You must pass the same index to GetNext and GetFirst (don't modify it). Please note that it is not the index of the current item (you will have some great surprises with wxRegConfig if you assume this) and you shouldn't even look at it: it is just a "cookie" which stores the state of the enumeration. It can't be stored inside the class because it would prevent you from running several enumerations simultaneously, that's why you must pass it explicitly. Having said all this, enumerating the config entries/groups is very simple:
wxArrayString aNames; // enumeration variables wxString str; long dummy; // first enum all entries bool bCont = config->GetFirstEntry(str, dummy); while ( bCont ) { aNames.Add(str); bCont = GetConfig()->GetNextEntry(str, dummy); } ... we have all entry names in aNames... // now all groups... bCont = GetConfig()->GetFirstGroup(str, dummy); while ( bCont ) { aNames.Add(str); bCont = GetConfig()->GetNextGroup(str, dummy); } ... we have all group (and entry) names in aNames...

There are also functions to get the number of entries/subgroups without actually enumerating them, but you will probably never need them.

180


CHAPTER 7
GetFirstGroup (p. 186) GetNextGroup (p. 186) GetFirstEntry (p. 186) GetNextEntry (p. 186) GetNumberOfEntries (p. 187) GetNumberOfGroups (p. 187)

Tests of existence
HasGroup (p. 187) HasEntry (p. 187) Exists (p. 185) GetEntryType (p. 185)

Miscellaneous functions
GetAppName (p. 185) GetVendorName (p. 187) SetUmask (p. 190)

Key access
These function are the core of wxConfigBase class: they allow you to read and write config file data. All Read function take a default value which will be returned if the specified key is not found in the config file. Currently, only two types of data are supported: string and long (but it might change in the near future). To work with other types: for int or bool you can work with function taking/returning long and just use the casts. Better yet, just use long for all variables which you're going to save in the config file: chances are that sizeof(bool) == sizeof(int) == sizeof(long) anyhow on your system. For float, double and, in general, any other type you'd have to translate them to/from string representation and use string functions. Try not to read long values into string variables and vice versa: although it just might work with wxFileConfig, you will get a system error with wxRegConfig because in the Windows registry the different types of entries are indeed used. Final remark: the szKey parameter for all these functions can contain an arbitrary path (either relative or absolute), not just the key name. Read (p. 188) Write (p. 190) Flush (p. 185)

Rename entries/groups

181


CHAPTER 7
The functions in this section allow to rename entries or subgroups of the current group. They will return false on error. typically because either the entry/group with the original name doesn't exist, because the entry/group with the new name already exists or because the function is not supported in this wxConfig implementation. RenameEntry (p. 189) RenameGroup (p. 189)

Delete entries/groups
The functions in this section delete entries and/or groups of entries from the config file. DeleteAll() is especially useful if you want to erase all traces of your program presence: for example, when you uninstall it. DeleteEntry (p. 184) DeleteGroup (p. 185) DeleteAll (p. 184)

Options
Some aspects of wxConfigBase behaviour can be changed during run-time. The first of them is the expansion of environment variables in the string values read from the config file: for example, if you have the following in your config file:
# config file for my program UserData = $HOME/data # the following syntax is valud only under Windows UserData = %windir%\\data.dat

the call to config->Read("UserData") will return something like"/home/zeitlin/data" if you're lucky enough to run a Linux system ;-) Although this feature is very useful, it may be annoying if you read a value which containts '$' or '%' symbols (% is used for environment variables expansion under Windows) which are not used for environment variable expansion. In this situation you may call SetExpandEnvVars(false) just before reading this value and SetExpandEnvVars(true) just after. Another solution would be to prefix the offending symbols with a backslash. The following functions control this option: IsExpandingEnvVars (p. 187) SetExpandEnvVars (p. 190) SetRecordDefaults (p. 190) IsRecordingDefaults (p. 187)

wxConfigBase::wxConfigBase

182


CHAPTER 7
wxConfigBase(const wxString& appName = wxEmptyString, const wxString& vendorName = wxEmptyString, const wxString& localFilename = wxEmptyString, const wxString& globalFilename = wxEmptyString, long style = 0, wxMBConv& conv = wxConvUTF8) This is the default and only constructor of the wxConfigBase class, and derived classes. Parameters appName The application name. If this is empty, the class will normally use wxApp::GetAppName (p. 32) to set it. The application name is used in the registry key on Windows, and can be used to deduce the local filename parameter if that is missing. vendorName The vendor name. If this is empty, it is assumed that no vendor name is wanted, if this is optional for the current config class. The vendor name is appended to the application name for wxRegConfig. localFilename Some config classes require a local filename. If this is not present, but required, the application name will be used instead. globalFilename Some config classes require a global filename. If this is not present, but required, the application name will be used instead. style Can be one of wxCONFIG_USE_LOCAL_FILE and wxCONFIG_USE_GLOBAL_FILE. The style interpretation depends on the config class and is ignored by some. For wxFileConfig, these styles determine whether a local or global config file is created or used. If the flag is present but the parameter is empty, the parameter will be set to a default. If the parameter is present but the style flag not, the relevant flag will be added to the style. For wxFileConfig you can also add wxCONFIG_USE_RELATIVE_PATH by logically or'ing it to either of the _FILE options to tell wxFileConfig to use relative instead of absolute paths. For wxFileConfig, you can also add wxCONFIG_USE_NO_ESCAPE_CHARACTERS which will turn off character escaping for the values of entries stored in the config file: for example a foo key with some backslash characters will be stored as foo=C:\mydir instead of the usual storage of foo=C:\\mydir. The wxCONFIG_USE_NO_ESCAPE_CHARACTERS style can be helpful if your config file must be read or written to by a non-wxWindows program (which might not understand the escape characters). Note, however, that if wxCONFIG_USE_NO_ESCAPE_CHARACTERS style is used, it is is now your application's responsibility to ensure that there is no newline or other illegal characters in a value, before writing that value to the file.

183


CHAPTER 7
conv This parameter is only used by wxFileConfig when compiled in Unicode mode. It specifies the encoding in what the configuration file is written. Remarks By default, environment variable expansion is on and recording defaults is off.

wxConfigBase::~wxConfigBase
~wxConfigBase() Empty but ensures that dtor of all derived classes is virtual.

wxConfigBase::Create
static wxConfigBase * Create() Create a new config object: this function will create the "best" implementation of wxConfig available for the current platform, see comments near the definition of wxCONFIG_WIN32_NATIVE for details. It returns the created object and also sets it as the current one.

wxConfigBase::DontCreateOnDemand
void DontCreateOnDemand() Calling this function will prevent Get() from automatically creating a new config object if the current one is NULL. It might be useful to call it near the program end to prevent new config object "accidental" creation.

wxConfigBase::DeleteAll
bool DeleteAll() Delete the whole underlying object (disk file, registry key, ...). Primarly for use by desinstallation routine.

wxConfigBase::DeleteEntry
bool DeleteEntry(const wxString& key, bool bDeleteGroupIfEmpty = true) Deletes the specified entry and the group it belongs to if it was the last key in it and the second parameter is true.

184


CHAPTER 7 wxConfigBase::DeleteGroup
bool DeleteGroup(const wxString& key) Delete the group (with all subgroups)

wxConfigBase::Exists
bool Exists(wxString& strName) const returns true if either a group or an entry with a given name exists

wxConfigBase::Flush
bool Flush(bool bCurrentOnly = false) permanently writes all changes (otherwise, they're only written from object's destructor)

wxConfigBase::Get
static wxConfigBase * Get(bool CreateOnDemand = true) Get the current config object. If there is no current object andCreateOnDemand is true, creates one (using Create) unless DontCreateOnDemand was called previously.

wxConfigBase::GetAppName
wxString GetAppName() const Returns the application name.

wxConfigBase::GetEntryType
enum wxConfigBase::EntryType GetEntryType(const wxString& name) const Returns the type of the given entry or Unknown if the entry doesn't exist. This function should be used to decide which version of Read() should be used because some of wxConfig implementations will complain about type mismatch otherwise: e.g., an attempt to read a string value from an integer key with wxRegConfig will fail. The result is an element of enum EntryType:
enum EntryType { Unknown, String, Boolean, Integer, Float

185


CHAPTER 7
};

wxConfigBase::GetFirstGroup
bool GetFirstGroup(wxString& str, long& index) const Gets the first group. wxPython note: The wxPython version of this method returns a 3-tuple consisting of the continue flag, the value string, and the index for the next call. wxPerl note: In wxPerl this method takes no arguments and returns a 3-element list ( continue, str, index ).

wxConfigBase::GetFirstEntry
bool GetFirstEntry(wxString& str, long& index) const Gets the first entry. wxPython note: The wxPython version of this method returns a 3-tuple consisting of the continue flag, the value string, and the index for the next call. wxPerl note: In wxPerl this method takes no arguments and returns a 3-element list ( continue, str, index ).

wxConfigBase::GetNextGroup
bool GetNextGroup(wxString& str, long& index) const Gets the next group. wxPython note: The wxPython version of this method returns a 3-tuple consisting of the continue flag, the value string, and the index for the next call. wxPerl note: In wxPerl this method only takes the index parameter and returns a 3element list ( continue, str, index ).

wxConfigBase::GetNextEntry
bool GetNextEntry(wxString& str, long& index) const Gets the next entry. wxPython note: The wxPython version of this method returns a 3-tuple consisting of the continue flag, the value string, and the index for the next call. wxPerl note: In wxPerl this method only takes the index parameter and returns a 3element list ( continue, str, index ).

186


CHAPTER 7 wxConfigBase::GetNumberOfEntries
uint GetNumberOfEntries(bool bRecursive = false) const

wxConfigBase::GetNumberOfGroups
uint GetNumberOfGroups(bool bRecursive = false) const Get number of entries/subgroups in the current group, with or without its subgroups.

wxConfigBase::GetPath
const wxString& GetPath() const Retrieve the current path (always as absolute path).

wxConfigBase::GetVendorName
wxString GetVendorName() const Returns the vendor name.

wxConfigBase::HasEntry
bool HasEntry(wxString& strName) const returns true if the entry by this name exists

wxConfigBase::HasGroup
bool HasGroup(const wxString& strName) const returns true if the group by this name exists

wxConfigBase::IsExpandingEnvVars
bool IsExpandingEnvVars() const Returns true if we are expanding environment variables in key values.

wxConfigBase::IsRecordingDefaults
bool IsRecordingDefaults() const Returns true if we are writing defaults back to the config file.

187


CHAPTER 7 wxConfigBase::Read
bool Read(const wxString& key, wxString* str) const Read a string from the key, returning true if the value was read. If the key was not found, str is not changed. bool Read(const wxString& key, wxString* str, const wxString& defaultVal) const Read a string from the key. The default value is returned if the key was not found. Returns true if value was really read, false if the default was used. wxString Read(const wxString& key, const wxString& defaultVal) const Another version of Read(), returning the string value directly. bool Read(const wxString& key, long* l) const Reads a long value, returning true if the value was found. If the value was not found, l is not changed. bool Read(const wxString& key, long* l,long defaultVal) const Reads a long value, returning true if the value was found. If the value was not found, defaultVal is used instead. long Read(const wxString& key, long defaultVal) const Reads a long value from the key and returns it. defaultVal is returned if the key is not found. NB: writing
conf->Read("key", 0);

won't work because the call is ambiguous: compiler can not choose between twoRead functions. Instead, write:
conf->Read("key", 0l);

bool Read(const wxString& key, double* d) const Reads a double value, returning true if the value was found. If the value was not found, d is not changed. bool Read(const wxString& key, double* d, double defaultVal) const Reads a double value, returning true if the value was found. If the value was not found, defaultVal is used instead. bool Read(const wxString& key, bool* b) const

188


CHAPTER 7
Reads a bool value, returning true if the value was found. If the value was not found, b is not changed. bool Read(const wxString& key, bool* d,bool defaultVal) const Reads a bool value, returning true if the value was found. If the value was not found, defaultVal is used instead. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: Read(key, default="") ReadInt(key, default=0) ReadFloat(key, default=0.0) Returns a string. Returns an int. Returns a floating point number.

wxPerl note: In place of a single overloaded method, wxPerl uses: Read(key, default="") ReadInt(key, default=0) ReadFloat(key, default=0.0) ReadBool(key, default=0) Returns a string Returns an integer Returns a floating point number Returns a boolean

wxConfigBase::RenameEntry
bool RenameEntry(const wxString& oldName, const wxString& newName) Renames an entry in the current group. The entries names (both the old and the new one) shouldn't contain backslashes, i.e. only simple names and not arbitrary paths are accepted by this function. Returns false if the oldName doesn't exist or if newName already exists.

wxConfigBase::RenameGroup
bool RenameGroup(const wxString& oldName, const wxString& newName) Renames a subgroup of the current group. The subgroup names (both the old and the new one) shouldn't contain backslashes, i.e. only simple names and not arbitrary paths are accepted by this function. Returns false if the oldName doesn't exist or if newName already exists.

wxConfigBase::Set

189


CHAPTER 7
static wxConfigBase * Set(wxConfigBase *pConfig) Sets the config object as the current one, returns the pointer to the previous current object (both the parameter and returned value may be NULL)

wxConfigBase::SetExpandEnvVars
void SetExpandEnvVars (bool bDoIt = true) Determine whether we wish to expand environment variables in key values.

wxConfigBase::SetPath
void SetPath(const wxString& strPath) Set current path: if the first character is '/', it is the absolute path, otherwise it is a relative path. '..' is supported. If the strPath doesn't exist it is created.

wxConfigBase::SetRecordDefaults
void SetRecordDefaults(bool bDoIt = true) Sets whether defaults are recorded to the config file whenever an attempt to read read the value which is not present in it is done. If on (default is off) all default values for the settings used by the program are written back to the config file. This allows the user to see what config options may be changed and is probably useful only for wxFileConfig.

wxConfigBase::SetUmask
void SetUmask(int mode) NB: this function is not in the base wxConfigBase class but is only implemented in wxFileConfig. Moreover, this function is Unix-specific and doesn't do anything on other platforms. SetUmask() allows to set the mode to be used for the config file creation. For example, to create a config file which is not readable by other users (useful if it stores some sensitive information, such as passwords), you should do SetUmask(0077).

wxConfigBase::Write
bool Write(const wxString& key, const wxString& value) bool Write(const wxString& key, long value)

190


CHAPTER 7
bool Write(const wxString& key, double value) bool Write(const wxString& key, bool value) These functions write the specified value to the config file and return true on success. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: Write(key, value) WriteInt(key, value) WriteFloat(key, value) Writes a string. Writes an int. Writes a floating point number.

wxPerl note: In place of a single overloaded method, wxPerl uses: Write(key, value) WriteInt(key, value) WriteFloat(key, value) WriteBool(key, value) Writes a string Writes an integer Writes a floating point number Writes a boolean

wxConnection
A wxConnection object represents the connection between a client and a server. It is created by making a connection using a wxClient (p. 131) object, or by the acceptance of a connection by a wxServer (p. 1101) object. The bulk of a DDE-like (Dynamic Data Exchange) conversation is controlled by calling members in a wxConnection object or by overriding its members. The actual DDE-based implementation using wxDDEConnection is available on Windows only, but a platform-independent, socketbased version of this API is available using wxTCPConnection, which has the same API. An application should normally derive a new connection class from wxConnection, in order to override the communication event handlers to do something interesting. Derived from wxConnectionBase wxObject (p. 954) Include files <wx/ipc.h> Types wxIPCFormat is defined as follows:
enum wxIPCFormat

191


CHAPTER 7
{ wxIPC_INVALID = wxIPC_TEXT = wxIPC_BITMAP = wxIPC_METAFILE = wxIPC_SYLK = wxIPC_DIF = wxIPC_TIFF = wxIPC_OEMTEXT = wxIPC_DIB = wxIPC_PALETTE = wxIPC_PENDATA = wxIPC_RIFF = wxIPC_WAVE = wxIPC_UNICODETEXT = wxIPC_ENHMETAFILE = wxIPC_FILENAME = wxIPC_LOCALE = wxIPC_PRIVATE = }; 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 20 /* CF_TEXT */ /* CF_BITMAP */ /* CF_METAFILEPICT */

/* CF_OEMTEXT */ /* CF_DIB */

/* CF_HDROP */

See also wxClient (p. 131), wxServer (p. 1101),Interprocess communications overview (p. 1688)

wxConnection::wxConnection
wxConnection() wxConnection(char* buffer, int size) Constructs a connection object. If no user-defined connection object is to be derived from wxConnection, then the constructor should not be called directly, since the default connection object will be provided on requesting (or accepting) a connection. However, if the user defines his or her own derived connection object, thewxServer::OnAcceptConnection (p. 1102) and/or wxClient::OnMakeConnection (p. 133) members should be replaced by functions which construct the new connection object. If the arguments of the wxConnection constructor are void then the wxConnection object manages its own connection buffer, allocating memory as needed. A programmersupplied buffer cannot be increased if necessary, and the program will assert if it is not large enough. The programmer-supplied buffer is included mainly for backwards compatibility.

wxConnection::Advise
bool Advise(const wxString& item, char* data, int size = -1, wxIPCFormat format = wxCF_TEXT) Called by the server application to advise the client of a change in the data associated with the given item. Causes the client connection's wxConnection::OnAdvise (p. 193) member to be called. Returns true if successful.

192


CHAPTER 7 wxConnection::Execute
bool Execute(char* data, int size = -1, wxIPCFormat format = wxCF_TEXT) Called by the client application to execute a command on the server. Can also be used to transfer arbitrary data to the server (similar to wxConnection::Poke (p. 194) in that respect). Causes the server connection's wxConnection::OnExecute (p. 193) member to be called. Returns true if successful.

wxConnection::Disconnect
bool Disconnect() Called by the client or server application to disconnect from the other program; it causes the wxConnection::OnDisconnect (p. 193) message to be sent to the corresponding connection object in the other program. Returns true if successful or already disconnected. The application that calls Disconnect must explicitly delete its side of the connection.

wxConnection::OnAdvise
virtual bool OnAdvise(const wxString& topic, const wxString& item, char* data, int size, wxIPCFormat format) Message sent to the client application when the server notifies it of a change in the data associated with the given item, usingAdvise (p. 192).

wxConnection::OnDisconnect
virtual bool OnDisconnect() Message sent to the client or server application when the other application notifies it to end the connection. The default behaviour is to delete the connection object and return true, so applications should generally override OnDisconnect(finally calling the inherited method as well) so that they know the connection object is no longer available.

wxConnection::OnExecute
virtual bool OnExecute(const wxString& topic, char* data, int size, wxIPCFormat format) Message sent to the server application when the client notifies it to execute the given data, using Execute (p. 193). Note that there is no item associated with this message.

wxConnection::OnPoke

193


CHAPTER 7
virtual bool OnPoke(const wxString& topic, const wxString& item, char* data, int size, wxIPCFormat format) Message sent to the server application when the client notifies it to accept the given data.

wxConnection::OnRequest
virtual char* OnRequest(const wxString& topic, const wxString& item, int *size, wxIPCFormat format) Message sent to the server application when the client calls wxConnection::Request (p. 194). The server's OnRequest (p. 194) method should respond by returning a character string, or NULL to indicate no data, and setting *size. The character string must of course persist after the call returns.

wxConnection::OnStartAdvise
virtual bool OnStartAdvise(const wxString& topic, const wxString& item) Message sent to the server application by the client, when the client wishes to start an 'advise loop' for the given topic and item. The server can refuse to participate by returning false.

wxConnection::OnStopAdvise
virtual bool OnStopAdvise(const wxString& topic, const wxString& item) Message sent to the server application by the client, when the client wishes to stop an 'advise loop' for the given topic and item. The server can refuse to stop the advise loop by returning false, although this doesn't have much meaning in practice.

wxConnection::Poke
bool Poke(const wxString& item, char* data, int size = -1, wxIPCFormat format = wxCF_TEXT) Called by the client application to poke data into the server. Can be used to transfer arbitrary data to the server. Causes the server connection's wxConnection::OnPoke (p. 193) member to be called. If size is -1 the size is computed from the string length of data. Returns true if successful.

wxConnection::Request
char* Request(const wxString& item, int *size, wxIPCFormat format = wxIPC_TEXT)

194


CHAPTER 7
Called by the client application to request data from the server. Causes the server connection's wxConnection::OnRequest (p. 194) member to be called. Size may be NULL or a pointer to a variable to receive the size of the requested item. Returns a character string (actually a pointer to the connection's buffer) if successful, NULL otherwise. This buffer does not need to be deleted.

wxConnection::StartAdvise
bool StartAdvise(const wxString& item) Called by the client application to ask if an advise loop can be started with the server. Causes the server connection's wxConnection::OnStartAdvise (p. 194) member to be called. Returns true if the server okays it, false otherwise.

wxConnection::StopAdvise
bool StopAdvise(const wxString& item) Called by the client application to ask if an advise loop can be stopped. Causes the server connection's wxConnection::OnStopAdvise (p. 194) member to be called. Returns true if the server okays it, false otherwise.

wxContextHelp
This class changes the cursor to a query and puts the application into a 'contextsensitive help mode'. When the user left-clicks on a window within the specified window, a wxEVT_HELP event is sent to that control, and the application may respond to it by popping up some help. For example:
wxContextHelp contextHelp(myWindow);

There are a couple of ways to invoke this behaviour implicitly:  Use the wxDIALOG_EX_CONTEXTHELP style for a dialog (Windows only). This will put a question mark in the titlebar, and Windows will put the application into context-sensitive help mode automatically, with further programming. Create a wxContextHelpButton (p. 196), whose predefined behaviour is to create a context help object. Normally you will write your application so that this button is only added to a dialog for non-Windows platforms (use wxDIALOG_EX_CONTEXTHELP on Windows).



Derived from wxObject (p. 954)

195


CHAPTER 7
Include files <wx/cshelp.h> See also wxHelpEvent (p. 650), wxHelpController (p. 644), wxContextHelpButton (p. 196)

wxContextHelp::wxContextHelp
wxContextHelp(wxWindow* window = NULL, bool doNow = true) Constructs a context help object, calling BeginContextHelp (p. 196) if doNow is true (the default). If window is NULL, the top window is used.

wxContextHelp::~wxContextHelp
~wxContextHelp() Destroys the context help object.

wxContextHelp::BeginContextHelp
bool BeginContextHelp(wxWindow* window = NULL) Puts the application into context-sensitive help mode. window is the window which will be used to catch events; if NULL, the top window will be used. Returns true if the application was successfully put into context-sensitive help mode. This function only returns when the event loop has finished.

wxContextHelp::EndContextHelp
bool EndContextHelp() Ends context-sensitive help mode. Not normally called by the application.

wxContextHelpButton
Instances of this class may be used to add a question mark button that when pressed, puts the application into context-help mode. It does this by creating a wxContextHelp (p. 195) object which itself generates a wxEVT_HELP event when the user clicks on a window.

196


CHAPTER 7
On Windows, you may add a question-mark icon to a dialog by use of the wxDIALOG_EX_CONTEXTHELP extra style, but on other platforms you will have to add a button explicitly, usually next to OK, Cancel or similar buttons. Derived from wxBitmapButton (p. 80) wxButton (p. 103) wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/cshelp.h> See also wxBitmapButton (p. 80), wxContextHelp (p. 195)

wxContextHelpButton::wxContextHelpButton
wxContextHelpButton() Default constructor. wxContextHelpButton(wxWindow* parent, wxWindowID id = wxID_CONTEXT_HELP, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxBU_AUTODRAW) Constructor, creating and showing a context help button. Parameters parent Parent window. Must not be NULL. id Button identifier. Defaults to wxID_CONTEXT_HELP. pos Button position. size Button size. If the default size (-1, -1) is specified then the button is sized appropriately for the question mark bitmap.

197


CHAPTER 7
style Window style. Remarks Normally you need pass only the parent window to the constructor, and use the defaults for the remaining parameters.

wxControl
This is the base class for a control or 'widget'. A control is generally a small window which processes user input and/or displays one or more item of data. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/control.h> See also wxValidator (p. 1358)

wxControl::Command
void Command(wxCommandEvent& event) Simulates the effect of the user issuing a command to the item. See wxCommandEvent (p. 164).

wxControl::GetLabel
wxString& GetLabel() Returns the control's text.

wxControl::SetLabel
void SetLabel(const wxString& label)

198


CHAPTER 7
Sets the item's text.

wxControlWithItems
This class is an abstract base class for some wxWindows controls which contain several items, such as wxListBox (p. 793) and wxCheckListBox (p. 124) derived from it, wxChoice (p. 127) and wxComboBox (p. 158). It defines the methods for accessing the controls items and although each of the derived classes implements them differently, they still all conform to the same interface. The items in a wxControlWithItems have (non empty) string labels and, optionally, client data associated with them. Client data may be of two different kinds: either simple untyped (void *) pointers which are simply stored by the control but not used in any way by it, or typed pointers (wxClientData *) which are owned by the control meaning that the typed client data (and only it) will be deleted when an item is deleted (p. 200) or the entire control is cleared (p. 200) (which also happens when it is destroyed). Finally note that in the same control all items must have client data of the same type (typed or untyped), if any. This type is determined by the first call to Append (p. 199) (the version with client data pointer) or SetClientData (p. 204). Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/ctrlsub.h> but usually never included directly

wxControlWithItems::Append
int Append(const wxString& item) Adds the item to the end of the list box. int Append(const wxString& item, void *clientData) int Append(const wxString& item, wxClientData *clientData) Adds the item to the end of the list box, associating the given, typed or untyped, client data pointer with the item. void Append(const wxArrayString& strings) Appends several items at once to the control. Notice that calling this method may be much faster than appending the items one by one if you need to add a lot of items.

199


CHAPTER 7
Parameters item String to add. clientData Client data to associate with the item. Return value When appending a single item, the return value is the index of the newly added item which may be different from the last one if the control is sorted (e.g. has wxLB_SORT or wxCB_SORT style).

wxControlWithItems::Clear
void Clear() Removes all items from the control. Clear() also deletes the client data of the existing items if it is owned by the control.

wxControlWithItems::Delete
void Delete(int n) Deletes an item from the control. The client data associated with the item will be also deleted if it is owned by the control. Note that it is an error (signalled by an assert failure in debug builds) to remove an item with the index negative or greater or equal than the number of items in the control. Parameters n The zero-based item index. See also Clear (p. 200)

wxControlWithItems::FindString
int FindString(const wxString& string) Finds an item whose label matches the given string. Parameters

200


CHAPTER 7
string String to find. Return value The zero-based position of the item, or wxNOT_FOUND if the string was not found.

wxControlWithItems::GetClientData
void * GetClientData(int n) const Returns a pointer to the client data associated with the given item (if any). It is an error to call this function for a control which doesn't have untyped client data at all although it is ok to call it even if the given item doesn't have any client data associated with it (but other items do). Parameters n The zero-based position of the item. Return value A pointer to the client data, or NULL if not present.

wxControlWithItems::GetClientObject
wxClientData * GetClientObject(int n) const Returns a pointer to the client data associated with the given item (if any). It is an error to call this function for a control which doesn't have typed client data at all although it is ok to call it even if the given item doesn't have any client data associated with it (but other items do). Parameters n The zero-based position of the item. Return value A pointer to the client data, or NULL if not present.

wxControlWithItems::GetCount
int GetCount() const Returns the number of items in the control.

201


CHAPTER 7
See also IsEmpty (p. 203)

wxControlWithItems::GetSelection
int GetSelection() const Returns the index of the selected item or wxNOT_FOUND if no item is selected. Return value The position of the current selection. Remarks This method can be used with single selection list boxes only, you should use wxListBox::GetSelections (p. 796) for the list boxes with wxLB_MULTIPLE style. See also SetSelection (p. 204), GetStringSelection (p. 202)

wxControlWithItems::GetString
wxString GetString(int n) const Returns the label of the item with the given index. Parameters n The zero-based index. Return value The label of the item or an empty string if the position was invalid.

wxControlWithItems::GetStringSelection
wxString GetStringSelection() const Returns the label of the selected item or an empty string if no item is selected. See also GetSelection (p. 202)

wxControlWithItems::Insert 202


CHAPTER 7
int Insert(const wxString& item, int pos) Inserts the item into the list before pos. Not valid for wxLB_SORT or wxCB_SORT styles, use Append instead. int Insert(const wxString& item, int pos, void *clientData) int Insert(const wxString& item, int pos, wxClientData *clientData) Inserts the item into the list before pos, associating the given, typed or untyped, client data pointer with the item. Not valid for wxLB_SORT or wxCB_SORT styles, use Append instead. Parameters item String to add. pos Position to insert item before, zero based. clientData Client data to associate with the item. Return value The return value is the index of the newly inserted item. If the insertion failed for some reason, -1 is returned.

wxControlWithItems::IsEmpty
bool IsEmpty() const Returns true if the control is empty or false if it has some items. See also GetCount (p. 201)

wxControlWithItems::Number
int Number() const Obsolescence note: This method is obsolete and was replaced withGetCount (p. 201), please use the new method in the new code. This method is only available if wxWindows was compiled with WXWIN_COMPATIBILITY_2_2 defined and will disappear completely in future versions.

203


CHAPTER 7 wxControlWithItems::SetClientData
void SetClientData(int n, void *data) Associates the given untyped client data pointer with the given item. Note that it is an error to call this function if any typed client data pointers had been associated with the control items before. Parameters n The zero-based item index. data The client data to associate with the item.

wxControlWithItems::SetClientObject
void SetClientObject(int n, wxClientData *data) Associates the given typed client data pointer with the given item: the data object will be deleted when the item is deleted (either explicitly by using Deletes (p. 200) or implicitly when the control itself is destroyed). Note that it is an error to call this function if any untyped client data pointers had been associated with the control items before. Parameters n The zero-based item index. data The client data to associate with the item.

wxControlWithItems::SetSelection
void SetSelection(int n) Sets the choice by passing the desired string position. This does not cause any command events to get emitted. Parameters n The string position to select, starting from zero.

204


CHAPTER 7
See also SetString (p. 205), SetStringSelection (p. 205)

wxControlWithItems::SetString
void SetString(int n, const wxString& string) Sets the label for the given item. Parameters n The zero-based item index. string The label to set.

wxControlWithItems::SetStringSelection
void SetStringSelection(const wxString& string) Selects the item with the specified string in the control. This doesn't cause any command events being emitted. Parameters string The string to select. See also SetSelection (p. 204)

wxCountingOutputStream
wxCountingOutputStream is a specialized output stream which does not write any data anyway, instead it counts how many bytes would get written if this were a normal stream. This can sometimes be useful or required if some data gets serialized to a stream or compressed by using stream compression and thus the final size of the stream cannot be known other than pretending to write the stream. One case where the resulting size would have to be known is if the data has to be written to a piece of memory and the memory has to be allocated before writing to it (which is probably always the case when writing to a memory stream). Derived from

205


CHAPTER 7
wxOutputStream (p. 958)wxStreamBase (p. 1191) Include files <wx/stream.h>

wxCountingOutputStream::wxCountingOutputStream
wxCountingOutputStream() Creates a wxCountingOutputStream object.

wxCountingOutputStream::~wxCountingOutputStream
~wxCountingOutputStream() Destructor.

wxCountingOutputStream::GetSize
size_t GetSize() const Returns the current size of the stream.

wxCriticalSection
A critical section object is used for exactly the same purpose as mutexes (p. 938). The only difference is that under Windows platform critical sections are only visible inside one process, while mutexes may be shared between processes, so using critical sections is slightly more efficient. The terminology is also slightly different: mutex may be locked (or acquired) and unlocked (or released) while critical section is entered and left by the program. Finally, you should try to use wxCriticalSectionLocker (p. 207) class whenever possible instead of directly using wxCriticalSection for the same reasons wxMutexLocker (p. 941) is preferrable to wxMutex (p. 938) - please see wxMutex for an example. Derived from None. Include files <wx/thread.h> See also

206


CHAPTER 7
wxThread (p. 1284), wxCondition (p. 173), wxCriticalSectionLocker (p. 207)

wxCriticalSection::wxCriticalSection
wxCriticalSection() Default constructor initializes critical section object.

wxCriticalSection::~wxCriticalSection
~wxCriticalSection() Destructor frees the resources.

wxCriticalSection::Enter
void Enter() Enter the critical section (same as locking a mutex). There is no error return for this function. After entering the critical section protecting some global data the thread running in critical section may safely use/modify it.

wxCriticalSection::Leave
void Leave() Leave the critical section allowing other threads use the global data protected by it. There is no error return for this function.

wxCriticalSectionLocker
This is a small helper class to be used with wxCriticalSection (p. 206) objects. A wxCriticalSectionLocker enters the critical section in the constructor and leaves it in the destructor making it much more difficult to forget to leave a critical section (which, in general, will lead to serious and difficult to debug problems). Example of using it:
void Set Foo() { // gs_critSect is some (global) critical section guarding access to the // object "foo" wxCriticalSectionLocker locker(gs_critSect); if ( ... ) {

207


CHAPTER 7
// do something ... return; } // do something else ... return; }

Without wxCriticalSectionLocker, you would need to remember to manually leave the critical section before each return. Derived from None. Include files <wx/thread.h> See also wxCriticalSection (p. 206), wxMutexLocker (p. 941)

wxCriticalSectionLocker::wxCriticalSectionLocker
wxCriticalSectionLocker(wxCriticalSection& criticalsection) Constructs a wxCriticalSectionLocker object associated with givencriticalsection and enters it.

wxCriticalSectionLocker::~wxCriticalSectionLocker
~wxCriticalSectionLocker() Destructor leaves the critical section.

wxCSConv
This class converts between any character sets and Unicode. It has one predefined instance, wxConvLocal, for the default user character set. Derived from wxMBConv (p. 863) Include files

208


CHAPTER 7
<wx/strconv.h> See also wxMBConv (p. 863), wxEncodingConverter (p. 435), wxMBConv classes overview (p. 1586)

wxCSConv::wxCSConv
wxCSConv(const wxChar* charset) wxCSConv(wxFontEncodingencoding) Constructor. You may specify either the name of the character set you want to convert from/to or an encoding constant. If the character set name is not recognized, ISO 8859-1 is used as fall back.

wxCSConv::~wxCSConv
~wxCSConv() Destructor frees any resources needed to perform the conversion.

wxCSConv::MB2WC
size_t MB2WC(wchar_t* buf, const char* psz, size_t n) const Converts from the selected character set to Unicode. Returns the size of the destination buffer.

wxCSConv::WC2MB
size_t WC2MB(char* buf, const wchar_t* psz, size_t n) const Converts from Unicode to the selected character set. Returns the size of the destination buffer.

wxCursor
A cursor is a small bitmap usually used for denoting where the mouse pointer is, with a picture that might indicate the interpretation of a mouse click. As with icons, cursors in X and MS Windows are created in a different manner. Therefore, separate cursors will be created for the different environments. Platform-specific methods for creating a wxCursor object are catered for, and this is an occasion where conditional compilation will probably be required (see wxIcon (p. 716) for an example).

209


CHAPTER 7
A single cursor object may be used in many windows (any subwindow type). The wxWindows convention is to set the cursor for a window, as in X, rather than to set it globally as in MS Windows, although a global ::wxSetCursor (p. 1501) is also available for MS Windows use. Derived from wxBitmap (p. 67) wxGDIObject (p. 560) wxObject (p. 954) Include files <wx/cursor.h> Predefined objects Objects: wxNullCursor Pointers: wxSTANDARD_CURSOR wxHOURGLASS_CURSOR wxCROSS_CURSOR See also wxBitmap (p. 67), wxIcon (p. 716), wxWindow::SetCursor (p. 1421), ::wxSetCursor (p. 1501)

wxCursor::wxCursor
wxCursor() Default constructor. wxCursor(const char bits[], int width, int height, int hotSpotX=-1, int hotSpotY=-1, const char maskBits[]=NULL, wxColour* fg=NULL, wxColour* bg=NULL) Constructs a cursor by passing an array of bits (Motif and GTK+ only). maskBits is used only under Motif and GTK+. The parameters fg and bg are only present on GTK+, and force the cursor to use particular background and foreground colours. If either hotSpotX or hotSpotY is -1, the hotspot will be the centre of the cursor image (Motif only). wxCursor(const wxString& cursorName, long type, int hotSpotX=0, int hotSpotY=0) Constructs a cursor by passing a string resource name or filename.

210


CHAPTER 7
On MacOS when specifying a string resource name, first the color cursors 'crsr' and then the black/white cursors 'CURS' in the resource chain are scanned through. hotSpotX and hotSpotY are currently only used under Windows when loading from an icon file, to specify the cursor hotspot relative to the top left of the image. wxCursor(int cursorId) Constructs a cursor using a cursor identifier. wxCursor(const wxImage& image) Constructs a cursor from a wxImage. The cursor is monochrome, colors with the RGB elements all greater than 127 will be foreground, colors less than this background. The mask (if any) will be used as transparent. In MSW the foreground will be white and the background black. The cursor is resized to 32x32 In GTK, the two most frequent colors will be used for foreground and background. The cursor will be displayed at the size of the image. On MacOS the cursor is resized to 16x16 and currently only shown as black/white (mask respected). wxCursor(const wxCursor& cursor) Copy constructor. This uses reference counting so is a cheap operation. Parameters bits An array of bits. maskBits Bits for a mask bitmap. width Cursor width. height Cursor height. hotSpotX Hotspot x coordinate. hotSpotY Hotspot y coordinate. type Icon type to load. Under Motif, type defaults to wxBITMAP_TYPE_XBM. Under Windows, it defaults to wxBITMAP_TYPE_CUR_RESOURCE. Under MacOS, it defaults to wxBITMAP_TYPE_MACCURSOR_RESOURCE.

211


CHAPTER 7
Under X, the permitted cursor types are: wxBITMAP_TYPE_XBM Load an X bitmap file.

Under Windows, the permitted types are: wxBITMAP_TYPE_CUR Load a cursor from a .cur cursor file (only if USE_RESOURCE_LOADING_IN_MSW is enabled in setup.h).

wxBITMAP_TYPE_CUR_RESOURCE Load a Windows resource (as specified in the .rc file). wxBITMAP_TYPE_ICO Load a cursor from a .ico icon file (only if USE_RESOURCE_LOADING_IN_MSW is enabled in setup.h). Specify hotSpotX and hotSpotY.

cursorId A stock cursor identifier. May be one of: wxCURSOR_ARROW wxCURSOR_RIGHT_ARROW wxCURSOR_BLANK wxCURSOR_BULLSEYE wxCURSOR_CHAR wxCURSOR_CROSS wxCURSOR_HAND wxCURSOR_IBEAM wxCURSOR_LEFT_BUTTON wxCURSOR_MAGNIFIER A standard arrow cursor. A standard arrow cursor pointing to the right. Transparent cursor. Bullseye cursor. Rectangular character cursor. A cross cursor. A hand cursor. An I-beam cursor (vertical line). Represents a mouse with the left button depressed. A magnifier icon.

wxCURSOR_MIDDLE_BUTTON Represents a mouse with the middle button depressed. wxCURSOR_NO_ENTRY wxCURSOR_PAINT_BRUSH wxCURSOR_PENCIL wxCURSOR_POINT_LEFT wxCURSOR_POINT_RIGHT A no-entry sign cursor. A paintbrush cursor. A pencil cursor. A cursor that points left. A cursor that points right.

212


CHAPTER 7
wxCURSOR_QUESTION_ARROW wxCURSOR_RIGHT_BUTTON wxCURSOR_SIZENESW wxCURSOR_SIZENS wxCURSOR_SIZENWSE wxCURSOR_SIZEWE wxCURSOR_SIZING wxCURSOR_SPRAYCAN wxCURSOR_WAIT wxCURSOR_WATCH wxCURSOR_ARROWWAIT An arrow and question mark.

Represents a mouse with the right button depressed. A sizing cursor pointing NE-SW. A sizing cursor pointing N-S. A sizing cursor pointing NW-SE. A sizing cursor pointing W-E. A general sizing cursor. A spraycan cursor. A wait cursor. A watch cursor. A cursor with both an arrow and an hourglass, (windows.)

Note that not all cursors are available on all platforms. cursor Pointer or reference to a cursor to copy. wxPython note: Constructors supported by wxPython are: wxCursor(name, flags, hotSpotX=0, hotSpotY=0) from a filename wxStockCursor(id) Constructs a cursor

Constructs a stock cursor

wxPerl note: Constructors supported by wxPerl are: ::Cursor->new( name, type, hotSpotX = 0, hotSpotY = 0 ) ::Cursor->new( id ) ::Cursor->new( image ) ::Cursor->newData( bits, width, height, hotSpotX = -1, hotSpotY = -1, maskBits = 0 ) Example The following is an example of creating a cursor from 32x32 bitmap data (down_bits) and a mask (down_mask) where 1 is black and 0 is white for the bits, and 1 is opaque and 0 is transparent for the mask. It works on Windows and GTK+.
static char down_bits[] = { 255, 255, 255, 255, 31,

213


CHAPTER 7
255, 255, 255, 31, 255, 255, 255, 31, 255, 255, 255, 31, 255, 255, 255, 31, 255, 255, 255, 31, 255, 255, 255, 31, 255, 255, 255, 31, 255, 255, 255, 25, 243, 255, 255, 19, 249, 255, 255, 7, 252, 255, 255, 15, 254, 255, 255, 31, 255, 255, 255, 191, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255 }; static char down_mask[] = { 240, 1, 0, 0, 240, 1, 0, 0, 240, 1, 0, 0, 240, 1, 0, 0, 240, 1, 0, 0, 240, 1, 0, 0, 240, 1, 0, 0, 240, 1, 0, 0, 255, 31, 0, 0, 255, 31, 0, 0, 254, 15, 0, 0, 252, 7, 0, 0, 248, 3, 0, 0, 240, 1, 0, 0, 224, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }; #ifdef __WXMSW__ wxBitmap down_bitmap(down_bits, 32, 32); wxBitmap down_mask_bitmap(down_mask, 32, 32); down_bitmap.SetMask(new wxMask(down_mask_bitmap)); wxImage down_image = down_bitmap.ConvertToImage(); down_image.SetOption(wxIMAGE_OPTION_CUR_HOTSPOT_X, 6); down_image.SetOption(wxIMAGE_OPTION_CUR_HOTSPOT_Y, 14); wxCursor down_cursor = wxCursor(down_image); #else wxCursor down_cursor = wxCursor(down_bits, 32, 32, 6, 14, down_mask, wxWHITE, wxBLACK); #endif

wxCursor::~wxCursor
~wxCursor() Destroys the cursor. A cursor can be reused for more than one window, and does not get destroyed when the window is destroyed. wxWindows destroys all cursors on application exit, although it is best to clean them up explicitly.

wxCursor::Ok
bool Ok() const Returns true if cursor data is present.

wxCursor::operator =
wxCursor& operator =(const wxCursor& cursor) Assignment operator, using reference counting. Returns a reference to 'this'.

214


CHAPTER 7 wxCursor::operator ==
bool operator ==(const wxCursor& cursor) Equality operator. Two cursors are equal if they contain pointers to the same underlying cursor data. It does not compare each attribute, so two independently-created cursors using the same parameters will fail the test.

wxCursor::operator !=
bool operator !=(const wxCursor& cursor) Inequality operator. Two cursors are not equal if they contain pointers to different underlying cursor data. It does not compare each attribute.

wxCustomDataObject
wxCustomDataObject is a specialization of wxDataObjectSimple (p. 226) for some application-specific data in arbitrary (either custom or one of the standard ones). The only restriction is that it is supposed that this data can be copied bitwise (i.e. with memcpy()), so it would be a bad idea to make it contain a C++ object (though C struct is fine). By default, wxCustomDataObject stores the data inside in a buffer. To put the data into the buffer you may use either SetData (p. 217) or TakeData (p. 217) depending on whether you want the object to make a copy of data or not. If you already store the data in another place, it may be more convenient and efficient to provide the data on-demand which is possible too if you override the virtual functions mentioned below. Virtual functions to override This class may be used as is, but if you don't want store the data inside the object but provide it on demand instead, you should override GetSize (p. 216), GetData (p. 216) and SetData (p. 217) (or may be only the first two or only the last one if you only allow reading/writing the data) Derived from wxDataObjectSimple (p. 226) wxDataObject (p. 222) Include files <wx/dataobj.h> See also wxDataObject (p. 222)

215


CHAPTER 7

wxCustomDataObject::wxCustomDataObject
wxCustomDataObject(const wxDataFormat& format = wxFormatInvalid) The constructor accepts a format argument which specifies the (single) format supported by this object. If it isn't set here, SetFormat (p. 227) should be used.

wxCustomDataObject::~wxCustomDataObject
~wxCustomDataObject() The destructor will free the data hold by the object. Notice that although it calls a virtual Free() (p. 216) function, the base class version will always be called (C++ doesn't allow calling virtual functions from constructors or destructors), so if you override Free(), you should override the destructor in your class as well (which would probably just call the derived class' version of Free()).

wxCustomDataObject::Alloc
virtual void * Alloc(size_t size) This function is called to allocate size bytes of memory from SetData(). The default version just uses the operator new.

wxCustomDataObject::Free
virtual void Free() This function is called when the data is freed, you may override it to anything you want (or may be nothing at all). The default version calls operator delete[] on the data.

wxCustomDataObject::GetSize
virtual size_t GetSize() const Returns the data size in bytes.

wxCustomDataObject::GetData
virtual void * GetData() const Returns a pointer to the data.

216


CHAPTER 7 wxCustomDataObject::SetData
virtual void SetData( size_t size, const void *data) Set the data. The data object will make an internal copy. wxPython note: This method expects a string in wxPython. You can pass nearly any object by pickling it first.

wxCustomDataObject::TakeData
virtual void TakeData( size_t size, const void *data) Like SetData (p. 217), but doesn't copy the data - instead the object takes ownership of the pointer. wxPython note: This method expects a string in wxPython. You can pass nearly any object by pickling it first.

wxDataFormat
A wxDataFormat is an encapsulation of a platform-specific format handle which is used by the system for the clipboard and drag and drop operations. The applications are usually only interested in, for example, pasting data from the clipboard only if the data is in a format the program understands and a data format is something which uniquely identifies this format. On the system level, a data format is usually just a number (CLIPFORMATunder Windows or Atom under X11, for example) and the standard formats are, indeed, just numbers which can be implicitly converted to wxDataFormat. The standard formats are: wxDF_INVALID wxDF_TEXT wxDF_BITMAP wxDF_METAFILE wxDF_FILENAME wxDF_HTML An invalid format - used as default argument for functions taking a wxDataFormat argument sometimes Text format (wxString) A bitmap (wxBitmap) A metafile (wxMetafile, Windows only) A list of filenames An HTML string. This is only valid when passed to wxSetClipboardData when compiled with Visual C++ in non-Unicode mode

As mentioned above, these standard formats may be passed to any function taking wxDataFormat argument because wxDataFormat has an implicit conversion from them (or, to be precise from the type wxDataFormat::NativeFormat which is the type used by the underlying platform for data formats).

217


CHAPTER 7
Aside the standard formats, the application may also use custom formats which are identified by their names (strings) and not numeric identifiers. Although internally custom format must be created (or registered) first, you shouldn't care about it because it is done automatically the first time the wxDataFormat object corresponding to a given format name is created. The only implication of this is that you should avoid having global wxDataFormat objects with non-default constructor because their constructors are executed before the program has time to perform all necessary initialisations and so an attempt to do clipboard format registration at this time will usually lead to a crash! Virtual functions to override None Derived from None See also Clipboard and drag and drop overview (p. 1666), DnD sample (p. 1563), wxDataObject (p. 222)

wxDataFormat::wxDataFormat
wxDataFormat(NativeFormat format = wxDF_INVALID) Constructs a data format object for one of the standard data formats or an empty data object (use SetType (p. 219) or SetId (p. 219) later in this case) wxPerl note: In wxPerl this function is named newNative.

wxDataFormat::wxDataFormat
wxDataFormat(const wxChar *format) Constructs a data format object for a custom format identified by its name format. wxPerl note: In wxPerl this function is named newUser.

wxDataFormat::operator ==
bool operator ==(const wxDataFormat& format) const Returns true if the formats are equal.

wxDataFormat::operator !=

218


CHAPTER 7
bool operator !=(const wxDataFormat& format) const Returns true if the formats are different.

wxDataFormat::GetId
wxString GetId() const Returns the name of a custom format (this function will fail for a standard format).

wxDataFormat::GetType
NativeFormat GetType() const Returns the platform-specific number identifying the format.

wxDataFormat::SetId
void SetId(const wxChar *format) Sets the format to be the custom format identified by the given name.

wxDataFormat::SetType
void SetType(NativeFormat format) Sets the format to the given value, which should be one of wxDF_XXX constants.

wxDataInputStream
This class provides functions that read binary data types in a portable way. Data can be read in either big-endian or little-endian format, little-endian being the default on all architectures. If you want to read data from text files (or streams) use wxTextInputStream (p. 1276) instead. The >> operator is overloaded and you can use this class like a standard C++ iostream. Note, however, that the arguments are the fixed size types wxUint32, wxInt32 etc and on a typical 32-bit computer, none of these match to the "long" type (wxInt32 is defined as signed int on 32-bit architectures) so that you cannot use long. To avoid problems (here and elsewhere), make use of the wxInt32, wxUint32, etc types. For example:
wxFileInputStream input( "mytext.dat" ); wxDataInputStream store( input ); wxUint8 i1;

219


CHAPTER 7
float f2; wxString line; store >> i1; // read a 8 bit integer. store >> i1 >> f2; // read a 8 bit integer followed by float. store >> line; // read a text line

See also wxDataOutputStream (p. 228). Derived from None Include files <wx/datstrm.h>

wxDataInputStream::wxDataInputStream
wxDataInputStream(wxInputStream& stream) wxDataInputStream(wxInputStream& stream, wxMBConv& conv = wxMBConvUTF8) Constructs a datastream object from an input stream. Only read methods will be available. The second form is only available in Unicode build of wxWindows. Parameters stream The input stream. conv Charset conversion object object used to decode strings in Unicode mode (see wxDataInputStream::ReadString (p. 222)documentation for detailed description). Note that you must not destroyconv before you destroy this wxDataInputStream instance!

wxDataInputStream::~wxDataInputStream
~wxDataInputStream() Destroys the wxDataInputStream object.

wxDataInputStream::BigEndianOrdered
void BigEndianOrdered(bool be_order)

220


CHAPTER 7 If be_order is true, all data will be read in big-endian order, such as written by programs on a big endian architecture (e.g. Sparc) or written by Java-Streams (which always use big-endian order). wxDataInputStream::Read8
wxUint8 Read8() Reads a single byte from the stream. void Read8(wxUint8 *buffer, size_t size) Reads bytes from the stream in a specified buffer. The amount of bytes to read is specified by the size variable.

wxDataInputStream::Read16
wxUint16 Read16() Reads a 16 bit unsigned integer from the stream. void Read16(wxUint16 *buffer, size_t size) Reads 16 bit unsigned integers from the stream in a specified buffer. the amount of 16 bit unsigned integer to read is specified by the size variable.

wxDataInputStream::Read32
wxUint32 Read32() Reads a 32 bit unsigned integer from the stream. void Read32(wxUint32 *buffer, size_t size) Reads 32 bit unsigned integers from the stream in a specified buffer. the amount of 32 bit unsigned integer to read is specified by the size variable.

wxDataInputStream::Read64
wxUint64 Read64() Reads a 64 bit unsigned integer from the stream. void Read64(wxUint64 *buffer, size_t size) Reads 64 bit unsigned integers from the stream in a specified buffer. the amount of 64 bit unsigned integer to read is specified by the size variable.

wxDataInputStream::ReadDouble
double ReadDouble()

221


CHAPTER 7
Reads a double (IEEE encoded) from the stream. void ReadDouble(double *buffer, size_t size) Reads double data (IEEE encoded) from the stream in a specified buffer. the amount of double to read is specified by the size variable.

wxDataInputStream::ReadString
wxString ReadString() Reads a string from a stream. Actually, this function first reads a long integer specifying the length of the string (without the last null character) and then reads the string. In Unicode build of wxWindows, the fuction first reads multibyte (char*) string from the stream and then converts it to Unicode using the convobject passed to constructor and returns the result as wxString. You are responsible for using the same convertor as when writing the stream. See also wxDataOutputStream::WriteString (p. 230).

wxDataObject
A wxDataObject represents data that can be copied to or from the clipboard, or dragged and dropped. The important thing about wxDataObject is that this is a 'smart' piece of data unlike usual 'dumb' data containers such as memory buffers or files. Being 'smart' here means that the data object itself should know what data formats it supports and how to render itself in each of supported formats. A supported format, incidentally, is exactly the format in which the data can be requested from a data object or from which the data object may be set. In the general case, an object may support different formats on 'input' and 'output', i.e. it may be able to render itself in a given format but not be created from data on this format or vice versa. wxDataObject defines an enumeration type
enum Direction { Get = 0x01, Set = 0x02 };

// format is supported by GetDataHere() // format is supported by SetData()

which allows to distinguish between them. See wxDataFormat (p. 217) documentation for more about formats. Not surprisingly, being 'smart' comes at a price of added complexity. This is reasonable for the situations when you really need to support multiple formats, but may be annoying if you only want to do something simple like cut and paste text. To provide a solution for both cases, wxWindows has two predefined classes which derive from wxDataObject: wxDataObjectSimple (p. 226) and wxDataObjectComposite (p. 225). wxDataObjectSimple (p. 226) is the simplest wxDataObject possible and only holds data in a single format (such as HTML or text) and wxDataObjectComposite (p.

222


CHAPTER 7
225) is the simplest way to implement wxDataObject which does support multiple formats because it achievs this by simply holding several wxDataObjectSimple objects. So, you have several solutions when you need a wxDataObject class (and you need one as soon as you want to transfer data via the clipboard or drag and drop): 1. Use one of the built-in classes You may use wxTextDataObject, wxBitmapDataObject or wxFileDataObject in the simplest cases when you only need to support one format and your data is either text, bitmap or list of files. 2. Use wxDataObjectSimple Deriving from wxDataObjectSimple is the simplest solution for custom data - you will only support one format and so probably won't be able to communicate with other programs, but data transfer will work in your program (or between different copies of it). 3. Use wxDataObjectComposite This is a simple but powerful solution which allows you to support any number of formats (either standard or custom if you combine it with the previous solution). 4. Use wxDataObject directly This is the solution for maximal flexibility and efficiency, but it is also is the most difficult to implement. Please note that the easiest way to use drag and drop and the clipboard with multiple formats is by using wxDataObjectComposite, but it is not the most efficient one as each wxDataObjectSimple would contain the whole data in its respective formats. Now imagine that you want to paste 200 pages of text in your proprietary format, as well as Word, RTF, HTML, Unicode and plain text to the clipboard and even today's computers are in trouble. For this case, you will have to derive from wxDataObject directly and make it enumerate its formats and provide the data in the requested format on demand. Note that neither the GTK data transfer mechanisms for the clipboard and drag and drop, nor the OLE data transfer copy any data until another application actually requests the data. This is in contrast to the 'feel' offered to the user of a program who would normally think that the data resides in the clipboard after having pressed 'Copy' - in reality it is only declared to be available. There are several predefined data object classes derived from wxDataObjectSimple: wxFileDataObject (p. 465), wxTextDataObject (p. 1266) and wxBitmapDataObject (p. 84) which can be used without change. You may also derive your own data object classes from wxCustomDataObject (p. 215) for user-defined types. The format of user-defined data is given as mime-type string literal, such as "application/word" or "image/png". These strings are used as they are under Unix (so far only GTK) to identify a format and are translated into their Windows equivalent under Win32 (using the OLE IDataObject for data exchange to and from the clipboard and for drag and drop). Note that the format string translation under Windows is not yet finished. wxPython note: At this time this class is not directly usable from wxPython. Derive a class from wxPyDataObjectSimple (p. 226) instead.

223


CHAPTER 7
wxPerl note: This class is not currently usable from wxPerl; you may use Wx::PlDataObjectSimple (p. 226) instead. Virtual functions to override Each class derived directly from wxDataObject must override and implement all of its functions which are pure virtual in the base class. The data objects which only render their data or only set it (i.e. work in only one direction), should return 0 from GetFormatCount (p. 225). Derived from None Include files <wx/dataobj.h> See also Clipboard and drag and drop overview (p. 1666), DnD sample (p. 1563), wxFileDataObject (p. 465), wxTextDataObject (p. 1266), wxBitmapDataObject (p. 84), wxCustomDataObject (p. 215), wxDropTarget (p. 429), wxDropSource (p. 427), wxTextDropTarget (p. 1268), wxFileDropTarget (p. 470)

wxDataObject::wxDataObject
wxDataObject() Constructor.

wxDataObject::~wxDataObject
~wxDataObject() Destructor.

wxDataObject::GetAllFormats
virtual void GetAllFormats( wxDataFormat *formats, Direction dir = Get) const Copy all supported formats in the given direction to the array pointed to by formats. There is enough space for GetFormatCount(dir) formats in it. wxPerl note: In wxPerl this method only takes the dir parameter. In scalar context it returns the first format, in list context it returns a list containing all the supported formats.

224


CHAPTER 7 wxDataObject::GetDataHere
virtual bool GetDataHere(const wxDataFormat& format, void *buf ) const The method will write the data of the format format in the buffer buf and return true on success, false on failure.

wxDataObject::GetDataSize
virtual size_t GetDataSize(const wxDataFormat& format ) const Returns the data size of the given format format.

wxDataObject::GetFormatCount
virtual size_t GetFormatCount(Direction dir = Get) const Returns the number of available formats for rendering or setting the data.

wxDataObject::GetPreferredFormat
virtual wxDataFormat GetPreferredFormat(Direction dir = Get) const Returns the preferred format for either rendering the data (if dir is Get, its default value) or for setting it. Usually this will be the native format of the wxDataObject.

wxDataObject::SetData
virtual bool SetData( const wxDataFormat& format, size_t len, const void *buf ) Set the data in the format format of the length len provided in the buffer buf. Returns true on success, false on failure.

wxDataObjectComposite
wxDataObjectComposite is the simplest wxDataObject (p. 222) derivation which may be sued to support multiple formats. It contains several wxDataObjectSimple (p. 226) objects and supports any format supported by at least one of them. Only one of these data objects ispreferred (the first one if not explicitly changed by using the second parameter of Add (p. 226)) and its format determines the preferred format of the composite data object as well. See wxDataObject (p. 222) documentation for the reasons why you might prefer to use wxDataObject directly instead of wxDataObjectComposite for efficiency reasons. Virtual functions to override

225


CHAPTER 7
None, this class should be used directly. Derived from wxDataObject (p. 222) Include files <wx/dataobj.h> See also Clipboard and drag and drop overview (p. 1666), wxDataObject (p. 222), wxDataObjectSimple (p. 226), wxFileDataObject (p. 465), wxTextDataObject (p. 1266), wxBitmapDataObject (p. 84)

wxDataObjectComposite::wxDataObjectComposite
wxDataObjectComposite() The default constructor.

wxDataObjectComposite::Add
void Add( wxDataObjectSimple *dataObject, bool preferred = false)

Adds the dataObject to the list of supported objects and it becomes the preferred object if preferred is true.

wxDataObjectSimple
This is the simplest possible implementation of the wxDataObject (p. 222) class. The data object of (a class derived from) this class only supports one format, so the number of virtual functions to be implemented is reduced. Notice that this is still an abstract base class and cannot be used but should be derived from. wxPython note: If you wish to create a derived wxDataObjectSimple class in wxPython you should derive the class from wxPyDataObjectSimple in order to get Python-aware capabilities for the various virtual methods. wxPerl note: In wxPerl, you need to derive your data object class from Wx::PlDataObjectSimple. Virtual functions to override The objects supporting rendering the data must override GetDataSize (p. 227) and

226


CHAPTER 7
GetDataHere (p. 227) while the objects which may be set must override SetData (p. 228). Of course, the objects supporting both operations must override all three methods. Derived from wxDataObject (p. 222) Include files <wx/dataobj.h> See also Clipboard and drag and drop overview (p. 1666), DnD sample (p. 1563), wxFileDataObject (p. 465), wxTextDataObject (p. 1266), wxBitmapDataObject (p. 84)

wxDataObjectSimple::wxDataObjectSimple
wxDataObjectSimple(const wxDataFormat& format = wxFormatInvalid) Constructor accepts the supported format (none by default) which may also be set later with SetFormat (p. 227).

wxDataObjectSimple::GetFormat
const wxDataFormat& GetFormat() const Returns the (one and only one) format supported by this object. It is supposed that the format is supported in both directions.

wxDataObjectSimple::SetFormat
void SetFormat(const wxDataFormat& format) Sets the supported format.

wxDataObjectSimple::GetDataSize
virtual size_t GetDataSize() const Gets the size of our data. Must be implemented in the derived class if the object supports rendering its data.

wxDataObjectSimple::GetDataHere
virtual bool GetDataHere(void *buf) const

227


CHAPTER 7
Copy the data to the buffer, return true on success. Must be implemented in the derived class if the object supports rendering its data. wxPython note: When implementing this method in wxPython, no additional parameters are required and the data should be returned from the method as a string.

wxDataObjectSimple::SetData
virtual bool SetData(size_t len, const void *buf) Copy the data from the buffer, return true on success. Must be implemented in the derived class if the object supports setting its data. wxPython note: When implementing this method in wxPython, the data comes as a single string parameter rather than the two shown here.

wxDataOutputStream
This class provides functions that write binary data types in a portable way. Data can be written in either big-endian or little-endian format, little-endian being the default on all architectures. If you want to write data to text files (or streams) use wxTextOutputStream (p. 1280) instead. The << operator is overloaded and you can use this class like a standard C++ iostream. See wxDataInputStream (p. 219) for its usage and caveats. See also wxDataInputStream (p. 219). Derived from None

wxDataOutputStream::wxDataOutputStream
wxDataOutputStream(wxOutputStream& stream) wxDataOutputStream(wxOutputStream& stream, wxMBConv& conv = wxMBConvUTF8) Constructs a datastream object from an output stream. Only write methods will be available. The second form is only available in Unicode build of wxWindows. Parameters stream

228


CHAPTER 7
The output stream. conv Charset conversion object object used to encoding Unicode strings before writing them to the stream in Unicode mode (see wxDataOutputStream::WriteString (p. 230)documentation for detailed description). Note that you must not destroyconv before you destroy this wxDataOutputStream instance! It is recommended to use default value (UTF-8).

wxDataOutputStream::~wxDataOutputStream
~wxDataOutputStream() Destroys the wxDataOutputStream object.

wxDataOutputStream::BigEndianOrdered
void BigEndianOrdered(bool be_order) If be_order is true, all data will be written in big-endian order, e.g. for reading on a Sparc or from Java-Streams (which always use big-endian order), otherwise data will be written in little-endian order.

wxDataOutputStream::Write8
void Write8(wxUint8 i8) Writes the single byte i8 to the stream. void Write8(const wxUint8 *buffer, size_t size) Writes an array of bytes to the stream. The amount of bytes to write is specified with the size variable.

wxDataOutputStream::Write16
void Write16(wxUint16 i16) Writes the 16 bit unsigned integer i16 to the stream. void Write16(const wxUint16 *buffer, size_t size) Writes an array of 16 bit unsigned integer to the stream. The amount of 16 bit unsigned integer to write is specified with the size variable.

wxDataOutputStream::Write32

229


CHAPTER 7
void Write32(wxUint32 i32) Writes the 32 bit unsigned integer i32 to the stream. void Write32(const wxUint32 *buffer, size_t size) Writes an array of 32 bit unsigned integer to the stream. The amount of 32 bit unsigned integer to write is specified with the size variable.

wxDataOutputStream::Write64
void Write64(wxUint64 i64) Writes the 64 bit unsigned integer i64 to the stream. void Write64(const wxUint64 *buffer, size_t size) Writes an array of 64 bit unsigned integer to the stream. The amount of 64 bit unsigned integer to write is specified with the size variable.

wxDataOutputStream::WriteDouble
void WriteDouble(double f) Writes the double f to the stream using the IEEE format. void WriteDouble(const double *buffer, size_t size) Writes an array of double to the stream. The amount of double to write is specified with the size variable.

wxDataOutputStream::WriteString
void WriteString(const wxString&string) Writes string to the stream. Actually, this method writes the size of the string before writing string itself. In ANSI build of wxWindows, the string is written to the stream in exactly same way it is represented in memory. In Unicode build, however, the string is first converted to multibyte representation with conv object passed to stream's constructor (consequently, ANSI application can read data written by Unicode application, as long as they agree on encoding) and this representation is written to the stream. UTF-8 is used by default.

wxDateSpan
This class is a "logical time span" and is useful for implementing program logic for such things as "add one month to the date" which, in general, doesn't mean to add

230


CHAPTER 7
60*60*24*31 seconds to it, but to take the same date the next month (to understand that this is indeed different consider adding one month to Feb, 15 -- we want to get Mar, 15, of course). When adding a month to the date, all lesser components (days, hours, ...) won't be changed unless the resulting date would be invalid: for example, Jan 31 + 1 month will be Feb 28, not (non existing) Feb 31. Because of this feature, adding and subtracting back again the same wxDateSpan will not, in general give back the original date: Feb 28 - 1 month will be Jan 28, not Jan 31! wxDateSpan objects can be either positive or negative. They may be multiplied by scalars which multiply all deltas by the scalar: i.e.2*(1 month and 1 day) is 2 months and 2 days. They can be added together and with wxDateTime (p. 236) or wxTimeSpan (p. 1298), but the type of result is different for each case. Beware about weeks: if you specify both weeks and days, the total number of days added will be 7*weeks + days! See also GetTotalDays() function. Equality operators are defined for wxDateSpans. Two datespans are equal if and only if they both give the same target date when added to everysource date. Thus wxDateSpan::Months(1) is not equal to wxDateSpan::Days(30), because they don't give the same date when added to 1 Feb. But wxDateSpan::Days(14) is equal to wxDateSpan::Weeks(2) Finally, notice that for adding hours, minutes and so on you don't need this class at all: wxTimeSpan (p. 1298) will do the job because there are no subtleties associated with those (we don't support leap seconds). Derived from No base class Include files <wx/datetime.h> See also Date classes overview (p. 1579), wxDateTime (p. 236)

wxDateSpan::wxDateSpan
wxDateSpan(int years = 0, int months = 0, int weeks = 0, int days = 0) Constructs the date span object for the given number of years, months, weeks and days. Note that the weeks and days add together if both are given.

wxDateSpan::Add

231


CHAPTER 7
wxDateSpan Add(const wxDateSpan& other) const wxDateSpan& Add(const wxDateSpan& other) wxDateSpan& operator+=(const wxDateSpan& other) Returns the sum of two date spans. The first version returns a new object, the second and third ones modify this object in place.

wxDateSpan::Day
static wxDateSpan Day() Returns a date span object corresponding to one day. See also Days (p. 232)

wxDateSpan::Days
static wxDateSpan Days(int days) Returns a date span object corresponding to the given number of days. See also Day (p. 232)

wxDateSpan::GetDays
int GetDays() const Returns the number of days (only, that it not counting the weeks component!) in this date span. See also GetTotalDays (p. 232)

wxDateSpan::GetMonths
int GetMonths() const Returns the number of the months (not counting the years) in this date span.

wxDateSpan::GetTotalDays

232


CHAPTER 7
int GetTotalDays() const Returns the combined number of days in this date span, counting both weeks and days. It still doesn't take neither months nor years into the account. See also GetWeeks (p. 233), GetDays (p. 232)

wxDateSpan::GetWeeks
int GetWeeks() const Returns the number of weeks in this date span. See also GetTotalDays (p. 232)

wxDateSpan::GetYears
int GetYears() const Returns the number of years in this date span.

wxDateSpan::Month
static wxDateSpan Month() Returns a date span object corresponding to one month. See also Months (p. 233)

wxDateSpan::Months
static wxDateSpan Months(int mon) Returns a date span object corresponding to the given number of months. See also Month (p. 233)

wxDateSpan::Multiply
wxDateSpan Multiply(int factor) const

233


CHAPTER 7
wxDateSpan& Multiply(int factor) wxDateSpan& operator*=(int factor) Returns the product of the date span by the specified factor. The product is computed by multiplying each of the components by the factor. The first version returns a new object, the second and third ones modify this object in place.

wxDateSpan::Negate
wxDateSpan Negate() const Returns the date span with the opposite sign. See also Neg (p. 234)

wxDateSpan::Neg
wxDateSpan& Neg() wxDateSpan& operator-() Changes the sign of this date span. See also Negate (p. 234)

wxDateSpan::SetDays
wxDateSpan& SetDays(int n) Sets the number of days (without modifying any other components) in this date span.

wxDateSpan::SetYears
wxDateSpan& SetYears(int n) Sets the number of years (without modifying any other components) in this date span.

wxDateSpan::SetMonths
wxDateSpan& SetMonths(int n)

234


CHAPTER 7
Sets the number of months (without modifying any other components) in this date span.

wxDateSpan::SetWeeks
wxDateSpan& SetWeeks(int n) Sets the number of weeks (without modifying any other components) in this date span.

wxDateSpan::Subtract
wxDateSpan Subtract(const wxDateSpan& other) const wxDateSpan& Subtract(const wxDateSpan& other) wxDateSpan& operator+=(const wxDateSpan& other) Returns the difference of two date spans. The first version returns a new object, the second and third ones modify this object in place.

wxDateSpan::Week
static wxDateSpan Week() Returns a date span object corresponding to one week. See also Weeks (p. 235)

wxDateSpan::Weeks
static wxDateSpan Weeks(int weeks) Returns a date span object corresponding to the given number of weeks. See also Week (p. 235)

wxDateSpan::Year
static wxDateSpan Year() Returns a date span object corresponding to one year. See also Years (p. 236)

235


CHAPTER 7 wxDateSpan::Years
static wxDateSpan Years(int years) Returns a date span object corresponding to the given number of years. See also Year (p. 235)

wxDateSpan::operator==
bool operator==(wxDateSpan& other) const Returns true if this date span is equal to the other one. Two date spans are considered equal if and only if they have the same number of years and months and the same total number of days (counting both days and weeks).

wxDateSpan::operator!=
bool operator!=(wxDateSpan& other) const Returns true if this date span is different from the other one. See also operator== (p. 236)

wxDateTime
wxDateTime class represents an absolute moment in the time. Types The type wxDateTime_t is typedefed as unsigned short and is used to contain the number of years, hours, minutes, seconds and milliseconds. Constants Global constant wxDefaultDateTime and synonym for it wxInvalidDateTime are defined. This constant will be different from any valid wxDateTime object. All the following constants are defined inside wxDateTime class (i.e., to refer to them you should prepend their names with wxDateTime::). Time zone symbolic names:
enum TZ { // the time in the current time zone Local,

236


CHAPTER 7
// zones from GMT (= Greenwhich Mean Time): they're guaranteed to be // consequent numbers, so writing something like `GMT0 + offset' is // safe if abs(offset) <= 12 // underscore stands for minus GMT_12, GMT_11, GMT_10, GMT_9, GMT_8, GMT_7, GMT_6, GMT_5, GMT_4, GMT_3, GMT_2, GMT_1, GMT0, GMT1, GMT2, GMT3, GMT4, GMT5, GMT6, GMT7, GMT8, GMT9, GMT10, GMT11, GMT12, // Note that GMT12 and GMT_12 are not the same: there is a difference // of exactly one day between them // some symbolic names for TZ // Europe WET = GMT0, WEST = GMT1, CET = GMT1, CEST = GMT2, EET = GMT2, EEST = GMT3, MSK = GMT3, MSD = GMT4, // US AST = ADT = EST = EDT = Time CST = GMT_6, CDT = GMT_5, Time MST = GMT_7, MDT = GMT_6, Time PST = GMT_8, PDT = GMT_7, Time HST = GMT_10, AKST = GMT_9, AKDT = GMT_8, // Australia A_WST = GMT8, A_CST = GMT12 + 1, (+9.5) A_EST = GMT10, A_ESST = GMT11, name // for GMT UTC = GMT0 }; // Eastern Standard Time // Eastern Summer Time // Western Standard Time // Central Standard Time // Hawaiian Standard Time // Alaska Standard Time // Alaska Daylight Saving Time // Pacific Standard Time // Pacific Daylight Saving // Mountain Standard Time // Mountain Daylight Saving // Central Standard Time // Central Daylight Saving and Canada GMT_4, GMT_3, GMT_5, GMT_4, // // // // // // // // // // // // Western Europe Time Western Europe Summer Time Central Europe Time Central Europe Summer Time Eastern Europe Time Eastern Europe Summer Time Moscow Time Moscow Summer Time Atlantic Standard Time Atlantic Daylight Time Eastern Standard Time Eastern Daylight Saving

// Universal Coordinated Time = the new and politically correct

Month names: Jan, Feb, Mar, Apr, May, Jun, Jul, Aug, Sep, Oct, Nov, Dec and Inv_Month for an invalid.month value are the values of wxDateTime::Monthenum. Likewise, Sun, Mon, Tue, Wed, Thu, Fri, Sat, and Inv_WeekDay are the values inwxDateTime::WeekDay enum. Finally, Inv_Year is defined to be an invalid value for year parameter.

237


CHAPTER 7
GetMonthName() (p. 245) andGetWeekDayName (p. 245) functions use the followign flags:
enum NameFlags { Name_Full = 0x01, Name_Abbr = 0x02 };

// return full name // return abbreviated name

Several functions accept an extra parameter specifying the calendar to use (although most of them only support now the Gregorian calendar). This parameters is one of the following values:
enum Calendar { Gregorian, Julian };

// calendar currently in use in Western countries // calendar in use since -45 until the 1582 (or later)

Date calculations often depend on the country and wxDateTime allows to set the country whose conventions should be used using SetCountry (p. 246). It takes one of the following values as parameter:
enum Country { Country_Unknown, // no special information for this country Country_Default, // set the default country with SetCountry() method // or use the default country with any other Country_WesternEurope_Start, Country_EEC = Country_WesternEurope_Start, France, Germany, UK, Country_WesternEurope_End = UK, Russia, USA };

Different parts of the world use different conventions for the week start. In some countries, the week starts on Sunday, while in others -- on Monday. The ISO standard doesn't address this issue, so we support both conventions in the functions whose result depends on it (GetWeekOfYear (p. 252) and GetWeekOfMonth (p. 252)). The desired behvaiour may be specified by giving one of the following constants as argument to these functions:
enum WeekFlags { Default_First, Monday_First, Sunday_First };

// Sunday_First for US, Monday_First for the rest // week starts with a Monday // week starts with a Sunday

Derived from No base class Include files

238


CHAPTER 7
<wx/datetime.h> See also Date classes overview (p. 1579), wxTimeSpan (p. 1298), wxDateSpan (p. 230), wxCalendarCtrl (p. 108)

Static functions
For convenience, all static functions are collected here. These functions either set or return the static variables of wxDateSpan (the country), return the current moment, year, month or number of days in it, or do some general calendar-related actions. Please note that although several function accept an extra Calendarparameter, it is currently ignored as only the Gregorian calendar is supported. Future versions will support other calendars. wxPython note: These methods are standalone functions named wxDateTime_<StaticMethodName> in wxPython. SetCountry (p. 246) GetCountry (p. 244) IsWestEuropeanCountry (p. 245) GetCurrentYear (p. 244) ConvertYearToBC (p. 243) GetCurrentMonth (p. 244) IsLeapYear (p. 245) GetCentury (p. 244) GetNumberOfDays (p. 245) GetNumberOfDays (p. 245) GetMonthName (p. 245) GetWeekDayName (p. 245) GetAmPmStrings (p. 243) IsDSTApplicable (p. 246) GetBeginDST (p. 243) GetEndDST (p. 244) Now (p. 246) UNow (p. 247) Today (p. 246)

Constructors, assignment operators and setters
Constructors and various Set() methods are collected here. If you construct a date object from separate values for day, month and year, you should use IsValid (p. 250) method to check that the values were correct as constructors can not return an error code. wxDateTime() (p. 247)

239


CHAPTER 7
wxDateTime(time_t) (p. 247) wxDateTime(struct tm) (p. 247) wxDateTime(double jdn) (p. 247) wxDateTime(h, m, s, ms) (p. 248) wxDateTime(day, mon, year, h, m, s, ms) (p. 248) SetToCurrent (p. 248) Set(time_t) (p. 248) Set(struct tm) (p. 248) Set(double jdn) (p. 248) Set(h, m, s, ms) (p. 249) Set(day, mon, year, h, m, s, ms) (p. 249) SetFromDOS(unsigned long ddt) (p. 253) ResetTime (p. 249) SetYear (p. 249) SetMonth (p. 249) SetDay (p. 249) SetHour (p. 250) SetMinute (p. 250) SetSecond (p. 250) SetMillisecond (p. 250) operator=(time_t) (p. 250) operator=(struct tm) (p. 250)

Accessors
Here are the trivial accessors. Other functions, which might have to perform some more complicated calculations to find the answer are under the Calendar calculations (p. 242) section. IsValid (p. 250) GetTicks (p. 251) GetYear (p. 251) GetMonth (p. 251) GetDay (p. 251) GetWeekDay (p. 251) GetHour (p. 251) GetMinute (p. 251) GetSecond (p. 252) GetMillisecond (p. 252) GetDayOfYear (p. 252) GetWeekOfYear (p. 252) GetWeekOfMonth (p. 252) GetYearDay (p. 261) IsWorkDay (p. 252) IsGregorianDate (p. 253) GetAsDOS (p. 253)

Date comparison

240


CHAPTER 7
There are several function to allow date comparison. To supplement them, a few global operators >, < etc taking wxDateTime are defined. IsEqualTo (p. 253) IsEarlierThan (p. 253) IsLaterThan (p. 253) IsStrictlyBetween (p. 253) IsBetween (p. 254) IsSameDate (p. 254) IsSameTime (p. 254) IsEqualUpTo (p. 254)

Date arithmetics
These functions carry out arithmetics (p. 1581) on the wxDateTime objects. As explained in the overview, either wxTimeSpan or wxDateSpan may be added to wxDateTime, hence all functions are overloaded to accept both arguments. Also, both Add() and Subtract() have both const and non-const version. The first one returns a new obejct which represents the sum/difference of the original one with the argument while the second form modifies the object to which it is applied. The operators -= and += are defined to be equivalent to the second forms of these functions. Add(wxTimeSpan) (p. 254) Add(wxDateSpan) (p. 255) Subtract(wxTimeSpan) (p. 255) Subtract(wxDateSpan) (p. 255) Subtract(wxDateTime) (p. 255) oparator+=(wxTimeSpan) (p. 254) oparator+=(wxDateSpan) (p. 255) oparator-=(wxTimeSpan) (p. 255) oparator-=(wxDateSpan) (p. 255)

Parsing and formatting dates
These functions convert wxDateTime obejcts to and from text. The conversions to text are mostly trivial: you can either do it using the default date and time representations for the current locale ( FormatDate (p. 257) and FormatTime (p. 257)), using the international standard representation defined by ISO 8601 ( FormatISODate (p. 258) and FormatISOTime (p. 258)) or by specifying any format at all and using Format (p. 257) directly. The conversions from text are more interesting, as there are much more possibilities to care about. The simplest cases can be taken care of with ParseFormat (p. 256) which can parse any date in the given (rigid) format. ParseRfc822Date (p. 255) is another function for parsing dates in predefined format -- the one of RFC 822 which (still...) defines the format of email messages on the Internet. This format can not be described with strptime(3)-like format strings used by Format (p. 257), hence the need for a separate function.

241


CHAPTER 7
But the most interesting functions are ParseTime (p. 257), ParseDate (p. 256) and ParseDateTime (p. 256). They try to parse the date ans time (or only one of them) in 'free' format, i.e. allow them to be specified in any of possible ways. These functions will usually be used to parse the (interactive) user input which is not bound to be in any predefined format. As an example, ParseDateTime (p. 256) can parse the strings such as "tomorrow", "March first" and even "next Sunday". ParseRfc822Date (p. 255) ParseFormat (p. 256) ParseDateTime (p. 256) ParseDate (p. 256) ParseTime (p. 257) Format (p. 257) FormatDate (p. 257) FormatTime (p. 257) FormatISODate (p. 258) FormatISOTime (p. 258)

Calendar calculations
The functions in this section perform the basic calendar calculations, mostly related to the week days. They allow to find the given week day in the week with given number (either in the month or in the year) and so on. All (non-const) functions in this section don't modify the time part of the wxDateTime -they only work with the date part of it. SetToWeekDayInSameWeek (p. 258) GetWeekDayInSameWeek (p. 258) SetToNextWeekDay (p. 258) GetNextWeekDay (p. 258) SetToPrevWeekDay (p. 258) GetPrevWeekDay (p. 259) SetToWeekDay (p. 259) GetWeekDay (p. 259) SetToLastWeekDay (p. 259) GetLastWeekDay (p. 259) SetToTheWeek (p. 260) GetWeek (p. 260) SetToLastMonthDay (p. 260) GetLastMonthDay (p. 260) SetToYearDay (p. 260) GetYearDay (p. 261)

Astronomical/historical functions
Some degree of support for the date units used in astronomy and/or history is provided. You can construct a wxDateTime object from aJDN (p. 248) and you may also get its JDN,MJD (p. 261) orRata Die number (p. 261) from it.

242


CHAPTER 7
wxDateTime(double jdn) (p. 247) Set(double jdn) (p. 248) GetJulianDayNumber (p. 261) GetJDN (p. 261) GetModifiedJulianDayNumber (p. 261) GetMJD (p. 261) GetRataDie (p. 261)

Time zone and DST support
Please see the time zone overview (p. 1581) for more information about time zones. ormally, these functions should be rarely used. ToTimezone (p. 262) MakeTimezone (p. 262) ToGMT (p. 262) MakeGMT (p. 262) GetBeginDST (p. 243) GetEndDST (p. 244) IsDST (p. 262)

wxDateTime::ConvertYearToBC
static int ConvertYearToBC(int year) Converts the year in absolute notation (i.e. a number which can be negative, positive or zero) to the year in BC/AD notation. For the positive years, nothing is done, but the year 0 is year 1 BC and so for other years there is a difference of 1. This function should be used like this:
wxDateTime dt(...); int y = dt.GetYear(); printf("The year is %d%s", wxDateTime::ConvertYearToBC(y), y > 0 ? "AD" : "BC");

wxDateTime::GetAmPmStrings
static void GetAmPmStrings(wxString *am, wxString *pm) Returns the translations of the strings AM and PM used for time formatting for the current locale. Either of the pointers may be NULL if the corresponding value is not needed.

wxDateTime::GetBeginDST
static wxDateTime GetBeginDST(int year = Inv_Year, Country country = Country_Default)

243


CHAPTER 7
Get the beginning of DST for the given country in the given year (current one by default). This function suffers from limitations described inDST overview (p. 1582). See also GetEndDST (p. 244)

wxDateTime::GetCountry
static Country GetCountry() Returns the current default country. The default country is used for DST calculations, for example. See also SetCountry (p. 246)

wxDateTime::GetCurrentYear
static int GetCurrentYear(Calendar cal = Gregorian) Get the current year in given calendar (only Gregorian is currently supported).

wxDateTime::GetCurrentMonth
static Month GetCurrentMonth(Calendar cal = Gregorian) Get the current month in given calendar (only Gregorian is currently supported).

wxDateTime::GetCentury
static int GetCentury(int year = Inv_Year) Get the current century, i.e. first two digits of the year, in given calendar (only Gregorian is currently supported).

wxDateTime::GetEndDST
static wxDateTime GetEndDST(int year = Inv_Year, Country country = Country_Default) Returns the end of DST for the given country in the given year (current one by default). See also GetBeginDST (p. 243)

244


CHAPTER 7 wxDateTime::GetMonthName
static wxString GetMonthName(Month month, NameFlags flags = Name_Full) Gets the full (default) or abbreviated (specify Name_Abbr name of the given month. See also GetWeekDayName (p. 245)

wxDateTime::GetNumberOfDays
static wxDateTime_t GetNumberOfDays(int year, Calendar cal = Gregorian) static wxDateTime_t GetNumberOfDays(Month month, int year = Inv_Year, Calendar cal = Gregorian) Returns the number of days in the given year or in the given month of the year. The only supported value for cal parameter is currently Gregorian. wxPython note: These two methods are named GetNumberOfDaysInYearand GetNumberOfDaysInMonth in wxPython.

wxDateTime::GetWeekDayName
static wxString GetWeekDayName(WeekDay weekday, NameFlags flags = Name_Full) Gets the full (default) or abbreviated (specify Name_Abbr name of the given week day. See also GetMonthName (p. 245)

wxDateTime::IsLeapYear
static bool IsLeapYear(int year = Inv_Year, Calendar cal = Gregorian) Returns true if the year is a leap one in the specified calendar. This functions supports Gregorian and Julian calendars.

wxDateTime::IsWestEuropeanCountry
static bool IsWestEuropeanCountry(Country country = Country_Default) This function returns true if the specified (or default) country is one of Western European ones. It is used internally by wxDateTime to determine the DST convention

245


CHAPTER 7
and date and time formatting rules.

wxDateTime::IsDSTApplicable
static bool IsDSTApplicable(int year = Inv_Year, Country country = Country_Default) Returns true if DST was used n the given year (the current one by default) in the given country.

wxDateTime::Now
static wxDateTime Now() Returns the object corresponding to the current time. Example:
wxDateTime now = wxDateTime::Now(); printf("Current time in Paris:\t%s\n", now.Format("%c", wxDateTime::CET).c_str());

Note that this function is accurate up to second: wxDateTime::UNow (p. 247) should be used for better precision (but it is less efficient and might not be available on all platforms). See also Today (p. 246)

wxDateTime::SetCountry
static void SetCountry(Country country) Sets the country to use by default. This setting influences the DST calculations, date formatting and other things. The possible values for country parameter are enumerated inwxDateTime constants section (p. 236). See also GetCountry (p. 244)

wxDateTime::Today
static wxDateTime Today() Returns the object corresponding to the midnight of the current day (i.e. the same as Now() (p. 246), but the time part is set to 0).

246


CHAPTER 7
See also Now (p. 246)

wxDateTime::UNow
static wxDateTime UNow() Returns the object corresponding to the current time including the milliseconds if a function to get time with such precision is available on the current platform (supported under most Unices and Win32). See also Now (p. 246)

wxDateTime::wxDateTime
wxDateTime() Default constructor. Use one of Set() functions to initialize the object later.

wxDateTime::wxDateTime
wxDateTime& wxDateTime(time_t timet) Same as Set (p. 247). wxPython note: This constructor is named wxDateTimeFromTimeT in wxPython.

wxDateTime::wxDateTime
wxDateTime& wxDateTime(const struct tm& tm) Same as Set (p. 247) wxPython note: Unsupported.

wxDateTime::wxDateTime
wxDateTime& wxDateTime(double jdn) Same as Set (p. 247) wxPython note: This constructor is named wxDateTimeFromJDN in wxPython.

247


CHAPTER 7 wxDateTime::wxDateTime
wxDateTime& wxDateTime(wxDateTime_t hour, wxDateTime_t minute = 0, wxDateTime_t second = 0, wxDateTime_t millisec = 0) Same as Set (p. 248) wxPython note: This constructor is named wxDateTimeFromHMS in wxPython.

wxDateTime::wxDateTime
wxDateTime& wxDateTime(wxDateTime_t day, Month month = Inv_Month, int Inv_Year, wxDateTime_t hour = 0, wxDateTime_t minute = 0, wxDateTime_t second = 0, wxDateTime_t millisec = 0) Same as Set (p. 249) wxPython note: This constructor is named wxDateTimeFromDMY in wxPython.

wxDateTime::SetToCurrent
wxDateTime& SetToCurrent() Sets the date and time of to the current values. Same as assigning the result of Now() (p. 246) to this object.

wxDateTime::Set
wxDateTime& Set(time_t timet) Constructs the object from timet value holding the number of seconds since Jan 1, 1970. wxPython note: This method is named SetTimeT in wxPython.

wxDateTime::Set
wxDateTime& Set(const struct tm& tm) Sets the date and time from the broken down representation in the standardtm structure. wxPython note: Unsupported.

wxDateTime::Set
wxDateTime& Set(double jdn) Sets the date from the so-called Julian Day Number.

248


CHAPTER 7
By definition, the Julian Day Number, usually abbreviated as JDN, of a particular instant is the fractional number of days since 12 hours Universal Coordinated Time (Greenwich mean noon) on January 1 of the year -4712 in the Julian proleptic calendar. wxPython note: This method is named SetJDN in wxPython.

wxDateTime::Set
wxDateTime& Set(wxDateTime_t hour, wxDateTime_t minute = 0, wxDateTime_t second = 0, wxDateTime_t millisec = 0) Sets the date to be equal to Today (p. 246) and the time from supplied parameters. wxPython note: This method is named SetHMS in wxPython.

wxDateTime::Set
wxDateTime& Set(wxDateTime_t day, Month month = Inv_Month, int year = Inv_Year, wxDateTime_t hour = 0, wxDateTime_t minute = 0, wxDateTime_t second = 0, wxDateTime_t millisec = 0) Sets the date and time from the parameters.

wxDateTime::ResetTime
wxDateTime& ResetTime() Reset time to midnight (00:00:00) without changing the date.

wxDateTime::SetYear
wxDateTime& SetYear(int year) Sets the year without changing other date components.

wxDateTime::SetMonth
wxDateTime& SetMonth(Month month) Sets the month without changing other date components.

wxDateTime::SetDay
wxDateTime& SetDay(wxDateTime_t day) Sets the day without changing other date components.

249


CHAPTER 7 wxDateTime::SetHour
wxDateTime& SetHour(wxDateTime_t hour) Sets the hour without changing other date components.

wxDateTime::SetMinute
wxDateTime& SetMinute(wxDateTime_t minute) Sets the minute without changing other date components.

wxDateTime::SetSecond
wxDateTime& SetSecond(wxDateTime_t second) Sets the second without changing other date components.

wxDateTime::SetMillisecond
wxDateTime& SetMillisecond(wxDateTime_t millisecond) Sets the millisecond without changing other date components.

wxDateTime::operator=
wxDateTime& operator(time_t timet) Same as Set (p. 248).

wxDateTime::operator=
wxDateTime& operator(const struct tm& tm) Same as Set (p. 248).

wxDateTime::IsValid
bool IsValid() const Returns true if the object represents a valid time moment.

wxDateTime::GetTm
Tm GetTm(const TimeZone& tz = Local) const

250


CHAPTER 7
Returns broken down representation of the date and time.

wxDateTime::GetTicks
time_t GetTicks() const Returns the number of seconds since Jan 1, 1970. An assert failure will occur if the date is not in the range covered by time_t type.

wxDateTime::GetYear
int GetYear(const TimeZone& tz = Local) const Returns the year in the given timezone (local one by default).

wxDateTime::GetMonth
Month GetMonth(const TimeZone& tz = Local) const Returns the month in the given timezone (local one by default).

wxDateTime::GetDay
wxDateTime_t GetDay(const TimeZone& tz = Local) const Returns the day in the given timezone (local one by default).

wxDateTime::GetWeekDay
WeekDay GetWeekDay(const TimeZone& tz = Local) const Returns the week day in the given timezone (local one by default).

wxDateTime::GetHour
wxDateTime_t GetHour(const TimeZone& tz = Local) const Returns the hour in the given timezone (local one by default).

wxDateTime::GetMinute
wxDateTime_t GetMinute(const TimeZone& tz = Local) const Returns the minute in the given timezone (local one by default).

251


CHAPTER 7 wxDateTime::GetSecond
wxDateTime_t GetSecond(const TimeZone& tz = Local) const Returns the seconds in the given timezone (local one by default).

wxDateTime::GetMillisecond
wxDateTime_t GetMillisecond(const TimeZone& tz = Local) const Returns the milliseconds in the given timezone (local one by default).

wxDateTime::GetDayOfYear
wxDateTime_t GetDayOfYear(const TimeZone& tz = Local) const Returns the day of the year (in 1...366 range) in the given timezone (local one by default).

wxDateTime::GetWeekOfYear
wxDateTime_t GetWeekOfYear(WeekFlags flags = Monday_First, const TimeZone& tz = Local) const Returns the number of the week of the year this date is in. The first week of the year is, according to international standards, the one containing Jan 4. The week number is in 1...53 range (52 for non leap years). The function depends on the week start (p. 236) convention specified by the flags argument.

wxDateTime::GetWeekOfMonth
wxDateTime_t GetWeekOfMonth(WeekFlags flags = Monday_First, const TimeZone& tz = Local) const Returns the ordinal number of the week in the month (in 1...5 range). As GetWeekOfYear (p. 252), this function supports both conventions for the week start. See the description of theseweek start (p. 236) conventions.

wxDateTime::IsWorkDay
bool IsWorkDay(Country country = Country_Default) const Returns true is this day is not a holiday in the given country.

252


CHAPTER 7 wxDateTime::IsGregorianDate
bool IsGregorianDate(GregorianAdoption country = Gr_Standard) const Returns true if the given date os later than the date of adoption of the Gregorian calendar in the given country (and hence the Gregorian calendar calculations make sense for it).

wxDateTime::SetFromDOS
wxDateTime& Set(unsigned long ddt) Sets the date from the date and time in DOS (http://developer.novell.com/ndk/doc/smscomp/index.html?page=/ndk /doc/smscomp/sms_docs/data/hc2vlu5i.html) format.

wxDateTime::GetAsDOS
unsigned long GetAsDOS() const Returns the date and time in DOS (http://developer.novell.com/ndk/doc/smscomp/index.html?page=/ndk /doc/smscomp/sms_docs/data/hc2vlu5i.html) format.

wxDateTime::IsEqualTo
bool IsEqualTo(const wxDateTime& datetime) const Returns true if the two dates are strictly identical.

wxDateTime::IsEarlierThan
bool IsEarlierThan(const wxDateTime& datetime) const Returns true if this date precedes the given one.

wxDateTime::IsLaterThan
bool IsLaterThan(const wxDateTime& datetime) const Returns true if this date is later than the given one.

wxDateTime::IsStrictlyBetween
bool IsStrictlyBetween(const wxDateTime& t1, const wxDateTime& t2) const

253


CHAPTER 7
Returns true if this date lies strictly between the two others, See also IsBetween (p. 254)

wxDateTime::IsBetween
bool IsBetween(const wxDateTime& t1, const wxDateTime& t2) const Returns true if IsStrictlyBetween (p. 253)is true or if the date is equal to one of the limit values. See also IsStrictlyBetween (p. 253)

wxDateTime::IsSameDate
bool IsSameDate(const wxDateTime& dt) const Returns true if the date is the same without comparing the time parts.

wxDateTime::IsSameTime
bool IsSameTime(const wxDateTime& dt) const Returns true if the time is the same (although dates may differ).

wxDateTime::IsEqualUpTo
bool IsEqualUpTo(const wxDateTime& dt, const wxTimeSpan& ts) const Returns true if the date is equal to another one up to the given time interval, i.e. if the absolute difference between the two dates is less than this interval.

wxDateTime::Add
wxDateTime Add(const wxTimeSpan& diff) const wxDateTime& Add(const wxTimeSpan& diff) wxDateTime& operator+=(const wxTimeSpan& diff) Adds the given time span to this object. wxPython note: This method is named AddTS in wxPython.

254


CHAPTER 7 wxDateTime::Add
wxDateTime Add(const wxDateSpan& diff) const wxDateTime& Add(const wxDateSpan& diff) wxDateTime& operator+=(const wxDateSpan& diff) Adds the given date span to this object. wxPython note: This method is named AddDS in wxPython.

wxDateTime::Subtract
wxDateTime Subtract(const wxTimeSpan& diff) const wxDateTime& Subtract(const wxTimeSpan& diff) wxDateTime& operator-=(const wxTimeSpan& diff) Subtracts the given time span from this object. wxPython note: This method is named SubtractTS in wxPython.

wxDateTime::Subtract
wxDateTime Subtract(const wxDateSpan& diff) const wxDateTime& Subtract(const wxDateSpan& diff) wxDateTime& operator-=(const wxDateSpan& diff) Subtracts the given date span from this object. wxPython note: This method is named SubtractDS in wxPython.

wxDateTime::Subtract
wxTimeSpan Subtract(const wxDateTime& dt) const Subtracts another date from this one and returns the difference between them as wxTimeSpan.

wxDateTime::ParseRfc822Date
const wxChar * ParseRfc822Date(const wxChar* date) Parses the string date looking for a date formatted according to the RFC 822 in it. The exact description of this format may, of course, be found in the RFC (section 5), but,

255


CHAPTER 7
briefly, this is the format used in the headers of Internet email messages and one of the most common strings expressing date in this format may be something like "Sat, 18 Dec 1999 00:48:30 +0100". Returns NULL if the conversion failed, otherwise return the pointer to the character immediately following the part of the string which could be parsed. If the entire string contains only the date in RFC 822 format, the returned pointer will be pointing to a NUL character. This function is intentionally strict, it will return an error for any string which is not RFC 822 compliant. If you need to parse date formatted in more free ways, you should use ParseDateTime (p. 256) orParseDate (p. 256) instead.

wxDateTime::ParseFormat
const wxChar * ParseFormat(const wxChar *date, const wxChar *format = "%c", const wxDateTime& dateDef = wxDefaultDateTime) This function parses the string date according to the givenformat. The system strptime(3) function is used whenever available, but even if it is not, this function is still implemented, although support for locale-dependent format specifiers such as "%c", "%x" or "%X" may not be perfect and GNU extensions such as "%z" and "%Z" are not implemented. This function does handle the month and weekday names in the current locale on all platforms, however. Please see the description of the ANSI C function strftime(3) for the syntax of the format string. The dateDef parameter is used to fill in the fields which could not be determined from the format string. For example, if the format is "%d" (the ay of the month), the month and the year are taken from dateDef. If it is not specified, Today (p. 246) is used as the default date. Returns NULL if the conversion failed, otherwise return the pointer to the character which stopped the scan.

wxDateTime::ParseDateTime
const wxChar * ParseDateTime(const wxChar *datetime) Parses the string datetime containing the date and time in free format. This function tries as hard as it can to interpret the given string as date and time. Unlike ParseRfc822Date (p. 255), it will accept anything that may be accepted and will only reject strings which can not be parsed in any way at all. Returns NULL if the conversion failed, otherwise return the pointer to the character which stopped the scan. This method is currently not implemented, so always returns NULL.

wxDateTime::ParseDate

256


CHAPTER 7
const wxChar * ParseDate(const wxChar *date) This function is like ParseDateTime (p. 256), but it only allows the date to be specified. It is thus less flexible then ParseDateTime (p. 256), but also has less chances to misinterpret the user input. Returns NULL if the conversion failed, otherwise return the pointer to the character which stopped the scan.

wxDateTime::ParseTime
const wxChar * ParseTime(const wxChar *time) This functions is like ParseDateTime (p. 256), but only allows the time to be specified in the input string. Returns NULL if the conversion failed, otherwise return the pointer to the character which stopped the scan.

wxDateTime::Format
wxString Format(const wxChar *format = "%c", const TimeZone& tz = Local) const This function does the same as the standard ANSI C strftime(3) function. Please see its description for the meaning of format parameter. It also accepts a few wxWindows-specific extensions: you can optionally specify the width of the field to follow using printf(3)-like syntax and the format specification %l can be used to get the number of milliseconds. See also ParseFormat (p. 256)

wxDateTime::FormatDate
wxString FormatDate() const Identical to calling Format() (p. 257) with "%x"argument (which means 'preferred date representation for the current locale').

wxDateTime::FormatTime
wxString FormatTime() const Identical to calling Format() (p. 257) with "%X"argument (which means 'preferred time representation for the current locale').

257


CHAPTER 7 wxDateTime::FormatISODate
wxString FormatISODate() const This function returns the date representation in the ISO 8601 format (YYYY-MM-DD).

wxDateTime::FormatISOTime
wxString FormatISOTime() const This function returns the time representation in the ISO 8601 format (HH:MM:SS).

wxDateTime::SetToWeekDayInSameWeek
wxDateTime& SetToWeekDayInSameWeek(WeekDay weekday, WeekFlagsflags = Monday_First) Adjusts the date so that it will still lie in the same week as before, but its week day will be the given one. Returns the reference to the modified object itself.

wxDateTime::GetWeekDayInSameWeek
wxDateTime GetWeekDayInSameWeek(WeekDay weekday, WeekFlagsflags = Monday_First) const Returns the copy of this object to which SetToWeekDayInSameWeek (p. 258) was applied.

wxDateTime::SetToNextWeekDay
wxDateTime& SetToNextWeekDay(WeekDay weekday) Sets the date so that it will be the first weekday following the current date. Returns the reference to the modified object itself.

wxDateTime::GetNextWeekDay
wxDateTime GetNextWeekDay(WeekDay weekday) const Returns the copy of this object to whichSetToNextWeekDay (p. 258) was applied.

wxDateTime::SetToPrevWeekDay

258


CHAPTER 7
wxDateTime& SetToPrevWeekDay(WeekDay weekday) Sets the date so that it will be the last weekday before the current date. Returns the reference to the modified object itself.

wxDateTime::GetPrevWeekDay
wxDateTime GetPrevWeekDay(WeekDay weekday) const Returns the copy of this object to whichSetToPrevWeekDay (p. 258) was applied.

wxDateTime::SetToWeekDay
bool SetToWeekDay(WeekDay weekday, int n = 1, Month month = Inv_Month, int year = Inv_Year) Sets the date to the n-th weekday in the given month of the given year (the current month and year are used by default). The parameter nmay be either positive (counting from the beginning of the month) or negative (counting from the end of it). For example, SetToWeekDay(2, wxDateTime::Wed) will set the date to the second Wednesday in the current month andSetToWeekDay(-1, wxDateTime::Sun) -- to the last Sunday in it. Returns true if the date was modified successfully, falseotherwise meaning that the specified date doesn't exist.

wxDateTime::GetWeekDay
wxDateTime GetWeekDay(WeekDay weekday, int n = 1, Month month = Inv_Month, int year = Inv_Year) const Returns the copy of this object to whichSetToWeekDay (p. 259) was applied.

wxDateTime::SetToLastWeekDay
bool SetToLastWeekDay(WeekDay weekday, Month month = Inv_Month, int year = Inv_Year) The effect of calling this function is the same as of callingSetToWeekDay(-1, weekday, month, year). The date will be set to the lastweekday in the given month and year (the current ones by default). Always returns true.

wxDateTime::GetLastWeekDay

259


CHAPTER 7
wxDateTime GetLastWeekDay(WeekDay weekday, Month month = Inv_Month, int year = Inv_Year) Returns the copy of this object to whichSetToLastWeekDay (p. 259) was applied.

wxDateTime::SetToTheWeek
bool SetToTheWeek(wxDateTime_t numWeek, WeekDay weekday = Mon, WeekFlagsflags = Monday_First) Set the date to the given weekday in the week with given numbernumWeek. The number should be in range 1...53 and false will be returned if the specified date doesn't exist. true is returned if the date was changed successfully.

wxDateTime::GetWeek
wxDateTime GetWeek(wxDateTime_t numWeek, WeekDay weekday = Mon, WeekFlagsflags = Monday_First) const Returns the copy of this object to whichSetToTheWeek (p. 260) was applied.

wxDateTime::SetToLastMonthDay
wxDateTime& SetToLastMonthDay(Month month = Inv_Month, int year = Inv_Year) Sets the date to the last day in the specified month (the current one by default). Returns the reference to the modified object itself.

wxDateTime::GetLastMonthDay
wxDateTime GetLastMonthDay(Month month = Inv_Month, int year = Inv_Year) const Returns the copy of this object to whichSetToLastMonthDay (p. 260) was applied.

wxDateTime::SetToYearDay
wxDateTime& SetToYearDay(wxDateTime_t yday) Sets the date to the day number yday in the same year (i.e., unlike the other functions, this one does not use the current year). The day number should be in the range 1...366 for the leap years and 1...365 for the other ones. Returns the reference to the modified object itself.

260


CHAPTER 7 wxDateTime::GetYearDay
wxDateTime GetYearDay(wxDateTime_t yday) const Returns the copy of this object to whichSetToYearDay (p. 260) was applied.

wxDateTime::GetJulianDayNumber
double GetJulianDayNumber() const Returns the JDN (p. 248) corresponding to this date. Beware of rounding errors! See also GetModifiedJulianDayNumber (p. 261)

wxDateTime::GetJDN
double GetJDN() const Synonym for GetJulianDayNumber (p. 261).

wxDateTime::GetModifiedJulianDayNumber
double GetModifiedJulianDayNumber() const Returns the Modified Julian Day Number (MJD) which is, by definition, equal to JDN 2400000.5. The MJDs are simpler to work with as the integral MJDs correspond to midnights of the dates in the Gregorian calendar and not th noons like JDN. The MJD 0 is Nov 17, 1858.

wxDateTime::GetMJD
double GetMJD() const Synonym for GetModifiedJulianDayNumber (p. 261).

wxDateTime::GetRataDie
double GetRataDie() const Return the Rata Die number of this date. By definition, the Rata Die number is a date specified as the number of days relative to a base date of December 31 of the year 0. Thus January 1 of the year 1 is Rata Die day 1.

261


CHAPTER 7 wxDateTime::ToTimezone
wxDateTime ToTimezone(const TimeZone& tz, bool noDST = false) const Transform the date to the given time zone. If noDST is true, no DST adjustments will be made. Returns the date in the new time zone.

wxDateTime::MakeTimezone
wxDateTime& MakeTimezone(const TimeZone& tz, bool noDST = false) Modifies the object in place to represent the date in another time zone. IfnoDST is true, no DST adjustments will be made.

wxDateTime::ToGMT
wxDateTime ToGMT(bool noDST = false) const This is the same as calling ToTimezone (p. 262) with the argument GMT0.

wxDateTime::MakeGMT
wxDateTime& MakeGMT(bool noDST = false) This is the same as calling MakeTimezone (p. 262) with the argument GMT0.

wxDateTime::IsDST
int IsDST(Country country = Country_Default) const Returns true if the DST is applied for this date in the given country. See also GetBeginDST (p. 243) andGetEndDST (p. 244)

wxDateTimeHolidayAuthority
TODO

wxDateTimeWorkDays
TODO

262


CHAPTER 7

wxDb
A wxDb instance is a connection to an ODBC datasource which may be opened, closed, and re-opened an unlimited number of times. A database connection allows function to be performed directly on the datasource, as well as allowing access to any tables/views defined in the datasource to which the user has sufficient privileges. See the database classes overview (p. 1668) for an introduction to using the ODBC classes. Include files <wx/db.h> Helper classes and data structures The following classes and structs are defined in db.cpp/.h for use with the wxDb class.     wxDbColFor (p. 293) wxDbColInf (p. 293) wxDbTableInf (p. 336) wxDbInf (p. 300)

Constants NOTE: In a future release, all ODBC class constants will be prefaced with 'wx'.
wxDB_PATH_MAX Maximum path length allowed to be passed to the ODBC driver to indicate where the data file(s) are located. Maximum supported length for the name of a column Maximum number of error messages retained in the queue before being overwritten by new errors. Maximum supported length of an error message returned by the ODBC classes Maximum supported length for a complete SQL statement to be passed to the ODBC driver Maximum supported length for the name of a table

DB_MAX_COLUMN_NAME_LEN DB_MAX_ERROR_HISTORY

DB_MAXERROR_MSG_LEN _ DB_MAX_STATEMENT_LEN DB_MAX_TABLE_NAME_LEN

DB_MAX_WHERE_CLAUSE_LEN Maximum supported WHERE clause length that can be passed to the ODBC driver DB_TYPE_NAME_LEN Maximum length of the name of a column's data type

Enumerated types

263


CHAPTER 7
Enumerated types enum wxDbSqlLogState sqlLogOFF, sqlLogON enum wxDBMS These are the databases currently tested and working with the ODBC classes. A call to wxDb::Dbms (p. 272) will return one of these enumerated values listed below.
dbmsUNIDENTIFIED dbmsORACLE dbmsSYBASE_ASA // Adaptive Server Anywhere dbmsYBASE_ASE S // Adaptive Server Enterprise dbmsMS_SQL_SERVER dbmsMY_SQL dbmsPOSTGRES dbmsACCESS dbmsDBASE dbmsINFORMIX dbmsVIRTUOSO dbmsDB2 dbmdINTERBASE

See the remarks in wxDb::Dbms (p. 272) for exceptions/issues with each of these database engines. Public member variables SWORD wxDb::cbErrorMsg This member variable is populated as a result of calling wxDb::GetNextError (p. 280). Contains the count of bytes in the wxDb::errorMsg string. int wxDb::DB_STATUS The last ODBC error/status that occurred on this data connection. Possible codes are:
DB_ERR_GENERAL_WARNING DB_ERR_DISCONNECT_ERROR DB_ERR_DATA_TRUNCATED DB_ERR_PRIV_NOT_REVOKED DB_ERR_INVALID_CONN_STR_ATTR DB_ERR_ERROR_IN_ROW DB_ERR_OPTION_VALUE_CHANGED DB_ERR_NO_ROWS_UPD_OR_DEL DB_ERR_MULTI_ROWS_UPD_OR_DEL DB_ERR_WRONG_NO_OF_PARAMS DB_ERR_DATA_TYPE_ATTR_VIOL DB_ERR_UNABLE_TO_CONNECT DB_ERR_CONNECTION_IN_USE DB_ERR_CONNECTION_NOT_OPEN DB_ERR_REJECTED_CONNECTION DB_ERR_CONN_FAIL_IN_TRANS DB_ERR_COMM_LINK_FAILURE DB_ERR_INSERT_VALUE_LIST_MISMATCH DB_ERR_DERIVED_TABLE_MISMATCH DB_ERR_STRING_RIGHT_TRUNC DB_ERR_NUMERIC_VALUE_OUT_OF_RNG DB_ERR_ERROR_IN_ASSIGNMENT DB_ERR_DATETIME_FLD_OVERFLOW DB_ERR_DIVIDE_BY_ZERO // // // // // // // // // // // // // // // // // // // // // // // // SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState = = = = = = = = = = = = = = = = = = = = = = = = '01000' '01002' '01004' '01006' '01S00' '01S01' '01S02' '01S03' '01S04' '07001' '07006' '08001' '08002' '08003' '08004' '08007' '08S01' '21S01' '21S02' '22001' '22003' '22005' '22008' '22012'

264


CHAPTER 7
DB_ERR_STR_DATA_LENGTH_MISMATCH DB_ERR_INTEGRITY_CONSTRAINT_VIOL DB_ERR_INVALID_CURSOR_STATE DB_ERR_INVALID_TRANS_STATE DB_ERR_INVALID_AUTH_SPEC DB_ERR_INVALID_CURSOR_NAME DB_ERR_SYNTAX_ERROR_OR_ACCESS_VIOL DB_ERR_DUPLICATE_CURSOR_NAME DB_ERR_SERIALIZATION_FAILURE DB_ERR_SYNTAX_ERROR_OR_ACCESS_VIOL2 DB_ERR_OPERATION_ABORTED DB_ERR_UNSUPPORTED_FUNCTION DB_ERR_NO_DATA_SOURCE DB_ERR_DRIVER_LOAD_ERROR DB_ERR_SQLALLOCENV_FAILED DB_ERR_SQLALLOCCONNECT_FAILED DB_ERR_SQLSETCONNECTOPTION_FAILED DB_ERR_NO_DATA_SOURCE_DLG_PROHIB DB_ERR_DIALOG_FAILED DB_ERR_UNABLE_TO_LOAD_TRANSLATION_DLL DB_ERR_DATA_SOURCE_NAME_TOO_LONG DB_ERR_DRIVER_NAME_TOO_LONG DB_ERR_DRIVER_KEYWORD_SYNTAX_ERROR DB_ERR_TRACE_FILE_ERROR DB_ERR_TABLE_OR_VIEW_ALREADY_EXISTS DB_ERR_TABLE_NOT_FOUND DB_ERR_INDEX_ALREADY_EXISTS DB_ERR_INDEX_NOT_FOUND DB_ERR_COLUMN_ALREADY_EXISTS DB_ERR_COLUMN_NOT_FOUND DB_ERR_NO_DEFAULT_FOR_COLUMN DB_ERR_GENERAL_ERROR DB_ERR_MEMORY_ALLOCATION_FAILURE DB_ERR_INVALID_COLUMN_NUMBER DB_ERR_PROGRAM_TYPE_OUT_OF_RANGE DB_ERR_SQL_DATA_TYPE_OUT_OF_RANGE DB_ERR_OPERATION_CANCELLED DB_ERR_INVALID_ARGUMENT_VALUE DB_ERR_FUNCTION_SEQUENCE_ERROR DB_ERR_OPERATION_INVALID_AT_THIS_TIME DB_ERR_INVALID_TRANS_OPERATION_CODE DB_ERR_NO_CURSOR_NAME_AVAIL DB_ERR_INVALID_STR_OR_BUF_LEN DB_ERR_DESCRIPTOR_TYPE_OUT_OF_RANGE DB_ERR_OPTION_TYPE_OUT_OF_RANGE DB_ERR_INVALID_PARAM_NO DB_ERR_INVALID_SCALE_VALUE DB_ERR_FUNCTION_TYPE_OUT_OF_RANGE DB_ERR_INF_TYPE_OUT_OF_RANGE DB_ERR_COLUMN_TYPE_OUT_OF_RANGE DB_ERR_SCOPE_TYPE_OUT_OF_RANGE DB_ERR_NULLABLE_TYPE_OUT_OF_RANGE DB_ERR_UNIQUENESS_OPTION_TYPE_OUT_OF_RANGE DB_ERR_ACCURACY_OPTION_TYPE_OUT_OF_RANGE DB_ERR_DIRECTION_OPTION_OUT_OF_RANGE DB_ERR_INVALID_PRECISION_VALUE DB_ERR_INVALID_PARAM_TYPE DB_ERR_FETCH_TYPE_OUT_OF_RANGE DB_ERR_ROW_VALUE_OUT_OF_RANGE DB_ERR_CONCURRENCY_OPTION_OUT_OF_RANGE DB_ERR_INVALID_CURSOR_POSITION DB_ERR_INVALID_DRIVER_COMPLETION DB_ERR_INVALID_BOOKMARK_VALUE DB_ERR_DRIVER_NOT_CAPABLE DB_ERR_TIMEOUT_EXPIRED // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState SqlState = '22026' = '23000' = '24000' = '25000' = '28000' = '34000' = '37000' = '3C000' = '40001' = '42000' = '70100' = 'IM001' = 'IM002' = 'IM003' = 'IM004' = 'IM005' = 'IM006' = 'IM007' = 'IM008' = 'IM009' = 'IM010' = 'IM011' = 'IM012' = 'IM013' = 'S0001' = 'S0002' = 'S0011' = 'S0012' = 'S0021' ='S0022' = 'S0023' = 'S1000' = 'S1001' = 'S1002' = 'S1003' = 'S1004' = 'S1008' = 'S1009' = 'S1010' = 'S1011' = 'S1012' = 'S1015' = 'S1090' = 'S1091' = 'S1092' = 'S1093' = 'S1094' = 'S1095' = 'S1096' = 'S1097' = 'S1098' = 'S1099' = 'S1100' = 'S1101' = 'S1103' = 'S1104' = 'S1105' = 'S1106' = 'S1107' = 'S1108' = 'S1109' = 'S1110' = 'S1111' = 'S1C00' = 'S1T00'

struct wxDb::dbInf This structure is internal to the wxDb class and contains details of the ODBC datasource that the current instance of the wxDb is connected to in its members.

265


CHAPTER 7
When the datasource is opened, all of the information contained in the dbInf structure is queried from the datasource. This information is used almost exclusively within the ODBC class library. Where there may be a need for particular portions of this information outside of the class library, member functions (e.g.wxDbTable::IsCursorClosedOnCommit (p. 321)) have been added for ease of use.
wxChar wxChar wxChar wxChar wxChar wxChar wxChar wxChar wxChar wxChar UWORD UWORD UWORD UWORD UWORD UWORD UWORD UWORD wxChar UDWORD UDWORD UDWORD UDWORD UDWORD UDWORD UDWORD UDWORD UDWORD UWORD UDWORD Name of the dbms product Version # of the dbms product Driver name ODBC version of the driver ODBC version of the driver manager Driver version Server Name, typically a connect string Database filename Does datasource support outer joins Doesdatasource support stored procedures maxConnections - Maximum # of connections datasource supports maxStmts - Maximum # of HSTMTs per HDBC apiConfLvl - ODBC API conformance level cliConfLvl - Is datasource SAG compliant sqlConfLvl - SQL conformance level cursorCommitBehavior - How cursors are affected on db commit cursorRollbackBehavior - How cursors are affected on db rollback supportNotNullClause - Does datasource support NOT NULL clause supportIEF[2] - Integrity Enhancement Facility (Ref. Integrity) txnIsolation - Transaction isolation level supported by driver txnIsolationOptions - Transaction isolation level options available fetchDirections - Fetch directions supported lockTypes - Lock types supported in SQLSetPos posOperations - Position operations supported in SQLSetPos posStmts - Position statements supported scrollConcurrency - Scrollable cursor concurrency options supported scrollOptions - Scrollable cursor options supported staticSensitivity - Can additions/deletions/updates be detected txnCapable - Indicates if datasource supports transactions loginTimeout - Number seconds to wait for a login request dbmsName[40] dbmsVer[64] driverName[40] odbcVer[60] drvMgrOdbcVer[60] driverVer[60] serverName[80] databaseName[128] outerJoins[2] procedureSupport[2] -

wxChar wxDb::errorList[DB_MAX_ERROR_HISTORY][DB_MAX_ERROR_MSG_LEN] The last n ODBC errors that have occurred on this database connection. wxChar wxDb::errorMsg[SQL_MAX_MESSAGE_LENGTH] This member variable is populated as a result of calling wxDb::GetNextError (p. 280). It contains the ODBC error message text. SDWORD wxDb::nativeError Set by wxDb::DispAllErrors, wxDb::GetNextError, and wxDb::DispNextError. It contains the datasource-specific error code returned by the datasource to the ODBC driver. Used for reporting ODBC errors.

266


CHAPTER 7
wxChar wxDb::sqlState[20] Set by wxDb::TranslateSqlState(). Indicates the error state after a failed ODBC operation. Used for reporting ODBC errors. Remarks Default cursor scrolling is defined by wxODBC_FWD_ONLY_CURSORS in setup.h when the wxWindows library is built. This behavior can be overridden when an instance of a wxDb is created (see wxDb constructor (p. 269)). Default setting of this value true, as not all databases/drivers support both types of cursors. See also wxDbColFor (p. 293), wxDbColInf (p. 293),wxDbTable (p. 301), wxDbTableInf (p. 336),wxDbInf (p. 300)

Associated non-class functions
The following functions are used in conjunction with the wxDb class. void wxDbCloseConnections() Remarks Closes all cached connections that have been made through use of thewxDbGetConnection (p. 267) function. NOTE: These connections are closed regardless of whether they are in use or not. This function should only be called after the program has finished using the connections and all wxDbTable instances that use any of the connections have been closed. This function performs a wxDb::CommitTrans (p. 271)on the connection before closing it to commit any changes that are still pending, as well as to avoid any function sequence errors upon closing each connection. int wxDbConnectionsInUse() Remarks Returns a count of how many database connections are currently free ( not being used) that have been cached through use of the wxDbGetConnection (p. 267)function. bool wxDbFreeConnection(wxDb *pDb) Remarks Searches the list of cached database connections connection for one matching the passed in wxDb instance. If found, that cached connection is freed. Freeing a connection means that it is marked as available (free) in the cache of connections, so that a call to wxDbGetConnection (p. 267)is able to return a pointer to the wxDb instance for use. Freeing a connection does NOT close the connection, it only

267


CHAPTER 7
makes the connection available again. wxDb * wxDbGetConnection(wxDbConnectInf *pDbConfig,bool FwdOnlyCursors=(bool)wxODBC_FWD_ONLY_CURSORS) Remarks This function is used to request a "new" wxDb instance for use by the program. The wxDb instance returned is also opened (see wxDb::Open (p. 285)). This function (along with wxDbFreeConnection() and wxDbCloseConnection()) maintain a cached of wxDb instances for user/re-use by a program. When a program needs a wxDb instance, it may call this function to obtain a wxDb instance. If there is a wxDb instance in the cache that is currently unused that matches the connection requirements specified in 'pDbConfig' then that cached connection is marked as no longer being free, and a pointer to the wxDb instance is returned. If there are no connections available in the cache that meet the requirements given in 'pDbConfig', then a new wxDb instance is created to connect to the datasource specified in 'pDbConfig' using the userID and password given in 'pDbConfig'. NOTE: The caching routine also uses the wxDb::Open (p. 285)connection datatype copying code. If the call to wxDbGetConnection() requests a connection to a datasource, and there is not one available in the cache, a new connection is created. But when the connection is opened, instead of polling the datasource over again for its datatypes, if a connection to the same datasource (using the same userID/password) has already been done previously, the new connection skips querying the datasource for its datatypes, and uses the same datatypes determined previously by the other connection(s) for that same datasource. This cuts down greatly on network traffic, database load, and connection creation time. When the program is done using a connection created through a call to wxDbGetConnection(), the program should call wxDbFreeConnection() to release the wxDb instance back to the cache. DO NOT DELETE THE wxDb INSTANCE! Deleting the wxDb instance returned can cause a crash/memory corruption later in the program when the cache is cleaned up. When exiting the program, call wxDbCloseConnections() to close all the cached connections created by calls to wxDbGetConnection(). const wxChar * wxDbLogExtendedErrorMsg(const wxChar *userText, wxDb *pDb, wxChar *ErrFile, int ErrLine) Writes a message to the wxLog window (stdout usually) when an internal error situation occurs. This function only works in DEBUG builds bool wxDbSqlLog(wxDbSqlLogState state, const wxString &filename = SQL_LOG_FILENAME) Remarks This function sets the sql log state for all open wxDb objects bool wxDbGetDataSource(HENV henv, wxChar *Dsn, SWORD DsnMax, wxChar

268


CHAPTER 7
*DsDesc, SWORD DsDescMax, UWORD direction = SQL_FETCH_NEXT) Remarks This routine queries the ODBC driver manager for a list of available datasources. Repeatedly call this function to obtain all the datasources available through the ODBC driver manager on the current workstation.
wxStringList strList; while (wxDbGetDataSource(DbConnectInf.GetHenv(), Dsn, SQL_MAX_DSN_LENGTH+1, DsDesc, 255)) strList.Add(Dsn);

wxDb::wxDb
wxDb() Default constructor. wxDb(const HENV &aHenv, bool FwdOnlyCursors=(bool)wxODBC_FWD_ONLY_CURSORS) Constructor, used to create an ODBC connection to a datasource. Parameters aHenv Environment handle used for this connection. SeewxDConnectInf::AllocHenv (p. 296) FwdOnlyCursors Will cursors created for use with this datasource connection only allow forward scrolling cursors. Remarks This is the constructor for the wxDb class. The wxDb object must be created and opened before any database activity can occur. Example
wxDbConnectInf ConnectInf; ....Set values for member variables of ConnectInf here wxDb sampleDB(ConnectInf.GetHenv()); if (!sampleDB.Open(ConnectInf.GetDsn(), ConnectInf.GetUserID(), ConnectInf.GetPassword())) { // Error opening datasource }

See also

269


CHAPTER 7
wxDbGetConnection (p. 267)

wxDb::Catalog
bool Catalog(wxChar * userID, const wxString &fileName = SQL_CATALOG_FILENAME) Allows a data "dictionary" of the datasource to be created, dumping pertinent information about all data tables to which the user specified in userID has access. Parameters userID Database user name to use in accessing the database. All tables to which this user has rights will be evaluated in the catalog. fileName OPTIONAL. Name of the text file to create and write the DB catalog to. Default is SQL_CATALOG_FILENAME. Return value Returns true if the catalog request was successful, or false if there was some reason that the catalog could not be generated. Example
============== TABLE NAME ============== EMPLOYEE EMPLOYEE EMPLOYEE EMPLOYEE EMPLOYEE ============== COLUMN NAME ============== RECID USER_ID FULL_NAME PASSWORD START_DATE ================ ========= ======= DATA TYPE PRECISION LENGTH ================ ========= ======= (0008)NUMBER 15 8 (0012)VARCHAR2 13 13 (0012)VARCHAR2 26 26 (0012)VARCHAR2 26 26 (0011)DATE 19 16

wxDb::Close
void Close() Closes the database connection. Remarks At the end of your program, when you have finished all of your database work, you must close the ODBC connection to the datasource. There are actually four steps involved in doing this as illustrated in the example. Any wxDbTable instances which use this connection must be deleted before closing the database connection. Example

270


CHAPTER 7
// Commit any open transactions on the datasource sampleDB.CommitTrans(); // Delete any remaining wxDbTable objects allocated with new delete parts; // Close the wxDb connection when finished with it sampleDB.Close();

wxDb::CommitTrans
bool CommitTrans() Permanently "commits" changes (insertions/deletions/updates) to the database. Return value Returns true if the commit was successful, or false if the commit failed. Remarks Transactions begin implicitly as soon as you make a change to the database with an insert/update/delete, or any other direct SQL command that performs one of these operations against the datasource. At any time thereafter, to save the changes to disk permanently, "commit" them by calling this function. Calling this member function commits ALL open transactions on this ODBC connection. For example, if three different wxDbTable instances used the same connection to the datasource, committing changes made on one of those wxDbTable instances commits any pending transactions on all three wxDbTable instances. Until a call to wxDb::CommitTrans() is made, no other user or cursor is able to see any changes made to the row(s) that have been inserted/modified/deleted. Special Note : Cursors It is important to understand that different database/ODBC driver combinations handle transactions differently. One thing in particular that you must pay attention to is cursors, in regard to transactions. Cursors are what allow you to scroll through records forward and backward and to manipulate records as you scroll through them. When you issue a query, a cursor is created behind the scenes. The cursor keeps track of the query and keeps track of the current record pointer. After you commit or rollback a transaction, the cursor may be closed automatically. This is database dependent, and with some databases this behavior can be controlled through management functions. This means you would need to requery the datasource before you can perform any additional work using this cursor. This is only necessary however if the datasource closes the cursor after a commit or rollback. Use thewxDbTable::IsCursorClosedOnCommit (p. 321)member function to determine the datasource's transaction behavior. Note, in many situations it is very inefficient to assume the cursor is closed and always requery. This could put a significant, unnecessary load on datasources that leave the cursors open after a transaction.

271


CHAPTER 7 wxDb::CreateView
bool CreateView(const wxString & viewName,const wxString & colList, const wxString &pSqlStmt) Creates a SQL VIEW of one or more tables in a single datasource. Note that this function will only work against databases which support views (currently only Oracle as of November 21 2000). Parameters viewName The name of the view. e.g. PARTS_V colList OPTIONAL Pass in a comma delimited list of column names if you wish to explicitly name each column in the result set. If not desired, pass in an empty string and the column names from the associated table(s) will be used. pSqlStmt Pointer to the select statement portion of the CREATE VIEW statement. Must be a complete, valid SQL SELECT statement. Remarks A 'view' is a logical table that derives columns from one or more other tables or views. Once the view is created, it can be queried exactly like any other table in the database. NOTE: Views are not available with all datasources. Oracle is one example of a datasource which does support views. Example
// Incomplete code sample db.CreateView("PARTS_SD1", "PN, PD, QTY", "SELECT PART_NO, PART_DESC, QTY_ON_HAND * 1.1 FROM PARTS \ WHERE STORAGE_DEVICE = 1"); // PARTS_SD1 can now be queried just as if it were a data table. // e.g. SELECT PN, PD, QTY FROM PARTS_SD1

wxDb::Dbms
wxDBMS Dbms() Remarks The return value will be of the enumerated type wxDBMS. This enumerated type contains a list of all the currently tested and supported databases. Additional databases may work with these classes, but the databases returned by this

272


CHAPTER 7
function have been tested and confirmed to work with these ODBC classes. Possible values returned by this function can be viewed in theEnumerated types (p. 263) section of wxDb. There are known issues with conformance to the ODBC standards with several datasources supported by the wxWindows ODBC classes. Please see the overview for specific details on which datasource have which issues. Return value The return value will indicate which of the supported datasources is currently connected to by this connection. In the event that the datasource is not recognized, a value of 'dbmsUNIDENTIFIED' is returned.

wxDb::DispAllErrors
bool DispAllErrors(HENV aHenv, HDBC aHdbc = SQL_NULL_HDBC, HSTMT aHstmt = SQL_NULL_HSTMT) Used to log all database errors that occurred as a result of an executed database command. This logging is automatic and also includes debug logging when compiled in debug mode via wxLogDebug (p. 1523). If logging is turned on via wxDb::SetSqlLogging (p. 287), then an entry is also logged to the defined log file. Parameters aHenv Handle to the ODBC environment. aHdbc Handle to the ODBC connection. Pass this in if the ODBC function call that erred required a hdbc or hstmt argument. aHstmt Handle to the ODBC statement being executed against. Pass this in if the ODBC function call that failed required a hstmt argument. Remarks This member function will log all of the ODBC error messages for the last ODBC function call that was made. This function is normally used internally within the ODBC class library, but can be used programmatically after calling ODBC functions directly (i.e. SQLFreeEnv()). Return value The function always returns false, so a call to this function can be made in the return statement of a code block in the event of a failure to perform an action (see the example below).

273


CHAPTER 7
See also wxDb::SetSqlLogging (p. 287), wxDbSqlLog Example
if (SQLExecDirect(hstmt, (UCHAR FAR *) pSqlStmt, SQL_NTS) != SQL_SUCCESS) // Display all ODBC errors for this stmt return(db.DispAllErrors(db.henv, db.hdbc, hstmt));

wxDb::DispNextError
void DispNextError() Remarks This function is normally used internally within the ODBC class library. It could be used programmatically after calling ODBC functions directly. This function works in conjunction with wxDb::GetNextError (p. 280) when errors (or sometimes informational messages) returned from ODBC need to be analyzed rather than simply displaying them as an error. GetNextError() retrieves the next ODBC error from the ODBC error queue. The wxDb member variables "sqlState", "nativeError" and "errorMsg" could then be evaluated. To display the error retrieved, DispNextError() could then be called. The combination of GetNextError() and DispNextError() can be used to iteratively step through the errors returned from ODBC evaluating each one in context and displaying the ones you choose. Example
// Drop the table before attempting to create it sprintf(sqlStmt, "DROP TABLE %s", tableName); // Execute the drop table statement if (SQLExecDirect(hstmt,(UCHAR FAR *)sqlStmt,SQL_NTS) != SQL_SUCCESS) { // Check for sqlState = S0002, "Table or view not found". // Ignore this error, bomb out on any other error. pDb->GetNextError(henv, hdbc, hstmt); if (wxStrcmp(pDb->sqlState, "S0002")) { pDb->DispNextError(); // Displayed error retrieved pDb->DispAllErrors(henv, hdbc, hstmt); // Display all other errors, if any pDb->RollbackTrans(); // Rollback the transaction CloseCursor(); // Close the cursor return(false); // Return Failure } }

wxDb::DropView
bool DropView(const wxString &viewName) Drops the data table view named in 'viewName'. Parameters

274


CHAPTER 7
viewName Name of the view to be dropped. Remarks If the view does not exist, this function will return true. Note that views are not supported with all datasources.

wxDb::ExecSql
bool ExecSql(const wxString &pSqlStmt) Allows a native SQL command to be executed directly against the datasource. In addition to being able to run any standard SQL command, use of this function allows a user to (potentially) utilize features specific to the datasource they are connected to that may not be available through ODBC. The ODBC driver will pass the specified command directly to the datasource. Parameters pSqlStmt Pointer to the SQL statement to be executed. Remarks This member extends the wxDb class and allows you to build and execute ANY VALID SQL statement against the datasource. This allows you to extend the class library by being able to issue any SQL statement that the datasource is capable of processing. See also wxDb::GetData (p. 278), wxDb::GetNext (p. 280)

wxDb::FwdOnlyCursors
bool IsFwdOnlyCursors() Older form (pre-2.3/2.4 of wxWindows) of thewxDb::IsFwdOnlyCursors (p. 282). This method is provided for backward compatibility only. The methodwxDb::IsFwdOnlyCursors (p. 282) should be used in place of this method. wxDbInf * GetCatalog(const wxChar *userID)

wxDb::GetCatalog
wxDbInf * GetCatalog(const wxChar *userID) Returns a wxDbInf (p. 300) pointer that points to the catalog (datasource) name,

275


CHAPTER 7
schema, number of tables accessible to the current user, and a wxDbTableInf pointer to all data pertaining to all tables in the users catalog. Parameters userID Owner/Schema of the table. Specify a userID when the datasource you are connected to allows multiple unique tables with the same name to be owned by different users. userID is evaluated as follows:
userID == NULL userID == "" userID != "" ... UserID is ignored (DEFAULT) ... UserID set equal to 'this->uid' ... UserID set equal to 'userID'

Remarks The returned catalog will only contain catalog entries for tables to which the user specified in 'userID' has sufficient privileges. If no user is specified (NULL passed in), a catalog pertaining to all tables in the datasource accessible to the connected user (permissions apply) via this connection will be returned.

wxDb::GetColumnCount
int GetColumnCount(const wxString &tableName, const wxChar *userID) Parameters tableName The table name you wish to obtain column information about. userID Name of the user that owns the table(s) (also referred to as schema). Required for some datasources for situations where there may be multiple tables with the same name in the datasource, but owned by different users. userID is evaluated in the following manner:
userID == NULL userID == "" userID != "" ... UserID is ignored (DEFAULT) ... UserID set equal to 'this->uid' ... UserID set equal to 'userID'

Return value Returns a count of how many columns are in the specified table. If an error occurs retrieving the number of columns, this function will return a -1.

wxDb::GetColumns
wxDbColInf * GetColumns(const wxString &tableName, UWORD *numCols, const wxChar *userID=NULL)

276


CHAPTER 7
wxDbColInf * GetColumns(wxChar *tableName[], const wxChar *userID) Parameters tableName The table name you wish to obtain column information about. numCols Pointer to a UWORD which will hold a count of the number of columns returned by this function tableName[] An array of pointers to table names you wish to obtain column information about. The last element of this array must be a NULL string. userID Name of the user that owns the table(s) (also referred to as schema). Required for some datasources for situations where there may be multiple tables with the same name in the datasource, but owned by different users. userID is evaluated in the following manner:
userID == NULL userID == "" userID != "" ... UserID is ignored (DEFAULT) ... UserID set equal to 'this->uid' ... UserID set equal to 'userID'

Return value This function returns a pointer to an array of wxDbColInf (p. 293)structures, allowing you to obtain information regarding the columns of the named table(s). If no columns were found, or an error occurred, this pointer will be NULL. THE CALLING FUNCTION IS RESPONSIBLE FOR DELETING THE wxDbColInf MEMORY WHEN IT IS FINISHED WITH IT. ALL column bindings associated with this wxDb instance are unbound by this function, including those used by any wxDbTable instances that use this wxDb instance. This function should use its own wxDb instance to avoid undesired unbinding of columns. See also wxDbColInf (p. 293) Example
wxChar *tableList[] = {"PARTS", 0}; wxDbColInf *colInf = pDb->GetColumns(tableList); if (colInf) { // Use the column inf ....... // Destroy the memory delete [] colInf; }

277


CHAPTER 7

wxDb::GetData
bool GetData(UWORD colNo, SWORD cType,PTR pData, SDWORD maxLen, SDWORD FAR * cbReturned ) Used to retrieve result set data without binding column values to memory variables (i.e. not using a wxDbTable instance to access table data). Parameters colNo Ordinal number of the desired column in the result set to be returned. cType The C data type that is to be returned. See a partial list in wxDbTable::SetColDefs (p. 328) pData Memory buffer which will hold the data returned by the call to this function. maxLen Maximum size of the buffer 'pData' in characters. NOTE: Not UNICODE safe. If this is a numeric field, a value of 0 may be passed for this parameter, as the API knows the size of the expected return value. cbReturned Pointer to the buffer containing the length of the actual data returned. If this value comes back as SQL_NULL_DATA, then thewxDb::GetData (p. 278) call has failed. See also wxDb::GetNext (p. 280), wxDb::ExecSql (p. 275) Example
SDWORD cb; ULONG reqQty; wxString sqlStmt; sqlStmt = "SELECT SUM(REQUIRED_QTY - PICKED_QTY) FROM ORDER_TABLE WHERE \ PART_RECID = 1450 AND REQUIRED_QTY > PICKED_QTY"; // Perform the query if (!pDb->ExecSql(sqlStmt.c_str())) { // ERROR return(0); } // Request the first row of the result set if (!pDb->GetNext()) { // ERROR

278


CHAPTER 7
return(0); } // Read column #1 of the row returned by the call to ::GetNext() // and return the value in 'reqQty' if (!pDb->GetData(1, SQL_C_ULONG, &reqQty, 0, &cb)) { // ERROR return(0); } // Check for a NULL result if (cb == SQL_NULL_DATA) return(0);

Remarks When requesting multiple columns to be returned from the result set (for example, the SQL query requested 3 columns be returned), the calls to this function must request the columns in ordinal sequence (1,2,3 or 1,3 or 2,3).

wxDb::GetDatabaseName
const wxChar * GetDatabaseName() Returns the name of the database engine.

wxDb::GetDatasourceName
const wxString & GetDatasourceName() Returns the ODBC datasource name.

wxDb::GetHDBC
HDBC GetHDBC() Returns the ODBC handle to the database connection.

wxDb::GetHENV
HENV GetHENV() Returns the ODBC environment handle.

wxDb::GetHSTMT
HSTMT GetHSTMT() Returns the ODBC statement handle associated with this database connection.

279


CHAPTER 7 wxDb::GetKeyFields
int GetKeyFields(const wxString &tableName, wxDbColInf *colInf, UWORD nocols) Used to determine which columns are members of primary or non-primary indexes on the specified table. If a column is a member of a foreign key for some other table, that information is detected also. This function is primarily for use by the wxDb::GetColumns (p. 276) function, but may be called if desired from the client application. Parameters tableName Name of the table for which the columns will be evaluated as to their inclusion in any indexes. colInf Data structure containing the column definitions (obtained with wxDb::GetColumns (p. 276)). This function populates the PkCol, PkTableName, and FkTableName members of the colInf structure. nocols Number of columns defined in the instance of colInf. Return value Currently always returns true. See also wxDbColInf (p. 293), wxDb::GetColumns (p. 276)

wxDb::GetNext
bool GetNext() Called after executing a query, this function requests the next row in the result set after the current position of the cursor. See also wxDb::ExecSql (p. 275), wxDb::GetData (p. 278)

wxDb::GetNextError
bool GetNextError(HENV aHenv,HDBC aHdbc = SQL_NULL_HDBC, HSTMT aHstmt = SQL_NULL_HSTMT)

280


CHAPTER 7
Parameters aHenv A handle to the ODBC environment. aHdbc OPTIONAL. A handle to the ODBC connection. Pass this in if the ODBC function call that failed required a hdbc or hstmt argument. AHstmt OPTIONAL.A handle to the ODBC statement being executed against. Pass this in if the ODBC function call that failed requires a hstmt argument. Example
if (SQLExecDirect(hstmt, (UCHAR FAR *) pSqlStmt, SQL_NTS) != SQL_SUCCESS) { return(db.GetNextError(db.henv, db.hdbc, hstmt)); }

See also wxDb::DispNextError (p. 274),wxDb::DispAllErrors (p. 273)

wxDb::GetPassword
const wxString & GetPassword() Returns the password used to establish this connection to the datasource.

wxDb::GetTableCount
int GetTableCount() Returns the number of wxDbTable() instances currently using this datasource connection.

wxDb::GetUsername
const wxString & GetUsername() Returns the user name (uid) used to establish this connection to the datasource.

wxDb::Grant
bool Grant(int privileges, const wxString &tableName,const wxString &userList =

281


CHAPTER 7
"PUBLIC") Use this member function to GRANT privileges to users for accessing tables in the datasource. Parameters privileges Use this argument to select which privileges you want to grant. Pass DB_GRANT_ALL to grant all privileges. To grant individual privileges pass one or more of the following OR'd together:
DB_GRANT_SELECT DB_GRANT_INSERT DB_GRANT_UPDATE DB_GRANT_DELETE DB_GRANT_ALL = = = = = 1 2 4 8 DB_GRANT_SELECT | DB_GRANT_INSERT | DB_GRANT_UPDATE | DB_GRANT_DELETE

tableName The name of the table you wish to grant privileges on. userList OPTIONAL. A comma delimited list of users to grant the privileges to. If this argument is not passed in, the privileges will be given to the general PUBLIC. Remarks Some databases require user names to be specified in all capital letters (i.e. Oracle). This function does not automatically capitalize the user names passed in the commaseparated list. This is the responsibility of the calling routine. The currently logged in user must have sufficient grantor privileges for this function to be able to successfully grant the indicated privileges. Example
db.Grant(DB_GRANT_SELECT | DB_GRANT_INSERT, "PARTS", "mary, sue");

wxDb::IsFwdOnlyCursors
bool IsFwdOnlyCursors() This setting indicates whether this database connection was created as being capable of using only forward scrolling cursors. This function does NOT indicate if the ODBC driver or datasource supports backward scrolling cursors. There is no standard way of detecting if the driver or datasource can support backward scrolling cursors. If a wxDb instance was created as being capable of only forward scrolling cursors, then even if the datasource and ODBC driver support backward scrolling cursors, tables

282


CHAPTER 7
using this database connection would only be able to use forward scrolling cursors. The default setting of whether a wxDb connection to a database allows forward-only or also backward scrolling cursors is defined in setup.h by the value of wxODBC_FWD_ONLY_CURSORS. This default setting can be overridden when the wxDb connection is initially created (seewxDb constructor (p. 269) and wxDbGetConnection (p. 267)). Return value Returns true if this datasource connection is defined as using only forward scrolling cursors, or false if the connection is defined as being allowed to use backward scrolling cursors and their associated functions (see note above). Remarks Added as of wxWindows v2.4 release, this function is a renamed version of wxDb::FwdOnlyCursors() to match the normal wxWindows naming conventions for class member functions. This function is not available in versions prior to v2.4. You should use wxDb::FwdOnlyCursors (p. 275) for wxWindows versions prior to 2.4. See also wxDb constructor (p. 269), wxDbGetConnection (p. 267)

wxDb::IsOpen
bool IsOpen() Indicates whether the database connection to the datasource is currently opened. Remarks This function may indicate that the database connection is open, even if the call to wxDb::Open (p. 285) may have failed to fully initialize the connection correctly. The connection to the databaseis open and can be used via the direct SQL commands, if this function returns true. Other functions which depend on thewxDb::Open (p. 285) to have completed correctly may not function as expected. The return result from wxDb::Open (p. 285) is the only way to know if complete initialization of this wxDb connection was successful or not. See wxDb::Open (p. 285) for more details on partial failures to open a connection instance.

wxDb::LogError
void LogError(const wxString &errMsg const wxString &SQLState="") errMsg Free-form text to display describing the error/text to be logged.

283


CHAPTER 7
SQLState OPTIONAL. Native SQL state error. Default is 0. Remarks Calling this function will enter a log message in the error list maintained for the database connection. This log message is free form and can be anything the programmer wants to enter in the error list. If SQL logging is turned on, the call to this function will also log the text into the SQL log file. See also wxDb::WriteSqlLog (p. 291)

wxDb::ModifyColumn
void ModifyColumn(const wxString &tableName const wxString &ColumnNameint dataType ULONG columnLength=0 const wxString &optionalParam="") Used to change certain properties of a column such as the length, or whether a column allows NULLs or not. tableName Name of the table that the column to be modified is in. columnName Name of the column to be modified. NOTE: Name of column cannot be changed with this function. dataType Any one of DB_DATA_TYPE_VARCHAR, DB_DATA_TYPE_INTEGER, DB_DATA_TYPE_FLOAT, DB_DATA_TYPE_DATE. columnLength New size of the column. Valid only for DB_DATA_TYPE_VARCHAR dataType fields. Default is 0. optionalParam Default is "". Remarks Cannot be used to modify the precision of a numeric column, therefore 'columnLength' is ignored unless the dataType is DB_DATA_TYPE_VARCHAR. Some datasources do not allow certain properties of a column to be changed if any rows

284


CHAPTER 7
currently have data stored in that column. Those datasources that do allow columns to be changed with data in the rows many handle truncation and/or expansion in different ways. Please refer to the reference material for the datasource being used for behavioral descriptions. Example
ok = pDb->ModifyColumn("CONTACTS", "ADDRESS2", DB_, colDefs[j].SzDataObj, wxT("NOT NULL"));

wxDb::Open
bool Open(const wxString &Dsn, const wxString &Uid,const wxString &AuthStr) bool Open(wxDb *copyDb) Opens a connection to the datasource, sets certain behaviors of the datasource to confirm to the accepted behaviors (e.g. cursor position maintained on commits), and queries the datasource for its representations of the basic datatypes to determine the form in which the data going to/from columns in the data tables are to be handled. The second form of this function, which accepts a "wxDb *" as a parameter, can be used to avoid the overhead (execution time, database load, network traffic) which are needed to determine the data types and representations of data that are necessary for crossdatasource support by these classes. Normally the first form of the wxDb::Open() function will open the connection and then send a series of queries to the datasource asking it for its representation of data types, and all the features it supports. If one connection to the datasource has already been made previously, the information gathered when that connection was created can just be copied to any new connections to the same datasource by passing a pointer to the first connection in as a parameter to the wxDb::Open() function. Note that this new connection created from the first connections information will use the same Dsn/Uid/AuthStr as the first connection used. Parameters Dsn datasource name. The name of the ODBC datasource as assigned when the datasource is initially set up through the ODBC data source manager. Uid User ID. The name (ID) of the user you wish to connect as to the datasource. The user name (ID) determines what objects you have access to in the datasource and what datasource privileges you have. Privileges include being able to create new objects, update objects, delete objects and so on. Users and privileges are normally administered by the database administrator. AuthStr

285


CHAPTER 7
The password associated with the Uid. copyDb Already completely configured and opened datasource connection from which all Dsn, Uid, AuthStr, and data typing information is to be copied from for use by this datasource connection. Remarks After a wxDb instance is created, it must then be opened. When opening a datasource, there must be three pieces of information passed. The data source name, user name (ID) and the password for the user. No database activity on the datasource can be performed until the connection is opened. This is normally done at program startup and the datasource remains open for the duration of the program/module run. It is possible to have connections to multiple datasources open at the same time to support distributed database connections by having separate instances of wxDb objects that use either the same or different Dsn/Uid/AuthStr settings. If this function returns a value of false, it does not necessarily mean that the connection to the datasource was not opened. It may mean that some portion of the initialization of the connection failed (such as a datatype not being able to be determined how the datasource represents it). To determine if the connection to the database failed, use the wxDb::IsOpen (p. 283)function after receiving a false result back from this function to determine if the connection was opened or not. If this function returns false, but wxDb::IsOpen (p. 283)returns true, then direct SQL commands may be passed to the database connection and can be successfully executed, but use of the datatypes (such as by a wxDbTable instance) that are normally determined during open will not be possible. The Dsn, Uid, and AuthStr string pointers that are passed in are copied. NOT the strings themselves, only the pointers. The calling routine must maintain the memory for these three strings for the life of the wxDb instance. Example
wxDb sampleDB(DbConnectInf.GetHenv()); if (!sampleDB.Open("Oracle 7.1 HP/UX", "gtasker", "myPassword")) { if (sampleDb.IsOpen()) { // Connection is open, but the initialization of // datatypes and parameter settings failed } else { // Error opening datasource } }

wxDb::RollbackTrans
bool RollbackTrans()

286


CHAPTER 7
Function to "undo" changes made to the database. After an insert/update/delete, the operation may be "undone" by issuing this command any time before a wxDb::CommitTrans (p. 271) is called on the database connection. Remarks Transactions begin implicitly as soon as you make a change to the database. The transaction continues until either a commit or rollback is executed. Calling wxDb::RollbackTrans() will result in ALL changes done using this database connection that have not already been committed to be "undone" back to the last commit/rollback that was successfully executed. Calling this member function rolls back ALL open (uncommitted) transactions on this ODBC connection, including all wxDbTable instances that use this connection. See also wxDb::CommitTrans (p. 271) for a special note on cursors

wxDb::SetDebugErrorMessages
void SetDebugErrorMessages(bool state) s ta te Either true (debug messages are logged) or false (debug messages are not logged). Remarks Turns on/off debug error messages from the ODBC class library. When this function is passed true, errors are reported to the user/logged automatically in a text or pop-up dialog when an ODBC error occurs. When passed false, errors are silently handled. When compiled in release mode (FINAL=1), this setting has no affect. See also wxDb constructor (p. 269)

wxDb::SetSqlLogging
bool SetSqlLogging(wxDbSqlLogState state, const wxString &filename = SQL_LOG_FILENAME, bool append = false) Parameters state Either sqlLogOFF or sqlLogON (see enum wxDbSqlLogState (p. 293)). Turns logging of SQL commands sent to the datasource OFF or ON.

287


CHAPTER 7
filename OPTIONAL. Name of the file to which the log text is to be written. Default is SQL_LOG_FILENAME. append OPTIONAL. W hether the file is appended to or overwritten. Default is false. Remarks When called with sqlLogON, all commands sent to the datasource engine are logged to the file specified by filename. Logging is done by embedded wxDb::WriteSqlLog (p. 291) calls in the database member functions, or may be manually logged by adding calls to wxDb::WriteSqlLog (p. 291) in your own source code. When called with sqlLogOFF, the logging file is closed, and any calls to wxDb::WriteSqlLog (p. 291) are ignored.

wxDb::SQLColumnName
const wxString SQLColumnName(const char * colName) Returns the column name in a form ready for use in SQL statements. In most cases, the column name is returned verbatim. But some databases (e.g. MS Access, SQL Server, MSDE) allow for spaces in column names, which must be specially quoted. For example, if the datasource allows spaces in the column name, the returned string will have the correct enclosing marks around the name to allow it to be properly included in a SQL statement for the DBMS that is currently connected to with this connection. Parameters colName Native name of the column in the table that is to be evaluated to determine if any special quoting marks needed to be added to it before including the column name in a SQL statement See also wxDb::SQLTableName (p. 288)

wxDb::SQLTableName
const wxString SQLTableName(const char * tableName) Returns the table name in a form ready for use in SQL statements. In most cases, the table name is returned verbatim. But some databases (e.g. MS Access, SQL Server, MSDE) allow for spaces in table names, which must be specially quoted. For example, if the datasource allows spaces in the table name, the returned string will have the correct enclosing marks around the name to allow it to be properly included in a SQL

288


CHAPTER 7
statement for the data source that is currently connected to with this connection. Parameters tableName Native name of the table that is to be evaluated to determine if any special quoting marks needed to be added to it before including the table name in a SQL statement See also wxDb::SQLColumnName (p. 288)

wxDb::TableExists
bool TableExists(const wxString &tableName, const wxChar *userID=NULL, const wxString &path="") Checks the ODBC datasource for the existence of a table. If a userIDis specified, then the table must be accessible by that user (user must have at least minimal privileges to the table). Parameters tableName Name of the table to check for the existence of. userID Owner of the table (also referred to as schema). Specify a userID when the datasource you are connected to allows multiple unique tables with the same name to be owned by different users. userIDis evaluated as follows:
userID == NULL userID == "" userID != "" ... UserID is ignored (DEFAULT) ... UserID set equal to 'this->uid' ... UserID set equal to 'userID'

Remarks tableName may refer to a table, view, alias or synonym. This function does not indicate whether or not the user has privileges to query or perform other functions on the table. Use the wxDb::TablePrivileges (p. 289) to determine if the user has sufficient privileges or not. See also wxDb::TablePrivileges (p. 289)

wxDb::TablePrivileges

289


CHAPTER 7
bool TablePrivileges(const wxString &tableName, const wxString &priv,const wxChar *userID=NULL, const wxChar *schema=NULL,const wxString &path="") Checks the ODBC datasource for the existence of a table. If a userIDis specified, then the table must be accessible by that user (user must have at least minimal privileges to the table). Parameters tableName Name of the table on which to check privileges.tableName may refer to a table, view, alias or synonym. priv The table privilege being evaluated. May be one of the following (or a datasource specific privilege):
SELECT INSERT : The connected user is permitted to retrieve data for one or more columns of the table. : The connected user is permitted to insert new rows containing data for one or more columns into the table. : The connected user is permitted to update the data in one or more columns of the table. : The connected user is permitted to delete rows of data from the table. : Is the connected user permitted to refer to one or more columns of the table within a constraint (for example, a unique, referential, or table check constraint).

UPDATE DELETE REFERENCES

userID OPTIONAL. User for which to determine if the privilege specified to be checked is granted or not. Default is "".userID is evaluated as follows:
userID == NULL userID == "" userID != "" ... NOT ALLOWED! ... UserID set equal to 'this->uid' ... UserID set equal to 'userID'

schema OPTIONAL. Owner of the table. Specify a userID when the datasource you are connected to allows multiple unique tables with the same name to be owned by different users. Specifying the table owner makes determination of the users privileges MUCH faster. Default is NULL. userID is evaluated as follows:
schema == NULL schema == "" schema != "" ... Any owner (DEFAULT) ... Owned by 'this->uid' ... Owned by userID specified in 'schema'

path OPTIONAL. Path to the table. Default is "". Currently unused.

290


CHAPTER 7
Remarks The scope of privilege allowed to the connected user by a given table privilege is datasource dependent. For example, the privilege UPDATE might allow the connected user to update all columns in a table on one datasource, but only those columns for which the grantor (the user that granted the connected user) has the UPDATE privilege on another datasource. Looking up a user's privileges to a table can be time consuming depending on the datasource and ODBC driver. This time can be minimized by passing a schemaas a parameter. With some datasources/drivers, the difference can be several seconds of time difference.

wxDb::TranslateSqlState
int TranslateSqlState(const wxString &SQLState) Converts an ODBC sqlstate to an internal error code. Parameters SQLState State to be converted. Return value Returns the internal class DB_ERR code. See wxDb::DB_STATUS (p. 263) definition.

wxDb::WriteSqlLog
bool WriteSqlLog(const wxString &logMsg) Parameters logMsg Free form string to be written to the log file. Remarks Very useful debugging tool that may be turned on/off during run time (see (see wxDb::SetSqlLogging (p. 287) for details on turning logging on/off). The passed in string logMsg will be written to a log file if SQL logging is turned on. Return value If SQL logging is off when a call to WriteSqlLog() is made, or there is a failure to write the log message to the log file, the function returns false without performing the requested log, otherwise true is returned.

291


CHAPTER 7
See also wxDb::SetSqlLogging (p. 287)

wxDbColDataPtr
Pointer to dynamic column definitions for use with a wxDbTable instance. Currently there are no member functions for this class. See the database classes overview (p. 1668) for an introduction to using the ODBC classes.
void int SWORD *PtrDataObj; SzDataObj; SqlCtype;

wxDbColDef
This class is used to hold information about the columns bound to an instance of a wxDbTable object. Each instance of this class describes one column in the wxDbTable object. When calling the wxDb constructor (p. 269), a parameter passed in indicates the number of columns that will be defined for the wxDbTable object. The constructor uses this information to allocate adequate memory for all of the column descriptions in your wxDbTable object. Private member wxDbTable::colDefs is a pointer to this chunk of memory maintained by the wxDbTable class (and can be retrieved using thewxDbTable::GetColDefs (p. 315) function). To access the nth column definition of your wxDbTable object, just reference wxDbColDefs element [n - 1]. Typically, wxDbTable::SetColDefs (p. 328) is used to populate an array of these data structures for the wxDbTable instance. Currently there are no accessor functions for this class, so all members are public.
wxChar int ColName[DB_MAX_COLUMN_NAME_LEN+1]; // Column Name DbDataType; - Logical Data Type; e.g. DB_DATA_TYPE_INTEGER SWORD SqlCtype; - C data type; e.g. SQL_C_LONG void *PtrDataObj; - Address of the data object int SzDataObj; - Size, in bytes, of the data object bool KeyField; - Is column part of the PRIMARY KEY for the table? -- Date fields should NOT be KeyFields bool Updateable; - Column is updateable? bool InsertAllowed; - Column included in INSERT statements? bool DerivedCol; - Column is a derived value? SDWORD CbValue; - !!!Internal use only!!! bool Null; - NOT FULLY IMPLEMENTED Allows NULL values in Inserts and Updates

See also database classes overview (p. 1668),wxDbTable::GetColDefs (p. 315), wxDb constructor

292


CHAPTER 7
(p. 269)

wxDbColDef::Initialize
Simply initializes all member variables to a cleared state. Called by the constructor automatically.

wxDbColFor
Beginning support for handling international formatting specifically on dates and floats.
wxString wxString wxString int int s_Field; s_Format[7]; s_Amount[7]; i_Amount[7]; i_Nation; // Formated String for Output // Formated Objects - TIMESTAMP has the biggest (7) // Formated Objects - amount of things that can be formatted // Formated Objects TT MM YYYY HH MM SS m // 0 = timestamp 1 = EU 2 = UK 3 = International 4 = US // conversion of the 'sqlDataType' to the generic data type used by these classes

int SWORD

i_dbDataType; i_sqlDataType;

The constructor for this class initializes all the values to zero or NULL. The destructor does nothing at this time. Only one function is provided with this class currently. See the database classes overview (p. 1668) for an introduction to using the ODBC classes.

wxDbColFor::Format
int Format(int Nation, int dbDataType,SWORD sqlDataType, short columnSize,short decimalDigits) Work in progress, and should be inter-related with wxLocale eventually.

wxDbColFor::Initialize
Simply initializes all member variables to a cleared state. Called by the constructor automatically.

wxDbColInf
293


CHAPTER 7
Used with the wxDb::GetColumns (p. 276) functions for obtaining all retrievable information about a column's definition.
wxChar wxChar wxChar wxChar SWORD wxChar SWORD SWORD short short short wxChar int int catalog[128+1]; schema[128+1]; tableName[DB_MAX_TABLE_NAME_LEN+1]; colName[DB_MAX_COLUMN_NAME_LEN+1]; sqlDataType; typeName[128+1]; columnSize; bufferLength; decimalDigits; numPrecRadix; nullable; remarks[254+1]; dbDataType; // conversion of the 'sqlDataType' // to the generic data type used by // these classes PkCol; // Primary key column 0 = No 1 = First Key 2 = Second Key, etc... PkTableName[DB_MAX_TABLE_NAME_LEN+1]; // Tables that use this PKey as a FKey FkCol; // Foreign key column 0 = No 1 = First Key 2 = Second Key, etc... FkTableName[DB_MAX_TABLE_NAME_LEN+1]; // Foreign key table name *pColFor; // How should this column be formatted

wxChar int

wxChar wxDbColFor

The constructor for this class initializes all the values to zero, "", or NULL. The destructor for this class takes care of deleting the pColFor member if it is non-NULL. See the database classes overview (p. 1668) for an introduction to using the ODBC classes.

wxDbColInf::Initialize
Simply initializes all member variables to a cleared state. Called by the constructor automatically.

wxDbConnectInf
This class is used for holding the data necessary for connecting to the ODBC datasource. That information includes: SQL environment handle, datasource name, user ID, password and default directory path (used with dBase). Other optional fields held in this class are and file type, both for future functions planned to be added for creating/manipulating datasource definitions.

wxDbConnectInf::wxDbConnectInf
wxDbConnectInf()

294


CHAPTER 7
Default constructor. wxDbConnectInf(HENV henv, const wxString &dsn,const wxString &userID="", const wxString &password,const wxString &defaultDir="", const wxString &description="",const wxString &fileType="") Constructor which allows initial settings of all the classes member variables. See the special note below on the henv parameter for forcing this constructor to create a SQL environment handle automatically, rather than needing to pass one in to the function. Parameters henv Environment handle used for this connection. SeewxDConnectInf::AllocHenv (p. 296) for how to create an SQL environment handle. NOTE: Passing in a NULL for this parameter will inform the constructor that it should create its own SQL environment handle. If NULL is passed for this parameter, the constructor will callwxDConnectInf::AllocHenv (p. 296) internally. A flag is set internally also to indicate that the HENV was created by the constructor so that when the default class destructor is called, the destructor will call wxDConnectInf::FreeHenv (p. 296)to free the environment handle automatically. dsn Name of the datasource to be used in creating wxDb instances for creating connection(s) to a datasource. userID OPTIONAL Many datasources allow (or even require) use of a username to determine privileges that connecting user is allowed to have when accessing the datasource or the data tables. Default is "". password OPTIONAL Password to be associated with the user ID specified in 'userID'. Default is "". defaultDir OPTIONAL Used for datasources which require the path to where the data file is stored to be specified. dBase is one example of the type of datasource which requires this information. Default is "". description OPTIONAL FUTURE USE Default is "". fileType OPTIONAL FUTURE USE Default is "".

295


CHAPTER 7
Remarks It is strongly recommended that programs use the longer form of the constructor and allow the constructor to create the SQL environment handle automatically, and manage the destruction of the handle. Example
wxDbConnectInf *DbConnectInf; DbConnectInf = new wxDbConnectInf(0,"MY_DSN", "MY_USER", "MY_PASSWORD"); ....the rest of the program delete DbConnectInf;

See also wxDConnectInf::AllocHenv (p. 296),wxDConnectInf::FreeHenv (p. 296)

wxDbConnectInf::~wxDbConnectInf
~wxDbConnectInf() Handles the default destruction of the instance of the class. If the long form of the wxDConnectInf (p. 294) was used, then this destructor also takes care of callingwxDConnectInf::FreeHenv (p. 296) to free the SQL environment handle.

wxDbConnectInf::AllocHenv
bool AllocHenv() Allocates a SQL environment handle that will be used to interface with an ODBC datasource. Remarks This function can be automatically called by the long from of thewxDbConnectInf (p. 294) constructor.

wxDbConnectInf::FreeHenv
void FreeHenv() Frees the SQL environment handle being managed by the instance of this class. Remarks If the SQL environment handle was created using the long form of thewxDbConnectInf (p. 294) constructor, then the flag indicating that the HENV should be destroyed when the classes destructor is called is reset to be false, so that any future handles created using thewxDbConnectInf::AllocHenv (p. 296) function must be manually released with a

296


CHAPTER 7
call to this function.

wxDbConnectInf::Initialize
Simply initializes all member variables to a cleared state. Called by the constructor automatically.

wxDbConnectInf::GetAuthStr
const wxChar * GetAuthStr() Accessor function to return the password assigned for this class instance that will be used with the user ID. Synonymous with wxDbConnectInf::GetPassword (p. 298)

wxDbConnectInf::GetDefaultDir
const wxChar * GetDefaultDir() Accessor function to return the default directory in which the datasource's data table is stored. This directory is only used for file based datasources like dBase. MS-Access does not require this to be set, as the path is set in the ODBC Administrator for MSAccess.

wxDbConnectInf::GetDescription
const wxChar * GetDescription() Accessor function to return the description assigned for this class instance. NOTE: Description is a FUTURE USE item and is unused currently.

wxDbConnectInf::GetDsn
const wxChar * GetDsn() Accessor function to return the datasource name assigned for this class instance.

wxDbConnectInf::GetFileType
const wxChar * GetFileType() Accessor function to return the filetype of the ODBC datasource assigned for this class instance.

297


CHAPTER 7
NOTE: FileType is a FUTURE USE item and is unused currently.

wxDbConnectInf::GetHenv
const HENV GetHenv() Accessor function to return the SQL environment handle being managed by this class instance.

wxDbConnectInf::GetPassword
const wxChar * GetPassword() Accessor function to return the password assigned for this class instance that will be used with the user ID. Synonymous with wxDbConnectInf::GetAuthStr (p. 297)

wxDbConnectInf::GetUid
const wxChar * GetUid() Accessor function to return the user ID assigned for this class instance.

wxDbConnectInf::GetUserID
const wxChar * GetUserID() Accessor function to return the user ID assigned for this class instance.

wxDbConnectInf::SetAuthStr
SetAuthStr(const wxString &authstr) Accessor function to assign the password for this class instance that will be used with the user ID. Synonymous with wxDbConnectInf::SetPassword (p. 299)

wxDbConnectInf::SetDefaultDir
SetDefaultDir(const wxString &defDir) Accessor function to assign the default directory in which the datasource's data table is stored. This directory is only used for file based datasources like dBase. MS-Access does not require this to be set, as the path is set in the ODBC Administrator for MS-

298


CHAPTER 7
Access.

wxDbConnectInf::SetDescription
SetDescription(const wxString &desc) Accessor function to assign the description assigned for this class instance. NOTE: Description is a FUTURE USE item and is unused currently.

wxDbConnectInf::SetDsn
SetDsn(const wxString &dsn) Accessor function to assign the datasource name for this class instance.

wxDbConnectInf::SetFileType
SetFileType(const wxString &) Accessor function to return the filetype of the ODBC datasource assigned for this class instance. NOTE: FileType is a FUTURE USE item and is unused currently.

wxDbConnectInf::SetHenv
void SetHenv(const HENV henv) Accessor function to set the SQL environment handle for this class instance.

wxDbConnectInf::SetPassword
SetPassword(const wxString &password) Accessor function to assign the password for this class instance that will be used with the user ID. Synonymous with wxDbConnectInf::SetAuthStr (p. 298)

wxDbConnectInf::SetUid
SetUid(const wxString &uid) Accessor function to set the user ID for this class instance.

299


CHAPTER 7 wxDbConnectInf::SetUserID
SetUserID(const wxString &userID) Accessor function to assign the user ID for this class instance.

wxDbIdxDef
Used in creation of non-primary indexes. Currently there are no member functions for this class.
wxChar bool ColName[DB_MAX_COLUMN_NAME_LEN+1] // Name of column Ascending // Is index maintained in ASCENDING sequence?

There are no constructors/destructors as of this time, and no member functions. See the database classes overview (p. 1668) for an introduction to using the ODBC classes.

wxDbInf
Contains information regarding the database connection (datasource name, number of tables, etc). A pointer to a wxDbTableInf is included in this class so a program can create a wxDbTableInf array instance to maintain all information about all tables in the datasource to have all the datasource's information in one memory structure. Primarily, this class is used internally by the wxWindows ODBC classes.
wxChar wxChar int catalog[128+1]; schema[128+1]; // typically means owner of table(s) numTables; // How many tables does this datasource have wxDbTableInf *pTableInf; // Equals a new wxDbTableInf[numTables];

The constructor for this class initializes all the values to zero, "", or NULL. The destructor for this class takes care of deleting the pTableInf member if it is nonNULL. See the database classes overview (p. 1668) for an introduction to using the ODBC classes.

wxDbInf::Initialize
Simply initializes all member variables to a cleared state. Called by the constructor automatically.

300


CHAPTER 7

wxDbTable
A wxDbTable instance provides re-usable access to rows of data in a table contained within the associated ODBC datasource See the database classes overview (p. 1668) for an introduction to using the ODBC classes. Include files <wx/dbtable.h> <wx/db.h> Helper classes and data structures The following classes and structs are defined in dbtable.cpp/.h for use with the wxDbTable class.    wxDbColDef (p. 292) wxDbColDataPtr (p. 292) wxDbIdxDef (p. 300)

Constants
wxDB_DEFAULT_CURSOR wxDB_QUERY_ONLY Primary cursor normally used for cursor based operations. Used to indicate whether a table that is opened is for query only, or if insert/update/deletes will be performed on the table. Less overhead (cursors and memory) are allocated for query only tables, plus read access times are faster with some datasources. [Oracle only] - Used when CanUpdateByRowID() is true. Optimizes updates so they are faster by updating on the Oracle-specific ROWID column rather than some other index. Use to indicate when a database view should not be if a table is normally set up to use a view. [Currently unsupported.]

wxDB_ROWID_LEN

wxDB_DISABLE_VIEW

wxDbTable::wxDbTable
wxDbTable(wxDb *pwxDb, const wxString &tblName, const UWORD numColumns, const wxString &qryTblName = "", bool qryOnly = !wxDB_QUERY_ONLY, const wxString &tblPath = "") Default constructor.

301


CHAPTER 7
Parameters pwxDb Pointer to the wxDb instance to be used by this wxDbTable instance. tblName The name of the table in the RDBMS. numColumns The number of columns in the table. (Do NOT include the ROWID column in the count if using Oracle). qryTblName OPTIONAL. The name of the table or view to base your queries on. This argument allows you to specify a table/view other than the base table for this object to base your queries on. This allows you to query on a view for example, but all of the INSERT, UPDATE and DELETES will still be performed on the base table for this wxDbTable object. Basing your queries on a view can provide a substantial performance increase in cases where your queries involve many tables with multiple joins. Default is "". qryOnly OPTIONAL. Indicates whether the table will be accessible for query purposes only, or should the table create the necessary cursors to be able to insert, update, and delete data from the table. Default is !wxDB_QUERY_ONLY. tblPath OPTIONAL. Some datasources (such as dBase) require a path to where the table is stored on the system. Default is "".

wxDbTable::wxDbTable
virtual ~wxDbTable() Virtual default destructor.

wxDbTable::BuildDeleteStmt
void BuildDeleteStmt(wxString &pSqlStmt,int typeOfDel, const wxString &pWhereClause="") Constructs the full SQL statement that can be used to delete all rows matching the criteria in the pWhereClause. Parameters

302


CHAPTER 7
pSqlStmt Pointer to buffer for the SQL statement retrieved. To be sure you have adequate space allocated for the SQL statement, allocate DB_MAX_STATEMENT_LEN bytes. typeOfDel The type of delete statement being performed. Can be one of three values: DB_DEL_KEYFIELDS, DB_DEL_WHERE or DB_DEL_MATCHING pWhereClause OPTIONAL. If the typeOfDel is DB_DEL_WHERE, then you must also pass in a SQL WHERE clause in this argument. Default is "". Remarks This member function constructs a SQL DELETE statement. This can be used for debugging purposes if you are having problems executing your SQL statement. WHERE and FROM clauses specified using wxDbTable::SetWhereClause (p. 333)and wxDbTable::SetFromClause (p. 330) are ignored by this function.

wxDbTable::BuildSelectStmt
void BuildSelectStmt(wxString &pSqlStmt,int typeOfSelect, bool distinct) Constructs the full SQL statement that can be used to select all rows matching the criteria in the pWhereClause. This function is called internally in the wxDbTable class whenever the function wxDbTable::Query (p. 323)is called. NOTE: Only the columns specified in wxDbTable::SetColDefs (p. 328)statements are included in the list of columns returned by the SQL statement created by a call to this function. Parameters pSqlStmt Pointer to storage for the SQL statement retrieved. To be sure you have adequate space allocated for the SQL statement, allocate DB_MAX_STATEMENT_LEN bytes. typeOfSelect The type of select statement being performed. Can be one of four values: DB_SELECT_KEYFIELDS, DB_SELECT_WHERE, DB_SELECT_MATCHING or DB_SELECT_STATEMENT. distinct Whether to select distinct records only.

303


CHAPTER 7
Remarks This member function constructs a SQL SELECT statement. This can be used for debugging purposes if you are having problems executing your SQL statement. WHERE and FROM clauses specified usingwxDbTable::SetWhereClause (p. 333)and wxDbTable::SetFromClause (p. 330) are ignored by this function.

wxDbTable::BuildUpdateStmt
void BuildUpdateStmt(wxString &pSqlStmt, int typeOfUpd,const wxString &pWhereClause="") Constructs the full SQL statement that can be used to update all rows matching the criteria in the pWhereClause. If typeOfUpd is DB_UPD_KEYFIELDS, then the current values in the bound columns are used to determine which row(s) in the table are to be updated. The exception to this is when a datasource supports ROW IDs (Oracle). The ROW ID column is used for efficiency purposes when available. NOTE: Only the columns specified in wxDbTable::SetColDefs (p. 328)statements are included in the list of columns updated by the SQL statement created by a call to this function. Any column definitions that were defined as being non-updateable will be excluded from the SQL UPDATE statement created by this function. Parameters pSqlStmt Pointer to storage for the SQL statement retrieved. To be sure you have adequate space allocated for the SQL statement, allocate DB_MAX_STATEMENT_LEN bytes. typeOfUpd The type of update statement being performed. Can be one of two values: DB_UPD_KEYFIELDS or DB_UPD_WHERE. pWhereClause OPTIONAL. If the typeOfUpd is DB_UPD_WHERE, then you must also pass in a SQL WHERE clause in this argument. Default is "". Remarks This member function allows you to see what the SQL UPDATE statement looks like that the ODBC class library builds. This can be used for debugging purposes if you are having problems executing your SQL statement. WHERE and FROM clauses specified using wxDbTable::SetWhereClause (p. 333)and wxDbTable::SetFromClause (p. 330) are ignored by this function.

304


CHAPTER 7 wxDbTable::BuildWhereStmt
void BuildSelectStmt(wxString &pWhereClause,int typeOfWhere, const wxString &qualTableName="",bool useLikeComparison=false) Constructs the portion of a SQL statement which would follow the word 'WHERE' in a SQL statement to be passed to the datasource. The returned string does NOT include the word 'WHERE'. Parameters pWhereClause Pointer to storage for the SQL statement retrieved. To be sure you have adequate space allocated for the SQL statement, allocate DB_MAX_STATEMENT_LEN bytes. typeOfWhere The type of where clause to generate. Can be one of two values: DB_WHERE_KEYFIELDS or DB_WHERE_MATCHING. qualTableName OPTIONAL. Prepended to all base table column names. For use when a FROM clause has been specified with thewxDbTable::SetFromClause (p. 330), to clarify which table a column name reference belongs to. Default is "". useLikeComparison OPTIONAL. Should the constructed WHERE clause utilize the LIKE comparison operator. If false, then the '=' operator is used. Default is false. Remarks This member function allows you to see what the SQL WHERE clause looks like that the ODBC class library builds. This can be used for debugging purposes if you are having problems executing your own SQL statements. If using 'typeOfWhere' set to DB_WHERE_MATCHING, any bound columns currently containing a NULL value are not included in the WHERE clause's list of columns to use in the comparison.

wxDbTable::CanSelectForUpdate
bool CanSelectForUpdate() Use this function to determine if the datasource supports SELECT ... FOR UPDATE. When the keywords "FOR UPDATE" are included as part of your SQL SELECT statement, all records retrieved (not just queried, but actually retrieved usingwxDbTable::GetNext (p. 317), etc) from the result set are locked. Remarks

305


CHAPTER 7
Not all datasources support the "FOR UPDATE" clause, so you must use this member function to determine if the datasource currently connected to supports this behavior or not before trying to select using "FOR UPDATE". If the wxDbTable instance was created with the parameter wxDB_QUERY_ONLY, then this function will return false. For all known databases which do not support the FOR UPDATE clause, this function will return false also.

wxDbTable::CanUpdateByROWID
bool CanUpdateByROWID() CURRENTLY ONLY POSSIBLE IF USING ORACLE. --- CURRENTLY DISABLED FOR *ALL* DATASOURCES --- NOV 1 2000 - gt Every Oracle table has a hidden column named ROWID. This is a pointer to the physical location of the record in the datasource and allows for very fast updates and deletes. The key is to retrieve this ROWID during your query so it is available during an update or delete operation. Use of the ROWID feature is always handled by the class library except in the case of wxDbTable::QueryBySqlStmt (p. 324). Since you are passing in the SQL SELECT statement, it is up to you to include the ROWID column in your query. If you do not, the application will still work, but may not be as optimized. The ROWID is always the last column in the column list in your SQL SELECT statement. The ROWID is not a column in the normal sense and should not be considered part of the column definitions for the wxDbTable object. Remarks The decision to include the ROWID in your SQL SELECT statement must be deferred until runtime since it depends on whether you are connected to an Oracle datasource or not. Example
// Incomplete code sample wxDbTable parts; ..... if (parts.CanUpdByROWID()) { // Note that the ROWID column must always be the last column selected sqlStmt = "SELECT PART_NO, PART_DESC, ROWID" FROM PARTS"; } else sqlStmt = "SELECT PART_NO, PART_DESC FROM PARTS";

wxDbTable::ClearMemberVar
void ClearMemberVar(UWORD colNo, bool setToNull=false) Same as wxDbTable::ClearMemberVars (p. 307) except that this function clears only the

306


CHAPTER 7
specified column of its values, and optionally sets the column to be a NULL column. colNo Column number that is to be cleared. This number (between 0 and (noCols-1)) is the index of the column definition created using thewxDbTable::SetColDefs (p. 328) function. setToNull OPTIONAL. Indicates whether the column should be flagged as being a NULL value stored in the bound memory variable. If true, then any value stored in the bound member variable is cleared. Default is false.

wxDbTable::ClearMemberVars
void ClearMemberVars(bool setToNull=false) Initializes all bound columns of the wxDbTable instance to zero. In the case of a string, zero is copied to the first byte of the string. setToNull OPTIONAL. Indicates whether all columns should be flagged as having a NULL value stored in the bound memory variable. If true, then any value stored in the bound member variable is cleared. Default is false. Remarks This is useful before calling functions such aswxDbTable::QueryMatching (p. 326) orwxDbTable::DeleteMatching (p. 312) since these functions build their WHERE clauses from non-zero columns. To call eitherwxDbTable::QueryMatching (p. 326) orwxDbTable::DeleteMatching (p. 312) use this sequence:
1) 2) 3) ClearMemberVars() Assign columns values you wish to match on Call wxDbTable::QueryMatching() or wxDbTable::DeleteMatching()

wxDbTable::CloseCursor
bool CloseCursor(HSTMTcursor) Closes the specified cursor associated with the wxDbTable object. Parameters cursor The cursor to be closed. Remarks Typically handled internally by the ODBC class library, but may be used by the

307


CHAPTER 7
programmer if desired. DO NOT CLOSE THE wxDB_DEFAULT_CURSOR!

wxDbTable::Count
ULONG Count(const wxString &args="*") Returns the number of records which would be in the result set using the current query parameters specified in the WHERE and FROM clauses. Parameters args OPTIONAL. This argument allows the use of the DISTINCT keyword against a column name to cause the returned count to only indicate the number of rows in the result set that have a unique value in the specified column. An example is shown below. Default is "*", meaning a count of the total number of rows matching is returned, regardless of uniqueness. Remarks This function can be called before or after an actual query to obtain the count of records in the result set. Count() uses its own cursor, so result set cursor positioning is not affected by calls to Count(). WHERE and FROM clauses specified usingwxDbTable::SetWhereClause (p. 333)and wxDbTable::SetFromClause (p. 330) ARE used by this function. Example
USERS TABLE FIRST_NAME ----------John Richard Michael John LAST_NAME ---------Doe Smith Jones Carpenter

// Incomplete code sample wxDbTable users; ..... users.SetWhereClause(""); // This Count() will return 4, as there are four users listed above // that match the query parameters totalNumberOfUsers = users.Count(); // This Count() will return 3, as there are only 3 unique first names // in the table above - John, Richard, Michael. totalNumberOfUniqueFirstNames = users.Count("DISTINCT FIRST_NAME");

wxDbTable::CreateIndex

308


CHAPTER 7
bool CreateIndex(const wxString &idxName, bool unique,UWORD noIdxCols, wxDbIdxDef *pIdxDefs,bool attemptDrop=true) This member function allows you to create secondary (non primary) indexes on your tables. You first create your table, normally specifying a primary index, and then create any secondary indexes on the table. Indexes in relational model are not required. You do not need indexes to look up records in a table or to join two tables together. In the relational model, indexes, if available, provide a quicker means to look up data in a table. To enjoy the performance benefits of indexes, the indexes must be defined on the appropriate columns and your SQL code must be written in such a way as to take advantage of those indexes. Parameters idxName Name of the Index. Name must be unique within the table space of the datasource. unique Indicates if this index is unique. noIdxCols Number of columns in the index. pIdxDefs A pointer to an array wxDbIdxDef structures. attemptDrop OPTIONAL. Indicates if the function should try to execute a wxDbTable::DropIndex (p. 313) on the index name provided before trying to create the index name. Default is true. Remarks The first parameter, index name, must be unique and should be given a meaningful name. Common practice is to include the table name as a prefix in the index name (e.g. For table PARTS, you might want to call your index PARTS_IDX1). This will allow you to easily view all of the indexes defined for a given table grouped together alphabetically. The second parameter indicates if the index is unique or not. Uniqueness is enforced at the RDBMS level preventing rows which would have duplicate indexes from being inserted into the table when violating a unique index's uniqueness. In the third parameter, specify how many columns are in your index. This number must match the number of columns defined in the 'pIdxDefs' parameter. The fourth parameter specifies which columns make up the index using the wxDbIdxDef structure. For each column in the index, you must specify two things, the column name and the sort order (ascending / descending). See the example below to see how to build

309


CHAPTER 7
and pass in the wxDbIdxDef structure. The fifth parameter is provided to handle the differences in datasources as to whether they will automatically overwrite existing indexes with the same name or not. Some datasources require that the existing index must be dropped first, so this is the default behavior. Some datasources (MySQL, and possibly others) require columns which are to be part of an index to be defined as NOT NULL. When this function is called, if a column is not defined to be NOT NULL, a call to this function will modify the column definition to change any columns included in the index to be NOT NULL. In this situation, if a NULL value already exists in one of the columns that is being modified, creation of the index will fail. PostGres is unable to handle index definitions which specify whether the index is ascending or descending, and defaults to the system default when the index is created. It is not necessary to call wxDb::CommitTrans (p. 271)after executing this function. Example
// Create a secondary index on the PARTS table wxDbIdxDef idxDef[2]; // 2 columns make up the index wxStrcpy(idxDef[0].ColName, "PART_DESC"); idxDef[0].Ascending = true; wxStrcpy(idxDef[1].ColName, "SERIAL_NO"); idxDef[1].Ascending = false; // Column 1 // Column 2

// Create a name for the index based on the table's name wxString indexName; indexName.Printf("%s_IDX1",parts->GetTableName()); parts->CreateIndex(indexName, true, 2, idxDef);

wxDbTable::CreateTable
bool CreateTable(bool attemptDrop=true) Creates a table based on the definitions previously defined for this wxDbTable instance. Parameters attemptDrop OPTIONAL. Indicates whether the driver should attempt to drop the table before trying to create it. Some datasources will not allow creation of a table if the table already exists in the table space being used. Default is true. Remarks This function creates the table and primary index (if any) in the table space associated with the connected datasource. The owner of these objects will be the user id that was given when wxDb::Open (p. 285) was called. The objects will be created in the default schema/table space for that user.

310


CHAPTER 7
In your derived wxDbTable object constructor, the columns and primary index of the table are described through the wxDbColDef (p. 292) structure.wxDbTable::CreateTable (p. 310) uses this information to create the table and to add the primary index. SeewxDbTable (p. 301) ctor and wxDbColDef description for additional information on describing the columns of the table. It is not necessary to call wxDb::CommitTrans (p. 271)after executing this function.

wxDbTable::DB_STATUS
bool DB_STATUS() Accessor function that returns the wxDb private member variable DB_STATUS for the database connection used by this instance of wxDbTable.

wxDbTable::Delete
bool Delete() Deletes the row from the table indicated by the current cursor. Remarks Use wxDbTable::GetFirst (p. 316),wxDbTable::GetLast (p. 316),wxDbTable::GetNext (p. 317) orwxDbTable::GetPrev (p. 318) to position the cursor to a valid record. Once positioned on a record, call this function to delete the row from the table. A wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286) must be called after use of this function to commit or rollback the deletion. NOTE: Most datasources have a limited size "rollback" segment. This means that it is only possible to insert/update/delete a finite number of rows without performing a wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286). Size of the rollback segment varies from database to database, and is user configurable in most databases. Therefore it is usually best to try to perform a commit or rollback at relatively small intervals when processing a larger number of actions that insert/update/delete rows in a table.

wxDbTable::DeleteCursor
bool DeleteCursor(HSTMT *hstmtDel) Allows a program to delete a cursor. Parameters hstmtDel Handle of the cursor to delete.

311


CHAPTER 7
Remarks For default cursors associated with the instance of wxDbTable, it is not necessary to specifically delete the cursors. This is automatically done in the wxDbTable destructor. NOTE: If the cursor could not be deleted for some reason, an error is logged indicating the reason. Even if the cursor could not be deleted, the HSTMT that is passed in is deleted, and the pointer is set to NULL. DO NOT DELETE THE wxDB_DEFAULT_CURSOR!

wxDbTable::DeleteMatching
bool DeleteMatching() This member function allows you to delete records from your wxDbTable object by specifying the data in the columns to match on. Remarks To delete all users with a first name of "JOHN", do the following: 1. 2. 3. Clear all "columns" using wxDbTable::ClearMemberVars(). Set the FIRST_NAME column equal to "JOHN". Call wxDbTable::DeleteMatching().

The WHERE clause is built by the ODBC class library based on all non-NULL columns. This allows deletion of records by matching on any column(s) in your wxDbTable instance, without having to write the SQL WHERE clause. A wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286) must be called after use of this function to commit or rollback the deletion. NOTE: Row(s) should be locked before deleting them to make sure they are not already in use. This can be achieved by callingwxDbTable::QueryMatching (p. 326), and then retrieving the records, locking each as you go (assuming FOR UPDATE is allowed on the datasource). After the row(s) have been successfully locked, call this function. NOTE: Most datasources have a limited "rollback" segment. This means that it is only possible to insert/update/delete a finite number of rows without performing a wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286). Size of the rollback segment varies from database to database, and is user configurable in most databases. Therefore it is usually best to try to perform a commit or rollback at relatively small intervals when processing a larger number of actions that insert/update/delete rows in a table. Example
// Incomplete code sample to delete all users with a first name // of "JOHN" users.ClearMemberVars(); wxStrcpy(users.FirstName,"JOHN");

312


CHAPTER 7
users.DeleteMatching();

wxDbTable::DeleteWhere
bool DeleteWhere(const wxString &pWhereClause) Deletes all rows from the table which match the criteria specified in the WHERE clause that is passed in. Parameters pWhereClause SQL WHERE clause. This WHERE clause determines which records will be deleted from the table interfaced through the wxDbTable instance. The WHERE clause passed in must be compliant with the SQL 92 grammar. Do not include the keyword 'WHERE' Remarks This is the most powerful form of the wxDbTable delete functions. This function gives access to the full power of SQL. This function can be used to delete records by passing a valid SQL WHERE clause. Sophisticated deletions can be performed based on multiple criteria using the full functionality of the SQL language. A wxDb::CommitTrans (p. 271) must be called after use of this function to commit the deletions. Note: This function is limited to deleting records from the table associated with this wxDbTable object only. Deletions on joined tables is not possible. NOTE: Most datasources have a limited size "rollback" segment. This means that it is only possible to insert/update/delete a finite number of rows without performing a wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286). Size of the rollback segment varies from database to database, and is user configurable in most databases. Therefore it is usually best to try to perform a commit or rollback at relatively small intervals when processing a larger number of actions that insert/update/delete rows in a table. WHERE and FROM clauses specified using wxDbTable::SetWhereClause (p. 333)and wxDbTable::SetFromClause (p. 330) are ignored by this function. Example
// Delete parts 1 thru 10 from containers 'X', 'Y' and 'Z' that // are magenta in color parts.DeleteWhere("(PART_NUMBER BETWEEN 1 AND 10) AND \ CONTAINER IN ('X', 'Y', 'Z') AND \ UPPER(COLOR) = 'MAGENTA'");

wxDbTable::DropIndex

313


CHAPTER 7
bool DropIndex(const wxString &idxName) Allows an index on the associated table to be dropped (deleted) if the user login has sufficient privileges to do so. Parameters idxName Name of the index to be dropped. Remarks If the index specified in the 'idxName' parameter does not exist, an error will be logged, and the function will return a result of false. It is not necessary to call wxDb::CommitTrans (p. 271)after executing this function.

wxDbTable::DropTable
bool DropTable() Deletes the associated table if the user has sufficient privileges to do so. Remarks This function returns true if the table does not exist, but only for supported databases (see wxDb::Dbms (p. 272)). If a datasource is not specifically supported, and this function is called, the function will return false. Most datasources/ODBC drivers will delete any indexes associated with the table automatically, and others may not. Check the documentation for your database to determine the behavior. It is not necessary to call wxDb::CommitTrans (p. 271)after executing this function.

wxDbTable::From
const wxString & From() void From(const wxString &From) Accessor function for the private class member wxDbTable::from. Can be used as a synonym for wxDbTable::GetFromClause (p. 316)(the first form of this function) orwxDbTable::SetFromClause (p. 330) (the second form of this function). Parameters From A comma separated list of table names that are to be outer joined with the base table's columns so that the joined table's columns may be returned in the result set

314


CHAPTER 7
or used as a portion of a comparison with the base table's columns. NOTE that the base tables name must NOT be included in the FROM clause, as it is automatically included by the wxDbTable class in constructing query statements. Return value The first form of this function returns the current value of the wxDbTable member variable ::from. The second form of the function has no return value, as it will always set the from clause successfully. See also wxDbTable::GetFromClause (p. 316),wxDbTable::SetFromClause (p. 330)

wxDbTable::GetColDefs
wxDbColDef * GetColDefs() Accessor function that returns a pointer to the array of column definitions that are bound to the columns that this wxDbTable instance is associated with. To determine the number of elements pointed to by the returnedwxDbColDef (p. 292) pointer, use thewxDbTable::GetNumberOfColumns (p. 317) function. Remarks These column definitions must not be manually redefined after they have been set.

wxDbTable::GetCursor
HSTMT GetCursor() Returns the HSTMT value of the current cursor for this wxDbTable object. Remarks This function is typically used just before changing to use a different cursor so that after the program is finished using the other cursor, the current cursor can be set back to being the cursor in use. See also wxDbTable::SetCursor (p. 330), wxDbTable::GetNewCursor (p. 317)

wxDbTable::GetDb
wxDb * GetDb() Accessor function for the private member variable pDb which is a pointer to the

315


CHAPTER 7
datasource connection that this wxDbTable instance uses.

wxDbTable::GetFirst
bool GetFirst() Retrieves the FIRST row in the record set as defined by the current query. Before retrieving records, a query must be performed usingwxDbTable::Query (p. 323),wxDbTable::QueryOnKeyFields (p. 327),wxDbTable::QueryMatching (p. 326) orwxDbTable::QueryBySqlStmt (p. 324). Remarks This function can only be used if the datasource connection used by the wxDbTable instance was created with FwdOnlyCursors set to false. If the connection does not allow backward scrolling cursors, this function will return false, and the data contained in the bound columns will be undefined. See also wxDb::IsFwdOnlyCursors (p. 282)

wxDbTable::GetFromClause
const wxString & GetFromClause() Accessor function that returns the current FROM setting assigned with thewxDbTable::SetFromClause (p. 330). See also wxDbTable::From (p. 314)

wxDbTable::GetLast
bool GetLast() Retrieves the LAST row in the record set as defined by the current query. Before retrieving records, a query must be performed usingwxDbTable::Query (p. 323),wxDbTable::QueryOnKeyFields (p. 327),wxDbTable::QueryMatching (p. 326) orwxDbTable::QueryBySqlStmt (p. 324). Remarks This function can only be used if the datasource connection used by the wxDbTable instance was created with FwdOnlyCursors set to false. If the connection does not allow backward scrolling cursors, this function will return false, and the data contained in the bound columns will be undefined. See also

316


CHAPTER 7
wxDb::IsFwdOnlyCursors (p. 282)

wxDbTable::GetNewCursor
HSTMT * GetNewCursor(bool setCursor=false,bool bindColumns=true) This function will create a new cursor that can be used to access the table being referenced by this wxDbTable instance, or to execute direct SQL commands on without affecting the cursors that are already defined and possibly positioned. Parameters setCursor OPTIONAL. Should this new cursor be set to be the current cursor after successfully creating the new cursor. Default is false. bindColumns OPTIONAL. Should this new cursor be bound to all the memory variables that the default cursor is bound to. Default is true. Remarks This new cursor must be closed usingwxDbTable::DeleteCursor (p. 311)by the calling program before the wxDbTable instance is deleted, or both memory and resource leaks will occur.

wxDbTable::GetNext
bool GetNext() Retrieves the NEXT row in the record set after the current cursor position as defined by the current query. Before retrieving records, a query must be performed using wxDbTable::Query (p. 323),wxDbTable::QueryOnKeyFields (p. 327),wxDbTable::QueryMatching (p. 326) orwxDbTable::QueryBySqlStmt (p. 324). Return value This function returns false when the current cursor has reached the end of the result set. When false is returned, data in the bound columns is undefined. Remarks This function works with both forward and backward scrolling cursors. See alsowxDbTable::++ (p. 335)

wxDbTable::GetNumberOfColumns

317


CHAPTER 7
UWORD GetNumberOfColumns() Accessor function that returns the number of columns that are statically bound for access by the wxDbTable instance.

wxDbTable::GetOrderByClause
const wxString & GetOrderByClause() Accessor function that returns the current ORDER BY setting assigned with the wxDbTable::SetOrderByClause (p. 332). See also wxDbTable::OrderBy (p. 322)

wxDbTable::GetPrev
bool GetPrev() Retrieves the PREVIOUS row in the record set before the current cursor position as defined by the current query. Before retrieving records, a query must be performed using wxDbTable::Query (p. 323),wxDbTable::QueryOnKeyFields (p. 327),wxDbTable::QueryMatching (p. 326) orwxDbTable::QueryBySqlStmt (p. 324). Return value This function returns false when the current cursor has reached the beginning of the result set and there are now other rows prior to the cursors current position. When false is returned, data in the bound columns is undefined. Remarks This function can only be used if the datasource connection used by the wxDbTable instance was created with FwdOnlyCursors set to false. If the connection does not allow backward scrolling cursors, this function will return false, and the data contained in the bound columns will be undefined. See also wxDb::IsFwdOnlyCursors (p. 282),wxDbTable::-- (p. 336)

wxDbTable::GetQueryTableName
const wxString & GetQueryTableName() Accessor function that returns the name of the table/view that was indicated as being the table/view to query against when this wxDbTable instance was created. See also

318


CHAPTER 7
wxDbTable constructor (p. 301)

wxDbTable::GetRowNum
UWORD GetRowNum() Returns the ODBC row number for performing positioned updates and deletes. Remarks This function is not being used within the ODBC class library and may be a candidate for removal if no use is found for it. Row number with some datasources/ODBC drivers is the position in the result set, while in others it may be a physical position in the database. Check your database documentation to find out which behavior is supported.

wxDbTable::GetTableName
const wxString & GetTableName() Accessor function that returns the name of the table that was indicated as being the table that this wxDbTable instance was associated with.

wxDbTable::GetTablePath
const wxString & GetTablePath() Accessor function that returns the path to the data table that was indicated during creation of this wxDbTable instance. Remarks Currently only applicable to dBase and MS-Access datasources.

wxDbTable::GetWhereClause
const wxString & GetWhereClause() Accessor function that returns the current WHERE setting assigned with thewxDbTable::SetWhereClause (p. 333) See also wxDbTable::Where (p. 335)

wxDbTable::Insert

319


CHAPTER 7
int Insert() Inserts a new record into the table being referenced by this wxDbTable instance. The values in the member variables of the wxDbTable instance are inserted into the columns of the new row in the database. Return value
DB_SUCCESS DB_FAILURE Record inserted successfully (value = 1) Insert failed (value = 0)

DB_ERR_INTEGRITY_CONSTRAINT_VIOL The insert failed due to an integrity constraint violation (duplicate non-unique index entry) is attempted.

Remarks A wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286) must be called after use of this function to commit or rollback the insertion. Example
// Incomplete code snippet wxStrcpy(parts->PartName, "10"); wxStrcpy(parts->PartDesc, "Part #10"); parts->Qty = 1000; RETCODE retcode = parts->Insert(); switch(retcode) { case DB_SUCCESS: parts->GetDb()->CommitTrans(); return(true); case DB_ERR_INTEGRITY_CONSTRAINT_VIOL: // Current data would result in a duplicate key // on one or more indexes that do not allow duplicates parts->GetDb()->RollbackTrans(); return(false); default: // Insert failed for some unexpected reason parts->GetDb()->RollbackTrans(); return(false); }

wxDbTable::IsColNull
bool IsColNull(UWORD colNo) const Used primarily in the ODBC class library to determine if a column value is set to "NULL". Works for all data types supported by the ODBC class library. Parameters colNo The column number of the bound column as defined by thewxDbTable::SetColDefs (p. 328)calls which defined the columns accessible to this wxDbTable instance.

320


CHAPTER 7
Remarks NULL column support is currently not fully implemented as of wxWindows 2.4.

wxDbTable::IsCursorClosedOnCommit
bool IsCursorClosedOnCommit() Accessor function to return information collected during the opening of the datasource connection that is used by this wxDbTable instance. The result returned by this function indicates whether an implicit closing of the cursor is done after a commit on the database connection. Return value Returns true if the cursor associated with this wxDbTable object is closed after a commit or rollback operation. Returns false otherwise. Remarks If more than one wxDbTable instance used the same database connection, all cursors which use the database connection are closed on the commit if this function indicates true.

wxDbTable::IsQueryOnly
bool IsQueryOnly() Accessor function that returns a value indicating if this wxDbTable instance was created to allow only queries to be performed on the bound columns. If this function returns true, then no actions may be performed using this wxDbTable instance that would modify (insert/delete/update) the table's data.

wxDbTable::Open
bool Open(bool checkPrivileges=false, bool checkTableExists=true) Every wxDbTable instance must be opened before it can be used. This function checks for the existence of the requested table, binds columns, creates required cursors, (insert/select and update if connection is not wxDB_QUERY_ONLY) and constructs the insert statement that is to be used for inserting data as a new row in the datasource. Parameters checkPrivileges Indicates whether the Open() function should check whether the current connected user has at least SELECT privileges to access the table to which they are trying to open. Default is false.

321


CHAPTER 7
checkTableExists Indicates whether the Open() function should check whether the table exists in the database or not before opening it. Default is true. Remarks If the function returns a false value due to the table not existing, a log entry is recorded for the datasource connection indicating the problem that was detected when checking for table existence. Note that it is usually best for the calling routine to check for the existence of the table and for sufficient user privileges to access the table in the mode (wxDB_QUERY_ONLY or !wxDB_QUERY_ONLY) before trying to open the table for the best possible explanation as to why a table cannot be opened. Checking the user's privileges on a table can be quite time consuming during the open phase. With most applications, the programmer already knows that the user has sufficient privileges to access the table, so this check is normally not required. For best performance, open the table, and then use thewxDb::TablePrivileges (p. 289) function to check the users privileges. Passing a schema to the TablePrivileges() function can significantly speed up the privileges checks. See also wxDb::TableExists (p. 289),wxDb::TablePrivileges (p. 289)

wxDbTable::OrderBy
const wxString & OrderBy() void OrderBy(const wxString &OrderBy) Accessor function for the private class member wxDbTable::orderBy. Can be used as a synonym forwxDbTable::GetOrderByClause (p. 318)(the first form of this function) orwxDbTable::SetOrderByClause (p. 332)(the second form of this function). Parameters OrderBy A comma separated list of column names that indicate the alphabetized/numeric sorting sequence that the result set is to be returned in. If a FROM clause has also been specified, each column name specified in the ORDER BY clause should be prefaced with the table name to which the column belongs using DOT notation (TABLE_NAME.COLUMN_NAME). Return value The first form of this function returns the current value of the wxDbTable member variable ::orderBy. The second form of the function has no return value.

322


CHAPTER 7
See also wxDbTable::GetOrderByClause (p. 318),wxDbTable::SetFromClause (p. 330)

wxDbTable::Query
virtual bool Query(bool forUpdate=false, bool distinct=false) Parameters forUpdate OPTIONAL. Gives you the option of locking records as they are retrieved. If the RDBMS is not capable of the FOR UPDATE clause, this argument is ignored. SeewxDbTable::CanSelectForUpdate (p. 305) for additional information regarding this argument. Default is false. distinct OPTIONAL. Allows selection of only distinct values from the query (SELECT DISTINCT ... FROM ...). The notion of DISTINCT applies to all columns returned in the result set, not individual columns. Default is false. Remarks This function queries records from the datasource based on the three wxDbTable members: "where", "orderBy", and "from". UsewxDbTable::SetWhereClause (p. 333) to filter on records to be retrieved (e.g. All users with a first name of "JOHN"). Use wxDbTable::SetOrderByClause (p. 332) to change the sequence in which records are returned in the result set from the datasource (e.g. Ordered by LAST_NAME). UsewxDbTable::SetFromClause (p. 330) to allow outer joining of the base table (the one being associated with this instance of wxDbTable) with other tables which share a related field. After each of these clauses are set/cleared, call wxDbTable::Query() to fetch the result set from the datasource. This scheme has an advantage if you have to requery your record set frequently in that you only have to set your WHERE, ORDER BY, and FROM clauses once. Then to refresh the record set, simply call wxDbTable::Query() as frequently as needed. Note that repeated calls to wxDbTable::Query() may tax the database server and make your application sluggish if done too frequently or unnecessarily. The base table name is automatically prepended to the base column names in the event that the FROM clause has been set (is non-null) usingwxDbTable::SetFromClause (p. 330). The cursor for the result set is positioned before the first record in the result set after the query. To retrieve the first record, call eitherwxDbTable::GetFirst (p. 316) (only if backward scrolling cursors are available) orwxDbTable::GetNext (p. 317). Typically, no data from the result set is returned to the client driver until a request such

323


CHAPTER 7
aswxDbTable::GetNext (p. 317) is performed, so network traffic and database load are not overwhelmed transmitting data until the data is actually requested by the client. This behavior is solely dependent on the ODBC driver though, so refer to the ODBC driver's reference material for information on its behaviors. Values in the bound columns' memory variables are undefined after executing a call to this function and remain that way until a row in the result set is requested to be returned. The wxDbTable::Query() function is defined as "virtual" so that it may be overridden for application specific purposes. Be sure to set the wxDbTable's "where", "orderBy", and "from" member variables to "" if they are not to be used in the query. Otherwise, the results returned may have unexpected results (or no results) due to improper or incorrect query parameters constructed from the uninitialized clauses. Example
// Incomplete code sample parts->SetWhereClause("DESCRIPTION = 'FOOD'"); parts->SetOrderByClause("EXPIRATION_DATE"); parts->SetFromClause(""); // Query the records based on the where, orderBy and from clauses // specified above parts->Query(); // Display all records queried while(parts >GetNext()) dispPart(parts); // user defined function

wxDbTable::QueryBySqlStmt
bool QueryBySqlStmt(const wxString &pSqlStmt) Performs a query against the datasource by accepting and passing verbatim the SQL SELECT statement passed to the function. Parameters pSqlStmt Pointer to the SQL SELECT statement to be executed. Remarks This is the most powerful form of the query functions available. This member function allows a programmer to write their own custom SQL SELECT statement for requesting data from the datasource. This gives the programmer access to the full power of SQL for performing operations such as scalar functions, aggregate functions, table joins, and sub-queries, as well as datasource specific function calls. The requirements of the SELECT statement are the following: 1. Must return the correct number of columns. In the derived wxDbTable constructor, it is specified how many columns are in the wxDbTable object. The SELECT statement must return exactly that many columns.

324


CHAPTER 7
2. The columns must be returned in the same sequence as specified when defining the bounds columns using wxDbTable::SetColDefs(), and the columns returned must be of the proper data type. For example, if column 3 is defined in the wxDbTable bound column definitions to be a float, the SELECT statement must return a float for column 3 (e.g. PRICE * 1.10 to increase the price by 10 The ROWID can be included in your SELECT statement as the lastcolumn selected, if the datasource supports it. Use wxDbTable::CanUpdByROWID() to determine if the ROWID can be selected from the datasource. If it can, much better performance can be achieved on updates and deletes by including the ROWID in the SELECT statement.

3.

Even though data can be selected from multiple tables (joins) in your select statement, only the base table associated with this wxDbTable object is automatically updated through the ODBC class library. Data from multiple tables can be selected for display purposes however. Include columns in the wxDbTable object and mark them as nonupdateable (SeewxDbColDef (p. 292) for details). This way columns can be selected and displayed from other tables, but only the base table will be updated automatically when performed through thewxDbTable::Update (p. 334) function after using this type of query. To update tables other than the base table, use thewxDbTable::Update (p. 334) function passing a SQL statement. After this function has been called, the cursor is positioned before the first record in the record set. To retrieve the first record, call either wxDbTable::GetFirst (p. 316) orwxDbTable::GetNext (p. 317). Example
// Incomplete code samples wxString sqlStmt; sqlStmt = "SELECT * FROM PARTS WHERE STORAGE_DEVICE = 'SD98' \ AND CONTAINER = 12"; // Query the records using the SQL SELECT statement above parts->QueryBySqlStmt(sqlStmt); // Display all records queried while(parts >GetNext()) dispPart(&parts); Example SQL statements ---------------------// Table Join returning 3 columns SELECT part_no, part_desc, sd_name from parts, storage_devices where parts.storage_device_id = storage_devices.storage_device_id // Aggregate function returning total number of // parts in container 99 SELECT count(*) from PARTS where container = 99 // Order by clause; ROWID, scalar function SELECT part_no, substring(part_desc, 1, 10), qty_on_hand + 1, ROWID from parts where warehouse = 10 order by part_no desc // descending order // Subquery SELECT * from parts where container in (select container from storage_devices where device_id = 12)

325


CHAPTER 7

wxDbTable::QueryMatching
virtual bool QueryMatching(bool forUpdate=false,bool distinct=false) QueryMatching allows querying of records from the table associated with the wxDbTable object by matching "columns" to values. For example: To query the datasource for the row with a PART_NUMBER column value of "32", clear all column variables of the wxDbTable object, set the PartNumber variable that is bound to the PART_NUMBER column in the wxDbTable object to "32", and then call wxDbTable::QueryMatching(). Parameters forUpdate OPTIONAL. Gives you the option of locking records as they are queried (SELECT ... FOR UPDATE). If the RDBMS is not capable of the FOR UPDATE clause, this argument is ignored. SeewxDbTable::CanSelectForUpdate (p. 305) for additional information regarding this argument. Default is false. distinct OPTIONAL. Allows selection of only distinct values from the query (SELECT DISTINCT ... FROM ...). The notion of DISTINCT applies to all columns returned in the result set, not individual columns. Default is false. Remarks The SQL WHERE clause is built by the ODBC class library based on all non-zero/nonNULL columns in your wxDbTable object. Matches can be on one, many or all of the wxDbTable's columns. The base table name is prepended to the column names in the event that the wxDbTable's FROM clause is non-null. This function cannot be used to perform queries which will check for columns that are 0 or NULL, as the automatically constructed WHERE clause only will contain comparisons on column member variables that are non-zero/non-NULL. The primary difference between this function and wxDbTable::QueryOnKeyFields (p. 327)is that this function can query on any column(s) in the wxDbTable object. Note however that this may not always be very efficient. Searching on non-indexed columns will always require a full table scan. The cursor is positioned before the first record in the record set after the query is performed. To retrieve the first record, the program must call either wxDbTable::GetFirst (p. 316) orwxDbTable::GetNext (p. 317). WHERE and FROM clauses specified using wxDbTable::SetWhereClause (p. 333)and wxDbTable::SetFromClause (p. 330) are ignored by this function. Example
// Incomplete code sample

326


CHAPTER 7
parts->ClearMemberVars(); // Set all columns to zero wxStrcpy(parts->PartNumber,"32"); // Set columns to query on parts->OnHold = true; parts->QueryMatching(); // Query // Display all records queried while(parts >GetNext()) dispPart(parts); // Some application defined function

wxDbTable::QueryOnKeyFields
bool QueryOnKeyFields(bool forUpdate=false,bool distinct=false) QueryOnKeyFields provides an easy mechanism to query records in the table associated with the wxDbTable object by the primary index column(s). Simply assign the primary index column(s) values and then call this member function to retrieve the record. Note that since primary indexes are always unique, this function implicitly always returns a single record from the database. The base table name is prepended to the column names in the event that the wxDbTable's FROM clause is non-null. Parameters forUpdate OPTIONAL. Gives you the option of locking records as they are queried (SELECT ... FOR UPDATE). If the RDBMS is not capable of the FOR UPDATE clause, this argument is ignored. SeewxDbTable::CanSelectForUpdate (p. 305) for additional information regarding this argument. Default is false. distinct OPTIONAL. Allows selection of only distinct values from the query (SELECT DISTINCT ... FROM ...). The notion of DISTINCT applies to all columns returned in the result set, not individual columns. Default is false. Remarks The cursor is positioned before the first record in the record set after the query is performed. To retrieve the first record, the program must call either wxDbTable::GetFirst (p. 316) orwxDbTable::GetNext (p. 317). WHERE and FROM clauses specified using wxDbTable::SetWhereClause (p. 333)and wxDbTable::SetFromClause (p. 330) are ignored by this function. Example
// Incomplete code sample wxStrcpy(parts->PartNumber, "32"); parts->QueryOnKeyFields(); // Display all records queried while(parts >GetNext()) dispPart(parts); // Some application defined function

327


CHAPTER 7 wxDbTable::Refresh
bool Refresh() This function re-reads the bound columns into the memory variables, setting them to the current values stored on the disk. The cursor position and result set are unaffected by calls to this function. (The one exception is in the case where the record to be refreshed has been deleted by some other user or transaction since it was originally retrieved as part of the result set. For most datasources, the default behavior in this situation is to return the value that was originally queried for the result set, even though it has been deleted from the database. But this is datasource dependent, and should be tested before relying on this behavior.) Remarks This routine is only guaranteed to work if the table has a unique primary index defined for it. Otherwise, more than one record may be fetched and there is no guarantee that the correct record will be refreshed. The table's columns are refreshed to reflect the current data in the database.

wxDbTable::SetColDefs
void SetColDefs(UWORD index, const wxString &fieldName,int dataType, void *pData, SWORD cType,int size, bool keyField = false, bool upd = true,bool insAllow = true, bool derivedCol = false) wxDbColDataPtr * SetColDefs(wxDbColInf *colInfs, UWORD numCols) Parameters index Column number (0 to n-1, where n is the number of columns specified as being defined for this wxDbTable instance when the wxDbTable constructor was called. fieldName Column name from the associated data table. dataType Logical data type. Valid logical types include:
DB_DATA_TYPE_VARCHAR DB_DATA_TYPE_INTEGER DB_DATA_TYPE_FLOAT DB_DATA_TYPE_DATE : : : : strings non-floating point numbers floating point numbers dates

p D a ta Pointer to the data object that will hold the column's value when a row of data is returned from the datasource.

328


CHAPTER 7
cType SQL C Type. This defines the data type that the SQL representation of the data is converted to to be stored in pData. Other valid types are available also, but these are the most common ones:
SQL_C_CHAR // strings SQL_C_LONG SQL_C_ULONG SQL_C_SHORT SQL_C_USHORT SQL_C_FLOAT SQL_C_DOUBLE SQL_C_NUMERIC SQL_C_TIMESTAMP SQL_C_BOOLEAN SQL_C_ENUM // defined in db.h // defined in db.h

size Maximum size in bytes of the pData object. keyField OPTIONAL. Indicates if this column is part of the primary index. Default is false. upd OPTIONAL. Are updates allowed on this column? Default is true. insAllow OPTIONAL. Inserts allowed on this column? Default is true. derivedCol OPTIONAL. Is this a derived column (non-base table column for query only)? Default is false. colInfs Pointer to an array of wxDbColInf instances which contains all the information necessary to create numCols column definitions. numCols Number of elements of wxDbColInf type that are pointed to by colInfs, which are to have column definitions created from them. Remarks If pData is to hold a string of characters, be sure to include enough space for the NULL terminator in pData and in the byte count of size. Both forms of this function provide a shortcut for defining the columns in your wxDbTable object. Use this function in any derived wxDbTable constructor when describing the column/columns in the wxDbTable object.

329


CHAPTER 7
The second form of this function is primarily used when thewxDb::GetColumns (p. 276) function was used to query the datasource for the column definitions, so that the column definitions are already stored in wxDbColInf form. One example use of usingwxDb::GetColumns (p. 276) then using this function is if a data table existed in one datasource, and the table's column definitions were to be copied over to another datasource or table. Example
// Long way not using this function wxStrcpy(colDefs[0].ColName, "PART_NO"); colDefs[0].DbDataType = DB_DATA_TYPE_VARCHAR; colDefs[0].PtrDataObj = PartNumber; colDefs[0].SqlCtype = SQL_C_CHAR; colDefs[0].SzDataObj = PART_NUMBER_LEN; colDefs[0].KeyField = true; colDefs[0].Updateable = false; colDefs[0].InsertAllowed= true; colDefs[0].DerivedCol = false; // Shortcut using this function SetColDefs(0, "PART_NUMBER", DB_DATA_TYPE_VARCHAR, PartNumber, SQL_C_CHAR, PART_NUMBER_LEN, true, false,true,false);

wxDbTable::SetCursor
bool SetCursor(HSTMT *hstmtActivate = (void **) wxDB_DEFAULT_CURSOR) Parameters hstmtActivate OPTIONAL. Pointer to the cursor that is to become the current cursor. Passing no cursor handle will reset the cursor back to the wxDbTable's default (original) cursor that was created when the wxDbTable instance was first created. Default is wxDB_DEFAULT_CURSOR. Remarks When swapping between cursors, the member variables of the wxDbTable object are automatically refreshed with the column values of the row that the current cursor is positioned at (if any). If the cursor is not positioned, then the data in member variables is undefined. The only way to return back to the cursor that was in use before this function was called is to programmatically determine the current cursor's HSTMTBEFORE calling this function using wxDbTable::GetCursor (p. 315)and saving a pointer to that cursor. See also wxDbTable::GetNewCursor (p. 317),wxDbTable::GetCursor (p. 315),wxDbTable::SetCursor (p. 330)

wxDbTable::SetFromClause

330


CHAPTER 7
void SetFromClause(const wxString &From) Accessor function for setting the private class member wxDbTable::from that indicates what other tables should be outer joined with the wxDbTable's base table for access to the columns in those other tables. Synonym to this function is one form of wxDbTable::From (p. 314) Parameters From A comma separated list of table names that are to be outer joined with the base table's columns so that the joined table's columns may be returned in the result set or used as a portion of a comparison with the base table's columns. NOTE that the base tables name must NOT be included in the FROM clause, as it is automatically included by the wxDbTable class in constructing query statements. Remarks Used by the wxDbTable::Query (p. 323) andwxDbTable::Count (p. 308) member functions to allow outer joining of records from multiple tables. Do not include the keyword "FROM" when setting the FROM clause. If using the FROM clause when performing a query, be certain to include in the corresponding WHERE clause a comparison of a column from either the base table or one of the other joined tables to each other joined table to ensure the datasource knows on which column values the tables should be joined on. Example
... // Base table is the "LOCATION" table, and it is being // outer joined to the "PART" table via the the field "PART_NUMBER" // that can be related between the two tables. location->SetWhereClause("LOCATION.PART_NUMBER = PART.PART_NUMBER") location->SetFromClause("PART"); ...

See also wxDbTable::From (p. 314),wxDbTable::GetFromClause (p. 316)

wxDbTable::SetColNull
bool SetColNull(UWORD colNo, bool set=true) bool SetColNull(const wxString &colName,bool set=true) Both forms of this function allow a member variable representing a column in the table associated with this wxDbTable object to be set to NULL. The first form allows the column to be set by the index into the column definitions used to create the wxDbTable instance, while the second allows the actual column name to

331


CHAPTER 7
be specified. Parameters colNo Index into the column definitions used when first defining this wxDbTable object. colName Actual data table column name that is to be set to NULL. set Whether the column is set to NULL or not. Passing true sets the column to NULL, passing false sets the column to be non-NULL. Default is true. Remarks No database updates are done by this function. It only operates on the member variables in memory. Use and insert or update function to store this value to disk.

wxDbTable::SetOrderByClause
void SetOrderByClause(const wxString &OrderBy) Accessor function for setting the private class member wxDbTable::orderBy which determines sequence/ordering of the rows returned in the result set of a query. A synonym to this function is one form of the function wxDbTable::OrderBy (p. 322) Parameters OrderBy A comma separated list of column names that indicate the alphabetized sorting sequence that the result set is to be returned in. If a FROM clause has also been specified, each column name specified in the ORDER BY clause should be prefaced with the table name to which the column belongs using DOT notation (TABLE_NAME.COLUMN_NAME). Remarks Do not include the keywords "ORDER BY" when setting the ORDER BY clause. Example
... parts->SetOrderByClause("PART_DESCRIP, QUANTITY"); ... ... location->SetOrderByClause("LOCATION.POSITION, PART.PART_NUMBER); ...

332


CHAPTER 7
See also wxDbTable::OrderBy (p. 322),wxDbTable::GetOrderByClause (p. 318)

wxDbTable::SetQueryTimeout
bool SetQueryTimeout(UDWORD nSeconds) Allows a time period to be set as the timeout period for queries. Parameters nSeconds The number of seconds to wait for the query to complete before timing out. Remarks Neither Oracle or Access support this function as of yet. Other databases should be evaluated for support before depending on this function working correctly.

wxDbTable::SetWhereClause
void SetWhereClause(const wxString &Where) Accessor function for setting the private class member wxDbTable::where that determines which rows are returned in the result set by the datasource. A synonym to this function is one form of the function wxDbTable::Where (p. 335) Parameters Where SQL "where" clause. This clause can contain any SQL language that is legal in standard where clauses. If a FROM clause has also been specified, each column name specified in the ORDER BY clause should be prefaced with the table name to which the column belongs using DOT notation (TABLE_NAME.COLUMN_NAME). Remarks Do not include the keywords "WHERE" when setting the WHERE clause. Example
... // Simple where clause parts->SetWhereClause("PART_NUMBER = '32'"); ... // Any comparison operators parts >SetWhereClause("PART_DESCRIP LIKE 'HAMMER%'"); ... // Multiple comparisons, including a function call parts->Where("QTY > 0 AND {fn UCASE(PART_DESCRIP)} LIKE '%DRILL%'");

333


CHAPTER 7
... // Using parameters and multiple logical combinations parts->Where("((QTY > 10) OR (ON_ORDER > 0)) AND ON_HOLD = 0"); ... // This query uses an outer join (requiring a FROM clause also) // that joins the PART and LOCATION table on he common field // PART_NUMBER. parts->Where("PART.ON_HOLD = 0 AND \ PART.PART_NUMBER = LOCATION.PART_NUMBER AND \ LOCATION.PART_NUMBER > 0");

See also wxDbTable::Where (p. 335),wxDbTable::GetWhereClause (p. 319)

wxDbTable::Update
bool Update() bool Update(const wxString &pSqlStmt) The first form of this function will update the row that the current cursor is currently positioned at with the values in the memory variables that are bound to the columns. The actual SQL statement to perform the update is automatically created by the ODBC class, and then executed. The second form of the function allows full access through SQL statements for updating records in the database. Write any valid SQL UPDATE statement and submit it to this function for execution. Sophisticated updates can be performed using the full power of the SQL dialect. The full SQL statement must have the exact syntax required by the driver/datasource for performing the update. This usually is in the form of:
UPDATE tablename SET col1=X, col2=Y, ... where ...

Parameters pSqlStmt Pointer to SQL UPDATE statement to be executed. Remarks A wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286) must be called after use of this function to commit or rollback the update. Example
wxString sqlStmt; sqlStmt = "update PART set QTY = 0 where PART_NUMBER = '32'";

wxDbTable::UpdateWhere
bool UpdateWhere(const wxString &pWhereClause) Performs updates to the base table of the wxDbTable object, updating only the rows

334


CHAPTER 7
which match the criteria specified in the pWhereClause. All columns that are bound to member variables for this wxDbTable instance that were defined with the "updateable" parameter set to true will be updated with the information currently held in the memory variable. Parameters pWhereClause Pointer to a valid SQL WHERE clause. Do not include the keyword 'WHERE'. Remarks Care should be used when updating columns that are part of indexes with this function so as not to violate an unique key constraints. A wxDb::CommitTrans (p. 271) orwxDb::RollbackTrans (p. 286) must be called after use of this function to commit or rollback the update(s).

wxDbTable::Where
const wxString & Where() void Where(const wxString& Where) Accessor function for the private class member wxDbTable::where. Can be used as a synonym for wxDbTable::GetWhereClause (p. 319)(the first form of this function) to return the current where clause orwxDbTable::SetWhereClause (p. 333) (the second form of this function) to set the where clause for this table instance. Parameters Where A valid SQL WHERE clause. Do not include the keyword 'WHERE'. Return value The first form of this function returns the current value of the wxDbTable member variable ::where. The second form of the function has no return value, as it will always set the where clause successfully. See also wxDbTable::GetWhereClause (p. 319),wxDbTable::SetWhereClause (p. 333)

wxDbTable::operator ++
bool operator ++()

335


CHAPTER 7
Synonym for wxDbTable::GetNext (p. 317) See also wxDbTable::GetNext (p. 317)

wxDbTable::operator -bool operator --() Synonym for wxDbTable::GetPrev (p. 318) See also wxDbTable::GetPrev (p. 318)

wxDbTableInf
tableName[0] tableType[0] tableRemarks[0] numCols pColInf = = = = = 0; 0; 0; 0; NULL;

Currently only used by wxDb::GetCatalog (p. 275) internally and wxDbInf (p. 300) class, but may be used in future releases for user functions. Contains information describing the table (Name, type, etc). A pointer to a wxDbColInf array instance is included so a program can create awxDbColInf (p. 293) array instance (usingwxDb::GetColumns (p. 276)) to maintain all information about the columns of a table in one memory structure. Eventually, accessor functions will be added for this class See the database classes overview (p. 1668) for an introduction to using the ODBC classes.

wxDbTableInf::Initialize
Simply initializes all member variables to a cleared state. Called by the constructor automatically.

wxDbGridColInfo
This class is used to define columns to be shown, names of the columns, order and type of data, when using wxdbGridTableBase (p. 338) to display a Table or query in a wxGrid (p. 569) See the database grid example in wxDbGridTableBase (p. 338) for an introduction to using the wxDbGrid classes.

336


CHAPTER 7
Include files <wx/dbgrid.h>

wxDbGridColInfo::wxDbGridColInfo
wxDbGridColInfo(int colNo, wxString type, wxString title, wxDbGridColInfo *next) Default constructor. See the database grid example in wxDbGridTableBase (p. 338) to see two different ways for adding columns. Parameters colNo Column number in the wxDbTable (p. 301) instance to be used (first column is 0). type Column type ,wxString specifying the grid name for the datatype in this column, or use wxGRID_VALUE_DBAUTO to determine the type automatically from the wxDbColDef (p. 292) definition title The column label to be used in the grid display next A pointer to the next wxDbGridColInfo structure if using one-step construction, NULL terminates the list. Use Null also if using two step construction. See the database grid example in wxDbGridTableBase (p. 338) to see two different ways for adding columns.

wxDbGridColInfo::~wxDbGridColInfo
~wxDbGridColInfo() Destructor.

wxDbGridColInfo::AddColInfo
void AddColInfo(int colNo,wxString type, wxString title) Use this member function for adding columns. See the database grid example in wxDbGridTableBase (p. 338) to see two different ways for adding columns. It is important to note that this class is merely a specifier to the wxDbGridTableBase (p.

337


CHAPTER 7
338) constructor. Changes made to this datatype after the wxDbGridTableBase (p. 338) is called will not have any effect. ParameterscolNo Column number in the wxDbTable (p. 301) instance to be used (first column is 0). type Column type ,wxString specifying the grid name for the datatype in this column, or use wxGRID_VALUE_DBAUTO to determine the type automatically from the wxDbColDef (p. 292) definition title The column label to be used in the grid display Remarks As wxDbTable must be defined with to have columns which match those to by a wxDbGridColInfo info structure as this is the structure which informs the grid of how you want to display your wxDbTable (p. 301). If no datatype conversion or the referenced column number does not exist the the behavior is undefined. See the example at wxDbGridColInfo::wxDbGridColInfo (p. 337).

wxDbGridTableBase
You can view a database table in a grid using this class. If you are deriving your own wxDbTable subclass for your table , then you may consider overriding GetCol() and SetCol() to provide calculated fields. This does work but care should be taken when using wxDbGridTableBase in this way. The constructor and AssignDbTable() call allows you to specify the ownership if the wxDbTable object pointer. If you tell wxGridTableBase to take ownership , it will delete the passed wxDbTable when an new on is assigned or wxGridTableBase's destructor is called. However no checks for aliasing are done so Assign(table,..,true); Assign(table,..,true); is an error. If you need to requery an table object the preferred way is that the client keeps ownership. Derived From wxGridTableBase (p. 629) Include files <wx/dbgrid.h> Example
// First step, let's define wxDbTable int numColumns = 2; wxDbTable *table = new wxDbTable (db, tblName, numColumns);

338


CHAPTER 7
int int_var; wxChar string_name[255]; table->SetColDef (0, "column 0", DB_DATA_TYPE_INTEGER, &int_var, SQL_C_LONG, sizeof(int_var), true); table->SetColDef (1, "column 1", DB_DATA_TYPE_VARCHAR, &string_name, SQL_C_LONG, sizeof(string_name), false); // now let's define columns in the grid // first way to do it wxDbGridColInfo *columns; columns = new wxDbGridColInfo(0, wxGRID_VALUE_LONG, "first column", new wxDbGridColInfo(1, wxGRID_VALUE_STRING, "second column", NULL); // second way to do it wxDbGridColInfo *columns; // first column is special columns = new wxDbGridColInfo(0, wxGRID_VALUE_LONG, "first column", NULL); // all the rest columns->AddColInfo (1, wxGRID_VALUE_STRING, "second column"); // second way may be better when columns are not known at compile time // now, let's open the table and make a Query() table >Open(); // this step is very important table->SetRowMode (wxDbTable::WX_ROW_MODE_QUERY); // in the grid we will see only the rows of the result query m_dbTable->Query(); wxDbGridTableBase *dbgrid = new wxDbGridTableBase(table, columns, wxUSE_QUERY, true); delete columns; // not needed anymore wxGrid *grid = new wxGrid ( ... ); grid->SetTable(dbgrid, true); grid->Fit();

Include files <wx/dbgrid.h> Helper classes and data structures

wxDbGridTableBase::wxDbGridTableBase
wxDbGridTableBase(wxDbTable *tab, wxDbGridColInfo *ColInfo, int count = wxUSE_QUERY, bool takeOwnership = true) Constructor. Parameters tab The database table you want to display. Must be opened and queried before display the grid. See the example above (p. 338). ColInfo Columns titles, and other values. See wxDbGridColInfo (p. 336).

339


CHAPTER 7
count You can use a query result set (wxUSE_QUERY, to use wxDbTable::Count(wxDbTable::Count() or you can fix the total number of rows (count >= 0) to display, or specify it if you already know the size in avoid calling takeOwnership If true, this class deletes wxDbTable when it stops referring to it, if false application must take care of deleting it.

wxDbGridTableBase::ValidateRow
void ValidateRow(int row) It ensures that the row data is fetched from the database, and it the wxDbTable local buffer, the row number passed should be the grid row. Parameters row Row where validation must be done.

wxDbGridTableBase::UpdateRow
bool UpdateRow(int row) If row has changed it forces that row to be written back to the database, however support for detecting whether insert/update is required is currently not in wxDbTable, so this function is currently unsupported. Parameters row Row you want to update.

wxDbGridTableBase::AssignDbTable
bool AssignDbTable(wxDbTable *tab,int count = wxUSE_QUERY,bool takeOwnership = true) Resets the grid for using with a new database table, but using the same columns definition. This can be useful when re-querying the database and want to see the changes. Parameters tab

340


CHAPTER 7
Database table you want to assign to the grid. count Number of rows you want to show or wxUSE_QUERY for using a query. takeOwnership If false, user must take care of deleting tab after deleting the wxDbGridTableBase. If true, deletion is made by destructor class.

wxDebugContext
A class for performing various debugging and memory tracing operations. Full functionality (such as printing out objects currently allocated) is only present in a debugging build of wxWindows, i.e. if the __WXDEBUG__ symbol is defined. wxDebugContext and related functions and macros can be compiled out by setting wxUSE_DEBUG_CONTEXT to 0 is setup.h Derived from No parent class. Include files <wx/memory.h> See also Overview (p. 1599)

wxDebugContext::Check
int Check() Checks the memory blocks for errors, starting from the currently set checkpoint. Return value Returns the number of errors, so a value of zero represents success. Returns -1 if an error was detected that prevents further checking.

wxDebugContext::Dump
bool Dump() Performs a memory dump from the currently set checkpoint, writing to the current debug stream. Calls the Dump member function for each wxObject derived instance.

341


CHAPTER 7
Return value true if the function succeeded, false otherwise.

wxDebugContext::GetCheckPrevious
bool GetCheckPrevious() Returns true if the memory allocator checks all previous memory blocks for errors. By default, this is false since it slows down execution considerably. See also wxDebugContext::SetCheckPrevious (p. 344)

wxDebugContext::GetDebugMode
bool GetDebugMode() Returns true if debug mode is on. If debug mode is on, the wxObject new and delete operators store or use information about memory allocation. Otherwise, a straight malloc and free will be performed by these operators. See also wxDebugContext::SetDebugMode (p. 344)

wxDebugContext::GetLevel
int GetLevel() Gets the debug level (default 1). The debug level is used by the wxTraceLevel function and the WXTRACELEVEL macro to specify how detailed the trace information is; setting a different level will only have an effect if trace statements in the application specify a value other than one. This is obsolete, replaced by wxLog (p. 843) functionality. See also wxDebugContext::SetLevel (p. 345)

wxDebugContext::GetStream
ostream& GetStream() Returns the output stream associated with the debug context. This is obsolete, replaced by wxLog (p. 843) functionality.

342


CHAPTER 7
See also wxDebugContext::SetStream (p. 345)

wxDebugContext::GetStreamBuf
streambuf* GetStreamBuf() Returns a pointer to the output stream buffer associated with the debug context. There may not necessarily be a stream buffer if the stream has been set by the user. This is obsolete, replaced by wxLog (p. 843) functionality.

wxDebugContext::HasStream
bool HasStream() Returns true if there is a stream currently associated with the debug context. This is obsolete, replaced by wxLog (p. 843) functionality. See also wxDebugContext::SetStream (p. 345), wxDebugContext::GetStream (p. 342)

wxDebugContext::PrintClasses
bool PrintClasses() Prints a list of the classes declared in this application, giving derivation and whether instances of this class can be dynamically created. See also wxDebugContext::PrintStatistics (p. 343)

wxDebugContext::PrintStatistics
bool PrintStatistics(bool detailed = true) Performs a statistics analysis from the currently set checkpoint, writing to the current debug stream. The number of object and non-object allocations is printed, together with the total size. Parameters detailed If true, the function will also print how many objects of each class have been

343


CHAPTER 7
allocated, and the space taken by these class instances. See also wxDebugContext::PrintStatistics (p. 343)

wxDebugContext::SetCheckpoint
void SetCheckpoint(bool all = false) Sets the current checkpoint: Dump and PrintStatistics operations will be performed from this point on. This allows you to ignore allocations that have been performed up to this point. Parameters all If true, the checkpoint is reset to include all memory allocations since the program started.

wxDebugContext::SetCheckPrevious
void SetCheckPrevious(bool check) Tells the memory allocator to check all previous memory blocks for errors. By default, this is false since it slows down execution considerably. See also wxDebugContext::GetCheckPrevious (p. 342)

wxDebugContext::SetDebugMode
void SetDebugMode(bool debug) Sets the debug mode on or off. If debug mode is on, the wxObject new and delete operators store or use information about memory allocation. Otherwise, a straight malloc and free will be performed by these operators. By default, debug mode is on if __WXDEBUG__ is defined. If the application uses this function, it should make sure that all object memory allocated is deallocated with the same value of debug mode. Otherwise, the delete operator might try to look for memory information that does not exist. See also wxDebugContext::GetDebugMode (p. 342)

344


CHAPTER 7 wxDebugContext::SetFile
bool SetFile(const wxString& filename) Sets the current debug file and creates a stream. This will delete any existing stream and stream buffer. By default, the debug context stream outputs to the debugger (Windows) or standard error (other platforms).

wxDebugContext::SetLevel
void SetLevel(int level) Sets the debug level (default 1). The debug level is used by the wxTraceLevel function and the WXTRACELEVEL macro to specify how detailed the trace information is; setting a different level will only have an effect if trace statements in the application specify a value other than one. This is obsolete, replaced by wxLog (p. 843) functionality. See also wxDebugContext::GetLevel (p. 342)

wxDebugContext::SetStandardError
bool SetStandardError() Sets the debugging stream to be the debugger (Windows) or standard error (other platforms). This is the default setting. The existing stream will be flushed and deleted. This is obsolete, replaced by wxLog (p. 843) functionality.

wxDebugContext::SetStream
void SetStream(ostream* stream, streambuf* streamBuf = NULL) Sets the stream and optionally, stream buffer associated with the debug context. This operation flushes and deletes the existing stream (and stream buffer if any). This is obsolete, replaced by wxLog (p. 843) functionality. Parameters stream Stream to associate with the debug context. Do not set this to NULL. streamBuf Stream buffer to associate with the debug context.

345


CHAPTER 7
See also wxDebugContext::GetStream (p. 342), wxDebugContext::HasStream (p. 343)

wxDebugStreamBuf
This class allows you to treat debugging output in a similar (stream-based) fashion on different platforms. Under Windows, an ostream constructed with this buffer outputs to the debugger, or other program that intercepts debugging output. On other platforms, the output goes to standard error (cerr). This is soon to be obsolete, replaced by wxLog (p. 843) functionality. Derived from streambuf Include files <wx/memory.h> Example
wxDebugStreamBuf streamBuf; ostream stream(&streamBuf); stream << "Hello world!" << endl;

See also Overview (p. 1599)

wxDelegateRendererNative
wxDelegateRendererNative allows reuse of renderers code by forwarding all the wxRendererNative (p. 1059) methods to the given object and thus allowing you to only modify some of its methods -- without having to reimplement all of them. Note that the "normal'', inheritance-based approach, doesn't work with the renderers as it is impossible to derive from a class unknown at compile-time and the renderer is only chosen at run-time. So suppose that you want to only add something to the drawing of the tree control buttons but leave all the other methods unchanged -- the only way to do it, considering that the renderer class which you want to customize might not even be written yet when you write your code (it could be written later and loaded from a DLL during run-time), is by using this class. Except for the constructor, it has exactly the same methods as wxRendererNative (p. 1059) and their implementation is trivial: they are simply forwarded to the real renderer. Note that the "real'' renderer may, in turn, be a wxDelegateRendererNative as well and that there may be arbitrarily many levels like this -- but at the end of the chain there must be a real renderer which does the drawing.

346


CHAPTER 7
Derived from wxRendererNative (p. 1059) Include files <wx/renderer.h>

wxDelegateRendererNative::wxDelegateRendererNative
wxDelegateRendererNative() wxDelegateRendererNative(wxRendererNative& rendererNative) The default constructor does the same thing as the other one except that it uses the generic renderer (p. 1061) instead of the user-specified rendererNative. In any case, this sets up the delegate renderer object to follow all calls to the specified real renderer. Note that this object does not take ownership of (i.e. won't delete)rendererNative.

wxDelegateRendererNative::DrawXXX
DrawXXX(...) This class also provides all the virtual methods of wxRendererNative (p. 1059), please refer to that class documentation for the details.

wxDC
A wxDC is a device context onto which graphics and text can be drawn. It is intended to represent a number of output devices in a generic way, so a window can have a device context associated with it, and a printer also has a device context. In this way, the same piece of code may write to a number of different devices, if the device context is used as a parameter. Derived types of wxDC have documentation for specific features only, so refer to this section for most device context information. Please note that in addition to the versions of the methods documented here, there are also versions which accept single wxPoint parameter instead of two wxCoord ones or wxPoint and wxSize instead of four of them. Derived from wxObject (p. 954)

347


CHAPTER 7
Include files <wx/dc.h> See also Overview (p. 1641)

wxDC::wxDC
wxDC() Constructor.

wxDC::~wxDC
~wxDC() Destructor.

wxDC::BeginDrawing
void BeginDrawing() Allows optimization of drawing code under MS Windows. Enclose drawing primitives between BeginDrawing and EndDrawing calls. Drawing to a wxDialog panel device context outside of a system-generated OnPaint event requires this pair of calls to enclose drawing code. This is because a Windows dialog box does not have a retained device context associated with it, and selections such as pen and brush settings would be lost if the device context were obtained and released for each drawing operation.

wxDC::Blit
bool Blit(wxCoord xdest, wxCoord ydest, wxCoord width, wxCoord height, wxDC* source, wxCoord xsrc, wxCoord ysrc, int logicalFunc = wxCOPY, bool useMask = false, wxCoord xsrcMask = -1, wxCoord ysrcMask = -1) Copy from a source DC to this DC, specifying the destination coordinates, size of area to copy, source DC, source coordinates, logical function, whether to use a bitmap mask, and mask source position. Parameters xdest Destination device context x position.

348


CHAPTER 7
ydest Destination device context y position. width Width of source area to be copied. height Height of source area to be copied. source Source device context. xsrc Source device context x position. ysrc Source device context y position. logicalFunc Logical function to use: see wxDC::SetLogicalFunction (p. 364). useMask If true, Blit does a transparent blit using the mask that is associated with the bitmap selected into the source device context. The Windows implementation does the following if MaskBlt cannot be used: 1. 2. 3. Creates a temporary bitmap and copies the destination area into it. Copies the source area into the temporary bitmap using the specified logical function. Sets the masked area in the temporary bitmap to BLACK by ANDing the mask bitmap with the temp bitmap with the foreground colour set to WHITE and the bg colour set to BLACK. Sets the unmasked area in the destination area to BLACK by ANDing the mask bitmap with the destination area with the foreground colour set to BLACK and the background colour set to WHITE. ORs the temporary bitmap with the destination area. Deletes the temporary bitmap.

4.

5. 6.

This sequence of operations ensures that the source's transparent area need not be black, and logical functions are supported. Note: on Windows, blitting with masks can be speeded up considerably by compiling wxWindows with the wxUSE_DC_CACHE option enabled. You can also

349


CHAPTER 7
influence whether MaskBlt or the explicit mask blitting code above is used, by using wxSystemOptions (p. 1228) and setting the no-maskblt option to 1.

xsrcMask Source x position on the mask. If both xsrcMask and ysrcMask are -1, xsrc and ysrc will be assumed for the mask source position. Currently only implemented on Windows. ysrcMask Source y position on the mask. If both xsrcMask and ysrcMask are -1, xsrc and ysrc will be assumed for the mask source position. Currently only implemented on Windows. Remarks There is partial support for Blit in wxPostScriptDC, under X. See wxMemoryDC (p. 881) for typical usage. See also wxMemoryDC (p. 881), wxBitmap (p. 67), wxMask (p. 860)

wxDC::CalcBoundingBox
void CalcBoundingBox(wxCoord x, wxCoord y) Adds the specified point to the bounding box which can be retrieved with MinX (p. 362), MaxX (p. 361) and MinY (p. 362), MaxY (p. 361) functions. See also ResetBoundingBox (p. 362)

wxDC::Clear
void Clear() Clears the device context using the current background brush.

wxDC::CrossHair
void CrossHair(wxCoord x, wxCoord y) Displays a cross hair using the current pen. This is a vertical and horizontal line the height and width of the window, centred on the given point.

350


CHAPTER 7 wxDC::DestroyClippingRegion
void DestroyClippingRegion() Destroys the current clipping region so that none of the DC is clipped. See also wxDC::SetClippingRegion (p. 363).

wxDC::DeviceToLogicalX
wxCoord DeviceToLogicalX(wxCoord x) Convert device X coordinate to logical coordinate, using the current mapping mode.

wxDC::DeviceToLogicalXRel
wxCoord DeviceToLogicalXRel(wxCoord x) Convert device X coordinate to relative logical coordinate, using the current mapping mode but ignoring the x axis orientation. Use this function for converting a width, for example.

wxDC::DeviceToLogicalY
wxCoord DeviceToLogicalY(wxCoord y) Converts device Y coordinate to logical coordinate, using the current mapping mode.

wxDC::DeviceToLogicalYRel
wxCoord DeviceToLogicalYRel(wxCoord y) Convert device Y coordinate to relative logical coordinate, using the current mapping mode but ignoring the y axis orientation. Use this function for converting a height, for example.

wxDC::DrawArc
void DrawArc(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2, wxCoord xc, wxCoord yc) Draws an arc of a circle, centred on (xc, yc), with starting point (x1, y1) and ending at (x2, y2). The current pen is used for the outline and the current brush for filling the shape. The arc is drawn in an anticlockwise direction from the start point to the end point.

351


CHAPTER 7 wxDC::DrawBitmap
void DrawBitmap(const wxBitmap& bitmap, wxCoord x, wxCoord y, bool transparent) Draw a bitmap on the device context at the specified point. If transparent is true and the bitmap has a transparency mask, the bitmap will be drawn transparently. When drawing a mono-bitmap, the current text foreground colour will be used to draw the foreground of the bitmap (all bits set to 1), and the current text background colour to draw the background (all bits set to 0). See also SetTextForeground (p. 366), SetTextBackground (p. 366) and wxMemoryDC (p. 881).

wxDC::DrawCheckMark
void DrawCheckMark(wxCoord x, wxCoord y, wxCoord width, wxCoord height) void DrawCheckMark(const wxRect &rect) Draws a check mark inside the given rectangle.

wxDC::DrawCircle
void DrawCircle(wxCoord x, wxCoord y, wxCoord radius) void DrawCircle(const wxPoint& pt, wxCoord radius) Draws a circle with the given centre and radius. See also DrawEllipse (p. 352)

wxDC::DrawEllipse
void DrawEllipse(wxCoord x, wxCoord y, wxCoord width, wxCoord height) void DrawEllipse(const wxPoint& pt, const wxSize& size) void DrawEllipse(const wxRect& rect) Draws an ellipse contained in the rectangle specified either with the given top left corner and the given size or directly. The current pen is used for the outline and the current brush for filling the shape. See also DrawCircle (p. 352)

352


CHAPTER 7 wxDC::DrawEllipticArc
void DrawEllipticArc(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double start, double end) Draws an arc of an ellipse. The current pen is used for drawing the arc and the current brush is used for drawing the pie. x and y specify the x and y coordinates of the upper-left corner of the rectangle that contains the ellipse. width and height specify the width and height of the rectangle that contains the ellipse. start and end specify the start and end of the arc relative to the three-o'clock position from the center of the rectangle. Angles are specified in degrees (360 is a complete circle). Positive values mean counter-clockwise motion. If start is equal to end, a complete ellipse will be drawn.

wxDC::DrawIcon
void DrawIcon(const wxIcon& icon, wxCoord x, wxCoord y) Draw an icon on the display (does nothing if the device context is PostScript). This can be the simplest way of drawing bitmaps on a window.

wxDC::DrawLine
void DrawLine(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2) Draws a line from the first point to the second. The current pen is used for drawing the line. Note that the point (x2, y2) is not part of the line and is not drawn by this function (this is consistent with the behaviour of many other toolkits).

wxDC::DrawLines
void DrawLines(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0) void DrawLines(wxList *points, wxCoord xoffset = 0, wxCoord yoffset = 0) Draws lines using an array of points of size n, or list of pointers to points, adding the optional offset coordinate. The current pen is used for drawing the lines. The programmer is responsible for deleting the list of points. wxPython note: The wxPython version of this method accepts a Python list of wxPoint objects. wxPerl note: The wxPerl version of this method accepts as its first parameter a reference to an array of wxPoint objects.

353


CHAPTER 7 wxDC::DrawPolygon
void DrawPolygon(int n, wxPoint points[], wxCoord xoffset = 0, wxCoord yoffset = 0, int fill_style = wxODDEVEN_RULE) void DrawPolygon(wxList *points, wxCoord xoffset = 0, wxCoord yoffset = 0, int fill_style = wxODDEVEN_RULE) Draws a filled polygon using an array of points of size n, or list of pointers to points, adding the optional offset coordinate. The last argument specifies the fill rule: wxODDEVEN_RULE (the default) or wxWINDING_RULE. The current pen is used for drawing the outline, and the current brush for filling the shape. Using a transparent brush suppresses filling. The programmer is responsible for deleting the list of points. Note that wxWindows automatically closes the first and last points. wxPython note: The wxPython version of this method accepts a Python list of wxPoint objects. wxPerl note: The wxPerl version of this method accepts as its first parameter a reference to an array of wxPoint objects.

wxDC::DrawPolyPolygon
void DrawPolyPolygon(int n, int start[], wxPoint points[], wxCoord xoffset, wxCoord yoffset, int fillStyle = wxODDEVEN_RULE) Draw many polygons at once. For the platforms providing a native implementation of this function (Windows and PostScript-based wxDC), this is more efficient than using DrawPolygon (p. 354) in a loop.

wxDC::DrawPoint
void DrawPoint(wxCoord x, wxCoord y) Draws a point using the current pen.

wxDC::DrawRectangle
void DrawRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height) Draws a rectangle with the given top left corner, and with the given size. The current pen is used for the outline and the current brush for filling the shape.

354


CHAPTER 7 wxDC::DrawRotatedText
void DrawRotatedText(const wxString& text, wxCoord x, wxCoord y, double angle) Draws the text rotated by angle degrees. NB: Under Win9x only TrueType fonts can be drawn by this function. In particular, a font different from wxNORMAL_FONT should be used as the latter is not a TrueType font. wxSWISS_FONT is an example of a font which is. See also DrawText (p. 355)

wxDC::DrawRoundedRectangle
void DrawRoundedRectangle(wxCoord x, wxCoord y, wxCoord width, wxCoord height, double radius = 20) Draws a rectangle with the given top left corner, and with the given size. The corners are quarter-circles using the given radius. The current pen is used for the outline and the current brush for filling the shape. If radius is positive, the value is assumed to be the radius of the rounded corner. If radius is negative, the absolute value is assumed to be the proportion of the smallest dimension of the rectangle. This means that the corner can be a sensible size relative to the size of the rectangle, and also avoids the strange effects X produces when the corners are too big for the rectangle.

wxDC::DrawSpline
void DrawSpline(wxList *points) Draws a spline between all given control points, using the current pen. Doesn't delete the wxList and contents. The spline is drawn using a series of lines, using an algorithm taken from the X drawing program 'XFIG'. void DrawSpline(wxCoord x1, wxCoord y1, wxCoord x2, wxCoord y2, wxCoord x3, wxCoord y3) Draws a three-point spline using the current pen. wxPython note: The wxPython version of this method accepts a Python list of wxPoint objects. wxPerl note: The wxPerl version of this method accepts a reference to an array of wxPoint objects.

wxDC::DrawText

355


CHAPTER 7
void DrawText(const wxString& text, wxCoord x, wxCoord y) Draws a text string at the specified point, using the current text font, and the current text foreground and background colours. The coordinates refer to the top-left corner of the rectangle bounding the string. See wxDC::GetTextExtent (p. 360) for how to get the dimensions of a text string, which can be used to position the text more precisely. NB: under wxGTK the current logical function (p. 358) is used by this function but it is ignored by wxMSW. Thus, you should avoid using logical functions with this function in portable programs.

wxDC::EndDoc
void EndDoc() Ends a document (only relevant when outputting to a printer).

wxDC::EndDrawing
void EndDrawing() Allows optimization of drawing code under MS Windows. Enclose drawing primitives between BeginDrawing and EndDrawing calls.

wxDC::EndPage
void EndPage() Ends a document page (only relevant when outputting to a printer).

wxDC::FloodFill
bool FloodFill(wxCoord x, wxCoord y, const wxColour& colour, int style=wxFLOOD_SURFACE) Flood fills the device context starting from the given point, using the current brush colour, and using a style:   wxFLOOD_SURFACE: the flooding occurs until a colour other than the given colour is encountered. wxFLOOD_BORDER: the area to be flooded is bounded by the given colour.

Returns false if the operation failed. Note: The present implementation for non-Windows platforms may fail to find colour borders if the pixels do not match the colour exactly. However the function will still return

356


CHAPTER 7
true.

wxDC::GetBackground
wxBrush& GetBackground() const wxBrush& GetBackground() const Gets the brush used for painting the background (see wxDC::SetBackground (p. 363)).

wxDC::GetBackgroundMode
int GetBackgroundMode() const Returns the current background mode: wxSOLID or wxTRANSPARENT. See also SetBackgroundMode (p. 363)

wxDC::GetBrush
wxBrush& GetBrush() const wxBrush& GetBrush() const Gets the current brush (see wxDC::SetBrush (p. 364)).

wxDC::GetCharHeight
wxCoord GetCharHeight() Gets the character height of the currently set font.

wxDC::GetCharWidth
wxCoord GetCharWidth() Gets the average character width of the currently set font.

wxDC::GetClippingBox
void GetClippingBox(wxCoord *x, wxCoord *y, wxCoord *width, wxCoord *height) Gets the rectangle surrounding the current clipping region. wxPython note: No arguments are required and the four values defining the rectangle

357


CHAPTER 7
are returned as a tuple. wxPerl note: This method takes no arguments and returns a four element list( x, y, width, height )

wxDC::GetFont
wxFont& GetFont() const wxFont& GetFont() const Gets the current font (see wxDC::SetFont (p. 364)).

wxDC::GetLogicalFunction
int GetLogicalFunction() Gets the current logical function (see wxDC::SetLogicalFunction (p. 364)).

wxDC::GetMapMode
int GetMapMode() Gets the mapping mode for the device context (see wxDC::SetMapMode (p. 365)).

wxDC::GetOptimization
bool GetOptimization() Returns true if device context optimization is on. See wxDC::SetOptimization (p. 365) for details.

wxDC::GetPartialTextExtents
bool GetPartialTextExtents(const wxString& text, wxArrayInt& widths) const Fills the widths array with the widths from the begining of text to the coresponding character of text. The generic version simply builds a running total of the widths of each character using GetTextExtent (p. 360), however if the various platforms have a native API function that is faster or more accurate than the generic implementaiton then it should be used instead. wxPython note: This method only takes the text parameter and returns a Python list of integers.

wxDC::GetPen

358


CHAPTER 7
wxPen& GetPen() const wxPen& GetPen() const Gets the current pen (see wxDC::SetPen (p. 366)).

wxDC::GetPixel
bool GetPixel(wxCoord x, wxCoord y, wxColour *colour) Sets colour to the colour at the specified location. Windows only; an X implementation is being worked on. Not available for wxPostScriptDC or wxMetafileDC. wxPython note: For wxPython the wxColour value is returned and is not required as a parameter. wxPerl note: This method only takes the parameters x and y and returns a Wx::Colour value

wxDC::GetSize
void GetSize(wxCoord *width, wxCoord *height) For a PostScript device context, this gets the maximum size of graphics drawn so far on the device context. For a Windows printer device context, this gets the horizontal and vertical resolution. It can be used to scale graphics to fit the page when using a Windows printer device context. For example, if maxX and maxY represent the maximum horizontal and vertical 'pixel' values used in your application, the following code will scale the graphic to fit on the printer page:
wxCoord w, h; dc.GetSize(&w, &h); double scaleX=(double)(maxX/w); double scaleY=(double)(maxY/h); dc.SetUserScale(min(scaleX,scaleY),min(scaleX,scaleY));

wxPython note: In place of a single overloaded method name, wxPython implements the following methods: GetSize() GetSizeTuple() Returns a wxSize Returns a 2-tuple (width, height)

wxPerl note: In place of a single overloaded method, wxPerl uses: GetSize() GetSizeWH() Returns a Wx::Size Returns a 2-element list ( width, height )

359


CHAPTER 7

wxDC::GetTextBackground
wxColour& GetTextBackground() const wxColour& GetTextBackground() const Gets the current text background colour (see wxDC::SetTextBackground (p. 366)).

wxDC::GetTextExtent
void GetTextExtent(const wxString& string, wxCoord *w, wxCoord *h, wxCoord *descent = NULL, wxCoord *externalLeading = NULL, wxFont *font = NULL) Gets the dimensions of the string using the currently selected font. string is the text string to measure, w and h are the total width and height respectively, descent is the dimension from the baseline of the font to the bottom of the descender, and externalLeading is any extra vertical space added to the font by the font designer (usually is zero). The optional parameter font specifies an alternative to the currently selected font: but note that this does not yet work under Windows, so you need to set a font for the device context first. See also wxFont (p. 510), wxDC::SetFont (p. 364). wxPython note: The following methods are implemented in wxPython: GetTextExtent(string) Returns a 2-tuple, (width, height)

GetFullTextExtent(string, font=NULL)Returns a 4-tuple, (width, height, descent, externalLeading) wxPerl note: In wxPerl this method is implemented as GetTextExtent( string, font = undef ) returning a four element array ( width, height, descent, externalLeading )

wxDC::GetTextForeground
wxColour& GetTextForeground() const wxColour& GetTextForeground() const Gets the current text foreground colour (see wxDC::SetTextForeground (p. 366)).

wxDC::GetUserScale

360


CHAPTER 7
void GetUserScale(double *x, double *y) Gets the current user scale factor (set by SetUserScale (p. 366)). wxPerl note: In wxPerl this method takes no arguments and return a two element array ( x, y )

wxDC::LogicalToDeviceX
wxCoord LogicalToDeviceX(wxCoord x) Converts logical X coordinate to device coordinate, using the current mapping mode.

wxDC::LogicalToDeviceXRel
wxCoord LogicalToDeviceXRel(wxCoord x) Converts logical X coordinate to relative device coordinate, using the current mapping mode but ignoring the x axis orientation. Use this for converting a width, for example.

wxDC::LogicalToDeviceY
wxCoord LogicalToDeviceY(wxCoord y) Converts logical Y coordinate to device coordinate, using the current mapping mode.

wxDC::LogicalToDeviceYRel
wxCoord LogicalToDeviceYRel(wxCoord y) Converts logical Y coordinate to relative device coordinate, using the current mapping mode but ignoring the y axis orientation. Use this for converting a height, for example.

wxDC::MaxX
wxCoord MaxX() Gets the maximum horizontal extent used in drawing commands so far.

wxDC::MaxY
wxCoord MaxY() Gets the maximum vertical extent used in drawing commands so far.

361


CHAPTER 7 wxDC::MinX
wxCoord MinX() Gets the minimum horizontal extent used in drawing commands so far.

wxDC::MinY
wxCoord MinY() Gets the minimum vertical extent used in drawing commands so far.

wxDC::Ok
bool Ok() Returns true if the DC is ok to use.

wxDC::ResetBoundingBox
void ResetBoundingBox() Resets the bounding box: after a call to this function, the bounding box doesn't contain anything. See also CalcBoundingBox (p. 350)

wxDC::SetAxisOrientation
void SetAxisOrientation(bool xLeftRight, bool yBottomUp)

Sets the x and y axis orientation (i.e., the direction from lowest to highest values on the axis). The default orientation is the natural orientation, e.g. x axis from left to right and y axis from bottom up. Parameters xLeftRight True to set the x axis orientation to the natural left to right orientation, false to invert it. yBottomUp True to set the y axis orientation to the natural bottom up orientation, false to invert it.

362


CHAPTER 7 wxDC::SetDeviceOrigin
void SetDeviceOrigin(wxCoord x, wxCoord y) Sets the device origin (i.e., the origin in pixels after scaling has been applied). This function may be useful in Windows printing operations for placing a graphic on a page.

wxDC::SetBackground
void SetBackground(const wxBrush& brush) Sets the current background brush for the DC.

wxDC::SetBackgroundMode
void SetBackgroundMode(int mode) mode may be one of wxSOLID and wxTRANSPARENT. This setting determines whether text will be drawn with a background colour or not.

wxDC::SetClippingRegion
void SetClippingRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height) void SetClippingRegion(const wxPoint& pt, const wxSize& sz) void SetClippingRegion(const wxRect& rect) void SetClippingRegion(const wxRegion& region) Sets the clipping region for this device context to the intersection of the given region described by the parameters of this method and the previously set clipping region. You should call DestroyClippingRegion (p. 351) if you want to set the clipping region exactly to the region specified. The clipping region is an area to which drawing is restricted. Possible uses for the clipping region are for clipping text or for speeding up window redraws when only a known area of the screen is damaged. See also wxDC::DestroyClippingRegion (p. 351), wxRegion (p. 1052)

wxDC::SetPalette
void SetPalette(const wxPalette& palette)

363


CHAPTER 7
If this is a window DC or memory DC, assigns the given palette to the window or bitmap associated with the DC. If the argument is wxNullPalette, the current palette is selected out of the device context, and the original palette restored. See wxPalette (p. 968) for further details.

wxDC::SetBrush
void SetBrush(const wxBrush& brush) Sets the current brush for the DC. If the argument is wxNullBrush, the current brush is selected out of the device context, and the original brush restored, allowing the current brush to be destroyed safely. See also wxBrush (p. 90). See also wxMemoryDC (p. 881) for the interpretation of colours when drawing into a monochrome bitmap.

wxDC::SetFont
void SetFont(const wxFont& font) Sets the current font for the DC. It must be a valid font, in particular you should not pass wxNullFont to this method. See also wxFont (p. 510).

wxDC::SetLogicalFunction
void SetLogicalFunction(int function) Sets the current logical function for the device context. This determines how a source pixel (from a pen or brush colour, or source device context if using wxDC::Blit (p. 348)) combines with a destination pixel in the current device context. The possible values and their meaning in terms of source and destination pixel values are as follows:
wxAND wxAND_INVERT wxAND_REVERSE wxCLEAR wxCOPY wxEQUIV wxINVERT wxNAND wxNOR wxNO_OP wxOR wxOR_INVERT wxOR_REVERSE wxSET src AND dst (NOT src) AND dst src AND (NOT dst) 0 src (NOT src) XOR dst NOT dst (NOT src) OR (NOT dst) (NOT src) AND (NOT dst) dst src OR dst (NOT src) OR dst src OR (NOT dst) 1

364


CHAPTER 7
wxSRC_INVERT wxXOR NOT src src XOR dst

The default is wxCOPY, which simply draws with the current colour. The others combine the current colour and the background using a logical operation. wxINVERT is commonly used for drawing rubber bands or moving outlines, since drawing twice reverts to the original colour.

wxDC::SetMapMode
void SetMapMode(int int) The mapping mode of the device context defines the unit of measurement used to convert logical units to device units. Note that in X, text drawing isn't handled consistently with the mapping mode; a font is always specified in point size. However, setting the user scale (see wxDC::SetUserScale (p. 366)) scales the text appropriately. In Windows, scalable TrueType fonts are always used; in X, results depend on availability of fonts, but usually a reasonable match is found. Note that the coordinate origin should ideally be selectable, but for now is always at the top left of the screen/printer. Drawing to a Windows printer device context under UNIX uses the current mapping mode, but mapping mode is currently ignored for PostScript output. The mapping mode can be one of the following: wxMM_TWIPS wxMM_POINTS wxMM_METRIC wxMM_LOMETRIC wxMM_TEXT Each logical unit is 1/20 of a point, or 1/1440 of an inch. Each logical unit is a point, or 1/72 of an inch. Each logical unit is 1 mm. Each logical unit is 1/10 of a mm. Each logical unit is 1 pixel.

wxDC::SetOptimization
void SetOptimization(bool optimize) If optimize is true (the default), this function sets optimization mode on. This currently means that under X, the device context will not try to set a pen or brush property if it is known to be set already. This approach can fall down if non-wxWindows code is using the same device context or window, for example when the window is a panel on which the windowing system draws panel items. The wxWindows device context 'memory' will now be out of step with reality. Setting optimization off, drawing, then setting it back on again, is a trick that must occasionally be employed.

365


CHAPTER 7 wxDC::SetPen
void SetPen(const wxPen& pen) Sets the current pen for the DC. If the argument is wxNullPen, the current pen is selected out of the device context, and the original pen restored. See also wxMemoryDC (p. 881) for the interpretation of colours when drawing into a monochrome bitmap.

wxDC::SetTextBackground
void SetTextBackground(const wxColour& colour) Sets the current text background colour for the DC.

wxDC::SetTextForeground
void SetTextForeground(const wxColour& colour) Sets the current text foreground colour for the DC. See also wxMemoryDC (p. 881) for the interpretation of colours when drawing into a monochrome bitmap.

wxDC::SetUserScale
void SetUserScale(double xScale, double yScale) Sets the user scaling factor, useful for applications which require 'zooming'.

wxDC::StartDoc
bool StartDoc(const wxString& message) Starts a document (only relevant when outputting to a printer). Message is a message to show whilst printing.

wxDC::StartPage
bool StartPage() Starts a document page (only relevant when outputting to a printer).

366


CHAPTER 7

wxDCClipper
This is a small helper class which sets the specified to its constructor clipping region and then automatically destroys it in its destructor. Using it ensures that unwanted clipping region is not left set on the DC. Derived from No base class Include files <wx/dc.h> See also wxDC (p. 347)

wxDCClipper::wxDCClipper
wxDCClipper(wxDC& dc, wxCoord x,wxCoord y,wxCoord w,wxCoord h,) wxDCClipper(wxDC& dc, const wxRect& rect) Constructor: sets the the clipping region for the given device context to the specified rectangle.

wxDCClipper::~wxDCClipper
~wxDCClipper() Destructor: destroys the clipping region set in the constructor.

wxDialog
A dialog box is a window with a title bar and sometimes a system menu, which can be moved around the screen. It can contain controls and other windows and is usually used to allow the user to make some choice or to answer a question. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/dialog.h>

367


CHAPTER 7
Remarks There are two kinds of dialog -- modal and modeless. A modal dialog blocks program flow and user input on other windows until it is dismissed, whereas a modeless dialog behaves more like a frame in that program flow continues, and input in other windows is still possible. To show a modal dialog you should use the ShowModal (p. 375) method while to show a dialog modelessly you simply use Show (p. 375), just as with frames. Note that the modal dialog is one of the very few examples of wxWindow-derived objects which may be created on the stack and not on the heap. In other words, although this code snippet:
void AskUser() { MyAskDialog *dlg = new MyAskDialog(...); if ( dlg->ShowModal() == wxID_OK ) ... //else: dialog was cancelled or some another button pressed dlg->Destroy(); }

works, you can also achieve the same result by using a simpler code fragment below:
void AskUser() { MyAskDialog dlg(...); if ( dlg.ShowModal() == wxID_OK ) ... // no need to call Destroy() here }

An application can define an wxCloseEvent (p. 139) handler for the dialog to respond to system close events. Window styles wxCAPTION Puts a caption on the dialog box.

wxDEFAULT_DIALOG_STYLE Equivalent to a combination of wxCAPTION, wxCLOSE_BOX and wxSYSTEM_MENU (the last one is not used under Unix) wxRESIZE_BORDER wxSYSTEM_MENU wxCLOSE_BOX wxMAXIMIZE_BOX wxMINIMIZE_BOX wxTHICK_FRAME wxSTAY_ON_TOP Display a resizeable frame around the window. Display a system menu. Displays a close box on the frame. Displays a maximize box on the dialog. Displays a minimize box on the dialog. Display a thick frame around the window. The dialog stays on top of all other windows (Windows

368


CHAPTER 7
only). wxNO_3D wxDIALOG_NO_PARENT Under Windows, specifies that the child controls should not have 3D borders unless specified in the control. By default, a dialog created with a NULL parent window will be given the application's top level window (p. 33) as parent. Use this style to prevent this from happening and create an orphan dialog. This is not recommended for modal dialogs.

wxDIALOG_EX_CONTEXTHELP Under Windows, puts a query button on the caption. When pressed, Windows will go into a contextsensitive help mode and wxWindows will send a wxEVT_HELP event if the user clicked on an application window. Note that this is an extended style and must be set by calling SetExtraStyle (p. 1423) before Create is called (two-step construction). Under Unix or Linux, MWM (the Motif Window Manager) or other window managers recognizing the MHM hints should be running for any of these styles to have an effect. See also Generic window styles (p. 1611). See also wxDialog overview (p. 1614), wxFrame (p. 530), Validator overview (p. 1614)

wxDialog::wxDialog
wxDialog() Default constructor. wxDialog(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_DIALOG_STYLE, const wxString& name = "dialogBox") Constructor. Parameters parent Can be NULL, a frame or another dialog box. id An identifier for the dialog. A value of -1 is taken to mean a default. title

369


CHAPTER 7
The title of the dialog. pos The dialog position. A value of (-1, -1) indicates a default position, chosen by either the windowing system or wxWindows, depending on platform. size The dialog size. A value of (-1, -1) indicates a default size, chosen by either the windowing system or wxWindows, depending on platform. style The window style. See wxDialog (p. 367). name Used to associate a name with the window, allowing the application user to set Motif resource values for individual dialog boxes. See also wxDialog::Create (p. 370)

wxDialog::~wxDialog
~wxDialog() Destructor. Deletes any child windows before deleting the physical window.

wxDialog::Centre
void Centre(int direction = wxBOTH) Centres the dialog box on the display. Parameters direction May be wxHORIZONTAL, wxVERTICAL or wxBOTH.

wxDialog::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_DIALOG_STYLE, const wxString& name = "dialogBox") Used for two-step dialog box construction. See wxDialog::wxDialog (p. 369) for details.

370


CHAPTER 7 wxDialog::EndModal
void EndModal(int retCode) Ends a modal dialog, passing a value to be returned from the wxDialog::ShowModal (p. 375) invocation. Parameters retCode The value that should be returned by ShowModal. See also wxDialog::ShowModal (p. 375), wxDialog::GetReturnCode (p. 371), wxDialog::SetReturnCode (p. 374)

wxDialog::GetReturnCode
int GetReturnCode() Gets the return code for this window. Remarks A return code is normally associated with a modal dialog, where wxDialog::ShowModal (p. 375) returns a code to the application. See also wxDialog::SetReturnCode (p. 374), wxDialog::ShowModal (p. 375), wxDialog::EndModal (p. 371)

wxDialog::GetTitle
wxString GetTitle() const Returns the title of the dialog box.

wxDialog::Iconize
void Iconize(const bool iconize) Iconizes or restores the dialog. Windows only. Parameters iconize If true, iconizes the dialog box; if false, shows and restores it.

371


CHAPTER 7
Remarks Note that in Windows, iconization has no effect since dialog boxes cannot be iconized. However, applications may need to explicitly restore dialog boxes under Motif which have user-iconizable frames, and under Windows calling Iconize(false) will bring the window to the front, as does Show(true).

wxDialog::IsIconized
bool IsIconized() const Returns true if the dialog box is iconized. Windows only. Remarks Always returns false under Windows since dialogs cannot be iconized.

wxDialog::IsModal
bool IsModal() const Returns true if the dialog box is modal, false otherwise.

wxDialog::OnCharHook
void OnCharHook(wxKeyEvent& event) This member is called to allow the window to intercept keyboard events before they are processed by child windows. Remarks wxDialog implements this handler to fake a cancel command if the escape key has been pressed. This will dismiss the dialog.

wxDialog::OnApply
void OnApply(wxCommandEvent& event) The default handler for the wxID_APPLY identifier. Remarks This function calls wxWindow::Validate (p. 1435) and wxWindow::TransferDataToWindow (p. 1433). See also wxDialog::OnOK (p. 373), wxDialog::OnCancel (p. 373)

372


CHAPTER 7 wxDialog::OnCancel
void OnCancel(wxCommandEvent& event) The default handler for the wxID_CANCEL identifier. Remarks The function either calls EndModal(wxID_CANCEL) if the dialog is modal, or sets the return value to wxID_CANCEL and calls Show(false) if the dialog is modeless. See also wxDialog::OnOK (p. 373), wxDialog::OnApply (p. 372)

wxDialog::OnOK
void OnOK(wxCommandEvent& event) The default handler for the wxID_OK identifier. Remarks The function calls wxWindow::Validate (p. 1435), then wxWindow::TransferDataFromWindow (p. 1433). If this returns true, the function either calls EndModal(wxID_OK) if the dialog is modal, or sets the return value to wxID_OK and calls Show(false) if the dialog is modeless. See also wxDialog::OnCancel (p. 373), wxDialog::OnApply (p. 372)

wxDialog::OnSysColourChanged
void OnSysColourChanged(wxSysColourChangedEvent& event) The default handler for wxEVT_SYS_COLOUR_CHANGED. Parameters event The colour change event. Remarks Changes the dialog's colour to conform to the current settings (Windows only). Add an event table entry for your dialog class if you wish the behaviour to be different (such as keeping a user-defined background colour). If you do override this function, call wxEvent::Skip to propagate the notification to child windows and controls. See also

373


CHAPTER 7
wxSysColourChangedEvent (p. 1227)

wxDialog::SetIcon
void SetIcon(const wxIcon& icon) Sets the icon for this dialog. Parameters icon The icon to associate with this dialog. See also wxIcon (p. 716).

wxDialog::SetIcons
void SetIcons(const wxIconBundle& icons) Sets the icons for this dialog. Parameters icons The icons to associate with this dialog. See also wxIconBundle (p. 723).

wxDialog::SetModal
void SetModal(const bool flag) NB: This function is deprecated and doesn't work for all ports, just use ShowModal (p. 375) to show a modal dialog instead. Allows the programmer to specify whether the dialog box is modal (wxDialog::Show blocks control until the dialog is hidden) or modeless (control returns immediately). Parameters flag If true, the dialog will be modal, otherwise it will be modeless.

wxDialog::SetReturnCode
void SetReturnCode(int retCode)

374


CHAPTER 7
Sets the return code for this window. Parameters retCode The integer return code, usually a control identifier. Remarks A return code is normally associated with a modal dialog, where wxDialog::ShowModal (p. 375) returns a code to the application. The function wxDialog::EndModal (p. 371) calls SetReturnCode. See also wxDialog::GetReturnCode (p. 371), wxDialog::ShowModal (p. 375), wxDialog::EndModal (p. 371)

wxDialog::SetTitle
void SetTitle(const wxString& title) Sets the title of the dialog box. Parameters title The dialog box title.

wxDialog::Show
bool Show(const bool show) Hides or shows the dialog. Parameters show If true, the dialog box is shown and brought to the front; otherwise the box is hidden. If false and the dialog is modal, control is returned to the calling program. Remarks The preferred way of dismissing a modal dialog is to use wxDialog::EndModal (p. 371).

wxDialog::ShowModal
int ShowModal()

375


CHAPTER 7
Shows a modal dialog. Program flow does not return until the dialog has been dismissed with wxDialog::EndModal (p. 371). Return value The return value is the value set with wxDialog::SetReturnCode (p. 374). See also wxDialog::EndModal (p. 371), wxDialog:GetReturnCode (p. 371), wxDialog::SetReturnCode (p. 374)

wxDialUpEvent
This is the event class for the dialup events sent by wxDialUpManager (p. 377). Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/dialup.h>

wxDialUpEvent::wxDialUpEvent
wxDialUpEvent(bool isConnected, bool isOwnEvent) Constructor is only used by wxDialUpManager (p. 377).

wxDialUpEvent::IsConnectedEvent
bool IsConnectedEvent() const Is this a CONNECTED or DISCONNECTED event? In other words, does it notify about transition from offline to online state or vice versa?

wxDialUpEvent::IsOwnEvent
bool IsOwnEvent() const Does this event come from wxDialUpManager::Dial() or from some extrenal process (i.e. does it result from our own attempt to establish the connection)?

376


CHAPTER 7

wxDialUpManager
This class encapsulates functions dealing with verifying the connection status of the workstation (connected to the Internet via a direct connection, connected through a modem or not connected at all) and to establish this connection if possible/required (i.e. in the case of the modem). The program may also wish to be notified about the change in the connection status (for example, to perform some action when the user connects to the network the next time or, on the contrary, to stop receiving data from the net when the user hangs up the modem). For this, you need to use one of the event macros described below. This class is different from other wxWindows classes in that there is at most one instance of this class in the program accessed via wxDialUpManager::Create() (p. 377) and you can't create the objects of this class directly. Derived from No base class Include files <wx/dialup.h> Event table macros To be notified about the change in the network connection status, use these event handler macros to direct input to member functions that take a wxDialUpEvent (p. 376) argument. EVT_DIALUP_CONNECTED(func) A connection with the network was established.

EVT_DIALUP_DISCONNECTED(func) The connection with the network was lost. See also dialup sample (p. 1563) wxDialUpEvent (p. 376)

wxDialUpManager::Create
wxDialUpManager* Create() This function should create and return the object of the platform-specific class derived from wxDialUpManager. You should delete the pointer when you are done with it.

wxDialUpManager::IsOk
bool IsOk() const

377


CHAPTER 7
Returns true if the dialup manager was initialized correctly. If this function returns false, no other functions will work neither, so it is a good idea to call this function and check its result before calling any other wxDialUpManager methods

wxDialUpManager::~wxDialUpManager
~wxDialUpManager() Destructor.

wxDialUpManager::GetISPNames
size_t GetISPNames(wxArrayString& names) const This function is only implemented under Windows. Fills the array with the names of all possible values for the first parameter to Dial() (p. 378) on this machine and returns their number (may be 0).

wxDialUpManager::Dial
bool Dial(const wxString& nameOfISP = wxEmptyString, const wxString& username = wxEmptyString, const wxString& password = wxEmptyString, bool async = true) Dial the given ISP, use username and password to authenticate. The parameters are only used under Windows currently, for Unix you should use SetConnectCommand (p. 380) to customize this functions behaviour. If no nameOfISP is given, the function will select the default one (proposing the user to choose among all connections defined on this machine) and if no username and/or password are given, the function will try to do without them, but will ask the user if really needed. If async parameter is false, the function waits until the end of dialing and returns true upon successful completion. If async is true, the function only initiates the connection and returns immediately - the result is reported via events (an event is sent anyhow, but if dialing failed it will be a DISCONNECTED one).

wxDialUpManager::IsDialing
bool IsDialing() const Returns true if (async) dialing is in progress. See also

378


CHAPTER 7
Dial (p. 378)

wxDialUpManager::CancelDialing
bool CancelDialing() Cancel dialing the number initiated with Dial (p. 378) with async parameter equal to true. Note that this won't result in DISCONNECTED event being sent. See also IsDialing (p. 378)

wxDialUpManager::HangUp
bool HangUp() Hang up the currently active dial up connection.

wxDialUpManager::IsAlwaysOnline
bool IsAlwaysOnline() const Returns true if the computer has a permanent network connection (i.e. is on a LAN) and so there is no need to use Dial() function to go online. NB: this functions tries to guess the result and it is not always guaranteed to be correct, so it is better to ask user for confirmation or give him a possibility to override it.

wxDialUpManager::IsOnline
bool IsOnline() const Returns true if the computer is connected to the network: under Windows, this just means that a RAS connection exists, under Unix we check that the "well-known host" (as specified by SetWellKnownHost (p. 380)) is reachable.

wxDialUpManager::SetOnlineStatus
void SetOnlineStatus(bool isOnline = true) Sometimes the built-in logic for determining the online status may fail, so, in general, the user should be allowed to override it. This function allows to forcefully set the online status - whatever our internal algorithm may think about it. See also

379


CHAPTER 7
IsOnline (p. 379)

wxDialUpManager::EnableAutoCheckOnlineStatus
bool EnableAutoCheckOnlineStatus(size_t nSeconds = 60) Enable automatic checks for the connection status and sending of wxEVT_DIALUP_CONNECTED/wxEVT_DIALUP_DISCONNECTED events. The interval parameter is only for Unix where we do the check manually and specifies how often should we repeat the check (each minute by default). Under Windows, the notification about the change of connection status is sent by the system and so we don't do any polling and this parameter is ignored. Returns false if couldn't set up automatic check for online status.

wxDialUpManager::DisableAutoCheckOnlineStatus
void DisableAutoCheckOnlineStatus() Disable automatic check for connection status change - notice that thewxEVT_DIALUP_XXX events won't be sent any more neither.

wxDialUpManager::SetWellKnownHost
void SetWellKnownHost(const wxString& hostname, int portno = 80) This method is for Unix only. Under Unix, the value of well-known host is used to check whether we're connected to the internet. It is unused under Windows, but this function is always safe to call. The default value is www.yahoo.com:80.

wxDialUpManager::SetConnectCommand
SetConnectCommand(const wxString& commandDial = wxT("/usr/bin/pon"), const wxString& commandHangup = wxT("/usr/bin/poff")) This method is for Unix only. Sets the commands to start up the network and to hang up again. See also Dial (p. 378)

wxDir

380


CHAPTER 7
wxDir is a portable equivalent of Unix open/read/closedir functions which allow enumerating of the files in a directory. wxDir allows enumerate files as well as directories. wxDir also provides a flexible way to enumerate files recursively using Traverse (p. 383) or a simpler GetAllFiles (p. 382) function. Example of use:
wxDir dir(wxGetCwd()); if ( !dir.IsOpened() ) { // deal with the error here - wxDir would already log an error message // explaining the exact reason of the failure return; } puts("Enumerating object files in current directory:"); wxString filename; bool cont = dir.GetFirst(&filename, filespec, flags); while ( cont ) { printf("%s\n", filename.c_str()); cont = dir.GetNext(&filename); }

Derived from No base class Constants These flags define what kind of filename is included in the list of files enumerated by GetFirst/GetNext.
enum { wxDIR_FILES wxDIR_DIRS wxDIR_HIDDEN wxDIR_DOTDOT = = = = 0x0001, 0x0002, 0x0004, 0x0008, // // // // include include include include files directories hidden files '.' and '..'

// by default, enumerate everything except '.' and '..' wxDIR_DEFAULT = wxDIR_FILES | wxDIR_DIRS | wxDIR_HIDDEN }

Include files <wx/dir.h>

wxDir::wxDir

381


CHAPTER 7
wxDir() Default constructor, use Open() (p. 383) afterwards. wxDir(const wxString& dir) Opens the directory for enumeration, use IsOpened() (p. 383) to test for errors.

wxDir::~wxDir
~wxDir() Destructor cleans up the associated resources. It is not virtual and so this class is not meant to be used polymorphically.

wxDir::Exists
static bool Exists(const wxString& dir) Test for existence of a directory with the given name

wxDir::GetAllFiles
static size_t GetAllFiles(const wxString& dirname, wxArrayString *files, const wxString& filespec = wxEmptyString, int flags = wxDIR_DEFAULT) The function appends the names of all the files under directory dirname to the array files (note that its old contents is preserved). Only files matching the filespec are taken, with empty spec matching all the files. The flags parameter should always include wxDIR_FILES or the array would be unchanged and should include wxDIR_DIRS flag to recurse into subdirectories (both flags are included in the value by default). See also: Traverse (p. 383)

wxDir::GetFirst
bool GetFirst(wxString* filename, const wxString& filespec = wxEmptyString, int flags = wxDIR_DEFAULT) const Start enumerating all files matching filespec (or all files if it is empty) and flags, return true on success.

wxDir::GetName
wxString GetName() const

382


CHAPTER 7
Returns the name of the directory itself. The returned string does not have the trailing path separator (slash or backslash).

wxDir::GetNext
bool GetNext(wxString* filename) const Continue enumerating files satisfying the criteria specified by the last call to GetFirst (p. 382).

wxDir::HasFiles
bool HasFiles(const wxString& filespec = wxEmptyString) Returns true if the directory contains any files matching the given filespec. If filespec is empty, look for any files at all. In any case, even hidden files are taken into account.

wxDir::HasSubDirs
bool HasSubDirs(const wxString& dirspec = wxEmptyString) Returns true if the directory contains any subdirectories (if a non empty filespec is given, only check for directories matching it). The hidden subdirectories are taken into account as well.

wxDir::IsOpened
bool IsOpened() const Returns true if the directory was successfully opened by a previous call to Open (p. 383).

wxDir::Open
bool Open(const wxString& dir) Open the directory for enumerating, returns true on success or false if an error occurred.

wxDir::Traverse
size_t Traverse(wxDirTraverser& sink, const wxString& filespec = wxEmptyString, int flags = wxDIR_DEFAULT) Enumerate all files and directories under the given directory recursively calling the element of the provided wxDirTraverser (p. 386) object for each of them. More precisely, the function will really recurse into subdirectories if flags contains

383


CHAPTER 7
wxDIR_DIRS flag. It will ignore the files (but still possibly recurse into subdirectories) if wxDIR_FILES flag is given. For each found directory, sink.OnDir() (p. 387) is called and sink.OnFile() (p. 387) is called for every file. Depending on the return value, the enumeration may continue or stop. The function returns the total number of files found or (size_t)-1 on error. See also: GetAllFiles (p. 382)

wxDirDialog
This class represents the directory chooser dialog. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/dirdlg.h> <wx/generic/dirdlgg.h> Window styles wxDD_NEW_DIR_BUTTON Add "Create new directory" button and allow directory names to be editable. On Windows the new directory button is only available with recent versions of the common dialogs. See also Generic window styles (p. 1611). See also wxDirDialog overview (p. 1650), wxFileDialog (p. 466)

wxDirDialog::wxDirDialog
wxDirDialog(wxWindow* parent, const wxString& message = "Choose a directory", const wxString& defaultPath = "", long style = 0, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, const wxString& name = "wxDirCtrl") Constructor. Use wxDirDialog::ShowModal (p. 386) to show the dialog. Parameters

384


CHAPTER 7
parent Parent window. message Message to show on the dialog. defaultPath The default path, or the empty string. style A dialog style, currently unused. pos Dialog position. Ignored under Windows. size Dialog size. Ignored under Windows. name The dialog name, not used.

wxDirDialog::~wxDirDialog
~wxDirDialog() Destructor.

wxDirDialog::GetPath
wxString GetPath() const Returns the default or user-selected path.

wxDirDialog::GetMessage
wxString GetMessage() const Returns the message that will be displayed on the dialog.

wxDirDialog::GetStyle
long GetStyle() const

385


CHAPTER 7
Returns the dialog style.

wxDirDialog::SetMessage
void SetMessage(const wxString& message) Sets the message that will be displayed on the dialog.

wxDirDialog::SetPath
void SetPath(const wxString& path) Sets the default path.

wxDirDialog::SetStyle
void SetStyle(long style) Sets the dialog style. This is currently unused.

wxDirDialog::ShowModal
int ShowModal() Shows the dialog, returning wxID_OK if the user pressed OK, and wxOK_CANCEL otherwise.

wxDirTraverser
wxDirTraverser is an abstract interface which must be implemented by objects passed to Traverse (p. 383) function. Example of use (this works almost like GetAllFiles (p. 382)):
class wxDirTraverserSimple : public wxDirTraverser { public: wxDirTraverserSimple(wxArrayString& files) : m_files(files) { } virtual wxDirTraverseResult OnFile(const wxString& filename) { m_files.Add(filename); return wxDIR_CONTINUE; } virtual wxDirTraverseResult OnDir(const wxString& WXUNUSED(dirname)) { return wxDIR_CONTINUE; } private:

386


CHAPTER 7
wxArrayString& m_files; }; // get the names of all files in the array wxArrayString files; wxDirTraverserSimple traverser(files); wxDir dir(dirname); dir.Traverse(traverser);

Derived from No base class Constants The elements of wxDirTraverseResult are the possible return values of the callback functions:
enum wxDirTraverseResult { wxDIR_IGNORE = -1, others wxDIR_STOP, wxDIR_CONTINUE };

// ignore this directory but continue with // stop traversing // continue into this directory

Include files <wx/dir.h>

wxDirTraverser::OnDir
virtual wxDirTraverseResult OnDir(const wxString& dirname) This function is called for each directory. It may return wxSIR_STOP to abort traversing completely, wxDIR_IGNORE to skip this directory but continue with others or wxDIR_CONTINUE to enumerate all files and subdirectories in this directory. This is a pure virtual function and must be implemented in the derived class.

wxDirTraverser::OnFile
virtual wxDirTraverseResult OnFile(const wxString& filename) This function is called for each file. It may return wxDIR_STOP to abort traversing (for example, if the file being searched is found) or wxDIR_CONTINUE to proceed. This is a pure virtual function and must be implemented in the derived class.

387


CHAPTER 7 wxOpenErrorTraverser::OnOpenError
virtual wxOpenErrorTraverseResult OnOpenError(const wxString& openerrorname) This function is called for each directory which we failed to open for enumerating. It may return wxSIR_STOP to abort traversing completely,wxDIR_IGNORE to skip this directory but continue with others or wxDIR_CONTINUE to retry opening this directory once again. The base class version always returns wxDIR_IGNORE.

wxDisplay
Determines the sizes and locations of displays connected to the system. Derived from None Include files <wx/display.h> See also wxClientDisplayRect (p. 1499), wxDisplaySize (p. 1499), wxDisplaySizeMM (p. 1499)

wxDisplay::wxDisplay
wxDisplay(size_t index = 0) Constructor, setting up a wxDisplay instance with the specified display. Parameters index The index of the display to use. This must be non-negative and lower than the value returned by GetCount() (p. 388).

wxDisplay::~wxDisplay
void ~wxDisplay() Destructor.

wxDisplay::GetCount

388


CHAPTER 7
static size_t GetCount() Returns the number of connected displays.

wxDisplay::GetDepth
int GetDepth() const Returns the bit depth of the display whose index was passed to the constructor.

wxDisplay::GetFromPoint
static int GetFromPoint(const wxPoint& pt) Returns the index of the display on which the given point lies. Returns -1 if the point is not on any connected display. Parameters pt The point to locate.

wxDisplay::GetGeometry
wxRect GetGeometry() const Returns the bounding rectangle of the display whose index was passed to the constructor.

wxDisplay::GetName
wxString GetName() const Returns the display's name. A name is not available on all platforms.

wxDisplay::IsColour
bool IsColour() const Returns true if the display is color (has a depth greater than 1).

wxDisplay::IsColor
bool IsColor() const

389


CHAPTER 7
Same as IsColour() (p. 389).

wxDisplay::IsPrimary
bool IsPrimary() Returns true if the display is the primary display. The primary display is the one whose index is 0.

wxDllLoader
wxDllLoader is a class providing an interface similar to Unix's dlopen(). It is used by the wxLibrary framework and manages the actual loading of shared libraries and the resolving of symbols in them. There are no instances of this class, it simply serves as a namespace for its static member functions. Please note that class wxDynamicLibrary (p. 433) provides alternative, friendlier interface to wxDllLoader. The terms DLL and shared library/object will both be used in the documentation to refer to the same thing: a .dll file under Windows or .so or .sl one under Unix. Example of using this class to dynamically load the strlen() function:
#if defined(__WXMSW__) static const wxChar static const wxChar #elif defined(__UNIX__) static const wxChar static const wxChar #endif *LIB_NAME = _T("kernel32"); *FUNC_NAME = _T("lstrlenA"); *LIB_NAME = _T("/lib/libc-2.0.7.so"); *FUNC_NAME = _T("strlen");

wxDllType dllHandle = wxDllLoader::LoadLibrary(LIB_NAME); if ( !dllHandle ) { ... error ... } else { typedef int (*strlenType)(char *); strlenType pfnStrlen = (strlenType)wxDllLoader::GetSymbol(dllHandle, FUNC_NAME); if ( !pfnStrlen ) { ... error ... } else { if ( pfnStrlen("foo") != 3 ) { ... error ... } else { ... ok! ... } } wxDllLoader::UnloadLibrary(dllHandle); }

390


CHAPTER 7

Derived from No base class Include files <wx/dynlib.h> Data structures This header defines a platform-dependent wxDllType typedef which stores a handle to a loaded DLLs on the given platform.

wxDllLoader::GetDllExt
static wxString GetDllExt() Returns the string containing the usual extension for shared libraries for the given systems (including the leading dot if not empty). For example, this function will return ".dll" under Windows or (usually) ".so" under Unix.

wxDllLoader::GetProgramHandle
wxDllType GetProgramHandle() This function returns a valid handle for the main program itself. Notice that the NULL return value is valid for some systems (i.e. doesn't mean that the function failed). NB: This function is Unix specific. It will always fail under Windows or OS/2.

wxDllLoader::GetSymbol
void * GetSymbol(wxDllType dllHandle, const wxString& name) This function resolves a symbol in a loaded DLL, such as a variable or function name. Returned value will be NULL if the symbol was not found in the DLL or if an error occured. Parameters dllHandle Valid handle previously returned by LoadLibrary (p. 392) name

391


CHAPTER 7
Name of the symbol.

wxDllLoader::LoadLibrary
wxDllType LoadLibrary(const wxString & libname, bool* success = NULL) This function loads a shared library into memory, with libname being the name of the library: it may be either the full name including path and (platform-dependent) extension, just the basename (no path and no extension) or a basename with extension. In the last two cases, the library will be searched in all standard locations. Returns a handle to the loaded DLL. Use success parameter to test if it is valid. If the handle is valid, the library must be unloaded later with UnloadLibrary (p. 392). Parameters libname Name of the shared object to load. success May point to a bool variable which will be set to true or false; may also be NULL.

wxDllLoader::UnloadLibrary
void UnloadLibrary(wxDllType dllhandle) This function unloads the shared library. The handle dllhandle must have been returned by LoadLibrary (p. 392) previously.

wxDocChildFrame
The wxDocChildFrame class provides a default frame for displaying documents on separate windows. This class can only be used for SDI (not MDI) child frames. The class is part of the document/view framework supported by wxWindows, and cooperates with the wxView (p. 1369), wxDocument (p. 413), wxDocManager (p. 394) and wxDocTemplate (p. 408) classes. See the example application in samples/docview. Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files

392


CHAPTER 7
<wx/docview.h> See also Document/view overview (p. 1651), wxFrame (p. 530)

wxDocChildFrame::m_childDocument
wxDocument* m_childDocument The document associated with the frame.

wxDocChildFrame::m_childView
wxView* m_childView The view associated with the frame.

wxDocChildFrame::wxDocChildFrame
wxDocChildFrame(wxDocument* doc, wxView* view, wxFrame* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor.

wxDocChildFrame::~wxDocChildFrame
~wxDocChildFrame() Destructor.

wxDocChildFrame::GetDocument
wxDocument* GetDocument() const Returns the document associated with this frame.

wxDocChildFrame::GetView
wxView* GetView() const Returns the view associated with this frame.

393


CHAPTER 7 wxDocChildFrame::OnActivate
void OnActivate(wxActivateEvent event) Sets the currently active view to be the frame's view. You may need to override (but still call) this function in order to set the keyboard focus for your subwindow.

wxDocChildFrame::OnCloseWindow
void OnCloseWindow(wxCloseEvent& event) Closes and deletes the current view and document.

wxDocChildFrame::SetDocument
void SetDocument(wxDocument *doc) Sets the document for this frame.

wxDocChildFrame::SetView
void SetView(wxView *view) Sets the view for this frame.

wxDocManager
The wxDocManager class is part of the document/view framework supported by wxWindows, and cooperates with the wxView (p. 1369), wxDocument (p. 413) and wxDocTemplate (p. 408) classes. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/docview.h> See also wxDocManager overview (p. 1655), wxDocument (p. 413), wxView (p. 1369), wxDocTemplate (p. 408), wxFileHistory (p. 471)

394


CHAPTER 7 wxDocManager::m_currentView
wxView* m_currentView The currently active view.

wxDocManager::m_defaultDocumentNameCounter
int m_defaultDocumentNameCounter Stores the integer to be used for the next default document name.

wxDocManager::m_fileHistory
wxFileHistory* m_fileHistory A pointer to an instance of wxFileHistory (p. 471), which manages the history of recentlyvisited files on the File menu.

wxDocManager::m_maxDocsOpen
int m_maxDocsOpen Stores the maximum number of documents that can be opened before existing documents are closed. By default, this is 10,000.

wxDocManager::m_docs
wxList m_docs A list of all documents.

wxDocManager::m_flags
long m_flags Stores the flags passed to the constructor.

wxDocManager::m_lastDirectory
The directory last selected by the user when opening a file. wxFileHistory* m_fileHistory

wxDocManager::m_templates 395


CHAPTER 7
wxList mnTemplates A list of all document templates.

wxDocManager::wxDocManager
void wxDocManager(long flags = wxDEFAULT_DOCMAN_FLAGS, bool initialize = true) Constructor. Create a document manager instance dynamically near the start of your application before doing any document or view operations. flags is currently unused. If initialize is true, the Initialize (p. 399) function will be called to create a default history list object. If you derive from wxDocManager, you may wish to call the base constructor with false, and then call Initialize in your own constructor, to allow your own Initialize or OnCreateFileHistory functions to be called.

wxDocManager::~wxDocManager
void ~wxDocManager() Destructor.

wxDocManager::ActivateView
void ActivateView(wxView* doc, bool activate, bool deleting) Sets the current view.

wxDocManager::AddDocument
void AddDocument(wxDocument *doc) Adds the document to the list of documents.

wxDocManager::AddFileToHistory
void AddFileToHistory(const wxString& filename) Adds a file to the file history list, if we have a pointer to an appropriate file menu.

wxDocManager::AssociateTemplate
void AssociateTemplate(wxDocTemplate *temp)

396


CHAPTER 7
Adds the template to the document manager's template list.

wxDocManager::CloseDocuments
bool CloseDocuments(bool force = true) Closes all currently opened documents.

wxDocManager::CreateDocument
wxDocument* CreateDocument(const wxString& path, long flags) Creates a new document in a manner determined by the flags parameter, which can be:   wxDOC_NEW Creates a fresh document. wxDOC_SILENT Silently loads the given document file.

If wxDOC_NEW is present, a new document will be created and returned, possibly after asking the user for a template to use if there is more than one document template. If wxDOC_SILENT is present, a new document will be created and the given file loaded into it. If neither of these flags is present, the user will be presented with a file selector for the file to load, and the template to use will be determined by the extension (Windows) or by popping up a template choice list (other platforms). If the maximum number of documents has been reached, this function will delete the oldest currently loaded document before creating a new one.

wxDocManager::CreateView
wxView* CreateView(wxDocument*doc, long flags) Creates a new view for the given document. If more than one view is allowed for the document (by virtue of multiple templates mentioning the same document type), a choice of view is presented to the user.

wxDocManager::DisassociateTemplate
void DisassociateTemplate(wxDocTemplate *temp) Removes the template from the list of templates.

wxDocManager::FileHistoryAddFilesToMenu
void FileHistoryAddFilesToMenu() Appends the files in the history list, to all menus managed by the file history object.

397


CHAPTER 7
void FileHistoryAddFilesToMenu(wxMenu* menu) Appends the files in the history list, to the given menu only.

wxDocManager::FileHistoryLoad
void FileHistoryLoad(wxConfigBase& config) Loads the file history from a config object. See also wxConfig (p. 177)

wxDocManager::FileHistoryRemoveMenu
void FileHistoryRemoveMenu(wxMenu* menu) Removes the given menu from the list of menus managed by the file history object.

wxDocManager::FileHistorySave
void FileHistorySave(wxConfigBase& resourceFile) Saves the file history into a config object. This must be called explicitly by the application. See also wxConfig (p. 177)

wxDocManager::FileHistoryUseMenu
void FileHistoryUseMenu(wxMenu* menu) Use this menu for appending recently-visited document filenames, for convenient access. Calling this function with a valid menu pointer enables the history list functionality. Note that you can add multiple menus using this function, to be managed by the file history object.

wxDocManager::FindTemplateForPath
wxDocTemplate * FindTemplateForPath(const wxString& path) Given a path, try to find template that matches the extension. This is only an approximate method of finding a template for creating a document.

398


CHAPTER 7 wxDocManager::GetCurrentDocument
wxDocument * GetCurrentDocument() Returns the document associated with the currently active view (if any).

wxDocManager::GetCurrentView
wxView * GetCurrentView() Returns the currently active view

wxDocManager::GetDocuments
wxList& GetDocuments() Returns a reference to the list of documents.

wxDocManager::GetFileHistory
wxFileHistory * GetFileHistory() Returns a pointer to file history.

wxDocManager::GetLastDirectory
wxString GetLastDirectory() const Returns the directory last selected by the user when opening a file. Initially empty.

wxDocManager::GetMaxDocsOpen
int GetMaxDocsOpen() Returns the number of documents that can be open simultaneously.

wxDocManager::GetHistoryFilesCount
size_t GetHistoryFilesCount() Returns the number of files currently stored in the file history.

wxDocManager::Initialize
bool Initialize()

399


CHAPTER 7
Initializes data; currently just calls OnCreateFileHistory. Some data cannot always be initialized in the constructor because the programmer must be given the opportunity to override functionality. If OnCreateFileHistory was called from the constructor, an overridden virtual OnCreateFileHistory would not be called due to C++'s 'interesting' constructor semantics. In fact Initialize is called from the wxDocManager constructor, but this can be vetoed by passing false to the second argument, allowing the derived class's constructor to call Initialize, possibly calling a different OnCreateFileHistory from the default. The bottom line: if you're not deriving from Initialize, forget it and construct wxDocManager with no arguments.

wxDocManager::MakeDefaultName
bool MakeDefaultName(const wxString& buf) Copies a suitable default name into buf. This is implemented by appending an integer counter to the string unnamed and incrementing the counter. wxPerl note: In wxPerl this function must return the modified name rather than just modifying the argument.

wxDocManager::OnCreateFileHistory
wxFileHistory * OnCreateFileHistory() A hook to allow a derived class to create a different type of file history. Called from Initialize (p. 399).

wxDocManager::OnFileClose
void OnFileClose() Closes and deletes the currently active document.

wxDocManager::OnFileCloseAll
void OnFileCloseAll() Closes and deletes all the currently opened documents.

wxDocManager::OnFileNew
void OnFileNew() Creates a document from a list of templates (if more than one template).

400


CHAPTER 7 wxDocManager::OnFileOpen
void OnFileOpen() Creates a new document and reads in the selected file.

wxDocManager::OnFileSave
void OnFileSave() Saves the current document by calling wxDocument::Save for the current document.

wxDocManager::OnFileSaveAs
void OnFileSaveAs() Calls wxDocument::SaveAs for the current document.

wxDocManager::OnMenuCommand
void OnMenuCommand(int cmd) Processes menu commands routed from child or parent frames. This deals with the following predefined menu item identifiers:       wxID_OPEN Creates a new document and opens a file into it. wxID_CLOSE Closes the current document. wxID_CLOSE_ALL Closes all documents. wxID_NEW Creates a new document. wxID_SAVE Saves the document. wxID_SAVE_AS Saves the document into a specified filename.

Unrecognized commands are routed to the currently active wxView's OnMenuCommand.

wxDocManager::RemoveDocument
void RemoveDocument(wxDocument *doc) Removes the document from the list of documents.

wxDocManager::SelectDocumentPath

401


CHAPTER 7
wxDocTemplate * SelectDocumentPath(wxDocTemplate **templates, int noTemplates, const wxString& path, const wxString& bufSize, long flags, bool save) Under Windows, pops up a file selector with a list of filters corresponding to document templates. The wxDocTemplate corresponding to the selected file's extension is returned. On other platforms, if there is more than one document template a choice list is popped up, followed by a file selector. This function is used in wxDocManager::CreateDocument. wxPerl note: In wxPerl templates is a reference to a list of templates. If you override this method in your document manager it must return two values, eg: (doctemplate, path) = My::DocManager->SelectDocumentPath( ... );

wxDocManager::SelectDocumentType
wxDocTemplate * SelectDocumentType(wxDocTemplate **templates, int noTemplates, bool sort=false) Returns a document template by asking the user (if there is more than one template). This function is used in wxDocManager::CreateDocument. Parameters templates Pointer to an array of templates from which to choose a desired template. noTemplates Number of templates being pointed to by the templates pointer. sort If more than one template is passed in in templates, then this parameter indicates whether the list of templates that the user will have to choose from is sorted or not when shown the choice box dialog. Default is false. wxPerl note: In wxPerl templates is a reference to a list of templates.

wxDocManager::SelectViewType
wxDocTemplate * SelectViewType(wxDocTemplate **templates, int noTemplates, bool sort=false) Returns a document template by asking the user (if there is more than one template), displaying a list of valid views. This function is used in wxDocManager::CreateView. The dialog normally will not appear because the array of templates only contains those relevant to the document in question, and often there will only be one such.

402


CHAPTER 7
Parameters templates Pointer to an array of templates from which to choose a desired template. noTemplates Number of templates being pointed to by the templates pointer. sort If more than one template is passed in in templates, then this parameter indicates whether the list of templates that the user will have to choose from is sorted or not when shown the choice box dialog. Default is false. wxPerl note: In wxPerl templates is a reference to a list of templates.

wxDocManager::SetLastDirectory
void SetLastDirectory(const wxString& dir) Sets the directory to be displayed to the user when opening a file. Initially this is empty.

wxDocManager::SetMaxDocsOpen
void SetMaxDocsOpen(int n) Sets the maximum number of documents that can be open at a time. By default, this is 10,000. If you set it to 1, existing documents will be saved and deleted when the user tries to open or create a new one (similar to the behaviour of Windows Write, for example). Allowing multiple documents gives behaviour more akin to MS Word and other Multiple Document Interface applications.

wxDocMDIChildFrame
The wxDocMDIChildFrame class provides a default frame for displaying documents on separate windows. This class can only be used for MDI child frames. The class is part of the document/view framework supported by wxWindows, and cooperates with the wxView (p. 1369), wxDocument (p. 413), wxDocManager (p. 394) and wxDocTemplate (p. 408) classes. See the example application in samples/docview. Derived from wxMDIChildFrame (p. 869) wxFrame (p. 530) wxWindow (p. 1386)

403


CHAPTER 7
wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/docmdi.h> See also Document/view overview (p. 1651), wxMDIChildFrame (p. 869)

wxDocMDIChildFrame::m_childDocument
wxDocument* m_childDocument The document associated with the frame.

wxDocMDIChildFrame::m_childView
wxView* m_childView The view associated with the frame.

wxDocMDIChildFrame::wxDocMDIChildFrame
wxDocMDIChildFrame(wxDocument* doc, wxView* view, wxFrame* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor.

wxDocMDIChildFrame::~wxDocMDIChildFrame
~wxDocMDIChildFrame() Destructor.

wxDocMDIChildFrame::GetDocument
wxDocument* GetDocument() const Returns the document associated with this frame.

wxDocMDIChildFrame::GetView

404


CHAPTER 7
wxView* GetView() const Returns the view associated with this frame.

wxDocMDIChildFrame::OnActivate
void OnActivate(wxActivateEvent event) Sets the currently active view to be the frame's view. You may need to override (but still call) this function in order to set the keyboard focus for your subwindow.

wxDocMDIChildFrame::OnCloseWindow
void OnCloseWindow(wxCloseEvent& event) Closes and deletes the current view and document.

wxDocMDIChildFrame::SetDocument
void SetDocument(wxDocument *doc) Sets the document for this frame.

wxDocMDIChildFrame::SetView
void SetView(wxView *view) Sets the view for this frame.

wxDocMDIParentFrame
The wxDocMDIParentFrame class provides a default top-level frame for applications using the document/view framework. This class can only be used for MDI parent frames. It cooperates with the wxView (p. 1369), wxDocument (p. 413), wxDocManager (p. 394) and wxDocTemplates (p. 408) classes. See the example application in samples/docview. Derived from wxMDIParentFrame (p. 874) wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954)

405


CHAPTER 7
Include files <wx/docmdi.h> See also Document/view overview (p. 1651), wxMDIParentFrame (p. 874)

wxDocMDIParentFrame::wxDocMDIParentFrame
wxDocParentFrame(wxDocManager* manager, wxFrame *parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor.

wxDocMDIParentFrame::~wxDocMDIParentFrame
~wxDocMDIParentFrame() Destructor.

wxDocMDIParentFrame::OnCloseWindow
void OnCloseWindow(wxCloseEvent& event) Deletes all views and documents. If no user input cancelled the operation, the frame will be destroyed and the application will exit. Since understanding how document/view clean-up takes place can be difficult, the implementation of this function is shown below.
void wxDocParentFrame::OnCloseWindow(wxCloseEvent& event) { if (m_docManager->Clear(!event.CanVeto())) { this->Destroy(); } else event.Veto(); }

wxDocParentFrame
The wxDocParentFrame class provides a default top-level frame for applications using the document/view framework. This class can only be used for SDI (not MDI) parent frames.

406


CHAPTER 7
It cooperates with the wxView (p. 1369), wxDocument (p. 413), wxDocManager (p. 394) and wxDocTemplates (p. 408) classes. See the example application in samples/docview. Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/docview.h> See also Document/view overview (p. 1651), wxFrame (p. 530)

wxDocParentFrame::wxDocParentFrame
wxDocParentFrame(wxDocManager* manager, wxFrame *parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor.

wxDocParentFrame::~wxDocParentFrame
~wxDocParentFrame() Destructor.

wxDocParentFrame::OnCloseWindow
void OnCloseWindow(wxCloseEvent& event) Deletes all views and documents. If no user input cancelled the operation, the frame will be destroyed and the application will exit. Since understanding how document/view clean-up takes place can be difficult, the implementation of this function is shown below.
void wxDocParentFrame::OnCloseWindow(wxCloseEvent& event) { if (m_docManager->Clear(!event.CanVeto())) { this->Destroy();

407


CHAPTER 7
} else event.Veto(); }

wxDocTemplate
The wxDocTemplate class is used to model the relationship between a document class and a view class. Derived from wxObject (p. 954) Include files <wx/docview.h> See also wxDocTemplate overview (p. 1654), wxDocument (p. 413), wxView (p. 1369)

wxDocTemplate::m_defaultExt
wxString m_defaultExt The default extension for files of this type.

wxDocTemplate::m_description
wxString m_description A short description of this template.

wxDocTemplate::m_directory
wxString m_directory The default directory for files of this type.

wxDocTemplate::m_docClassInfo
wxClassInfo* m_docClassInfo Run-time class information that allows document instances to be constructed dynamically.

408


CHAPTER 7 wxDocTemplate::m_docTypeName
wxString m_docTypeName The named type of the document associated with this template.

wxDocTemplate::m_documentManager
wxDocTemplate* m_documentManager A pointer to the document manager for which this template was created.

wxDocTemplate::m_fileFilter
wxString m_fileFilter The file filter (such as *.txt) to be used in file selector dialogs.

wxDocTemplate::m_flags
long m_flags The flags passed to the constructor.

wxDocTemplate::m_viewClassInfo
wxClassInfo* m_viewClassInfo Run-time class information that allows view instances to be constructed dynamically.

wxDocTemplate::m_viewTypeName
wxString m_viewTypeName The named type of the view associated with this template.

wxDocTemplate::wxDocTemplate
wxDocTemplate(wxDocManager* manager, const wxString& descr, const wxString& filter, const wxString& dir, const wxString& ext, const wxString& docTypeName, const wxString& viewTypeName, wxClassInfo* docClassInfo = NULL, wxClassInfo* viewClassInfo = NULL, long flags = wxDEFAULT_TEMPLATE_FLAGS) Constructor. Create instances dynamically near the start of your application after creating a wxDocManager instance, and before doing any document or view operations.

409


CHAPTER 7
manager is the document manager object which manages this template. descr is a short description of what the template is for. This string will be displayed in the file filter list of Windows file selectors. filter is an appropriate file filter such as *.txt. dir is the default directory to use for file selectors. ext is the default file extension (such as txt). docTypeName is a name that should be unique for a given type of document, used for gathering a list of views relevant to a particular document. viewTypeName is a name that should be unique for a given view. docClassInfo is a pointer to the run-time document class information as returned by the CLASSINFO macro, e.g. CLASSINFO(MyDocumentClass). If this is not supplied, you will need to derive a new wxDocTemplate class and override the CreateDocument member to return a new document instance on demand. viewClassInfo is a pointer to the run-time view class information as returned by the CLASSINFO macro, e.g. CLASSINFO(MyViewClass). If this is not supplied, you will need to derive a new wxDocTemplate class and override the CreateView member to return a new view instance on demand. flags is a bit list of the following:    wxTEMPLATE_VISIBLE The template may be displayed to the user in dialogs. wxTEMPLATE_INVISIBLE The template may not be displayed to the user in dialogs. wxDEFAULT_TEMPLATE_FLAGS Defined as wxTEMPLATE_VISIBLE.

wxPerl note: In wxPerl docClassInfo and viewClassInfo can be either Wx::ClassInfo objects or strings which contain the name of the perl packages which are to be used as Wx::Document andWx::View classes (they must have a constructor named new): Wx::DocTemplate->new( docmgr, descr, filter, dir, ext, docTypeName, viewTypeName, docClassInfo, viewClassInfo, flags ) will construct document and view objects from the class information Wx::DocTemplate->new( docmgr, descr, filter, dir, ext, docTypeName, viewTypeName, docClassName, viewClassName, flags ) will construct document and view objects from perl packages Wx::DocTemplate->new( docmgr, descr, filter, dir, ext, docTypeName, viewTypeName ) Wx::DocTemplate::CreateDocument(

410


CHAPTER 7
) andWx::DocTemplate::CreateView() must be overridden

wxDocTemplate::~wxDocTemplate
void ~wxDocTemplate() Destructor.

wxDocTemplate::CreateDocument
wxDocument * CreateDocument(const wxString& path, long flags = 0) Creates a new instance of the associated document class. If you have not supplied a wxClassInfo parameter to the template constructor, you will need to override this function to return an appropriate document instance.

wxDocTemplate::CreateView
wxView * CreateView(wxDocument *doc, long flags = 0) Creates a new instance of the associated view class. If you have not supplied a wxClassInfo parameter to the template constructor, you will need to override this function to return an appropriate view instance.

wxDocTemplate::GetDefaultExtension
wxString GetDefaultExtension() Returns the default file extension for the document data, as passed to the document template constructor.

wxDocTemplate::GetDescription
wxString GetDescription() Returns the text description of this template, as passed to the document template constructor.

wxDocTemplate::GetDirectory
wxString GetDirectory() Returns the default directory, as passed to the document template constructor.

411


CHAPTER 7 wxDocTemplate::GetDocumentManager
wxDocManager * GetDocumentManager() Returns a pointer to the document manager instance for which this template was created.

wxDocTemplate::GetDocumentName
wxString GetDocumentName() Returns the document type name, as passed to the document template constructor.

wxDocTemplate::GetFileFilter
wxString GetFileFilter() Returns the file filter, as passed to the document template constructor.

wxDocTemplate::GetFlags
long GetFlags() Returns the flags, as passed to the document template constructor.

wxDocTemplate::GetViewName
wxString GetViewName() Returns the view type name, as passed to the document template constructor.

wxDocTemplate::IsVisible
bool IsVisible() Returns true if the document template can be shown in user dialogs, false otherwise.

wxDocTemplate::SetDefaultExtension
void SetDefaultExtension(const wxString& ext) Sets the default file extension.

wxDocTemplate::SetDescription

412


CHAPTER 7
void SetDescription(const wxString& descr) Sets the template description.

wxDocTemplate::SetDirectory
void SetDirectory(const wxString& dir) Sets the default directory.

wxDocTemplate::SetDocumentManager
void SetDocumentManager(wxDocManager *manager) Sets the pointer to the document manager instance for which this template was created. Should not be called by the application.

wxDocTemplate::SetFileFilter
void SetFileFilter(const wxString& filter) Sets the file filter.

wxDocTemplate::SetFlags
void SetFlags(long flags) Sets the internal document template flags (see the constructor description for more details).

wxDocument
The document class can be used to model an application's file-based data. It is part of the document/view framework supported by wxWindows, and cooperates with the wxView (p. 1369), wxDocTemplate (p. 408) and wxDocManager (p. 394) classes. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/docview.h> See also

413


CHAPTER 7
wxDocument overview (p. 1653), wxView (p. 1369), wxDocTemplate (p. 408), wxDocManager (p. 394)

wxDocument::m_commandProcessor
wxCommandProcessor* m_commandProcessor A pointer to the command processor associated with this document.

wxDocument::m_documentFile
wxString m_documentFile Filename associated with this document ("" if none).

wxDocument::m_documentModified
bool m_documentModified true if the document has been modified, false otherwise.

wxDocument::m_documentTemplate
wxDocTemplate * m_documentTemplate A pointer to the template from which this document was created.

wxDocument::m_documentTitle
wxString m_documentTitle Document title. The document title is used for an associated frame (if any), and is usually constructed by the framework from the filename.

wxDocument::m_documentTypeName
wxString m_documentTypeName The document type name given to the wxDocTemplate constructor, copied to this variable when the document is created. If several document templates are created that use the same document type, this variable is used in wxDocManager::CreateView to collate a list of alternative view types that can be used on this kind of document. Do not change the value of this variable.

414


CHAPTER 7 wxDocument::m_documentViews
wxList m_documentViews List of wxView instances associated with this document.

wxDocument::wxDocument
wxDocument() Constructor. Define your own default constructor to initialize application-specific data.

wxDocument::~wxDocument
~wxDocument() Destructor. Removes itself from the document manager.

wxDocument::AddView
virtual bool AddView(wxView *view) If the view is not already in the list of views, adds the view and calls OnChangedViewList.

wxDocument::Close
virtual bool Close() Closes the document, by calling OnSaveModified and then (if this returned true) OnCloseDocument. This does not normally delete the document object: use DeleteAllViews to do this implicitly.

wxDocument::DeleteAllViews
virtual bool DeleteAllViews() Calls wxView::Close and deletes each view. Deleting the final view will implicitly delete the document itself, because the wxView destructor calls RemoveView. This in turns calls wxDocument::OnChangedViewList, whose default implemention is to save and delete the document if no views exist.

wxDocument::GetCommandProcessor
wxCommandProcessor* GetCommandProcessor() const

415


CHAPTER 7
Returns a pointer to the command processor associated with this document. See wxCommandProcessor (p. 170).

wxDocument::GetDocumentTemplate
wxDocTemplate* GetDocumentTemplate() const Gets a pointer to the template that created the document.

wxDocument::GetDocumentManager
wxDocManager* GetDocumentManager() const Gets a pointer to the associated document manager.

wxDocument::GetDocumentName
wxString GetDocumentName() const Gets the document type name for this document. See the comment for documentTypeName (p. 414).

wxDocument::GetDocumentWindow
wxWindow* GetDocumentWindow() const Intended to return a suitable window for using as a parent for document-related dialog boxes. By default, uses the frame associated with the first view.

wxDocument::GetFilename
wxString GetFilename() const Gets the filename associated with this document, or "" if none is associated.

wxDocument::GetFirstView
wxView * GetFirstView() const A convenience function to get the first view for a document, because in many cases a document will only have a single view. See also: GetViews (p. 417)

416


CHAPTER 7 wxDocument::GetPrintableName
virtual void GetPrintableName(wxString& name) const Copies a suitable document name into the supplied name buffer. The default function uses the title, or if there is no title, uses the filename; or if no filename, the string unnamed. wxPerl note: In wxPerl this function must return the modified name rather than just modifying the argument.

wxDocument::GetTitle
wxString GetTitle() const Gets the title for this document. The document title is used for an associated frame (if any), and is usually constructed by the framework from the filename.

wxDocument::GetViews
wxList & GetViews() const Returns the list whose elements are the views on the document. See also: GetFirstView (p. 416)

wxDocument::IsModified
virtual bool IsModified() const Returns true if the document has been modified since the last save, false otherwise. You may need to override this if your document view maintains its own record of being modified (for example if using wxTextWindow to view and edit the document). See also Modify (p. 418).

wxDocument::LoadObject
virtual istream& LoadObject(istream& stream) virtual wxInputStream& LoadObject(wxInputStream& stream) Override this function and call it from your own LoadObject before streaming your own data. LoadObject is called by the framework automatically when the document contents need to be loaded. Note that only one of these forms exists, depending on how wxWindows was configured.

417


CHAPTER 7 wxDocument::Modify
virtual void Modify(bool modify) Call with true to mark the document as modified since the last save, false otherwise. You may need to override this if your document view maintains its own record of being modified (for example if using wxTextWindow to view and edit the document). See also IsModified (p. 417).

wxDocument::OnChangedViewList
virtual void OnChangedViewList() Called when a view is added to or deleted from this document. The default implementation saves and deletes the document if no views exist (the last one has just been removed).

wxDocument::OnCloseDocument
virtual bool OnCloseDocument() The default implementation calls DeleteContents (an empty implementation) sets the modified flag to false. Override this to supply additional behaviour when the document is closed with Close.

wxDocument::OnCreate
virtual bool OnCreate(const wxString& path, long flags) Called just after the document object is created to give it a chance to initialize itself. The default implementation uses the template associated with the document to create an initial view. If this function returns false, the document is deleted.

wxDocument::OnCreateCommandProcessor
virtual wxCommandProcessor* OnCreateCommandProcessor() Override this function if you want a different (or no) command processor to be created when the document is created. By default, it returns an instance of wxCommandProcessor. See wxCommandProcessor (p. 170).

wxDocument::OnNewDocument
virtual bool OnNewDocument()

418


CHAPTER 7
The default implementation calls OnSaveModified and DeleteContents, makes a default title for the document, and notifies the views that the filename (in fact, the title) has changed.

wxDocument::OnOpenDocument
virtual bool OnOpenDocument(const wxString& filename) Constructs an input file stream for the given filename (which must not be empty), and calls LoadObject. If LoadObject returns true, the document is set to unmodified; otherwise, an error message box is displayed. The document's views are notified that the filename has changed, to give windows an opportunity to update their titles. All of the document's views are then updated.

wxDocument::OnSaveDocument
virtual bool OnSaveDocument(const wxString& filename) Constructs an output file stream for the given filename (which must not be empty), and calls SaveObject. If SaveObject returns true, the document is set to unmodified; otherwise, an error message box is displayed.

wxDocument::OnSaveModified
virtual bool OnSaveModified() If the document has been modified, prompts the user to ask if the changes should be changed. If the user replies Yes, the Save function is called. If No, the document is marked as unmodified and the function succeeds. If Cancel, the function fails.

wxDocument::RemoveView
virtual bool RemoveView(wxView* view) Removes the view from the document's list of views, and calls OnChangedViewList.

wxDocument::Save
virtual bool Save() Saves the document by calling OnSaveDocument if there is an associated filename, or SaveAs if there is no filename.

wxDocument::SaveAs

419


CHAPTER 7
virtual bool SaveAs() Prompts the user for a file to save to, and then calls OnSaveDocument.

wxDocument::SaveObject
virtual ostream& SaveObject(ostream& stream) virtual wxOutputStream& SaveObject(wxOutputStream& stream) Override this function and call it from your own SaveObject before streaming your own data. SaveObject is called by the framework automatically when the document contents need to be saved. Note that only one of these forms exists, depending on how wxWindows was configured.

wxDocument::SetCommandProcessor
virtual void SetCommandProcessor(wxCommandProcessor *processor) Sets the command processor to be used for this document. The document will then be responsible for its deletion. Normally you should not call this; override OnCreateCommandProcessor instead. See wxCommandProcessor (p. 170).

wxDocument::SetDocumentName
void SetDocumentName(const wxString& name) Sets the document type name for this document. See the comment for documentTypeName (p. 414).

wxDocument::SetDocumentTemplate
void SetDocumentTemplate(wxDocTemplate* templ) Sets the pointer to the template that created the document. Should only be called by the framework.

wxDocument::SetFilename
void SetFilename(const wxString& filename, bool notifyViews = false) Sets the filename for this document. Usually called by the framework. If notifyViews is true, wxView::OnChangeFilename is called for all views.

420


CHAPTER 7 wxDocument::SetTitle
void SetTitle(const wxString& title) Sets the title for this document. The document title is used for an associated frame (if any), and is usually constructed by the framework from the filename.

wxDocument::UpdateAllViews
void UpdateAllViews(wxView* sender = NULL, wxObject* hint = NULL) Updates all views. If sender is non-NULL, does not update this view. hint represents optional information to allow a view to optimize its update.

wxDragImage
This class is used when you wish to drag an object on the screen, and a simple cursor is not enough. On Windows, the WIN32 API is used to do achieve smooth dragging. On other platforms, wxGenericDragImage is used. Applications may also prefer to use wxGenericDragImage on Windows, too. wxPython note: wxPython uses wxGenericDragImage on all platforms, but uses the wxDragImage name. To use this class, when you wish to start dragging an image, create a wxDragImage object and store it somewhere you can access it as the drag progresses. Call BeginDrag to start, and EndDrag to stop the drag. To move the image, initially call Show and then Move. If you wish to update the screen contents during the drag (for example, highlight an item as in the dragimag sample), first call Hide, update the screen, call Move, and then call Show. You can drag within one window, or you can use full-screen dragging either across the whole screen, or just restricted to one area of the screen to save resources. If you want the user to drag between two windows, then you will need to use full-screen dragging. If you wish to draw the image yourself, use wxGenericDragImage and override wxDragImage::DoDrawImage (p. 424) and wxDragImage::GetImageRect (p. 424). Please see samples/dragimag for an example. Derived from wxObject (p. 954) Include files <wx/dragimag.h> <wx/generic/dragimgg.h>

421


CHAPTER 7

wxDragImage::wxDragImage
wxDragImage() Default constructor. wxDragImage(const wxBitmap& image, const wxCursor& cursor = wxNullCursor, const wxPoint& cursorHotspot = wxPoint(0, 0)) Constructs a drag image from a bitmap and optional cursor. wxDragImage(const wxIcon& image, const wxCursor& cursor = wxNullCursor, const wxPoint& cursorHotspot = wxPoint(0, 0)) Constructs a drag image from an icon and optional cursor. wxPython note: This constructor is called wxDragIcon in wxPython. wxDragImage(const wxString& text, const wxCursor& cursor = wxNullCursor, const wxPoint& cursorHotspot = wxPoint(0, 0)) Constructs a drag image from a text string and optional cursor. wxPython note: This constructor is called wxDragString in wxPython. wxDragImage(const wxTreeCtrl& treeCtrl, wxTreeItemId& id) Constructs a drag image from the text in the given tree control item, and optional cursor. wxPython note: This constructor is called wxDragTreeItem in wxPython. wxDragImage(const wxListCtrl& treeCtrl, long id) Constructs a drag image from the text in the given tree control item, and optional cursor. wxPython note: This constructor is called wxDragListItem in wxPython. wxDragImage(const wxCursor& cursor = wxNullCursor, const wxPoint& cursorHotspot = wxPoint(0, 0)) Constructs a drag image an optional cursor. This constructor is only available for wxGenericDragImage, and can be used when the application supplies wxDragImage::DoDrawImage (p. 424) and wxDragImage::GetImageRect (p. 424). Parameters image Icon or bitmap to be used as the drag image. The bitmap can have a mask. text

422


CHAPTER 7
Text used to construct a drag image. cursor Optional cursor to combine with the image. hotspot This parameter is deprecated. treeCtrl Tree control for constructing a tree drag image. listCtrl List control for constructing a list drag image. id Tree or list control item id.

wxDragImage::BeginDrag
bool BeginDrag(const wxPoint& hotspot, wxWindow* window, bool fullScreen = false, wxRect* rect = NULL) Start dragging the image, in a window or full screen. bool BeginDrag(const wxPoint& hotspot, wxWindow* window, wxWindow* boundingWindow) Start dragging the image, using the first window to capture the mouse and the second to specify the bounding area. This form is equivalent to using the first form, but more convenient than working out the bounding rectangle explicitly. You need to then call wxDragImage::Show (p. 425) and wxDragImage::Move (p. 425) to show the image on the screen. Call wxDragImage::EndDrag (p. 424) when the drag has finished. Note that this call automatically calls CaptureMouse. Parameters hotspot The location of the drag position relative to the upper-left corner of the image. window The window that captures the mouse, and within which the dragging is limited unless fullScreen is true.

423


CHAPTER 7
boundingWindow In the second form of the function, specifies the area within which the drag occurs. fullScreen If true, specifies that the drag will be visible over the full screen, or over as much of the screen as is specified by rect. Note that the mouse will still be captured in window. rec t If non-NULL, specifies the rectangle (in screen coordinates) that bounds the dragging operation. Specifying this can make the operation more efficient by cutting down on the area under consideration, and it can also make a visual difference since the drag is clipped to this area.

wxDragImage::DoDrawImage
virtual bool DoDrawImage(wxDC& dc, const wxPoint& pos) Draws the image on the device context with top-left corner at the given position. This function is only available with wxGenericDragImage, to allow applications to draw their own image instead of using an actual bitmap. If you override this function, you must also override wxDragImage::GetImageRect (p. 424).

wxDragImage::EndDrag
bool EndDrag() Call this when the drag has finished. Note that this call automatically calls ReleaseMouse.

wxDragImage::GetImageRect
virtual wxRect GetImageRect(const wxPoint& pos) const Returns the rectangle enclosing the image, assuming that the image is drawn with its top-left corner at the given point. This function is available in wxGenericDragImage only, and may be overridden (together with wxDragImage::DoDrawImage (p. 424)) to provide a virtual drawing capability.

wxDragImage::Hide
bool Hide()

424


CHAPTER 7
Hides the image. You may wish to call this before updating the window contents (perhaps highlighting an item). Then call wxDragImage::Move (p. 425) and wxDragImage::Show (p. 425).

wxDragImage::Move
bool Move(const wxPoint& pt) Call this to move the image to a new position. The image will only be shown if wxDragImage::Show (p. 425) has been called previously (for example at the start of the drag). pt is the position in client coordinates (relative to the window specified in BeginDrag). You can move the image either when the image is hidden or shown, but in general dragging will be smoother if you move the image when it is shown.

wxDragImage::Show
bool Show() Shows the image. Call this at least once when dragging.

wxDragImage::UpdateBackingFromWindow
bool UpdateBackingFromWindow(wxDC& windowDC, wxMemoryDC& destDC, const wxRect& sourceRect, const wxRect& destRect) const Override this if you wish to draw the window contents to the backing bitmap yourself. This can be desirable if you wish to avoid flicker by not having to redraw the updated window itself just before dragging, which can cause a flicker just as the drag starts. Instead, paint the drag image's backing bitmap to show the appropriate graphic minus the objects to be dragged, and leave the window itself to be updated by the drag image. This can provide eerily smooth, flicker-free drag behaviour. The default implementation copies the window contents to the backing bitmap. A new implementation will normally copy information from another source, such as from its own backing bitmap if it has one, or directly from internal data structures. This function is available in wxGenericDragImage only.

wxDropFilesEvent
This class is used for drop files events, that is, when files have been dropped onto the window. This functionality is currently only available under Windows. The window must have previously been enabled for dropping by calling wxWindow::DragAcceptFiles (p. 1396).

425


CHAPTER 7
Important note: this is a separate implementation to the more general drag and drop implementation documented here (p. 1666). It uses the older, Windows message-based approach of dropping files. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a drop files event, use these event handler macros to direct input to a member function that takes a wxDropFilesEvent argument. EVT_DROP_FILES(func) See also Event handling overview (p. 1602) Process a wxEVT_DROP_FILES event.

wxDropFilesEvent::wxDropFilesEvent
wxDropFilesEvent(WXTYPE id = 0, int noFiles = 0, wxString* files = NULL) Constructor.

wxDropFilesEvent::m_files
wxString* m_files An array of filenames.

wxDropFilesEvent::m_noFiles
int m_noFiles The number of files dropped.

wxDropFilesEvent::m_pos
wxPoint m_pos The point at which the drop took place.

426


CHAPTER 7 wxDropFilesEvent::GetFiles
wxString* GetFiles() const Returns an array of filenames.

wxDropFilesEvent::GetNumberOfFiles
int GetNumberOfFiles() const Returns the number of files dropped.

wxDropFilesEvent::GetPosition
wxPoint GetPosition() const Returns the position at which the files were dropped. Returns an array of filenames.

wxDropSource
This class represents a source for a drag and drop operation. See Drag and drop overview (p. 1666) and wxDataObject overview (p. 1667) for more information. Derived from None Include files <wx/dnd.h> Types wxDragResult is defined as follows:
enum wxDragResult { wxDragError, wxDragNone, wxDragCopy, wxDragMove, wxDragCancel };

// // // // //

error prevented the d&d operation from completing drag target didn't accept the data the data was successfully copied the data was successfully moved the operation was cancelled by user (not an error)

See also wxDropTarget (p. 429), wxTextDropTarget (p. 1268), wxFileDropTarget (p. 470)

427


CHAPTER 7

wxDropSource::wxDropSource
wxDropSource(wxWindow* win = NULL,const wxIconOrCursor& iconCopy = wxNullIconOrCursor, const wxIconOrCursor& iconMove = wxNullIconOrCursor, const wxIconOrCursor& iconNone = wxNullIconOrCursor) wxDropSource(wxDataObject& data, wxWindow* win = NULL,const wxIconOrCursor& iconCopy = wxNullIconOrCursor, const wxIconOrCursor& iconMove = wxNullIconOrCursor, const wxIconOrCursor& iconNone = wxNullIconOrCursor) The constructors for wxDataObject. If you use the constructor without data parameter you must call SetData (p. 428) later. Note that the exact type of iconCopy and subsequent parameters differs between wxMSW and wxGTK: these are cursors under Windows but icons for GTK. You should use the macro wxDROP_ICON (p. 1499) in portable programs instead of directly using either of these types. Parameters win The window which initiates the drag and drop operation. iconCopy The icon or cursor used for feedback for copy operation. iconMove The icon or cursor used for feedback for move operation. iconNone The icon or cursor used for feedback when operation can't be done. win is the window which initiates the drag and drop operation.

wxDropSource::~wxDropSource
virtual ~wxDropSource()

wxDropSource::SetData
void SetData(wxDataObject& data) Sets the data wxDataObject (p. 222) associated with the drop source. This will not

428


CHAPTER 7
delete any previously associated data.

wxDropSource::DoDragDrop
virtual wxDragResult DoDragDrop(int flags = wxDrag_CopyOnly) Do it (call this in response to a mouse button press, for example). This starts the dragand-drop operation which will terminate when the user releases the mouse. Parameters flags If wxDrag_AllowMove is included in the flags, data may be moved and not only copied (default). If wxDrag_DefaultMove is specified (which includes the previous flag), this is even the default operation . Return value Returns the operation requested by the user, may be wxDragCopy, wxDragMove, wxDragCancel or wxDragNone if an error occured.

wxDropSource::GiveFeedback
virtual bool GiveFeedback(wxDragResult effect, bool scrolling) Overridable: you may give some custom UI feedback during the drag and drop operation in this function. It is called on each mouse move, so your implementation must not be too slow. Parameters effect The effect to implement. One of wxDragCopy, wxDragMove and wxDragNone. scrolling true if the window is scrolling. MSW only. Return value Return false if you want default feedback, or true if you implement your own feedback. The return values is ignored under GTK.

wxDropTarget
This class represents a target for a drag and drop operation. A wxDataObject (p.

429


CHAPTER 7
222)can be associated with it and by default, this object will be filled with the data from the drag source, if the data formats supported by the data object match the drag source data format. There are various virtual handler functions defined in this class which may be overridden to give visual feedback or react in a more fine-tuned way, e.g. by not accepting data on the whole window area, but only a small portion of it. The normal sequence of calls isOnEnter (p. 431), possibly many times OnDragOver (p. 432),OnDrop (p. 431) and finally OnData (p. 431). See Drag and drop overview (p. 1666) and wxDataObject overview (p. 1667)for more information. Derived from None Include files <wx/dnd.h> Types wxDragResult is defined as follows:
enum wxDragResult { wxDragError, wxDragNone, wxDragCopy, wxDragMove, wxDragCancel };

// // // // //

error prevented the d&d operation from completing drag target didn't accept the data the data was successfully copied the data was successfully moved the operation was cancelled by user (not an error)

See also wxDropSource (p. 427), wxTextDropTarget (p. 1268), wxFileDropTarget (p. 470),wxDataFormat (p. 217), wxDataObject (p. 222)

wxDropTarget::wxDropTarget
wxDropTarget(wxDataObject* data = NULL) Constructor. data is the data to be associated with the drop target.

wxDropTarget::~wxDropTarget
~wxDropTarget() Destructor. Deletes the associated data object, if any.

430


CHAPTER 7 wxDropTarget::GetData
virtual void GetData() This method may only be called from within OnData (p. 431). By default, this method copies the data from the drop source to the wxDataObject (p. 222) associated with this drop target, calling its wxDataObject::SetData (p. 225) method.

wxDropTarget::OnData
virtual wxDragResult OnData(wxCoord x, wxCoord y, wxDragResult def) Called after OnDrop (p. 431) returns true. By default this will usually GetData (p. 431) and will return the suggested default value def.

wxDropTarget::OnDrop
virtual bool OnDrop(wxCoord x, wxCoord y) Called when the user drops a data object on the target. Return false to veto the operation. Parameters x The x coordinate of the mouse. y The y coordinate of the mouse. Return value Return true to accept the data, false to veto the operation.

wxDropTarget::OnEnter
virtual wxDragResult OnEnter(wxCoord x, wxCoord y, wxDragResult def) Called when the mouse enters the drop target. By default, this calls OnDragOver (p. 432). Parameters x The x coordinate of the mouse. y

431


CHAPTER 7
The y coordinate of the mouse. def Suggested default for return value. Determined by SHIFT or CONTROL key states. Return value Returns the desired operation or wxDragNone. This is used for optical feedback from the side of the drop source, typically in form of changing the icon.

wxDropTarget::OnDragOver
virtual wxDragResult OnDragOver(wxCoord x, wxCoord y, wxDragResult def) Called when the mouse is being dragged over the drop target. By default, this calls functions return the suggested return value def. Parameters x The x coordinate of the mouse. y The y coordinate of the mouse. def Suggested value for return value. Determined by SHIFT or CONTROL key states. Return value Returns the desired operation or wxDragNone. This is used for optical feedback from the side of the drop source, typically in form of changing the icon.

wxDropTarget::OnLeave
virtual void OnLeave() Called when the mouse leaves the drop target.

wxDropTarget::SetDataObject
void SetDataObject(wxDataObject* data) Sets the data wxDataObject (p. 222) associated with the drop target and deletes any previously associated data object.

432


CHAPTER 7

wxDynamicLibrary
wxDynamicLibrary is a class representing dynamically loadable library (Windows DLL, shared library under Unix etc.). Just create an object of this class to load a library and don't worry about unloading it -- it will be done in the objects destructor automatically.

wxDynamicLibrary::wxDynamicLibrary
wxDynamicLibrary() wxDynamicLibrary(const wxString& name, int flags = wxDL_DEFAULT) Constructor. Second form calls Load (p. 434).

wxDynamicLibrary::CanonicalizeName
wxString CanonicalizeName(const wxString& name, wxDynamicLibraryCategory cat = wxDL_LIBRARY) Returns the platform-specific full name for the library called name. E.g. it adds a ".dll" extension under Windows and "lib" prefix and ".so", ".sl" or maybe ".dylib" extension under Unix. The possible values for cat are: wxDL_LIBRARY wxDL_MODULE See also CanonicalizePluginName (p. 433) normal library a loadable module or plugin

wxDynamicLibrary::CanonicalizePluginName
wxString CanonicalizePluginName(const wxString& name, wxPluginCategory cat = wxDL_PLUGIN_GUI) This function does the same thing as CanonicalizeName (p. 433) but for wxWindows plugins. The only difference is that compiler and version information are added to the name to ensure that the plugin which is going to be loaded will be compatible with the main program. The possible values for cat are: wxDL_PLUGIN_GUI wxDL_PLUGIN_BASE plugin which uses GUI classes (default) plugin which only uses wxBase

433


CHAPTER 7 wxDynamicLibrary::Detach
wxDllType Detach() Detaches this object from its library handle, i.e. the object will not unload the library any longer in its destructor but it is now the callers responsability to do this using Unload (p. 434).

wxDynamicLibrary::GetSymbol
void* GetSymbol(const wxString& name) const Returns pointer to symbol name in the library or NULL if the library contains no such symbol. See also wxDYNLIB_FUNCTION (p. 1506)

wxDynamicLibrary::IsLoaded
bool IsLoaded() const Returns true if the library was successfully loaded, false otherwise.

wxDynamicLibrary::Load
bool Load(const wxString& name, int flags = wxDL_DEFAULT) Loads DLL with the given name into memory. The flags argument can be a combination of the following bits: wxDL_LAZY wxDL_NOW wxDL_GLOBAL wxDL_VERBATIM equivalent of RTLD_LAZY under Unix, ignored elsewhere equivalent of RTLD_NOW under Unix, ignored elsewhere equivalent of RTLD_GLOBAL under Unix, ignored elsewhere don't try to append the appropriate extension to the library name (this is done by default).

Returns true if the library was successfully loaded, false otherwise.

wxDynamicLibrary::Unload
void Unload()

434


CHAPTER 7
static void Unload(wxDllType handle) Unloads the library from memory. wxDynamicLibrary object automatically calls this method from its destructor if it had been successfully loaded. The second version is only used if you need to keep the library in memory during a longer period of time than the scope of the wxDynamicLibrary object. In this case you may call Detach (p. 434) and store the handle somewhere and call this static method later to unload it.

wxEncodingConverter
This class is capable of converting strings between two 8-bit encodings/charsets. It can also convert from/to Unicode (but only if you compiled wxWindows with wxUSE_WCHAR_T set to 1). Only limited subset of encodings in supported by wxEncodingConverter:wxFONTENCODING_ISO8859_1..15, wxFONTENCODING_CP1250..1257 and wxFONTENCODING_KOI8. Note Please use wxMBConv classes (p. 1586) instead if possible. wxCSConv (p. 208) has much better support for various encodings than wxEncodingConverter. wxEncodingConverter is useful only if you rely on wxCONVERT_SUBSTITUTE mode of operation (see Init (p. 435)). Derived from wxObject (p. 954) Include files <wx/encconv.h> See also wxFontMapper (p. 526), wxMBConv (p. 863), Writing non-English applications (p. 1590)

wxEncodingConverter::wxEncodingConverter
wxEncodingConverter() Constructor.

wxEncodingConverter::Init
bool Init(wxFontEncoding input_enc, wxFontEncoding output_enc, int method = wxCONVERT_STRICT)

435


CHAPTER 7
Initialize conversion. Both output or input encoding may be wxFONTENCODING_UNICODE, but only if wxUSE_ENCODING is set to 1. All subsequent calls to Convert() (p. 436) will interpret its argument as a string in input_enc encoding and will output string in output_enc encoding. You must call this method before calling Convert. You may call it more than once in order to switch to another conversion.Method affects behaviour of Convert() in case input character cannot be converted because it does not exist in output encoding: wxCONVERT_STRICT follow behaviour of GNU Recode - just copy unconvertible characters to output and don't change them (its integer value will stay the same) try some (lossy) substitutions - e.g. replace unconvertible latin capitals with acute by ordinary capitals, replace en-dash or em-dash by '-' etc.

wxCONVERT_SUBSTITUTE

Both modes guarantee that output string will have same length as input string. Return value false if given conversion is impossible, true otherwise (conversion may be impossible either if you try to convert to Unicode with non-Unicode build of wxWindows or if input or output encoding is not supported.)

wxEncodingConverter::CanConvert
static bool CanConvert(wxFontEncodingencIn, wxFontEncoding encOut) Return true if (any text in) multibyte encoding encIn can be converted to another one (encOut) losslessly. Do not call this method with wxFONTENCODING_UNICODE as either parameter, it doesn't make sense (always works in one sense and always depends on the text to convert in the other).

wxEncodingConverter::Convert
void Convert(const char* input, char* output) const void Convert(const wchar_t* input, wchar_t* output) const void Convert(const char* input, wchar_t* output) const void Convert(const wchar_t* input, char* output) const Convert input string according to settings passed toInit (p. 435) and writes the result to output. void Convert(char* str) const

436


CHAPTER 7
void Convert(wchar_t* str) const Convert input string according to settings passed toInit (p. 435) in-place, i.e. write the result to the same memory area. wxString Convert(const wxString& input) const Convert wxString and return new wxString object. Notes You must call Init (p. 435) before using this method! wchar_t versions of the method are not available if wxWindows was compiled with wxUSE_WCHAR_T set to 0.

wxEncodingConverter::GetPlatformEquivalents
static wxFontEncodingArray GetPlatformEquivalents(wxFontEncoding enc, int platform = wxPLATFORM_CURRENT) Return equivalents for given font that are used under given platform. Supported platforms:      wxPLATFORM_UNIX wxPLATFORM_WINDOWS wxPLATFORM_OS2 wxPLATFORM_MAC wxPLATFORM_CURRENT

wxPLATFORM_CURRENT means the platform this binary was compiled for. Examples:
current platform enc returned value ---------------------------------------------unix CP1250 {ISO8859_2} unix ISO8859_2 {ISO8859_2} windows ISO8859_2 {CP1250} unix CP1252 {ISO8859_1,ISO8859_15}

Equivalence is defined in terms of convertibility: two encodings are equivalent if you can convert text between then without losing information (it may - and will - happen that you lose special chars like quotation marks or em-dashes but you shouldn't lose any diacritics and language-specific characters when converting between equivalent encodings). Remember that this function does NOT check for presence of fonts in system. It only tells you what are most suitable encodings. (It usually returns only one encoding.) Notes

437


CHAPTER 7
 Note that argument enc itself may be present in the returned array, so that you can, as a side-effect, detect whether the encoding is native for this platform or not. Convert (p. 436) is not limited to converting between equivalent encodings, it can convert between two arbitrary encodings. If enc is present in the returned array, then it is always the first item of it. Please note that the returned array may contain no items at all.

  

wxEncodingConverter::GetAllEquivalents
static wxFontEncodingArray GetAllEquivalents(wxFontEncoding enc) Similar to GetPlatformEquivalents (p. 437), but this one will return ALL equivalent encodings, regardless of the platform, and including itself. This platform's encodings are before others in the array. And again, if enc is in the array, it is the very first item in it.

wxEraseEvent
An erase event is sent when a window's background needs to be repainted. On some platforms, such as GTK+, this event is simulated (simply generated just before the paint event) and may cause flicker. It is therefore recommended that you set the text background colour explicitly in order to prevent flicker. The default background colour under GTK+ is grey. To intercept this event, use the EVT_ERASE_BACKGROUND macro in an event table definition. You must call wxEraseEvent::GetDC and use the returned device context if it is nonNULL. If it is NULL, create your own temporary wxClientDC object. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process an erase event, use this event handler macro to direct input to a member function that takes a wxEraseEvent argument. EVT_ERASE_BACKGROUND(func) Process a wxEVT_ERASE_BACKGROUND

438


CHAPTER 7
event. Remarks Use the m_DC device context to draw into, don't create wxPaintDC in the event handler. See also Event handling overview (p. 1602)

wxEraseEvent::wxEraseEvent
wxEraseEvent(int id = 0, wxDC* dc = NULL) Constructor.

wxEraseEvent::m_dc
wxDC* m_dc The device context associated with the erase event.

wxEraseEvent::GetDC
wxDC* GetDC() const Returns the device context to draw into.

wxEvent
An event is a structure holding information about an event passed to a callback or member function. wxEvent used to be a multipurpose event object, and is an abstract base class for other event classes (see below). Derived from wxObject (p. 954) Include files <wx/event.h> See also wxCommandEvent (p. 164), wxMouseEvent (p. 928)

439


CHAPTER 7 wxEvent::wxEvent
wxEvent(int id = 0, wxEventType eventType = wxEVT_NULL) Constructor. Should not need to be used directly by an application.

wxEvent::m_eventObject
wxObject* m_eventObject The object (usually a window) that the event was generated from, or should be sent to.

wxEvent::m_eventType
WXTYPE m_eventType The type of the event, such as wxEVENT_TYPE_BUTTON_COMMAND.

wxEvent::m_id
int m_id Identifier for the window.

wxEvent::m_propagationLevel
int m_propagationLevel Indicates how many levels the event can propagate. This member is protected and should typically only be set in the constructors of the derived classes. It may be temporarily changed by StopPropagation (p. 443) and ResumePropagation (p. 442) and tested with ShouldPropagate (p. 443). The initial value is set to either wxEVENT_PROPAGATION_NONE (by default) meaning that the event shouldn't be propagated at all or to wxEVENT_PROPAGATION_MAX (for command events) meaning that it should be propagated as much as necessary. Any positive number means that the event should be propagated but no more than the given number of times. E.g. the propagation level may be set to 1 to propagate the event to its parent only, but not to its grandparent.

wxEvent::m_skipped
bool m_skipped Set to true by Skip if this event should be skipped.

440


CHAPTER 7 wxEvent::m_timeStamp
long m_timeStamp Timestamp for this event.

wxEvent::Clone
virtual wxEvent* Clone() const Returns a copy of the event. Any event that is posted to the wxWindows event system for later action (viawxEvtHandler::AddPendingEvent (p. 444) orwxPostEvent (p. 1512)) must implement this method. All wxWindows events fully implement this method, but any derived events implemented by the user should also implement this method just in case they (or some event derived from them) are ever posted. All wxWindows events implement a copy constructor, so the easiest way of implementing the Clone function is to implement a copy constructor for a new event (call it MyEvent) and then define the Clone function like this:
wxEvent *Clone(void) const { return new MyEvent(*this); }

wxEvent::GetEventObject
wxObject* GetEventObject() Returns the object associated with the event, if any.

wxEvent::GetEventType
WXTYPE GetEventType() Returns the identifier of the given event type, such as wxEVENT_TYPE_BUTTON_COMMAND.

wxEvent::GetId
int GetId() const Returns the identifier associated with this event, such as a button command id.

wxEvent::GetSkipped
bool GetSkipped() const

441


CHAPTER 7
Returns true if the event handler should be skipped, false otherwise.

wxEvent::GetTimestamp
long GetTimestamp() Gets the timestamp for the event.

wxEvent::IsCommandEvent
bool IsCommandEvent() const Returns true if the event is or is derived fromwxCommandEvent (p. 164) else it returns false. Note: Exists only for optimization purposes.

wxEvent::ResumePropagation
void ResumePropagation(int propagationLevel) Sets the propagation level to the given value (for example returned from an earlier call to StopPropagation (p. 443)).

wxEvent::SetEventObject
void SetEventObject(wxObject* object) Sets the originating object.

wxEvent::SetEventType
void SetEventType(WXTYPE typ) Sets the event type.

wxEvent::SetId
void SetId(int id) Sets the identifier associated with this event, such as a button command id.

wxEvent::SetTimestamp
void SetTimestamp(long timeStamp) Sets the timestamp for the event.

442


CHAPTER 7
Sets the originating object.

wxEvent::ShouldPropagate
bool ShouldPropagate() const Test if this event should be propagated or not, i.e. if the propagation level is currently greater than 0.

wxEvent::Skip
void Skip(bool skip = true) Called by an event handler to tell the event system that the event handler should be skipped, and the next valid handler used instead.

wxEvent::StopPropagation
int StopPropagation() Stop the event from propagating to its parent window. Returns the old propagation level value which may be later passed to ResumePropagation (p. 442) to allow propagating the event again.

wxEvtHandler
A class that can handle events from the windowing system. wxWindow (and therefore all window classes) are derived from this class. When events are received, wxEvtHandler invokes the method listed in the event table using itself as the object. When using multiple inheritance it is imperative that the wxEvtHandler(-derived) class be the first class inherited such that the "this" pointer for the overall object will be identical to the "this" pointer for the wxEvtHandler portion. Derived from wxObject (p. 954) Include files <wx/event.h> See also Event handling overview (p. 1602)

443


CHAPTER 7 wxEvtHandler::wxEvtHandler
wxEvtHandler() Constructor.

wxEvtHandler::~wxEvtHandler
~wxEvtHandler() Destructor. If the handler is part of a chain, the destructor will unlink itself and restore the previous and next handlers so that they point to each other.

wxEvtHandler::AddPendingEvent
virtual void AddPendingEvent(wxEvent& event) This function posts an event to be processed later. Parameters event Event to add to process queue. Remarks The difference between sending an event (using theProcessEvent (p. 447) method) and posting it is that in the first case the event is processed before the function returns, while in the second case, the function returns immediately and the event will be processed sometime later (usually during the next event loop iteration). A copy of event is made by the function, so the original can be deleted as soon as function returns (it is common that the original is created on the stack). This requires that the wxEvent::Clone (p. 441) method be implemented by event so that it can be duplicated and stored until it gets processed. This is also the method to call for inter-thread communication---it will post events safely between different threads which means that this method is thread-safe by using critical sections where needed. In a multi-threaded program, you often need to inform the main GUI thread about the status of other working threads and such notification should be done using this method. This method automatically wakes up idle handling if the underlying window system is currently idle and thus would not send any idle events. (Waking up idle handling is done calling ::wxWakeUpIdle (p. 1468).)

wxEvtHandler::Connect
void Connect(int id, wxEventType eventType, wxObjectEventFunction function,

444


CHAPTER 7
wxObject* userData = NULL, wxEvtHandler* eventSink = NULL) void Connect(int id, int lastId, wxEventType eventType, wxObjectEventFunction function, wxObject* userData = NULL, wxEvtHandler* eventSink = NULL) Connects the given function dynamically with the event handler, id and event type. This is an alternative to the use of static event tables. See the 'dynamic' sample for usage. Parameters id The identifier (or first of the identifier range) to be associated with the event handler function. lastId The second part of the identifier range to be associated with the event handler function. eventType The event type to be associated with this event handler. function The event handler function. userData Data to be associated with the event table entry. eventSink Object whose member function should be called. If this is NULL, 'this' will be used. Example
frame->Connect( wxID_EXIT, wxEVT_COMMAND_MENU_SELECTED, (wxObjectEventFunction) (wxEventFunction) (wxCommandEventFunction) MyFrame::OnQuit );

wxPerl note: In wxPerl this function takes 4 arguments: id, lastid, type, method; if method is undef, the handler is disconnected.

wxEvtHandler::Disconnect
bool Disconnect(int id, wxEventType eventType = wxEVT_NULL, wxObjectEventFunction function = NULL, wxObject* userData = NULL, wxEvtHandler* eventSink = NULL) bool Disconnect(int id, int lastId = -1, wxEventType eventType = wxEVT_NULL, wxObjectEventFunction function = NULL, wxObject* userData = NULL, wxEvtHandler* eventSink = NULL)

445


CHAPTER 7
Disconnects the given function dynamically from the event handler, using the specified parameters as search criteria and returning true if a matching function has been found and removed. This method can only disconnect functions which have been added using the wxEvtHandler::Connect (p. 444) method. There is no way to disconnect functions connected using the (static) event tables. Parameters id The identifier (or first of the identifier range) associated with the event handler function. lastId The second part of the identifier range associated with the event handler function. eventType The event type associated with this event handler. function The event handler function. userData Data associated with the event table entry. eventSink Object whose member function should be called. wxPerl note: In wxPerl this function takes 3 arguments: id, lastid, type.

wxEvtHandler::GetClientData
void* GetClientData() Gets user-supplied client data. Remarks Normally, any extra data the programmer wishes to associate with the object should be made available by deriving a new class with new data members. See also wxEvtHandler::SetClientData (p. 449)

wxEvtHandler::GetClientObject
wxClientData* GetClientObject() const

446


CHAPTER 7
Get a pointer to the user-supplied client data object. See also wxEvtHandler::SetClientObject (p. 450),wxClientData (p. 134)

wxEvtHandler::GetEvtHandlerEnabled
bool GetEvtHandlerEnabled() Returns true if the event handler is enabled, false otherwise. See also wxEvtHandler::SetEvtHandlerEnabled (p. 450)

wxEvtHandler::GetNextHandler
wxEvtHandler* GetNextHandler() Gets the pointer to the next handler in the chain. See also wxEvtHandler::SetNextHandler (p. 450), wxEvtHandler::GetPreviousHandler (p. 447), wxEvtHandler::SetPreviousHandler (p. 451), wxWindow::PushEventHandler (p. 1414), wxWindow::PopEventHandler (p. 1413)

wxEvtHandler::GetPreviousHandler
wxEvtHandler* GetPreviousHandler() Gets the pointer to the previous handler in the chain. See also wxEvtHandler::SetPreviousHandler (p. 451), wxEvtHandler::GetNextHandler (p. 447), wxEvtHandler::SetNextHandler (p. 450), wxWindow::PushEventHandler (p. 1414), wxWindow::PopEventHandler (p. 1413)

wxEvtHandler::ProcessEvent
virtual bool ProcessEvent(wxEvent& event) Processes an event, searching event tables and calling zero or more suitable event handler function(s). Parameters

447


CHAPTER 7
event Event to process. Return value true if a suitable event handler function was found and executed, and the function did not call wxEvent::Skip (p. 443). Remarks Normally, your application would not call this function: it is called in the wxWindows implementation to dispatch incoming user interface events to the framework (and application). However, you might need to call it if implementing new functionality (such as a new control) where you define new event types, as opposed to allowing the user to override virtual functions. An instance where you might actually override the ProcessEvent function is where you want to direct event processing to event handlers not normally noticed by wxWindows. For example, in the document/view architecture, documents and views are potential event handlers. When an event reaches a frame, ProcessEvent will need to be called on the associated document and view in case event handler functions are associated with these objects. The property classes library (wxProperty) also overrides ProcessEvent for similar reasons. The normal order of event table searching is as follows: 1. 2. 3. If the object is disabled (via a call to wxEvtHandler::SetEvtHandlerEnabled (p. 450)) the function skips to step (6). If the object is a wxWindow, ProcessEvent is recursively called on the window's wxValidator (p. 1358). If this returns true, the function exits. SearchEventTable is called for this event handler. If this fails, the base class table is tried, and so on until no more tables exist or an appropriate function was found, in which case the function exits. The search is applied down the entire chain of event handlers (usually the chain has a length of one). If this succeeds, the function exits. If the object is a wxWindow and the event is a wxCommandEvent, ProcessEvent is recursively applied to the parent window's event handler. If this returns true, the function exits. Finally, ProcessEvent is called on the wxApp object.

4. 5.

6.

See also wxEvtHandler::SearchEventTable (p. 448)

wxEvtHandler::SearchEventTable 448


CHAPTER 7
bool SearchEventTable(wxEventTable& table, wxEvent& event) Searches the event table, executing an event handler function if an appropriate one is found. Parameters table Event table to be searched. event Event to be matched against an event table entry. Return value true if a suitable event handler function was found and executed, and the function did not call wxEvent::Skip (p. 443). Remarks This function looks through the object's event table and tries to find an entry that will match the event. An entry will match if: 1. 2. The event type matches, and the identifier or identifier range matches, or the event table entry's identifier is zero.

If a suitable function is called but calls wxEvent::Skip (p. 443), this function will fail, and searching will continue. See also wxEvtHandler::ProcessEvent (p. 447)

wxEvtHandler::SetClientData
void SetClientData(void* data) Sets user-supplied client data. Parameters data Data to be associated with the event handler. Remarks Normally, any extra data the programmer wishes to associate with the object should be

449


CHAPTER 7
made available by deriving a new class with new data members. You must not call this method andSetClientObject (p. 450) on the same class - only one of them. See also wxEvtHandler::GetClientData (p. 446)

wxEvtHandler::SetClientObject
void SetClientObject(wxClientData* data) Set the client data object. Any previous object will be deleted. See also wxEvtHandler::GetClientObject (p. 446),wxClientData (p. 134)

wxEvtHandler::SetEvtHandlerEnabled
void SetEvtHandlerEnabled(bool enabled) Enables or disables the event handler. Parameters enabled true if the event handler is to be enabled, false if it is to be disabled. Remarks You can use this function to avoid having to remove the event handler from the chain, for example when implementing a dialog editor and changing from edit to test mode. See also wxEvtHandler::GetEvtHandlerEnabled (p. 447)

wxEvtHandler::SetNextHandler
void SetNextHandler(wxEvtHandler* handler) Sets the pointer to the next handler. Parameters handler Event handler to be set as the next handler. See also

450


CHAPTER 7
wxEvtHandler::GetNextHandler (p. 447), wxEvtHandler::SetPreviousHandler (p. 451), wxEvtHandler::GetPreviousHandler (p. 447), wxWindow::PushEventHandler (p. 1414), wxWindow::PopEventHandler (p. 1413)

wxEvtHandler::SetPreviousHandler
void SetPreviousHandler(wxEvtHandler* handler) Sets the pointer to the previous handler. Parameters handler Event handler to be set as the previous handler. See also wxEvtHandler::GetPreviousHandler (p. 447), wxEvtHandler::SetNextHandler (p. 450), wxEvtHandler::GetNextHandler (p. 447), wxWindow::PushEventHandler (p. 1414), wxWindow::PopEventHandler (p. 1413)

wxFFile
wxFFile implements buffered file I/O. This is a very small class designed to minimize the overhead of using it - in fact, there is hardly any overhead at all, but using it brings you automatic error checking and hides differences between platforms and compilers. It wraps inside it a FILE * handle used by standard C IO library (also known as stdio). Derived from None. Include files <wx/ffile.h> wxFromStart wxFromCurrent wxFromEnd Count offset from the start of the file Count offset from the current position of the file pointer Count offset from the end of the file (backwards)

wxFFile::wxFFile
wxFFile()

451


CHAPTER 7
Default constructor. wxFFile(const char* filename, const char* mode = "r") Opens a file with the given mode. As there is no way to return whether the operation was successful or not from the constructor you should test the return value of IsOpened (p. 454) to check that it didn't fail. wxFFile(FILE* fp) Opens a file with the given file pointer, which has already been opened. Parameters filename The filename. mode The mode in which to open the file using standard C strings. Note that you should use "b" flag if you use binary files under Windows or the results might be unexpected due to automatic newline conversion done for the text files. fp An existing file descriptor, such as stderr.

wxFFile::~wxFFile
~wxFFile() Destructor will close the file. NB: it is not virtual so you should not derive from wxFFile!

wxFFile::Attach
void Attach(FILE* fp) Attaches an existing file pointer to the wxFFile object. The descriptor should be already opened and it will be closed by wxFFile object.

wxFFile::Close
bool Close() Closes the file and returns true on success.

452


CHAPTER 7 wxFFile::Detach
void Detach() Get back a file pointer from wxFFile object -- the caller is responsible for closing the file if this descriptor is opened. IsOpened() (p. 454) will return false after call to Detach().

wxFFile::fp
FILE * fp() const Returns the file pointer associated with the file.

wxFFile::Eof
bool Eof() const Returns true if the an attempt has been made to read pastthe end of the file. Note that the behaviour of the file descriptor based classwxFile (p. 458) is different as wxFile::Eof (p. 462)will return true here as soon as the last byte of the file has been read. Also note that this method may only be called for opened files and may crash if the file is not opened. See also IsOpened (p. 454)

wxFFile::Error
Returns true if an error has occured on this file, similar to the standardferror() function. Please note that this method may only be called for opened files and may crash if the file is not opened. See also IsOpened (p. 454)

wxFFile::Flush
bool Flush() Flushes the file and returns true on success.

453


CHAPTER 7 wxFFile::IsOpened
bool IsOpened() const Returns true if the file is opened. Most of the methods of this class may only be used for an opened file.

wxFFile::Length
size_t Length() const Returns the length of the file.

wxFFile::Open
bool Open(const char* filename, const char* mode = "r") Opens the file, returning true if successful. Parameters filename The filename. mode The mode in which to open the file.

wxFFile::Read
size_t Read(void* buffer, off_t count) Reads the specified number of bytes into a buffer, returning the actual number read. Parameters buffer A buffer to receive the data. count The number of bytes to read. Return value The number of bytes read.

wxFFile::Seek 454


CHAPTER 7
bool Seek(long ofs, wxSeekMode mode = wxFromStart) Seeks to the specified position and returns true on success. Parameters ofs Offset to seek to. mode One of wxFromStart, wxFromEnd, wxFromCurrent.

wxFFile::SeekEnd
bool SeekEnd(long ofs = 0) Moves the file pointer to the specified number of bytes before the end of the file and returns true on success. Parameters ofs Number of bytes before the end of the file.

wxFFile::Tell
size_t Tell() const Returns the current position.

wxFFile::Write
size_t Write(const void* buffer, size_t count) Writes the specified number of bytes from a buffer. Parameters buffer A buffer containing the data. count The number of bytes to write. Return value Number of bytes written.

455


CHAPTER 7 wxFFile::Write
bool Write(const wxString& s, wxMBConv& conv = wxConvUTF8) Writes the contents of the string to the file, returns true on success. The second argument is only meaningful in Unicode build of wxWindows whenconv is used to convert s to multibyte representation.

wxFFileInputStream
This class represents data read in from a file. There are actually two such groups of classes: this one is based on wxFFile (p. 451) whereas wxFileInputStream (p. 474) is based in the wxFile (p. 458) class. Note that wxFile (p. 458) and wxFFile (p. 451) differ in one aspect, namely when to report that the end of the file has been reached. This is documented in wxFile::Eof (p. 462) and wxFFile::Eof (p. 453) and the behaviour of the stream classes reflects this difference, i.e. wxFileInputStream will report wxSTREAM_EOF after having read the last byte whereas wxFFileInputStream will report wxSTREAM_EOF after trying to read past the last byte. Derived from wxInputStream (p. 762) Include files <wx/wfstream.h> See also wxBufferedInputStream (p. 100), wxFFileOutputStream (p. 457), wxFileOutputStream (p. 490)

wxFFileInputStream::wxFFileInputStream
wxFFileInputStream(const wxString& ifileName) Opens the specified file using its ifilename name in read-only mode. wxFFileInputStream(wxFFile& file) Initializes a file stream in read-only mode using the file I/O object file. wxFFileInputStream(FILE * fp) Initializes a file stream in read-only mode using the specified file pointer fp.

456


CHAPTER 7 wxFFileInputStream::~wxFFileInputStream
~wxFFileInputStream() Destructor.

wxFFileInputStream::Ok
bool Ok() const Returns true if the stream is initialized and ready.

wxFFileOutputStream
This class represents data written to a file. There are actually two such groups of classes: this one is based on wxFFile (p. 451) whereas wxFileInputStream (p. 456) is based in the wxFile (p. 458) class. Note that wxFile (p. 458) and wxFFile (p. 451) differ in one aspect, namely when to report that the end of the file has been reached. This is documented in wxFile::Eof (p. 462) and wxFFile::Eof (p. 453) and the behaviour of the stream classes reflects this difference, i.e. wxFileInputStream will report wxSTREAM_EOF after having read the last byte whereas wxFFileInputStream will report wxSTREAM_EOF after trying to read past the last byte. Derived from wxOutputStream (p. 958) Include files <wx/wfstream.h> See also wxBufferedOutputStream (p. 100), wxFFileInputStream (p. 456), wxFileInputStream (p. 474)

wxFFileOutputStream::wxFFileOutputStream
wxFFileOutputStream(const wxString& ofileName) Creates a new file with ofilename name and initializes the stream in write-only mode. wxFFileOutputStream(wxFFile& file) Initializes a file stream in write-only mode using the file I/O object file.

457


CHAPTER 7
wxFFileOutputStream(FILE * fp) Initializes a file stream in write-only mode using the file descriptor fp.

wxFFileOutputStream::~wxFFileOutputStream
~wxFFileOutputStream() Destructor.

wxFFileOutputStream::Ok
bool Ok() const Returns true if the stream is initialized and ready.

wxFFileStream
Derived from wxFFileOutputStream (p. 457), wxFFileInputStream (p. 456) Include files <wx/wfstream.h> See also wxStreamBuffer (p. 1193)

wxFFileStream::wxFFileStream
wxFFileStream(const wxString& iofileName) Initializes a new file stream in read-write mode using the specified iofilename name.

wxFile
A wxFile performs raw file I/O. This is a very small class designed to minimize the overhead of using it - in fact, there is hardly any overhead at all, but using it brings you automatic error checking and hides differences between platforms and compilers. wxFile also automatically closes the file in its destructor making it unnecessary to worry about forgetting to do it. wxFile is a wrapper around file descriptor. - see also wxFFile (p. 451) for a wrapper around FILE structure.

458


CHAPTER 7
Derived from None. Include files <wx/file.h> Constants wx/file.h defines the following constants:
#define wxS_IRUSR 00400 #define wxS_IWUSR 00200 #define wxS_IXUSR 00100 #define wxS_IRGRP 00040 #define wxS_IWGRP 00020 #define wxS_IXGRP 00010 #define wxS_IROTH 00004 #define wxS_IWOTH 00002 #define wxS_IXOH 00001 T // default mode for the new files: corresponds to umask 022 #define wxS_DEFAULT (wxS_IRUSR | wxS_IWUSR | wxS_IRGRP | wxS_IWGRP | wxS_IROTH | wxS_IWOTH)

These constants define the file access rights and are used with wxFile::Create (p. 461) and wxFile::Open (p. 462). The OpenMode enumeration defines the different modes for opening a file, it is defined inside wxFile class so its members should be specified with wxFile:: scope resolution prefix. It is also used with wxFile::Access (p. 461) function. wxFile::read wxFile::write Open file for reading or test if it can be opened for reading with Access() Open file for writing deleting the contents of the file if it already exists or test if it can be opened for writing with Access() Open file for reading and writing; can not be used with Access() Open file for appending: the file is opened for writing, but the old contents of the file is not erased and the file pointer is initially placed at the end of the file; can not be used with Access(). This is the same as wxFile::write if the file doesn't exist. Open the file securely for writing (Uses O_EXCL | O_CREAT). Will fail if the file already exists, else create and open it atomically. Useful for opening temporary files without being vulnerable to race exploits.

wxFile::read_write wxFile::write_append

wxFile::write_excl

459


CHAPTER 7
Other constants defined elsewhere but used by wxFile functions are wxInvalidOffset which represents an invalid value of type off_t and is returned by functions returning off_t on error and the seek mode constants used with Seek() (p. 463): wxFromStart wxFromCurrent wxFromEnd Count offset from the start of the file Count offset from the current position of the file pointer Count offset from the end of the file (backwards)

wxFile::wxFile
wxFile() Default constructor. wxFile(const char* filename, wxFile::OpenMode mode = wxFile::read) Opens a file with the given mode. As there is no way to return whether the operation was successful or not from the constructor you should test the return value of IsOpened (p. 462) to check that it didn't fail. wxFile(int fd) Associates the file with the given file descriptor, which has already been opened. Parameters filename The filename. mode The mode in which to open the file. May be one of wxFile::read, wxFile::write and wxFile::read_write. fd An existing file descriptor (see Attach() (p. 461) for the list of predefined descriptors)

wxFile::~wxFile
~wxFile() Destructor will close the file.

460


CHAPTER 7
NB: it is not virtual so you should not use wxFile polymorphically.

wxFile::Access
static bool Access(const char * name, OpenMode mode) This function verifies if we may access the given file in specified mode. Only values of wxFile::read or wxFile::write really make sense here.

wxFile::Attach
void Attach(int fd) Attaches an existing file descriptor to the wxFile object. Example of predefined file descriptors are 0, 1 and 2 which correspond to stdin, stdout and stderr (and have symbolic names of wxFile::fd_stdin, wxFile::fd_stdout and wxFile::fd_stderr). The descriptor should be already opened and it will be closed by wxFile object.

wxFile::Close
void Close() Closes the file.

wxFile::Create
bool Create(const char* filename, bool overwrite = false, int access = wxS_DEFAULT) Creates a file for writing. If the file already exists, setting overwrite to true will ensure it is overwritten.

wxFile::Detach
void Detach() Get back a file descriptor from wxFile object - the caller is responsible for closing the file if this descriptor is opened. IsOpened() (p. 462) will return false after call to Detach().

wxFile::fd
int fd() const Returns the file descriptor associated with the file.

461


CHAPTER 7 wxFile::Eof
bool Eof() const Returns true if the end of the file has been reached. Note that the behaviour of the file pointer based class wxFFile (p. 451) is different as wxFFile::Eof (p. 453) will return true here only if an attempt has been made to read past the last byte of the file, while wxFile::Eof() will return true even before such attempt is made if the file pointer is at the last position in the file. Note also that this function doesn't work on unseekable file descriptors (examples include pipes, terminals and sockets under Unix) and an attempt to use it will result in an error message in such case. So, to read the entire file into memory, you should write a loop which uses Read (p. 463) repeatedly and tests its return condition instead of using Eof() as this will not work for special files under Unix.

wxFile::Exists
static bool Exists(const char* filename) Returns true if the given name specifies an existing regular file (not a directory or a link)

wxFile::Flush
bool Flush() Flushes the file descriptor. Note that wxFile::Flush is not implemented on some Windows compilers due to a missing fsync function, which reduces the usefulness of this function (it can still be called but it will do nothing on unsupported compilers).

wxFile::IsOpened
bool IsOpened() const Returns true if the file has been opened.

wxFile::Length
off_t Length() const Returns the length of the file.

wxFile::Open

462


CHAPTER 7
bool Open(const char* filename, wxFile::OpenMode mode = wxFile::read) Opens the file, returning true if successful. Parameters filename The filename. mode The mode in which to open the file. May be one of wxFile::read, wxFile::write and wxFile::read_write.

wxFile::Read
off_t Read(void* buffer, off_t count) Reads the specified number of bytes into a buffer, returning the actual number read. Parameters buffer A buffer to receive the data. count The number of bytes to read. Return value The number of bytes read, or the symbol wxInvalidOffset (-1) if there was an error.

wxFile::Seek
off_t Seek(off_t ofs, wxSeekMode mode = wxFromStart) Seeks to the specified position. Parameters ofs Offset to seek to. mode One of wxFromStart, wxFromEnd, wxFromCurrent. Return value

463


CHAPTER 7
The actual offset position achieved, or wxInvalidOffset on failure.

wxFile::SeekEnd
off_t SeekEnd(off_t ofs = 0) Moves the file pointer to the specified number of bytes before the end of the file. Parameters ofs Number of bytes before the end of the file. Return value The actual offset position achieved, or wxInvalidOffset on failure.

wxFile::Tell
off_t Tell() const Returns the current position or wxInvalidOffset if file is not opened or if another error occurred.

wxFile::Write
size_t Write(const void* buffer, off_t count) Writes the specified number of bytes from a buffer. Parameters buffer A buffer containing the data. count The number of bytes to write. Return value the number of bytes actually written

wxFile::Write
bool Write(const wxString& s, wxMBConv& conv = wxConvUTF8) Writes the contents of the string to the file, returns true on success.

464


CHAPTER 7
The second argument is only meaningful in Unicode build of wxWindows whenconv is used to convert s to multibyte representation. Note that this method only works with NUL-terminated strings, if you want to write data with embedded NULs to the file you should use the other Write() overload (p. 464).

wxFileDataObject
wxFileDataObject is a specialization of wxDataObject (p. 222) for file names. The program works with it just as if it were a list of absolute file names, but internally it uses the same format as Explorer and other compatible programs under Windows or GNOME/KDE filemanager under Unix which makes it possible to receive files from them using this class. Warning: Under all non-Windows platforms this class is currently "input-only", i.e. you can receive the files from another application, but copying (or dragging) file(s) from a wxWindows application is not currently supported. Virtual functions to override None. Derived from wxDataObjectSimple (p. 226) wxDataObject (p. 222) Include files <wx/dataobj.h> See also wxDataObject (p. 222), wxDataObjectSimple (p. 226), wxTextDataObject (p. 1266), wxBitmapDataObject (p. 84), wxDataObject (p. 222)

wxFileDataObject
wxFileDataObject() Constructor.

wxFileDataObject::AddFile
virtual void AddFile(const wxString& file) MSW only: adds a file to the file list represented by this data object.

465


CHAPTER 7 wxFileDataObject::GetFilenames
const wxArrayString& GetFilenames() const Returns the array (p. 53) of file names.

wxFileDialog
This class represents the file chooser dialog. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/filedlg.h> See also wxFileDialog overview (p. 1650), wxFileSelector (p. 1490) Remarks Pops up a file selector box. In Windows, this is the common file selector dialog. In X, this is a file selector box with somewhat less functionality. The path and filename are distinct elements of a full file pathname. If path is "", the current directory will be used. If filename is "", no default filename will be supplied. The wildcard determines what files are displayed in the file selector, and file extension supplies a type extension for the required filename. Flags may be a combination of wxOPEN, wxSAVE, wxOVERWRITE_PROMPT, wxHIDE_READONLY, wxFILE_MUST_EXIST, wxMULTIPLE or 0. Both the X and Windows versions implement a wildcard filter. Typing a filename containing wildcards (*, ?) in the filename text item, and clicking on Ok, will result in only those files matching the pattern being displayed. The wildcard may be a specification for multiple types of file with a description for each, such as:
"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"

It must be noted that wildcard support in the native Motif file dialog is quite limited: only one alternative is supported, and it is displayed without the descriptive test; "BMP files (*.bmp)|*.bmp'' is displayed as "*.bmp'', and both "BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif'' and "Image files|*.bmp;*.gif'' are errors.

wxFileDialog::wxFileDialog
wxFileDialog(wxWindow* parent, const wxString& message = "Choose a file", const

466


CHAPTER 7
wxString& defaultDir = "", const wxString& defaultFile = "", const wxString& wildcard = "*.*", long style = 0, const wxPoint& pos = wxDefaultPosition) Constructor. Use wxFileDialog::ShowModal (p. 470) to show the dialog. Parameters parent Parent window. message Message to show on the dialog. defaultDir The default directory, or the empty string. defaultFile The default filename, or the empty string. wildcard A wildcard, such as "*.*" or "BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif". Note that the native Motif dialog has some limitations with respect to wildcards; see the Remarks section above. style A dialog style. A bitlist of: wxOPEN wxSAVE wxHIDE_READONLY This is an open dialog. This is a save dialog. For open dialog only: hide the checkbox allowing to open the file in read-only mode.

wxOVERWRITE_PROMPT For save dialog only: prompt for a confirmation if a file will be overwritten. wxMULTIPLE wxCHANGE_DIR For open dialog only: allows selecting multiple files. Change the current working directory to the directory where the file(s) chosen by the user are.

pos Dialog position. Not implemented. NB: Previous versions of wxWindows used wxCHANGE_DIR by default under MS Windows which allowed the program to simply remember the last directory where user

467


CHAPTER 7
selected the files to open/save. This (desired) functionality must be implemented in the program itself now (manually remember the last path used and pass it to the dialog the next time it is called) or by using this flag.

wxFileDialog::~wxFileDialog
~wxFileDialog() Destructor.

wxFileDialog::GetDirectory
wxString GetDirectory() const Returns the default directory.

wxFileDialog::GetFilename
wxString GetFilename() const Returns the default filename.

wxFileDialog::GetFilenames
void GetFilenames(wxArrayString& filenames) const Fills the array filenames with the names of the files chosen. This function should only be used with the dialogs which have wxMULTIPLE style, use GetFilename (p. 468) for the others. Note that under Windows, if the user selects shortcuts, the filenames include paths, since the application cannot determine the full path of each referenced file by appending the directory containing the shortcuts to the filename.

wxFileDialog::GetFilterIndex
int GetFilterIndex() const Returns the index into the list of filters supplied, optionally, in the wildcard parameter. Before the dialog is shown, this is the index which will be used when the dialog is first displayed. After the dialog is shown, this is the index selected by the user.

wxFileDialog::GetMessage
wxString GetMessage() const

468


CHAPTER 7
Returns the message that will be displayed on the dialog.

wxFileDialog::GetPath
wxString GetPath() const Returns the full path (directory and filename) of the selected file.

wxFileDialog::GetPaths
void GetPaths(wxArrayString& paths) const Fills the array paths with the full paths of the files chosen. This function should only be used with the dialogs which have wxMULTIPLE style, use GetPath (p. 469) for the others.

wxFileDialog::GetStyle
long GetStyle() const Returns the dialog style.

wxFileDialog::GetWildcard
wxString GetWildcard() const Returns the file dialog wildcard.

wxFileDialog::SetDirectory
void SetDirectory(const wxString& directory) Sets the default directory.

wxFileDialog::SetFilename
void SetFilename(const wxString& setfilename) Sets the default filename.

wxFileDialog::SetFilterIndex
void SetFilterIndex(int filterIndex) Sets the default filter index, starting from zero.

469


CHAPTER 7 wxFileDialog::SetMessage
void SetMessage(const wxString& message) Sets the message that will be displayed on the dialog.

wxFileDialog::SetPath
void SetPath(const wxString& path) Sets the path (the combined directory and filename that will be returned when the dialog is dismissed).

wxFileDialog::SetStyle
void SetStyle(long style) Sets the dialog style. See wxFileDialog::wxFileDialog (p. 466) for details.

wxFileDialog::SetWildcard
void SetWildcard(const wxString& wildCard) Sets the wildcard, which can contain multiple file types, for example: "BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif" Note that the native Motif dialog has some limitations with respect to wildcards; see the Remarks section above.

wxFileDialog::ShowModal
int ShowModal() Shows the dialog, returning wxID_OK if the user pressed OK, and wxID_CANCEL otherwise.

wxFileDropTarget
This is a drop target (p. 429) which accepts files (dragged from File Manager or Explorer). Derived from wxDropTarget (p. 429) Include files

470


CHAPTER 7
<wx/dnd.h> See also Drag and drop overview (p. 1666), wxDropSource (p. 427), wxDropTarget (p. 429), wxTextDropTarget (p. 1268)

wxFileDropTarget::wxFileDropTarget
wxFileDropTarget() Constructor.

wxFileDropTarget::OnDrop
virtual bool OnDrop(long x, long y, const void *data, size_t size) See wxDropTarget::OnDrop (p. 431). This function is implemented appropriately for files, and calls wxFileDropTarget::OnDropFiles (p. 471).

wxFileDropTarget::OnDropFiles
virtual bool OnDropFiles(wxCoord x, wxCoord y, const wxArrayString& filenames) Override this function to receive dropped files. Parameters x The x coordinate of the mouse. y The y coordinate of the mouse. filenames An array of filenames. Return value Return true to accept the data, false to veto the operation.

wxFileHistory
The wxFileHistory encapsulates a user interface convenience, the list of most recently

471


CHAPTER 7
visited files as shown on a menu (usually the File menu). wxFileHistory can manage one or more file menus. More than one menu may be required in an MDI application, where the file history should appear on each MDI child menu as well as the MDI parent frame. Derived from wxObject (p. 954) Include files <wx/docview.h> See also wxFileHistory overview (p. 1656), wxDocManager (p. 394)

wxFileHistory::m_fileHistory
char** m_fileHistory A character array of strings corresponding to the most recently opened files.

wxFileHistory::m_fileHistoryN
size_t m_fileHistoryN The number of files stored in the history array.

wxFileHistory::m_fileMaxFiles
size_t m_fileMaxFiles The maximum number of files to be stored and displayed on the menu.

wxFileHistory::m_fileMenu
wxMenu* m_fileMenu The file menu used to display the file history list (if enabled).

wxFileHistory::wxFileHistory
wxFileHistory(size_t maxFiles = 9, wxWindowID idBase = wxID_FILE1)

472


CHAPTER 7
Constructor. Pass the maximum number of files that should be stored and displayed. idBase defaults to wxID_FILE1 and represents the id given to the first history menu item. Since menu items can't share the same ID you should change idBase (To one of your own defined IDs) when using more than one wxFileHistory in your application.

wxFileHistory::~wxFileHistory
~wxFileHistory() Destructor.

wxFileHistory::AddFileToHistory
void AddFileToHistory(const wxString& filename) Adds a file to the file history list, if the object has a pointer to an appropriate file menu.

wxFileHistory::AddFilesToMenu
void AddFilesToMenu() Appends the files in the history list, to all menus managed by the file history object. void AddFilesToMenu(wxMenu* menu) Appends the files in the history list, to the given menu only.

wxFileHistory::GetHistoryFile
wxString GetHistoryFile(size_t index) const Returns the file at this index (zero-based).

wxFileHistory::GetMaxFiles
size_t GetMaxFiles() const Returns the maximum number of files that can be stored.

wxFileHistory::GetNoHistoryFiles
size_t GetNoHistoryFiles() const Returns the number of files currently stored in the file history.

473


CHAPTER 7 wxFileHistory::Load
void Load(wxConfigBase& config) Loads the file history from the given config object. This function should be called explicitly by the application. See also wxConfig (p. 177)

wxFileHistory::RemoveMenu
void RemoveMenu(wxMenu* menu) Removes this menu from the list of those managed by this object.

wxFileHistory::Save
void Save(wxConfigBase& config) Saves the file history into the given config object. This must be called explicitly by the application. See also wxConfig (p. 177)

wxFileHistory::UseMenu
void UseMenu(wxMenu* menu) Adds this menu to the list of those managed by this object.

wxFileInputStream
This class represents data read in from a file. There are actually two such groups of classes: this one is based on wxFile (p. 458) whereas wxFFileInputStream (p. 456) is based in the wxFFile (p. 451) class. Note that wxFile (p. 458) and wxFFile (p. 451) differ in one aspect, namely when to report that the end of the file has been reached. This is documented in wxFile::Eof (p. 462) and wxFFile::Eof (p. 453) and the behaviour of the stream classes reflects this difference, i.e. wxFileInputStream will report wxSTREAM_EOF after having read the last byte whereas wxFFileInputStream will report wxSTREAM_EOF after trying to read past the last byte. Derived from

474


CHAPTER 7
wxInputStream (p. 762) Include files <wx/wfstream.h> See also wxBufferedInputStream (p. 100), wxFileOutputStream (p. 490), wxFFileOutputStream (p. 457)

wxFileInputStream::wxFileInputStream
wxFileInputStream(const wxString& ifileName) Opens the specified file using its ifilename name in read-only mode. wxFileInputStream(wxFile& file) Initializes a file stream in read-only mode using the file I/O object file. wxFileInputStream(int fd) Initializes a file stream in read-only mode using the specified file descriptor.

wxFileInputStream::~wxFileInputStream
~wxFileInputStream() Destructor.

wxFileInputStream::Ok
bool Ok() const Returns true if the stream is initialized and ready.

wxFileName
wxFileName encapsulates a file name. This class serves two purposes: first, it provides the functions to split the file names into components and to recombine these components in the full file name which can then be passed to the OS file functions (and wxWindows functions (p. 1475) wrapping them). Second, it includes the functions for working with the files itself. Note that to change the file data you should use wxFile (p. 458) class instead. wxFileName provides functions for working with the file attributes. Derived from

475


CHAPTER 7
No base class Data structures Many wxFileName methods accept the path format argument which is by wxPATH_NATIVE by default meaning to use the path format native for the current platform. The path format affects the operation of wxFileName functions in several ways: first and foremost, it defines the path separator character to use, but it also affects other things such as whether the path has the drive part or not.
enum wxPathFormat { wxPATH_NATIVE = 0, // the path format for the current platform wxPATH_UNIX, wxPATH_BEOS = wxPATH_UNIX, wxPATH_MAC, wxPATH_DOS, wxPATH_WIN = wxPATH_DOS, wxPATH_OS2 = wxPATH_DOS, wxPATH_VMS, wxPATH_MAX // Not a valid value for specifying path format }

File name format
wxFileName currently supports the file names in the Unix, DOS/Windows, Mac OS and VMS formats. Although these formats are quite different, wxFileName tries to treat them all in the same generic way. It supposes that all file names consist of the following parts: the volume (also known as drive under Windows or device under VMS), the path which is a sequence of directory names separated by the path separators (p. 483) and the full filename itself which, in turn, is composed from the base file name and the extension. All of the individual components of the file name may be empty and, for example, the volume name is always empty under Unix, but if they are all empty simultaneously, the filename object is considered to be in an invalid state and IsOk (p. 485) returns false for it. File names can be case-sensitive or not, the function IsCaseSensitive (p. 485) allows to determine this. The rules for determining if the file name is absolute or relative also depends on the file name format and the only portable way to answer to this question is to use IsAbsolute (p. 485) method. To ensure that the filename is absolute you may use MakeAbsolute (p. 486). There is also an inverse functionMakeRelativeTo (p. 486) which undoes whatNormalize(wxPATH_NORM_DOTS) (p. 487) does. Other functions returning information about the file format provided by this class are GetVolumeSeparator (p. 484), IsPathSeparator (p. 485). IsRelative (p. 485)

476


CHAPTER 7 File name construction
TODO.

File tests
Before doing the other tests you should use IsOk (p. 485) to verify that the filename is well defined. If it is, FileExists (p. 480) can be used to test if a file with such name exists and DirExists (p. 480) - if a directory with this name exists. File names should be compared using SameAs (p. 488) method or == (p. 490).

File name components
These functions allow to examine and modify the directories of the path: AppendDir (p. 478) InsertDir (p. 485) GetDirCount (p. 481)PrependDir (p. 488) RemoveDir (p. 488) To change the components of the file name individually you can use the following functions: GetExt (p. 481) GetName (p. 483) GetVolume (p. 484) HasExt (p. 484) HasName (p. 484) HasVolume (p. 485) SetExt (p. 488) SetName (p. 489) SetVolume (p. 489)

Operations
These methods allow to work with the file creation, access and modification times. Note that not all filesystems under all platforms implement these times in the same way. For example, the access time under Windows has a resolution of one day (so it is really the access date and not time). The access time may be updated when the file is executed or not depending on the platform. GetModificationTime (p. 482) GetTimes (p. 484) SetTimes (p. 489) Touch (p. 490) Other file system operations functions are:

477


CHAPTER 7
Mkdir (p. 487) Rmdir (p. 488)

wxFileName::wxFileName
wxFileName() Default constructor. wxFileName(const wxFileName& filename) Copy constructor. wxFileName(const wxString& fullpath, wxPathFormat format = wxPATH_NATIVE) Constructor taking a full filename. If it terminates with a '/', a directory path is constructed (the name will be empty), otherwise a file name and extension are extracted from it. wxFileName(const wxString& path, const wxString& name, wxPathFormat format = wxPATH_NATIVE) Constructor from a directory name and a file name. wxFileName(const wxString& path, const wxString& name, const wxString& ext, wxPathFormat format = wxPATH_NATIVE) Constructor from a directory name, base file name and extension. wxFileName(const wxString& volume, const wxString& path, const wxString& name, const wxString& ext, wxPathFormat format = wxPATH_NATIVE) Constructor from a volume name, a directory name, base file name and extension.

wxFileName::AppendDir
void AppendDir(const wxString& dir) Appends a directory component to the path. This component should contain a single directory name level, i.e. not contain any path or volume separators nor should it be empty, otherwise the function does nothing (and generates an assert failure in debug build).

wxFileName::Assign
void Assign(const wxFileName& filepath) void Assign(const wxString& fullpath, wxPathFormat format = wxPATH_NATIVE) void Assign(const wxString& volume, const wxString& path, const wxString&

478


CHAPTER 7
name, const wxString& ext, wxPathFormat format = wxPATH_NATIVE) void Assign(const wxString& path, const wxString& name, wxPathFormat format = wxPATH_NATIVE) void Assign(const wxString& path, const wxString& name, const wxString& ext, wxPathFormat format = wxPATH_NATIVE) Creates the file name from various combinations of data.

wxFileName::AssignCwd
static void AssignCwd(const wxString& volume = wxEmptyString) Makes this object refer to the current working directory on the specified volume (or current volume if volume is empty). See also GetCwd (p. 481)

wxFileName::AssignDir
void AssignDir(const wxString& dir, wxPathFormat format = wxPATH_NATIVE) Sets this file name object to the given directory name. The name and extension will be empty.

wxFileName::AssignHomeDir
void AssignHomeDir() Sets this file name object to the home directory.

wxFileName::AssignTempFileName
void AssignTempFileName(const wxString& prefix, wxFile *fileTemp = NULL) The function calls CreateTempFileName (p. 480) to create a temporary file and sets this object to the name of the file. If a temporary file couldn't be created, the object is put into the invalid (p. 485) state.

wxFileName::Clear
void Clear() Reset all components to default, uninitialized state.

479


CHAPTER 7 wxFileName::CreateTempFileName
static wxString CreateTempFileName(const wxString& prefix, wxFile *fileTemp = NULL) Returns a temporary file name starting with the given prefix. If the prefix is an absolute path, the temporary file is created in this directory, otherwise it is created in the default system directory for the temporary files or in the current directory. If the function succeeds, the temporary file is actually created. If fileTemp is not NULL, this file will be opened using the name of the temporary file. When possible, this is done in an atomic way ensuring that no race condition occurs between the temporary file name generation and opening it which could often lead to security compromise on the multiuser systems. If fileTemp is NULL, the file is only created, but not opened. Under Unix, the temporary file will have read and write permissions for the owner only to minimize the security problems. Parameters prefix Prefix to use for the temporary file name construction fileTemp The file to open or NULL to just get the name Return value The full temporary file name or an empty string on error.

wxFileName::DirExists
bool DirExists() const static bool DirExists(const wxString& dir) Returns true if the directory with this name exists.

wxFileName::DirName
static wxFileName DirName(const wxString& dir, wxPathFormat format = wxPATH_NATIVE) Returns the object corresponding to the directory with the given name. The dir parameter may have trailing path separator or not.

wxFileName::FileExists

480


CHAPTER 7
bool FileExists() const static bool FileExists(const wxString& file) Returns true if the file with this name exists. See also DirExists (p. 480)

wxFileName::FileName
static wxFileName FileName(const wxString& file, wxPathFormat format = wxPATH_NATIVE) Returns the file name object corresponding to the given file. This function exists mainly for symmetry with DirName (p. 480).

wxFileName::GetCwd
static wxString GetCwd(const wxString& volume = "") Retrieves the value of the current working directory on the specified volume. If the volume is empty, the programs current working directory is returned for the current volume. Return value The string containing the current working directory or an empty string on error. See also AssignCwd (p. 479)

wxFileName::GetDirCount
size_t GetDirCount() const Returns the number of directories in the file name.

wxFileName::GetDirs
const wxArrayString& GetDirs() const Returns the directories in string array form.

wxFileName::GetExt

481


CHAPTER 7
wxString GetExt() const Returns the file name extension.

wxFileName::GetForbiddenChars
static wxString GetForbiddenChars(wxPathFormat format = wxPATH_NATIVE) Returns the characters that can't be used in filenames and directory names for the specified format.

wxFileName::GetFormat
static wxPathFormat GetFormat(wxPathFormat format = wxPATH_NATIVE) Returns the canonical path format for this platform.

wxFileName::GetFullName
wxString GetFullName() const Returns the full name (including extension but excluding directories).

wxFileName::GetFullPath
wxString GetFullPath(wxPathFormat format = wxPATH_NATIVE) const Returns the full path with name and extension.

wxFileName::GetHomeDir
static wxString GetHomeDir() Returns the home directory.

wxFileName::GetLongPath
wxString GetLongPath() const Return the long form of the path (returns identity on non-Windows platforms)

wxFileName::GetModificationTime
wxDateTime GetModificationTime() const

482


CHAPTER 7
Returns the last time the file was last modified.

wxFileName::GetName
wxString GetName() const Returns the name part of the filename.

wxFileName::GetPath
wxString GetPath(int flags = wxPATH_GET_VOLUME, wxPathFormat format = wxPATH_NATIVE) const Returns the path part of the filename (without the name or extension). The possible flags values are: wxPATH_GET_VOLUME Return the path with the volume (does nothing for the filename formats without volumes), otherwise the path without volume part is returned.

wxPATH_GET_SEPARATOR Return the path with the trailing separator, if this flag is not given there will be no separator at the end of the path.

wxFileName::GetPathSeparator
static wxChar GetPathSeparator(wxPathFormat format = wxPATH_NATIVE) Returns the usually used path separator for this format. For all formats but wxPATH_DOS there is only one path separator anyhow, but for DOS there are two of them and the native one, i.e. the backslash is returned by this method. See also GetPathSeparators (p. 483)

wxFileName::GetPathSeparators
static wxString GetPathSeparators(wxPathFormat format = wxPATH_NATIVE) Returns the string containing all the path separators for this format. For all formats but wxPATH_DOS this string contains only one character but for DOS and Windows both '/' and '\' may be used as separators. See also GetPathSeparator (p. 483)

483


CHAPTER 7 wxFileName::GetShortPath
wxString GetShortPath() const Return the short form of the path (returns identity on non-Windows platforms).

wxFileName::GetTimes
bool GetTimes(wxDateTime* dtAccess, wxDateTime* dtMod, wxDateTime* dtCreate) const Returns the last access, last modification and creation times. The last access time is updated whenever the file is read or written (or executed in the case of Windows), last modification time is only changed when the file is written to. Finally, the creation time is indeed the time when the file was created under Windows and the inode change time under Unix (as it is impossible to retrieve the real file creation time there anyhow) which can also be changed by many operations after the file creation. Any of the pointers may be NULL if the corresponding time is not needed. Return value true on success, false if we failed to retrieve the times.

wxFileName::GetVolume
wxString GetVolume() const Returns the string containing the volume for this file name, mepty if it doesn't have one or if the file system doesn't support volumes at all (for example, Unix).

wxFileName::GetVolumeSeparator
static wxString GetVolumeSeparator(wxPathFormat format = wxPATH_NATIVE) Returns the string separating the volume from the path for this format.

wxFileName::HasExt
bool HasExt() const Returns true if an extension is present.

wxFileName::HasName
bool HasName() const

484


CHAPTER 7
Returns true if a name is present.

wxFileName::HasVolume
bool HasVolume() const Returns true if a volume specifier is present.

wxFileName::InsertDir
void InsertDir(int before, const wxString& dir) Inserts a directory component before the zero-based position in the directory list. Please see AppendDir (p. 478) for important notes.

wxFileName::IsAbsolute
bool IsAbsolute(wxPathFormat format = wxPATH_NATIVE) Returns true if this filename is absolute.

wxFileName::IsCaseSensitive
static bool IsCaseSensitive(wxPathFormat format = wxPATH_NATIVE) Returns true if the file names of this type are case-sensitive.

wxFileName::IsOk
bool IsOk() const Returns true if the filename is valid, false if it is not initialized yet. The assignment functions andClear (p. 479) may reset the object to the uninitialized, invalid state (the former only do it on failure).

wxFileName::IsPathSeparator
static bool IsPathSeparator(wxChar ch, wxPathFormat format = wxPATH_NATIVE) Returns true if the char is a path separator for this format.

wxFileName::IsRelative
bool IsRelative(wxPathFormat format = wxPATH_NATIVE)

485


CHAPTER 7
Returns true if this filename is not absolute.

wxFileName::IsDir
bool IsDir() const Returns true if this object represents a directory, false otherwise (i.e. if it is a file). Note that this method doesn't test whether the directory or file really exists, you should use DirExists (p. 480) or FileExists (p. 480) for this.

wxFileName::MakeAbsolute
bool MakeAbsolute(const wxString& cwd = wxEmptyString, wxPathFormat format = wxPATH_NATIVE) Make the file name absolute. This is a shortcut forNormalize (p. 487)(wxPATH_NORM_DOTS | wxPATH_NORM_ABSOLUTE | wxPATH_NORM_TILDE, cwd, format). See also MakeRelativeTo (p. 486),Normalize (p. 487),IsAbsolute (p. 485)

wxFileName::MakeRelativeTo
bool MakeRelativeTo(const wxString& pathBase = wxEmptyString, wxPathFormat format = wxPATH_NATIVE) This function tries to put this file name in a form relative to pathBase. In other words, it returns the file name which should be used to access this file if the current directory were pathBase. pathBase the directory to use as root, current directory is used by default format the file name format, native by default Return value true if the file name has been changed, false if we failed to do anything with it (currently this only happens if the file name is on a volume different from the volume specified by pathBase). See also Normalize (p. 487)

486


CHAPTER 7 wxFileName::Mkdir
bool Mkdir(int perm = 0777, int flags = 0) static bool Mkdir(const wxString& dir, int perm = 0777, int flags = 0) dir the directory to create parm the permissions for the newly created directory flags if the flags contain wxPATH_MKDIR_FULL flag, try to create each directory in the path and also don't return an error if the target directory already exists. Return value Returns true if the directory was successfully created, falseotherwise.

wxFileName::Normalize
bool Normalize(int flags = wxPATH_NORM_ALL, const wxString& cwd = wxEmptyString, wxPathFormat format = wxPATH_NATIVE) Normalize the path. With the default flags value, the path will be made absolute, without any ".." and "." and all environment variables will be expanded in it. flags The kind of normalization to do with the file name. It can be any or-combination of the following constants: wxPATH_NORM_ENV_VARS replace env vars with their values wxPATH_NORM_DOTS wxPATH_NORM_TILDE wxPATH_NORM_CASE squeeze all .. and . and prepend cwd Unix only: replace and user if filesystem is case insensitive, transform to tolower case

wxPATH_NORM_ABSOLUTE make the path absolute wxPATH_NORM_LONG make the path the long form

wxPATH_NORM_SHORTCUTresolve if it is a shortcut (Windows only) wxPATH_NORM_ALL all of previous flags except wxPATH_NORM_CASE

487


CHAPTER 7
cwd If not empty, this directory will be used instead of current working directory in normalization. format The file name format, native by default.

wxFileName::PrependDir
void PrependDir(const wxString& dir) Prepends a directory to the file path. Please see AppendDir (p. 478) for important notes.

wxFileName::RemoveDir
void RemoveDir(int pos) Removes a directory name.

wxFileName::Rmdir
bool Rmdir() static bool Rmdir(const wxString& dir) Deletes the specified directory from the file system.

wxFileName::SameAs
bool SameAs(const wxFileName& filepath, wxPathFormat format = wxPATH_NATIVE) const Compares the filename using the rules of this platform.

wxFileName::SetCwd
bool SetCwd() static bool SetCwd(const wxString& cwd) Changes the current working directory.

wxFileName::SetExt

488


CHAPTER 7
void SetExt(const wxString& ext) Sets the extension of this file name.

wxFileName::SetFullName
void SetFullName(const wxString& fullname) The full name is the file name and extension (but without the path).

wxFileName::SetName
void SetName(const wxString& name) Sets the name.

wxFileName::SetTimes
bool SetTimes(const wxDateTime* dtAccess, const wxDateTime* dtMod, const wxDateTime* dtCreate) Sets the file creation and last access/modification times (any of the pointers may be NULL).

wxFileName::SetVolume
void SetVolume(const wxString& volume) Sets the volume specifier.

wxFileName::SplitPath
static void SplitPath(const wxString& fullpath, wxString* volume, wxString* path, wxString* name, wxString* ext, wxPathFormat format = wxPATH_NATIVE) static void SplitPath(const wxString& fullpath, wxString* path, wxString* name, wxString* ext, wxPathFormat format = wxPATH_NATIVE) This function splits a full file name into components: the volume (with the first version) path (including the volume in the second version), the base name and the extension. Any of the output parameters (volume, path, name or ext) may be NULL if you are not interested in the value of a particular component. Also, fullpath may be empty on entry. On return, path contains the file path (without the trailing separator), name contains the file name and ext contains the file extension without leading dot. All three of them may be empty if the corresponding component is. The old contents of the strings pointed to by these parameters will be overwritten in any case (if the pointers are not NULL).

489


CHAPTER 7 wxFileName::Touch
bool Touch() Sets the access and modification times to the current moment.

wxFileName::operator=
wxFileName& operator operator=(const wxFileName& filename) wxFileName& operator operator=(const wxString& filename) Assigns the new value to this filename object.

wxFileName::operator==
bool operator operator==(const wxFileName& filename) const bool operator operator==(const wxString& filename) const Returns true if the filenames are equal. The string filenames is interpreted as a path in the native filename format.

wxFileName::operator!=
bool operator operator!=(const wxFileName& filename) const bool operator operator!=(const wxString& filename) const Returns true if the filenames are different. The string filenamesis interpreted as a path in the native filename format.

wxFileOutputStream
This class represents data written to a file. There are actually two such groups of classes: this one is based on wxFile (p. 458) whereas wxFFileInputStream (p. 456) is based in the wxFFile (p. 451) class. Note that wxFile (p. 458) and wxFFile (p. 451) differ in one aspect, namely when to report that the end of the file has been reached. This is documented in wxFile::Eof (p. 462) and wxFFile::Eof (p. 453) and the behaviour of the stream classes reflects this difference, i.e. wxFileInputStream will report wxSTREAM_EOF after having read the last byte whereas wxFFileInputStream will report wxSTREAM_EOF after trying to read past the last byte. Derived from wxOutputStream (p. 958)

490


CHAPTER 7
Include files <wx/wfstream.h> See also wxBufferedOutputStream (p. 100), wxFileInputStream (p. 474), wxFFileInputStream (p. 456)

wxFileOutputStream::wxFileOutputStream
wxFileOutputStream(const wxString& ofileName) Creates a new file with ofilename name and initializes the stream in write-only mode. wxFileOutputStream(wxFile& file) Initializes a file stream in write-only mode using the file I/O object file. wxFileOutputStream(int fd) Initializes a file stream in write-only mode using the file descriptor fd.

wxFileOutputStream::~wxFileOutputStream
~wxFileOutputStream() Destructor.

wxFileOutputStream::Ok
bool Ok() const Returns true if the stream is initialized and ready.

wxFileStream
Derived from wxFileOutputStream (p. 490), wxFileInputStream (p. 474) Include files <wx/wfstream.h> See also

491


CHAPTER 7
wxStreamBuffer (p. 1193)

wxFileStream::wxFileStream
wxFileStream(const wxString& iofileName) Initializes a new file stream in read-write mode using the specified iofilename name.

wxFileSystem
This class provides an interface for opening files on different file systems. It can handle absolute and/or local filenames. It uses a system of handlers (p. 494) to provide access to user-defined virtual file systems. Derived from wxObject (p. 954) Include files <wx/filesys.h> See Also wxFileSystemHandler (p. 494), wxFSFile (p. 543), Overview (p. 1601)

wxFileSystem::wxFileSystem
wxFileSystem() Constructor.

wxFileSystem::AddHandler
static void AddHandler(wxFileSystemHandler *handler) This static function adds new handler into the list of handlers. The handlers (p. 494) provide access to virtual FS. Note You can call:
wxFileSystem::AddHandler(new My_FS_Handler);

492


CHAPTER 7
This is because (a) AddHandler is a static method, and (b) the handlers are deleted in wxFileSystem's destructor so that you don't have to care about it.

wxFileSystem::ChangePathTo
void ChangePathTo(const wxString& location, bool is_dir = false) Sets the current location. location parameter passed to OpenFile (p. 494) is relative to this path. Caution! Unless is_dir is true the location parameter is not the directory name but the name of the file in this directory. All these commands change the path to "dir/subdir/":
ChangePathTo("dir/subdir/xh.htm"); ChangePathTo("dir/subdir", true); ChangePathTo("dir/subdir/", true);

Parameters location the new location. Its meaning depends on the value of is_dir is_dir if true location is new directory. If false (default) location is file in the new directory. Example
f = fs -> OpenFile("hello.htm"); // opens file 'hello.htm' fs -> ChangePathTo("subdir/folder", true); f = fs -> OpenFile("hello.htm"); // opens file 'subdir/folder/hello.htm' !!

wxFileSystem::GetPath
wxString GetPath() Returns actual path (set by ChangePathTo (p. 493)).

wxFileSystem::FileNameToURL
static wxString FileNameToURL(wxFileName filename) Converts filename into URL. See also wxFileSystem::URLToFileName (p. 494),wxFileName (p. 475)

wxFileSystem::FindFirst 493


CHAPTER 7
wxString FindFirst(const wxString& wildcard, int flags = 0) Works like wxFindFirstFile (p. 1476). Returns name of the first filename (within filesystem's current path) that matches wildcard. flags may be one of wxFILE (only files), wxDIR (only directories) or 0 (both).

wxFileSystem::FindNext
wxString FindNext() Returns the next filename that matches parameters passed to FindFirst (p. 493).

wxFileSystem::OpenFile
wxFSFile* OpenFile(const wxString& location) Opens the file and returns a pointer to a wxFSFile (p. 543) object or NULL if failed. It first tries to open the file in relative scope (based on value passed to ChangePathTo() method) and then as an absolute path. Note that the user is responsible for deleting the returned wxFSFile.

wxFileSystem::URLToFileName
static wxFileName URLToFileName(const wxString& url) Converts URL into a well-formed filename. The URL must use the file protocol. See also wxFileSystem::FileNameToURL (p. 493), wxFileName (p. 475)

wxFileSystemHandler
Classes derived from wxFileSystemHandler are used to access virtual file systems. Its public interface consists of two methods: CanOpen (p. 495) and OpenFile (p. 497). It provides additional protected methods to simplify the process of opening the file: GetProtocol, GetLeftLocation, GetRightLocation, GetAnchor, GetMimeTypeFromExt. Please have a look at overview (p. 1601) if you don't know how locations are constructed. Also consult list of available handlers (p. 1601). wxPerl note: In wxPerl, you need to derive your file system handler class from Wx::PlFileSystemHandler. Notes

494


CHAPTER 7
   The handlers are shared by all instances of wxFileSystem. wxHTML library provides handlers for local files and HTTP or FTP protocol The location parameter passed to OpenFile or CanOpen methods is always an absolute path. You don't need to check the FS's current path.

Derived from wxObject (p. 954) Include files <wx/filesys.h> See also wxFileSystem (p. 492), wxFSFile (p. 543), Overview (p. 1601)

wxFileSystemHandler::wxFileSystemHandler
wxFileSystemHandler() Constructor.

wxFileSystemHandler::CanOpen
virtual bool CanOpen(const wxString& location) Returns true if the handler is able to open this file. This function doesn't check whether the file exists or not, it only checks if it knows the protocol. Example:
bool MyHand::CanOpen(const wxString& location) { return (GetProtocol(location) == "http"); }

Must be overridden in derived handlers.

wxFileSystemHandler::GetAnchor
wxString GetAnchor(const wxString& location) const Returns the anchor if present in the location. See wxFSFile (p. 544) for details. Example: GetAnchor("index.htm#chapter2") == "chapter2" Note: the anchor is NOT part of the left location.

495


CHAPTER 7 wxFileSystemHandler::GetLeftLocation
wxString GetLeftLocation(const wxString& location) const Returns the left location string extracted from location. Example: GetLeftLocation("file:myzipfile.zip#zip:index.htm") == "file:myzipfile.zip"

wxFileSystemHandler::GetMimeTypeFromExt
wxString GetMimeTypeFromExt(const wxString& location) Returns the MIME type based on extension of location. (W hile wxFSFile::GetMimeType returns real MIME type - either extension-based or queried from HTTP.) Example : GetMimeTypeFromExt("index.htm") == "text/html"

wxFileSystemHandler::GetProtocol
wxString GetProtocol(const wxString& location) const Returns the protocol string extracted from location. Example: GetProtocol("file:myzipfile.zip#zip:index.htm") == "zip"

wxFileSystemHandler::GetRightLocation
wxString GetRightLocation(const wxString& location) const Returns the right location string extracted from location. Example : GetRightLocation("file:myzipfile.zip#zip:index.htm") == "index.htm"

wxFileSystemHandler::FindFirst
virtual wxString FindFirst(const wxString& wildcard, int flags = 0) Works like wxFindFirstFile (p. 1476). Returns name of the first filename (within filesystem's current path) that matches wildcard. flags may be one of wxFILE (only files), wxDIR (only directories) or 0 (both). This method is only called if CanOpen (p. 495) returns true.

wxFileSystemHandler::FindNext
virtual wxString FindNext() Returns next filename that matches parameters passed to FindFirst (p. 493).

496


CHAPTER 7
This method is only called if CanOpen (p. 495) returns true and FindFirst returned a nonempty string.

wxFileSystemHandler::OpenFile
virtual wxFSFile* OpenFile(wxFileSystem& fs, const wxString& location) Opens the file and returns wxFSFile pointer or NULL if failed. Must be overridden in derived handlers. Parameters fs Parent FS (the FS from that OpenFile was called). See ZIP handler for details of how to use it. location The absolute location of file.

wxFileType
This class holds information about a given file type. File type is the same as MIME type under Unix, but under Windows it corresponds more to an extension than to MIME type (in fact, several extensions may correspond to a file type). This object may be created in several different ways: the program might know the file extension and wish to find out the corresponding MIME type or, conversely, it might want to find the right extension for the file to which it writes the contents of given MIME type. Depending on how it was created some fields may be unknown so the return value of all the accessors must be checked: falsewill be returned if the corresponding information couldn't be found. The objects of this class are never created by the application code but are returned by wxMimeTypesManager::GetFileTypeFromMimeType (p. 921) and wxMimeTypesManager::GetFileTypeFromExtension (p. 921) methods. But it is your responsibility to delete the returned pointer when you're done with it! A brief reminder about what the MIME types are (see the RFC 1341 for more information): basically, it is just a pair category/type (for example, "text/plain") where the category is a basic indication of what a file is. Examples of categories are "application", "image", "text", "binary", and type is a precise definition of the document format: "plain" in the example above means just ASCII text without any formatting, while "text/html" is the HTML document source. A MIME type may have one or more associated extensions: "text/plain" will typically correspond to the extension ".txt", but may as well be associated with ".ini" or ".conf". Derived from None

497


CHAPTER 7
Include files <wx/mimetype.h> See also wxMimeTypesManager (p. 918)

MessageParameters class
One of the most common usages of MIME is to encode an e-mail message. The MIME type of the encoded message is an example of a message parameter. These parameters are found in the message headers ("Content-XXX"). At the very least, they must specify the MIME type and the version of MIME used, but almost always they provide additional information about the message such as the original file name or the charset (for the text documents). These parameters may be useful to the program used to open, edit, view or print the message, so, for example, an e-mail client program will have to pass them to this program. Because wxFileType itself can not know about these parameters, it uses MessageParameters class to query them. The default implementation only requires the caller to provide the file name (always used by the program to be called - it must know which file to open) and the MIME type and supposes that there are no other parameters. If you wish to supply additional parameters, you must derive your own class from MessageParameters and override GetParamValue() function, for example:
// provide the message parameters for the MIME type manager class MailMessageParameters : public wxFileType::MessageParameters { public: MailMessageParameters(const wxString& filename, const wxString& mimetype) : wxFileType::MessageParameters(filename, mimetype) { } virtual wxString GetParamValue(const wxString& name) const { // parameter names are not case-sensitive if ( name.CmpNoCase("charset") == 0 ) return "US-ASCII"; else return wxFileType::MessageParameters::GetParamValue(name); } };

Now you only need to create an object of this class and pass it to, for example, GetOpenCommand (p. 500) like this:
wxString command; if ( filetype->GetOpenCommand(&command, MailMessageParamaters("foo.txt", "text/plain")) ) { // the full command for opening the text documents is in 'command' // (it might be "notepad foo.txt" under Windows or "cat foo.txt" under Unix) } else {

498


CHAPTER 7
// we don't know how to handle such files... }

Windows: As only the file name is used by the program associated with the given extension anyhow (but no other message parameters), there is no need to ever derive from MessageParameters class for a Windows-only program.

wxFileType::wxFileType
wxFileType() The default constructor is private because you should never create objects of this type: they are only returned by wxMimeTypesManager (p. 918) methods.

wxFileType::~wxFileType
~wxFileType() The destructor of this class is not virtual, so it should not be derived from.

wxFileType::GetMimeType
bool GetMimeType(wxString* mimeType) If the function returns true, the string pointed to by mimeType is filled with full MIME type specification for this file type: for example, "text/plain".

wxFileType::GetMimeTypes
bool GetMimeType(wxArrayString& mimeTypes) Same as GetMimeType (p. 499) but returns array of MIME types. This array will contain only one item in most cases but sometimes, notably under Unix with KDE, may contain more MIME types. This happens when one file extension is mapped to different MIME types by KDE, mailcap and mime.types.

wxFileType::GetExtensions
bool GetExtensions(wxArrayString& extensions) If the function returns true, the array extensions is filled with all extensions associated with this file type: for example, it may contain the following two elements for the MIME type "text/html" (notice the absence of the leading dot): "html" and "htm". Windows: This function is currently not implemented: there is no (efficient) way to retrieve associated extensions from the given MIME type on this platform, so it will only return true if the wxFileType object was created by GetFileTypeFromExtension (p. 921)

499


CHAPTER 7
function in the first place.

wxFileType::GetIcon
bool GetIcon(wxIconLocation * iconLoc) If the function returns true, the iconLoc is filled with the location of the icon for this MIME type. A wxIcon (p. 716) may be created from iconLoc later. Windows: The function returns the icon shown by Explorer for the files of the specified type. Mac: This function is not implemented and always returns false. Unix: MIME manager gathers information about icons from GNOME and KDE settings and thus GetIcon's success depends on availability of these desktop environments.

wxFileType::GetDescription
bool GetDescription(wxString* desc) If the function returns true, the string pointed to by desc is filled with a brief description for this file type: for example, "text document" for the "text/plain" MIME type.

wxFileType::GetOpenCommand
bool GetOpenCommand(wxString* command, MessageParameters& params) wxString GetOpenCommand(const wxString& filename) With the first version of this method, if the true is returned, the string pointed to by command is filled with the command which must be executed (see wxExecute (p. 1469)) in order to open the file of the given type. In this case, the name of the file as well as any other parameters is retrieved from MessageParameters (p. 498) class. In the second case, only the filename is specified and the command to be used to open this kind of file is returned directly. An empty string is returned to indicate that an error occured (typically meaning that there is no standard way to open this kind of files).

wxFileType::GetPrintCommand
bool GetPrintCommand(wxString* command,MessageParameters& params) If the function returns true, the string pointed to by command is filled with the command which must be executed (see wxExecute (p. 1469)) in order to print the file of the given type. The name of the file is retrieved from MessageParameters (p. 498) class.

500


CHAPTER 7 wxFileType::ExpandCommand
static wxString ExpandCommand(const wxString& command, MessageParameters& params) This function is primarily intended for GetOpenCommand and GetPrintCommand usage but may be also used by the application directly if, for example, you want to use some non default command to open the file. The function replaces all occurrences of format specification %s %t %{param} with the full file name the MIME type the value of the parameter param

using the MessageParameters object you pass to it. If there is no '%s' in the command string (and the string is not empty), it is assumed that the command reads the data on stdin and so the effect is the same as "< %s" were appended to the string. Unlike all other functions of this class, there is no error return for this function.

wxFilterInputStream
A filter stream has the capability of a normal stream but it can be placed on top of another stream. So, for example, it can uncompress or decrypt the data which are read from another stream and pass it to the requester. Derived from wxInputStream (p. 762) wxStreamBase (p. 1191) Include files <wx/stream.h> Note The interface of this class is the same as that of wxInputStream. Only a constructor differs and it is documented below.

wxFilterInputStream::wxFilterInputStream
wxFilterInputStream(wxInputStream& stream) Initializes a "filter" stream.

501


CHAPTER 7

wxFilterOutputStream
A filter stream has the capability of a normal stream but it can be placed on top of another stream. So, for example, it can compress, encrypt the data which are passed to it and write them to another stream. Derived from wxOutputStream (p. 958) wxStreamBase (p. 1191) Include files <wx/stream.h> Note The use of this class is exactly the same as of wxOutputStream. Only a constructor differs and it is documented below.

wxFilterOutputStream::wxFilterOutputStream
wxFilterOutputStream(wxOutputStream& stream) Initializes a "filter" stream.

wxFindDialogEvent
wxFindReplaceDialog events Derived from wxCommandEvent (p. 164) Include files <wx/fdrepdlg.h> Event table macros To process a command event from wxFindReplaceDialog (p. 505), use these event handler macros to direct input to member functions that take a wxFindDialogEvent argument. The id parameter is the identifier of the find dialog and you may usually specify -1 for it unless you plan to have several find dialogs sending events to the same owner window simultaneously. EVT_FIND(id, func) EVT_FIND_NEXT(id, func) Find button was pressed in the dialog. Find next button was pressed in the dialog.

502


CHAPTER 7
EVT_FIND_REPLACE(id, func) EVT_FIND_REPLACE_ALL(id, func) EVT_FIND_CLOSE(id, func) Replace button was pressed in the dialog. Replace all button was pressed in the dialog. The dialog is being destroyed, any pointers to it cannot be used any longer.

wxFindDialogEvent::wxFindDialogEvent
wxFindDialogEvent(wxEventType commandType = wxEVT_NULL, int id = 0) Constuctor used by wxWindows only.

wxFindDialogEvent::GetFlags
int GetFlags() const Get the currently selected flags: this is the combination of wxFR_DOWN,wxFR_WHOLEWORD and wxFR_MATCHCASE flags.

wxFindDialogEvent::GetFindString
wxString GetFindString() const Return the string to find (never empty).

wxFindDialogEvent::GetReplaceString
const wxString& GetReplaceString() const Return the string to replace the search string with (only for replace and replace all events).

wxFindDialogEvent::GetDialog
wxFindReplaceDialog* GetDialog() const Return the pointer to the dialog which generated this event.

wxFindReplaceData
wxFindReplaceData holds the data for wxFindReplaceDialog (p. 505). It is used to initialize the dialog with the default values and will keep the last values from the dialog when it is closed. It is also updated each time a wxFindDialogEvent (p. 502) is generated

503


CHAPTER 7
so instead of using the wxFindDialogEvent methods you can also directly query this object. Note that all SetXXX() methods may only be called before showing the dialog and calling them has no effect later. Include files
#include <wx/fdrepdlg.h>

Derived from wxObject (p. 954) Data structures Flags used by wxFindReplaceData::GetFlags() (p. 505) andwxFindDialogEvent::GetFlags() (p. 503):
enum wxFindReplaceFlags { // downward search/replace selected (otherwise - upwards) wxFR_DOWN = 1, // whole word search/replace selected wxFR_WHOLEWORD = 2, // case sensitive search/replace selected (otherwise - case insensitive) wxFR_MATCHCASE = 4 }

These flags can be specified in wxFindReplaceDialog ctor (p. 506) or Create() (p. 506):
enum wxFindReplaceDialogStyles { // replace dialog (otherwise find dialog) wxFR_REPLACEDIALOG = 1, // don't allow changing the search direction wxFR_NOUPDOWN = 2, // don't allow case sensitive searching wxFR_NOMATCHCASE = 4, // don't allow whole word searching wxFR_NOWHOLEWORD =8 }

wxFindReplaceData::wxFindReplaceData
wxFindReplaceData(wxUint32 flags = 0) Constuctor initializes the flags to default value (0).

wxFindReplaceData::GetFindString

504


CHAPTER 7
const wxString& GetFindString() Get the string to find.

wxFindReplaceData::GetReplaceString
const wxString& GetReplaceString() Get the replacement string.

wxFindReplaceData::GetFlags
int GetFlags() const Get the combination of wxFindReplaceFlags values.

wxFindReplaceData::SetFlags
void SetFlags(wxUint32 flags) Set the flags to use to initialize the controls of the dialog.

wxFindReplaceData::SetFindString
void SetFindString(const wxString& str) Set the string to find (used as initial value by the dialog).

wxFindReplaceData::SetReplaceString
void SetReplaceString(const wxString& str) Set the replacement string (used as initial value by the dialog).

wxFindReplaceDialog
wxFindReplaceDialog is a standard modeless dialog which is used to allow the user to search for some text (and possibly replace it with something else). The actual searching is supposed to be done in the owner window which is the parent of this dialog. Note that it means that unlike for the other standard dialogs this one must have a parent window. Also note that there is no way to use this dialog in a modal way; it is always, by design and implementation, modeless. Please see the dialogs sample for an example of using it. Include files

505


CHAPTER 7
#include <wx/fdrepdlg.h>

Derived from wxDialog (p. 367)

wxFindReplaceDialog::wxFindReplaceDialog
wxFindReplaceDialog() wxFindReplaceDialog(wxWindow * parent, wxFindReplaceData* data, const wxString& title, int style = 0) After using default constructor Create() (p. 506) must be called. The parent and data parameters must be non-NULL.

wxFindReplaceDialog::~wxFindReplaceDialog
~wxFindReplaceDialog() Destructor.

wxFindReplaceDialog::Create
bool Create(wxWindow * parent, wxFindReplaceData* data, const wxString& title, int style = 0) Creates the dialog; use Show (p. 1432) to show it on screen.

The parent and data parameters must be nonNULL.wxFindReplaceDialog::GetData
const wxFindReplaceData* GetData() const Get the wxFindReplaceData (p. 503) object used by this dialog.

wxFlexGridSizer
A flex grid sizer is a sizer which lays out its children in a two-dimensional table with all table fields in one row having the same height and all fields in one column having the same width, but all rows or all columns are not necessarily the same height or width as in the wxGridSizer (p. 633). Since wxWindows 2.5.0, wxFlexGridSizer can also size items equally in one direction

506


CHAPTER 7
but unequally ("flexibly") in the other. If the sizer is only flexible in one direction (this can be changed using SetFlexibleDrection (p. 509)), it needs to be decided how the sizer should grow in the other ("non flexible") direction in order to fill the available space. The SetNonFlexibleGrowMode (p. 509) method serves this purpose. Derived from wxGridSizer (p. 633) wxSizer (p. 1109) wxObject (p. 954) See also wxSizer (p. 1109), Sizer overview (p. 1620)

wxFlexGridSizer::wxFlexGridSizer
wxFlexGridSizer(int rows, int cols, int vgap, int hgap) wxFlexGridSizer(int cols, int vgap = 0, int hgap = 0) Constructor for a wxGridSizer. rows and cols determine the number of columns and rows in the sizer - if either of the parameters is zero, it will be calculated to form the total number of children in the sizer, thus making the sizer grow dynamically. vgap and hgap define extra space between all children.

wxFlexGridSizer::AddGrowableCol
void AddGrowableCol(size_t idx, int proportion = 0) Specifies that column idx (starting from zero) should be grown if there is extra space available to the sizer. The proportion parameter has the same meaning as the stretch factor for the sizers (p. 1620) except that if all proportions are 0, then all columns are resized equally (instead of not being resized at all).

wxFlexGridSizer::AddGrowableRow
void AddGrowableRow(size_t idx, int proportion = 0) Specifies that row idx (starting from zero) should be grown if there is extra space available to the sizer. See AddGrowableCol (p. 507) for the description of proportion parameter.

wxFlexGridSizer::GetFlexibleDirection
int GetFlexibleDirections() const

507


CHAPTER 7
Returns a wxOrientation value that specifies whether the sizer flexibly resizes its columns, rows, or both (default). Return value One of the following values: wxVERTICAL wxHORIZONTAL wxBOTH See also SetFlexibleDrection (p. 509) Rows are flexibly sized. Columns are flexibly sized. Both rows and columns are flexibly sized (this is the default value).

wxFlexGridSizer::GetNonFlexibleGrowMode
int GetNonFlexibleGrowMode() const Returns the value that specifies how the sizer grows in the "non flexible" direction if there is one. Return value One of the following values: wxFLEX_GROWMODE_NONE wxFLEX_GROWMODE_SPECIFIED Sizer doesn't grow in the non flexible direction. Sizer honors growable columns/rows set withAddGrowableCol (p. 507) and AddGrowableRow (p. 507). In this case equal sizing applies to minimum sizes of columns or rows (this is the default value). Sizer equally stretches all columns or rows in the non flexible direction, whether they are growable or not in the flexbile direction.

wxFLEX_GROWMODE_ALL

See also SetFlexibleDrection (p. 509), SetNonFlexibleGrowMode (p. 509)

wxFlexGridSizer::RemoveGrowableCol
void RemoveGrowableCol(size_t idx) Specifies that column idx is no longer growable.

508


CHAPTER 7 wxFlexGridSizer::RemoveGrowableRow
void RemoveGrowableRow(size_t idx) Specifies that row idx is no longer growable.

wxFlexGridSizer::SetFlexibleDirection
void SetFlexibleDirections(int direction) Specifies whether the sizer should flexibly resize its columns, rows, or both. Argument direction can be wxVERTICAL, wxHORIZONTAL or wxBOTH (which is the default value). Any other value is ignored. SeeGetFlexibleDirection() (p. 507) for the explanation of these values. Note that this method does not trigger relayout.

wxFlexGridSizer::SetNonFlexibleGrowMode
void SetNonFlexibleGrowMode(int mode) Specifies how the sizer should grow in the non flexible direction if there is one (soSetFlexibleDirections() (p. 509) must have been called previously). Argument mode can be one of those documented inGetNonFlexibleGrowMode (p. 508), please see there for their explanation. Note that this method does not trigger relayout.

wxFocusEvent
A focus event is sent when a window's focus changes. The window losing focus receives a "kill focus'' event while the window gaining it gets a "set focus'' one. Notice that the set focus event happens both when the user gives focus to the window (whether using the mouse or keyboard) and when it is done from the program itself using SetFocus (p. 1424). Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a focus event, use these event handler macros to direct input to a member function that takes a wxFocusEvent argument.

509


CHAPTER 7
EVT_SET_FOCUS(func) EVT_KILL_FOCUS(func) See also Event handling overview (p. 1602) Process a wxEVT_SET_FOCUS event. Process a wxEVT_KILL_FOCUS event.

wxFocusEvent::wxFocusEvent
wxFocusEvent(WXTYPE eventType = 0, int id = 0) Constructor.

wxFont
A font is an object which determines the appearance of text. Fonts are used for drawing text to a device context, and setting the appearance of a window's text. You can retrieve the current system font settings with wxSystemSettings (p. 1229). wxSystemSettings (p. 1229) Derived from wxGDIObject (p. 560) wxObject (p. 954) Include files <wx/font.h> Constants The font flags which can be used during the font creation are:
enum { // no special flags: font with default weight/slant/anti-aliasing wxFONTFLAG_DEFAULT = 0, // slant flags (default: no slant) wxFONTFLAG_ITALIC = 1 << 0, wxFONTFLAG_SLANT = 1 << 1, // weight flags (default: medium) wxFONTFLAG_LIGHT = 1 << 2, wxFONTFLAG_BOLD = 1 << 3, // anti-aliasing flag: force on or off (default: the current system default) wxFONTFLAG_ANTIALIASED = 1 << 4, wxFONTFLAG_NOT_ANTIALIASED = 1 << 5, // underlined/strikethrough flags (default: no lines)

510


CHAPTER 7
wxFONTFLAG_UNDERLINED wxFONTFLAG_STRIKETHROUGH }; The known font encodings are:enum wxFontEncoding { wxFONTENCODING_SYSTEM = -1, // system default wxFONTENCODING_DEFAULT, // current default encoding // ISO8859 standard defines a number of single-byte charsets wxFONTENCODING_ISO8859_1, // West European (Latin1) wxFONTENCODING_ISO8859_2, // Central and East European (Latin2) wxFONTENCODING_ISO8859_3, // Esperanto (Latin3) wxFONTENCODING_ISO8859_4, // Baltic (old) (Latin4) wxFONTENCODING_ISO8859_5, // Cyrillic wxFONTENCODING_ISO8859_6, // Arabic wxFONTENCODING_ISO8859_7, // Greek wxFONTENCODING_ISO8859_8, // Hebrew wxFONTENCODING_ISO8859_9, // Turkish (Latin5) wxFONTENCODING_ISO8859_10, // Variation of Latin4 (Latin6) wxFONTENCODING_ISO8859_11, // Thai wxFONTENCODING_ISO8859_12, // doesn't exist currently, but put it // here anyhow to make all ISO8859 // consecutive numbers wxFONTENCODING_ISO8859_13, // Baltic (Latin7) wxFONTENCODING_ISO8859_14, // Latin8 wxFONTENCODING_ISO8859_15, // Latin9 (a.k.a. Latin0, includes euro) wxFONTENCODING_ISO8859_MAX, // Cyrillic charset soup (see http://czyborra.com/charsets/cyrillic.html) wxFONTENCODING_KOI8, // we don't support any of KOI8 variants wxFONTENCODING_ALTERNATIVE, // same as MS-DOS CP866 wxFONTENCODING_BULGARIAN, // used under Linux in Bulgaria // what would we do without Microsoft? They have their own encodings // for DOS wxFONTENCODING_CP437, // original MS-DOS codepage wxFONTENCODING_CP850, // CP437 merged with Latin1 wxFONTENCODING_CP852, // CP437 merged with Latin2 wxFONTENCODING_CP855, // another cyrillic encoding wxFONTENCODING_CP866, // and another one // and for Windows wxFONTENCODING_CP874, // WinThai wxFONTENCODING_CP1250, // WinLatin2 wxFONTENCODING_CP1251, // WinCyrillic wxFONTENCODING_CP1252, // WinLatin1 wxFONTENCODING_CP1253, // WinGreek (8859-7) wxFONTENCODING_CP1254, // WinTurkish wxFONTENCODING_CP1255, // WinHebrew wxFONTENCODING_CP1256, // WinArabic wxFONTENCODING_CP1257, // WinBaltic (same as Latin 7) wxFONTENCODING_CP12_MAX, wxFONTENCODING_UTF7, wxFONTENCODING_UTF8, wxFONTENCODING_UNICODE, wxFONTENCODING_MAX }; // UTF-7 Unicode encoding // UTF-8 Unicode encoding // Unicode - currently used only by // wxEncodingConverter class = 1 << 6, = 1 << 7,

Predefined objects Objects:

511


CHAPTER 7
wxNullFont Pointers: wxNORMAL_FONT wxSMALL_FONT wxITALIC_FONT wxSWISS_FONT See also wxFont overview (p. 1641), wxDC::SetFont (p. 364), wxDC::DrawText (p. 355), wxDC::GetTextExtent (p. 360), wxFontDialog (p. 522), wxSystemSettings (p. 1229)

wxFont::wxFont
wxFont() Default constructor. wxFont(int pointSize, int family, int style, int weight, const bool underline = false, const wxString& faceName = "", wxFontEncoding encoding = wxFONTENCODING_DEFAULT) Creates a font object (see font encoding overview (p. 1643) for the meaning of the last parameter). Parameters pointSize Size in points. family Font family, a generic way of referring to fonts without specifying actual facename. One of: wxDEFAULT wxDECORATIVE wxROMAN wxSCRIPT wxSWISS wxMODERN style Chooses a default font. A decorative font. A formal, serif font. A handwriting font. A sans-serif font. A fixed pitch font.

512


CHAPTER 7
One of wxNORMAL, wxSLANT and wxITALIC. weight One of wxNORMAL, wxLIGHT and wxBOLD. underline The value can be true or false. At present this has an effect on Windows and Motif 2.x only. faceName An optional string specifying the actual typeface to be used. If the empty string, a default typeface will chosen based on the family. encoding An encoding which may be one ofwxFONTENCODING_SYSTEM system encoding. Default

wxFONTENCODING_DEFAULT Default application encoding: this is the encoding set by calls to SetDefaultEncoding (p. 516) and which may be set to, say, KOI8 to create all fonts by default with KOI8 encoding. Initially, the default application encoding is the same as default system encoding. wxFONTENCODING_ISO8859_1...15 ISO8859 encodings. wxFONTENCODING_KOI8 The standard Russian encoding for Internet. wxFONTENCODING_CP1250...1252 Windows encodings similar to ISO8859 (but not identical). If the specified encoding isn't available, no font is created. Remarks If the desired font does not exist, the closest match will be chosen. Under Windows, only scalable TrueType fonts are used. See also wxDC::SetFont (p. 364), wxDC::DrawText (p. 355)and wxDC::GetTextExtent (p. 360).

wxFont::~wxFont
~wxFont() Destructor. Remarks The destructor may not delete the underlying font object of the native windowing system,

513


CHAPTER 7
since wxFont uses a reference counting system for efficiency. Although all remaining fonts are deleted when the application exits, the application should try to clean up all fonts itself. This is because wxWindows cannot know if a pointer to the font object is stored in an application data structure, and there is a risk of double deletion.

wxFont::IsFixedWidth
bool IsFixedWidth() const Returns true if the font is a fixed width (or monospaced) font, false if it is a proportional one or font is invalid.

wxFont::GetDefaultEncoding
static wxFontEncoding GetDefaultEncoding() Returns the current application's default encoding. See also Font encoding overview (p. 1643), SetDefaultEncoding (p. 516)

wxFont::GetFaceName
wxString GetFaceName() const Returns the typeface name associated with the font, or the empty string if there is no typeface information. See also wxFont::SetFaceName (p. 516)

wxFont::GetFamily
int GetFamily() const Gets the font family. See wxFont::wxFont (p. 512) for a list of valid family identifiers. See also wxFont::SetFamily (p. 516)

wxFont::GetNativeFontInfoDesc
wxString GetNativeFontInfoDesc() const

514


CHAPTER 7
Returns the platform-dependent string completely describing this font or an empty string if the font wasn't constructed using the native font description. See also wxFont::SetNativeFontInfo (p. 517)

wxFont::GetPointSize
int GetPointSize() const Gets the point size. See also wxFont::SetPointSize (p. 517)

wxFont::GetStyle
int GetStyle() const Gets the font style. See wxFont::wxFont (p. 512) for a list of valid styles. See also wxFont::SetStyle (p. 517)

wxFont::GetUnderlined
bool GetUnderlined() const Returns true if the font is underlined, false otherwise. See also wxFont::SetUnderlined (p. 518)

wxFont::GetWeight
int GetWeight() const Gets the font weight. See wxFont::wxFont (p. 512) for a list of valid weight identifiers. See also wxFont::SetWeight (p. 518)

wxFont::Ok

515


CHAPTER 7
bool Ok() const Returns true if this object is a valid font, false otherwise.

wxFont::SetDefaultEncoding
static void SetDefaultEncoding(wxFontEncoding encoding) Sets the default font encoding. See also Font encoding overview (p. 1643), GetDefaultEncoding (p. 514)

wxFont::SetFaceName
void SetFaceName(const wxString& faceName) Sets the facename for the font. Parameters faceName A valid facename, which should be on the end-user's system. Remarks To avoid portability problems, don't rely on a specific face, but specify the font family instead or as well. A suitable font will be found on the end-user's system. If both the family and the facename are specified, wxWindows will first search for the specific face, and then for a font belonging to the same family. See also wxFont::GetFaceName (p. 514), wxFont::SetFamily (p. 516)

wxFont::SetFamily
void SetFamily(int family) Sets the font family. Parameters family One of: wxDEFAULT Chooses a default font.

516


CHAPTER 7
wxDECORATIVE wxROMAN wxSCRIPT wxSWISS wxMODERN See also wxFont::GetFamily (p. 514), wxFont::SetFaceName (p. 516) A decorative font. A formal, serif font. A handwriting font. A sans-serif font. A fixed pitch font.

wxFont::SetNativeFontInfo
void SetNativeFontInfo(const wxString& info) Creates the font corresponding to the given native font description string which must have been previously returned by GetNativeFontInfoDesc (p. 514). If the string is invalid, font is unchanged.

wxFont::SetPointSize
void SetPointSize(int pointSize) Sets the point size. Parameters pointSize Size in points. See also wxFont::GetPointSize (p. 515)

wxFont::SetStyle
void SetStyle(int style) Sets the font style. Parameters style One of wxNORMAL, wxSLANT and wxITALIC.

517


CHAPTER 7
See also wxFont::GetStyle (p. 515)

wxFont::SetUnderlined
void SetUnderlined(const bool underlined) Sets underlining. Parameters underlining true to underline, false otherwise. See also wxFont::GetUnderlined (p. 515)

wxFont::SetWeight
void SetWeight(int weight) Sets the font weight. Parameters weight One of wxNORMAL, wxLIGHT and wxBOLD. See also wxFont::GetWeight (p. 515)

wxFont::operator =
wxFont& operator =(const wxFont& font) Assignment operator, using reference counting. Returns a reference to 'this'.

wxFont::operator ==
bool operator ==(const wxFont& font) Equality operator. Two fonts are equal if they contain pointers to the same underlying font data. It does not compare each attribute, so two indefontdently-created fonts using the same parameters will fail the test.

518


CHAPTER 7 wxFont::operator !=
bool operator !=(const wxFont& font) Inequality operator. Two fonts are not equal if they contain pointers to different underlying font data. It does not compare each attribute.

wxFontData
wxFontDialog overview (p. 1649) This class holds a variety of information related to font dialogs. Derived from wxObject (p. 954) Include files <wx/cmndata.h> See also Overview (p. 1649), wxFontDialog (p. 522)

wxFontData::wxFontData
wxFontData() Constructor. Initializes fontColour to black, showHelp to black, allowSymbols to true, enableEffects to true, minSize to 0 and maxSize to 0.

wxFontData::~wxFontData
~wxFontData() Destructor.

wxFontData::EnableEffects
void EnableEffects(bool enable) Enables or disables 'effects' under MS Windows only. This refers to the controls for manipulating colour, strikeout and underline properties. The default value is true.

519


CHAPTER 7 wxFontData::GetAllowSymbols
bool GetAllowSymbols() Under MS Windows, returns a flag determining whether symbol fonts can be selected. Has no effect on other platforms. The default value is true.

wxFontData::GetColour
wxColour& GetColour() Gets the colour associated with the font dialog. The default value is black.

wxFontData::GetChosenFont
wxFont GetChosenFont() Gets the font chosen by the user. If the user pressed OK (wxFontDialog::Show returned true), this returns a new font which is now 'owned' by the application, and should be deleted if not required. If the user pressed Cancel (wxFontDialog::Show returned false) or the colour dialog has not been invoked yet, this will return NULL.

wxFontData::GetEnableEffects
bool GetEnableEffects() Determines whether 'effects' are enabled under Windows. This refers to the controls for manipulating colour, strikeout and underline properties. The default value is true.

wxFontData::GetInitialFont
wxFont GetInitialFont() Gets the font that will be initially used by the font dialog. This should have previously been set by the application.

wxFontData::GetShowHelp
bool GetShowHelp() Returns true if the Help button will be shown (Windows only).

520


CHAPTER 7
The default value is false.

wxFontData::SetAllowSymbols
void SetAllowSymbols(bool allowSymbols) Under MS Windows, determines whether symbol fonts can be selected. Has no effect on other platforms. The default value is true.

wxFontData::SetChosenFont
void SetChosenFont(const wxFont& font) Sets the font that will be returned to the user (for internal use only).

wxFontData::SetColour
void SetColour(const wxColour& colour) Sets the colour that will be used for the font foreground colour. The default colour is black.

wxFontData::SetInitialFont
void SetInitialFont(const wxFont&font) Sets the font that will be initially used by the font dialog.

wxFontData::SetRange
void SetRange(int min, int max) Sets the valid range for the font point size (Windows only). The default is 0, 0 (unrestricted range).

wxFontData::SetShowHelp
void SetShowHelp(bool showHelp) Determines whether the Help button will be displayed in the font dialog (Windows only). The default value is false.

521


CHAPTER 7 wxFontData::operator =
void operator =(const wxFontData& data) Assignment operator for the font data.

wxFontDialog
This class represents the font chooser dialog. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/fontdlg.h> See also Overview (p. 1649), wxFontData (p. 519), wxGetFontFromUser (p. 1492)

wxFontDialog::wxFontDialog
wxFontDialog() wxFontDialog(wxWindow* parent) wxFontDialog(wxWindow* parent, const wxFontData& data) Constructor. Pass a parent window, and optionally the font data (p. 519) object to be used to initialize the dialog controls. If the default constructor is used, Create() (p. 522) must be called before the dialog can be shown.

wxFontDialog::Create
bool Create() bool Create(wxWindow* parent) bool Create(wxWindow* parent, const wxFontData& data) Creates the dialog if it the wxFontDialog object had been initialized using the default

522


CHAPTER 7
constructor. Returns true on success and false if an error occured.

wxFontDialog::~wxFontDialog
~wxFontDialog() Destructor.

wxFontDialog::GetFontData
const wxFontData& GetFontData() const wxFontData& GetFontData() Returns the font data (p. 519) associated with the font dialog.

wxFontDialog::ShowModal
int ShowModal() Shows the dialog, returning wxID_OK if the user pressed Ok, and wxID_CANCEL otherwise. If the user cancels the dialog (ShowModal returns wxID_CANCEL), no font will be created. If the user presses OK, a new wxFont will be created and stored in the font dialog's wxFontData structure.

wxFontEnumerator
wxFontEnumerator enumerates either all available fonts on the system or only the ones with given attributes - either only fixed-width (suited for use in programs such as terminal emulators and the like) or the fonts available in the given encoding (p. 1643). To do this, you just have to call one of EnumerateXXX() functions - either EnumerateFacenames (p. 524) or EnumerateEncodings (p. 524) and the corresponding callback (OnFacename (p. 525) or OnFontEncoding (p. 525)) will be called repeatedly until either all fonts satisfying the specified criteria are exhausted or the callback returns false. Virtual functions to override Either OnFacename (p. 525) or OnFontEncoding (p. 525) should be overridden depending on whether you plan to call EnumerateFacenames (p. 524) or EnumerateEncodings (p. 524). Of course, if you call both of them, you should override both functions. Derived from

523


CHAPTER 7
None Include files <wx/fontenum.h> See also Font encoding overview (p. 1643), Font sample (p. 1565), wxFont (p. 510), wxFontMapper (p. 526)

wxFontEnumerator::EnumerateFacenames
virtual bool EnumerateFacenames( wxFontEncoding encoding = wxFONTENCODING_SYSTEM, bool fixedWidthOnly = false) Call OnFacename (p. 525) for each font which supports given encoding (only if it is not wxFONTENCODING_SYSTEM) and is of fixed width (if fixedWidthOnly is true). Calling this function with default arguments will result in enumerating all fonts available on the system.

wxFontEnumerator::EnumerateEncodings
virtual bool EnumerateEncodings(const wxString& font = "") Call OnFontEncoding (p. 525) for each encoding supported by the given font - or for each encoding supported by at least some font if font is not specified.

wxFontEnumerator::GetEncodings
wxArrayString* GetEncodings() Return array of strings containing all encodings found by EnumerateEncodings (p. 524). This is convenience function. It is based on default implementation of OnFontEncoding (p. 525) so don't expect it to work if you overwrite that method.

wxFontEnumerator::GetFacenames
wxArrayString* GetFacenames() Return array of strings containing all facenames found by EnumerateFacenames (p. 524). This is convenience function. It is based on default implementation of OnFacename (p. 525) so don't expect it to work if you overwrite that method.

524


CHAPTER 7 wxFontEnumerator::OnFacename
virtual bool OnFacename(const wxString& font) Called by EnumerateFacenames (p. 524) for each match. Return true to continue enumeration or false to stop it.

wxFontEnumerator::OnFontEncoding
virtual bool OnFontEncoding( const wxString& font, const wxString& encoding) Called by EnumerateEncodings (p. 524) for each match. Return true to continue enumeration or false to stop it.

wxFontList
A font list is a list containing all fonts which have been created. There is only one instance of this class: wxTheFontList. Use this object to search for a previously created font of the desired type and create it if not already found. In some windowing systems, the font may be a scarce resource, so it is best to reuse old resources if possible. When an application finishes, all fonts will be deleted and their resources freed, eliminating the possibility of 'memory leaks'. Derived from wxList (p. 786) wxObject (p. 954) Include files <wx/gdicmn.h> See also wxFont (p. 510)

wxFontList::wxFontList
wxFontList() Constructor. The application should not construct its own font list: use the object pointer wxTheFontList.

wxFontList::AddFont
void AddFont(wxFont *font)

525


CHAPTER 7
Used by wxWindows to add a font to the list, called in the font constructor.

wxFontList::FindOrCreateFont
wxFont * FindOrCreateFont(int point_size, int family, int style, int weight, bool underline = false, const wxString& facename = NULL, wxFontEncoding encoding = wxFONTENCODING_DEFAULT) Finds a font of the given specification, or creates one and adds it to the list. See the wxFont constructor (p. 512) for details of the arguments.

wxFontList::RemoveFont
void RemoveFont(wxFont *font) Used by wxWindows to remove a font from the list.

wxFontMapper
wxFontMapper manages user-definable correspondence between logical font names and the fonts present on the machine. The default implementations of all functions will ask the user if they are not capable of finding the answer themselves and store the answer in a config file (configurable via SetConfigXXX functions). This behaviour may be disabled by giving the value of false to "interactive" parameter. However, the functions will always consult the config file to allow the user-defined values override the default logic and there is no way to disable this - which shouldn't be ever needed because if "interactive" was never true, the config file is never created anyhow. In case everything else fails (i.e. there is no record in config file and "interactive" is false or user denied to choose any replacement), the class queries wxEncodingConverter (p. 435) for "equivalent" encodings (e.g. iso8859-2 and cp1250) and tries them. Using wxFontMapper in conjunction with wxMBConv classes If you need to display text in encoding which is not available at host system (see IsEncodingAvailable (p. 528)), you may use these two classes to find font in some similar encoding (see GetAltForEncoding (p. 527)) and convert the text to this encoding (wxMBConv classes (p. 1586)). Following code snippet demonstrates it:
if (!wxFontMapper::Get()->IsEncodingAvailable(enc, facename)) { wxFontEncoding alternative; if (wxFontMapper::Get()->GetAltForEncoding(enc, &alternative, facename, false)) { wxCSConv convFrom(wxFontMapper::Get()->GetEncodingName(enc));

526


CHAPTER 7
wxCSConv convTo(wxFontMapper::Get()->GetEncodingName(alternative)); text = wxString(text.mb_str(convFrom), convTo); } else ...failure (or we may try iso8859-1/7bit ASCII)... } ...display text...

Derived from No base class Include files <wx/fontmap.h> See also wxEncodingConverter (p. 435), Writing non-English applications (p. 1590)

wxFontMapper::wxFontMapper
wxFontMapper() Default ctor. Note The preferred way of creating a wxFontMapper instance is to call wxFontMapper::Get (p. 527).

wxFontMapper::~wxFontMapper
~wxFontMapper() Virtual dtor for a base class.

wxFontMapper::Get
static wxFontMapper * Get() Get the current font mapper object. If there is no current object, creates one. See also wxFontMapper::Set (p. 529)

wxFontMapper::GetAltForEncoding

527


CHAPTER 7
bool GetAltForEncoding(wxFontEncoding encoding, wxNativeEncodingInfo* info, const wxString& facename = wxEmptyString, bool interactive = true) bool GetAltForEncoding(wxFontEncoding encoding, wxFontEncoding* alt_encoding, const wxString& facename = wxEmptyString, bool interactive = true) Find an alternative for the given encoding (which is supposed to not be available on this system). If successful, return true and fill info structure with the parameters required to create the font, otherwise return false. The first form is for wxWindows' internal use while the second one is better suitable for general use -- it returns wxFontEncoding which can consequently be passed to wxFont constructor.

wxFontMapper::IsEncodingAvailable
bool IsEncodingAvailable(wxFontEncoding encoding, const wxString& facename = wxEmptyString) Check whether given encoding is available in given face or not. If no facename is given, find any font in this encoding.

wxFontMapper::CharsetToEncoding
wxFontEncoding CharsetToEncoding(const wxString& charset, bool interactive = true) Returns the encoding for the given charset (in the form of RFC 2046) or wxFONTENCODING_SYSTEM if couldn't decode it.

wxFontMapper::GetEncoding
static wxFontEncoding GetEncoding(size_t n) Returns the n-th supported encoding. Together with GetSupportedEncodingsCount() (p. 529) this method may be used to get all supported encodings.

wxFontMapper::GetEncodingName
static wxString GetEncodingName(wxFontEncoding encoding) Return internal string identifier for the encoding (see also GetEncodingDescription() (p. 528))

wxFontMapper::GetEncodingDescription
static wxString GetEncodingDescription(wxFontEncoding encoding)

528


CHAPTER 7
Return user-readable string describing the given encoding.

wxFontMapper::GetSupportedEncodingsCount
static size_t GetSupportedEncodingsCount() Returns the number of the font encodings supported by this class. Together with GetEncoding (p. 528) this method may be used to get all supported encodings.

wxFontMapper::SetDialogParent
void SetDialogParent(wxWindow* parent) The parent window for modal dialogs.

wxFontMapper::SetDialogTitle
void SetDialogTitle(const wxString& title) The title for the dialogs (note that default is quite reasonable).

wxFontMapper::Set
static wxFontMapper * Set(wxFontMapper *mapper) Set the current font mapper object and return previous one (may be NULL). This method is only useful if you want to plug-in an alternative font mapper into wxWindows. See also wxFontMapper::Get (p. 527)

wxFontMapper::SetConfig
void SetConfig(wxConfigBase* config) Set the config object to use (may be NULL to use default). By default, the global one (from wxConfigBase::Get() will be used) and the default root path for the config settings is the string returned by GetDefaultConfigPath().

wxFontMapper::SetConfigPath
void SetConfigPath(const wxString& prefix) Set the root config path to use (should be an absolute path).

529


CHAPTER 7

wxFrame
A frame is a window whose size and position can (usually) be changed by the user. It usually has thick borders and a title bar, and can optionally contain a menu bar, toolbar and status bar. A frame can contain any window that is not a frame or dialog. A frame that has a status bar and toolbar created via the CreateStatusBar/CreateToolBar functions manages these windows, and adjusts the value returned by GetClientSize to reflect the remaining size available to application windows. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/frame.h> Window styles wxDEFAULT_FRAME_STYLE Defined as wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxRESIZE_BORDER | wxSYSTEM_MENU | wxCAPTION | wxCLOSE_BOX. wxICONIZE wxCAPTION wxMINIMIZE wxMINIMIZE_BOX wxMAXIMIZE wxMAXIMIZE_BOX wxCLOSE_BOX wxSTAY_ON_TOP wxSYSTEM_MENU wxRESIZE_BORDER Display the frame iconized (minimized). Windows only. Puts a caption on the frame. Identical to wxICONIZE. Windows only. Displays a minimize box on the frame. Displays the frame maximized. Windows only. Displays a maximize box on the frame. Displays a close box on the frame. Stay on top of all other windows, see also wxFRAME_FLOAT_ON_PARENT. Windows only. Displays a system menu. Displays a resizeable border around the window.

wxFRAME_TOOL_WINDOW Causes a frame with a small titlebar to be created; the frame does not appear in the taskbar under Windows. wxFRAME_NO_TASKBAR Creates an otherwise normal frame but it does not appear in the taskbar under Windows (note that it will minimize to the desktop window which may seem strange to the users

530


CHAPTER 7
and thus it might be better to use this style only without wxMINIMIZE_BOX style). Has no effect under other platforms. wxFRAME_FLOAT_ON_PARENT The frame will always be on top of its parent (unlike wxSTAY_ON_TOP). A frame created with this style must have a non-NULL parent. wxFRAME_EX_CONTEXTHELP Under Windows, puts a query button on the caption. When pressed, Windows will go into a contextsensitive help mode and wxWindows will send a wxEVT_HELP event if the user clicked on an application window. Note that this is an extended style and must be set by calling SetExtraStyle (p. 1423) before Create is called (two-step construction). You cannot use this style together with wxMAXIMIZE_BOX or wxMINIMIZE_BOX, so you should use wxDEFAULT_FRAME_STYLE & ~(wxMINIMIZE_BOX | wxMAXIMIZE_BOX) for the frames having this style (the dialogs don't have a minimize or a maximize box by default) wxFRAME_SHAPED Windows with this style are allowed to have their shape changed with the SetShape (p. 540) method.

The default frame style is for normal, resizeable frames. To create a frame which can not be resized by user, you may use the following combination of styles: wxDEFAULT_FRAME_STYLE & ~(wxRESIZE_BORDER | wxRESIZE_BOX | wxMAXIMIZE_BOX). See also window styles overview (p. 1611). Default event processing wxFrame processes the following events: wxEVT_SIZE (p. 1108) If the frame has exactly one child window, not counting the status and toolbar, this child is resized to take the entire frame client area. If two or more windows are present, they should be laid out explicitly either by manually handling wxEVT_SIZE or usingsizers (p. 1620)

The default implementation displays the wxEVT_MENU_HIGHLIGHT (p. 907) help string (p. 911) associated with the selected item in the first pane of the status bar, if there is one. Remarks An application should normally define an wxCloseEvent (p. 139) handler for the frame to respond to system close events, for example so that related data and subwindows can be cleaned up. See also wxMDIParentFrame (p. 874), wxMDIChildFrame (p. 869), wxMiniFrame (p. 922), wxDialog (p. 367)

531


CHAPTER 7

wxFrame::wxFrame
wxFrame() Default constructor. wxFrame(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor, creating the window. Parameters parent The window parent. This may be NULL. If it is non-NULL, the frame will always be displayed on top of the parent window on Windows. id The window identifier. It may take a value of -1 to indicate a default value. title The caption to be displayed on the frame's title bar. pos The window position. A value of (-1, -1) indicates a default position, chosen by either the windowing system or wxWindows, depending on platform. size The window size. A value of (-1, -1) indicates a default size, chosen by either the windowing system or wxWindows, depending on platform. style The window style. See wxFrame (p. 530). name The name of the window. This parameter is used to associate a name with the item, allowing the application user to set Motif resource values for individual windows. Remarks For Motif, MWM (the Motif Window Manager) should be running for any window styles to work (otherwise all styles take effect).

532


CHAPTER 7
See also wxFrame::Create (p. 533)

wxFrame::~wxFrame
void ~wxFrame() Destructor. Destroys all child windows and menu bar if present.

wxFrame::Centre
void Centre(int direction = wxBOTH) Centres the frame on the display. Parameters direction The parameter may be wxHORIZONTAL, wxVERTICAL or wxBOTH.

wxFrame::Command
void Command(int id) Simulate a menu command. Parameters id The identifier for a menu item.

wxFrame::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Used in two-step frame construction. See wxFrame::wxFrame (p. 532) for further details.

wxFrame::CreateStatusBar
virtual wxStatusBar* CreateStatusBar(int number = 1, long style = 0, wxWindowID id = -1, const wxString& name = "statusBar") Creates a status bar at the bottom of the frame.

533


CHAPTER 7
Parameters number The number of fields to create. Specify a value greater than 1 to create a multi-field status bar. style The status bar style. See wxStatusBar (p. 1185) for a list of valid styles. id The status bar window identifier. If -1, an identifier will be chosen by wxWindows. name The status bar window name. Return value A pointer to the the status bar if it was created successfully, NULL otherwise. Remarks The width of the status bar is the whole width of the frame (adjusted automatically when resizing), and the height and text size are chosen by the host windowing system. By default, the status bar is an instance of wxStatusBar. To use a different class, override wxFrame::OnCreateStatusBar (p. 537). Note that you can put controls and other windows on the status bar if you wish. See also wxFrame::SetStatusText (p. 541), wxFrame::OnCreateStatusBar (p. 537), wxFrame::GetStatusBar (p. 535)

wxFrame::CreateToolBar
virtual wxToolBar* CreateToolBar(long style = wxNO_BORDER | wxTB_HORIZONTAL, wxWindowID id = -1, const wxString& name = "toolBar") Creates a toolbar at the top or left of the frame. Parameters style The toolbar style. See wxToolBar (p. 1309) for a list of valid styles. id The toolbar window identifier. If -1, an identifier will be chosen by wxWindows.

534


CHAPTER 7
name The toolbar window name. Return value A pointer to the the toolbar if it was created successfully, NULL otherwise. Remarks By default, the toolbar is an instance of wxToolBar (which is defined to be a suitable toolbar class on each platform, such as wxToolBar95). To use a different class, override wxFrame::OnCreateToolBar (p. 538). When a toolbar has been created with this function, or made known to the frame with wxFrame::SetToolBar (p. 542), the frame will manage the toolbar position and adjust the return value from wxWindow::GetClientSize (p. 1401) to reflect the available space for application windows. See also wxFrame::CreateStatusBar (p. 533), wxFrame::OnCreateToolBar (p. 538), wxFrame::SetToolBar (p. 542), wxFrame::GetToolBar (p. 536)

wxFrame::GetClientAreaOrigin
wxPoint GetClientAreaOrigin() const Returns the origin of the frame client area (in client coordinates). It may be different from (0, 0) if the frame has a toolbar.

wxFrame::GetMenuBar
wxMenuBar* GetMenuBar() const Returns a pointer to the menubar currently associated with the frame (if any). See also wxFrame::SetMenuBar (p. 539), wxMenuBar (p. 898), wxMenu (p. 885)

wxFrame::GetStatusBar
wxStatusBar* GetStatusBar() const Returns a pointer to the status bar currently associated with the frame (if any). See also wxFrame::CreateStatusBar (p. 533), wxStatusBar (p. 1185)

535


CHAPTER 7 wxFrame::GetStatusBarPane
int GetStatusBarPane() Returns the status bar pane used to display menu and toolbar help. See also wxFrame::SetStatusBarPane (p. 540)

wxFrame::GetTitle
wxString GetTitle() const Gets a string containing the frame title. See wxFrame::SetTitle (p. 542).

wxFrame::GetToolBar
wxToolBar* GetToolBar() const Returns a pointer to the toolbar currently associated with the frame (if any). See also wxFrame::CreateToolBar (p. 534), wxToolBar (p. 1309), wxFrame::SetToolBar (p. 542)

wxFrame::Iconize
void Iconize(bool iconize) Iconizes or restores the frame. Parameters iconize If true, iconizes the frame; if false, shows and restores it. See also wxFrame::IsIconized (p. 537), wxFrame::Maximize (p. 537).

wxFrame::IsFullScreen
bool IsFullScreen() Returns true if the frame is in fullscreen mode. See also

536


CHAPTER 7
wxFrame::ShowFullScreen (p. 542)

wxFrame::IsIconized
bool IsIconized() const Returns true if the frame is iconized.

wxFrame::IsMaximized
bool IsMaximized() const Returns true if the frame is maximized.

wxFrame::Maximize
void Maximize(bool maximize) Maximizes or restores the frame. Parameters maximize If true, maximizes the frame, otherwise it restores it. Remarks This function only works under Windows. See also wxFrame::Iconize (p. 536)

wxFrame::OnCreateStatusBar
virtual wxStatusBar* OnCreateStatusBar(int number, long style, wxWindowID id, const wxString& name) Virtual function called when a status bar is requested by wxFrame::CreateStatusBar (p. 533). Parameters number The number of fields to create. style

537


CHAPTER 7
The window style. See wxStatusBar (p. 1185) for a list of valid styles. id The window identifier. If -1, an identifier will be chosen by wxWindows. name The window name. Return value A status bar object. Remarks An application can override this function to return a different kind of status bar. The default implementation returns an instance of wxStatusBar (p. 1185). See also wxFrame::CreateStatusBar (p. 533), wxStatusBar (p. 1185).

wxFrame::OnCreateToolBar
virtual wxToolBar* OnCreateToolBar(long style, wxWindowID id, const wxString& name) Virtual function called when a toolbar is requested by wxFrame::CreateToolBar (p. 534). Parameters style The toolbar style. See wxToolBar (p. 1309) for a list of valid styles. id The toolbar window identifier. If -1, an identifier will be chosen by wxWindows. name The toolbar window name. Return value A toolbar object. Remarks An application can override this function to return a different kind of toolbar. The default implementation returns an instance of wxToolBar (p. 1309). See also

538


CHAPTER 7
wxFrame::CreateToolBar (p. 534), wxToolBar (p. 1309).

wxFrame::SendSizeEvent
void SendSizeEvent() This function sends a dummy size event (p. 1108) to the frame forcing it to reevaluate its children positions. It is sometimes useful to call this function after adding or deleting a children after the frame creation or if a child size changes. Note that if the frame is using either sizers or constraints for the children layout, it is enough to call Layout() (p. 1410) directly and this function should not be used in this case.

wxFrame::SetIcon
void SetIcon(const wxIcon& icon) Sets the icon for this frame. Parameters icon The icon to associate with this frame. Remarks The frame takes a 'copy' of icon, but since it uses reference counting, the copy is very quick. It is safe to delete icon after calling this function. See also wxIcon (p. 716).

wxFrame::SetIcons
void SetIcons(const wxIconBundle& icons) Sets the icons for this frame. Parameters icons The icons to associate with this frame. See also wxIconBundle (p. 723).

wxFrame::SetMenuBar

539


CHAPTER 7
void SetMenuBar(wxMenuBar* menuBar) Tells the frame to show the given menu bar. Parameters menuBar The menu bar to associate with the frame. Remarks If the frame is destroyed, the menu bar and its menus will be destroyed also, so do not delete the menu bar explicitly (except by resetting the frame's menu bar to another frame or NULL). Under Windows, a size event is generated, so be sure to initialize data members properly before calling SetMenuBar. Note that on some platforms, it is not possible to call this function twice for the same frame object. See also wxFrame::GetMenuBar (p. 535), wxMenuBar (p. 898), wxMenu (p. 885).

wxFrame::SetShape
bool SetShape(const wxRegion& region) If the platform supports it, sets the shape of the window to that depicted by region. The system will not display or respond to any mouse event for the pixels that lie outside of the region. To reset the window to the normal rectangular shape simply call SetShape again with an empty region. Returns TRUE if the operation is successful.

wxFrame::SetStatusBar
void SetStatusBar(wxStatusBar* statusBar) Associates a status bar with the frame. See also wxFrame::CreateStatusBar (p. 533), wxStatusBar (p. 1185), wxFrame::GetStatusBar (p. 535)

wxFrame::SetStatusBarPane
void SetStatusBarPane(int n) Set the status bar pane used to display menu and toolbar help. Using -1 disables help

540


CHAPTER 7
display.

wxFrame::SetStatusText
virtual void SetStatusText(const wxString& text, int number = 0) Sets the status bar text and redraws the status bar. Parameters text The text for the status field. number The status field (starting from zero). Remarks Use an empty string to clear the status bar. See also wxFrame::CreateStatusBar (p. 533), wxStatusBar (p. 1185)

wxFrame::SetStatusWidths
virtual void SetStatusWidths(int n, int *widths) Sets the widths of the fields in the status bar. Parameters nThe number of fields in the status bar. It must be the same used in CreateStatusBar (p. 533). widths Must contain an array of n integers, each of which is a status field width in pixels. A value of -1 indicates that the field is variable width; at least one field must be -1. You should delete this array after calling SetStatusWidths. Remarks The widths of the variable fields are calculated from the total width of all fields, minus the sum of widths of the non-variable fields, divided by the number of variable fields. wxPython note: Only a single parameter is required, a Python list of integers. wxPerl note: In wxPerl this method takes the field widths as parameters.

541


CHAPTER 7 wxFrame::SetToolBar
void SetToolBar(wxToolBar* toolBar) Associates a toolbar with the frame. See also wxFrame::CreateToolBar (p. 534), wxToolBar (p. 1309), wxFrame::GetToolBar (p. 536)

wxFrame::SetTitle
virtual void SetTitle(const wxString& title) Sets the frame title. Parameters title The frame title. See also wxFrame::GetTitle (p. 536)

wxFrame::ShowFullScreen
bool ShowFullScreen(bool show, long style = wxFULLSCREEN_ALL) Depending on the value of show parameter the frame is either shown full screen or restored to its normal state. style is a bit list containing some or all of the following values, which indicate what elements of the frame to hide in full-screen mode:       wxFULLSCREEN_NOMENUBAR wxFULLSCREEN_NOTOOLBAR wxFULLSCREEN_NOSTATUSBAR wxFULLSCREEN_NOBORDER wxFULLSCREEN_NOCAPTION wxFULLSCREEN_ALL (all of the above)

This function has not been tested with MDI frames. Note that showing a frame full screen also actuallyShow()s (p. 1432) if it hadn't been shown yet. See also

542


CHAPTER 7
wxFrame::IsFullScreen (p. 536)

wxFSFile
This class represents a single file opened by wxFileSystem (p. 492). It provides more information than wxWindow's input stream (stream, filename, mime type, anchor). Note: Any pointer returned by a method of wxFSFile is valid only as long as the wxFSFile object exists. For example a call to GetStream() doesn't create the stream but only returns the pointer to it. In other words after 10 calls to GetStream() you will obtain ten identical pointers. Derived from wxObject (p. 954) Include files <wx/filesys.h> See Also wxFileSystemHandler (p. 494), wxFileSystem (p. 492), Overview (p. 1601)

wxFSFile::wxFSFile
wxFSFile(wxInputStream *stream, const wxString& loc, const wxString& mimetype, const wxString& anchor) Constructor. You probably won't use it. See Notes for details. Parameters stream The input stream that will be used to access data location The full location (aka filename) of the file mimetype MIME type of this file. Mime type is either extension-based or HTTP Content-Type anchor Anchor. See GetAnchor() (p. 544) for details. If you are not sure of the meaning of these params, see the description of the

543


CHAPTER 7
GetXXXX() functions. Notes It is seldom used by the application programmer but you will need it if you are writing your own virtual FS. For example you may need something similar to wxMemoryInputStream, but because wxMemoryInputStream doesn't free the memory when destroyed and thus passing a memory stream pointer into wxFSFile constructor would lead to memory leaks, you can write your own class derived from wxFSFile:
class wxMyFSFile : public wxFSFile { private: void *m_Mem; public: wxMyFSFile(.....) ~wxMyFSFile() {free(m_Mem);} // of course dtor is virtual ;-) };

wxFSFile::GetAnchor
const wxString& GetAnchor() const Returns anchor (if present). The term of anchor can be easily explained using few examples:
index.htm#anchor index/wx001.htm archive/main.zip#zip:index.htm#global archive/main.zip#zip:index.htm /* /* /* /* 'anchor' is anchor NO anchor here! 'global' NO anchor here! */ */ */ */

Usually an anchor is presented only if the MIME type is 'text/html'. But it may have some meaning with other files; for example myanim.avi#200 may refer to position in animation or reality.wrl#MyView may refer to a predefined view in VRML.

wxFSFile::GetLocation
const wxString& GetLocation() const Returns full location of the file, including path and protocol. Examples :
http://www.wxwindows.org http://www.ms.mff.cuni.cz/~vsla8348/wxhtml/archive.zip#zip:info.txt file:/home/vasek/index.htm relative-file.htm

wxFSFile::GetMimeType
const wxString& GetMimeType() const Returns the MIME type of the content of this file. It is either extension-based (see wxMimeTypesManager) or extracted from HTTP protocol Content-Type header.

544


CHAPTER 7 wxFSFile::GetModificationTime
wxDateTime GetModificationTime() const Returns time when this file was modified.

wxFSFile::GetStream
wxInputStream* GetStream() const Returns pointer to the stream. You can use the returned stream to directly access data. You may suppose that the stream provide Seek and GetSize functionality (even in the case of the HTTP protocol which doesn't provide this by default. wxHtml uses local cache to work around this and to speed up the connection).

wxFTP
wxFTP can be used to establish a connection to an FTP server and perform all the usual operations. Please consult the RFC 959 for more details about the FTP protocol. To use a commands which doesn't involve file transfer (i.e. directory oriented commands) you just need to call a corresponding member function or use the generic SendCommand (p. 547) method. However to actually transfer files you just get or give a stream to or from this class and the actual data are read or written using the usual stream methods. Example of using wxFTP for file downloading:
wxFTP ftp; // if you don't use these lines anonymous login will be used ftp.SetUser("user"); ftp.SetPassword("password"); if ( !ftp.Connect("ftp.wxwindows.org") ) { wxLogError("Couldn't connect"); return; } ftp.ChDir("/pub"); wxInputStream *in = ftp.GetInputStream("wxWindows-4.2.0.tar.gz"); if ( !in ) { wxLogError("Coudln't get file"); } else { size_t size = in->GetSize(); char *data = new char[size]; if ( !in->Read(data, size) ) { wxLogError("Read error"); } else { // file data is in the buffer ...

545


CHAPTER 7
} delete [] data; delete in; }

To upload a file you would do (assuming the connection to the server was opened successfully):
wxOutputStream *out = ftp.GetOutputStream("filename"); if ( out ) { out->Write(...); // your data delete out; }

Constants wxFTP defines constants corresponding to the two supported transfer modes:
enum TransferMode { ASCII, BINARY };

Derived from wxProtocol (p. 1027) Include files <wx/protocol/ftp.h> See also wxSocketBase (p. 1131)

wxFTP::wxFTP
wxFTP() Default constructor.

wxFTP::~wxFTP
~wxFTP() Destructor will close the connection if connected.

wxFTP::Abort

546


CHAPTER 7
bool Abort() Aborts the download currently in process, returns true if ok, false if an error occured.

wxFTP::CheckCommand
bool CheckCommand(const wxString& command, char ret) Send the specified command to the FTP server. ret specifies the expected result. Return value true if the command has been sent successfully, else false.

wxFTP::SendCommand
char SendCommand(const wxString& command) Send the specified command to the FTP server and return the first character of the return code.

wxFTP::GetLastResult
const wxString& GetLastResult() Returns the last command result, i.e. the full server reply for the last command.

wxFTP::ChDir
bool ChDir(const wxString& dir) Change the current FTP working directory. Returns true if successful.

wxFTP::MkDir
bool MkDir(const wxString& dir) Create the specified directory in the current FTP working directory. Returns true if successful.

wxFTP::RmDir
bool RmDir(const wxString& dir) Remove the specified directory from the current FTP working directory. Returns true if successful.

547


CHAPTER 7 wxFTP::Pwd
wxString Pwd() Returns the current FTP working directory.

wxFTP::Rename
bool Rename(const wxString& src, const wxString& dst) Rename the specified src element to dst. Returns true if successful.

wxFTP::RmFile
bool RmFile(const wxString& path) Delete the file specified by path. Returns true if successful.

wxFTP::SetAscii
bool SetAscii() Sets the transfer mode to ASCII. It will be used for the next transfer.

wxFTP::SetBinary
bool SetBinary() Sets the transfer mode to binary (IMAGE). It will be used for the next transfer.

wxFTP::SetTransferMode
bool SetTransferMode(TransferMode mode) Sets the transfer mode to the specified one. It will be used for the next transfer. If this function is never called, binary transfer mode is used by default.

wxFTP::SetUser
void SetUser(const wxString& user) Sets the user name to be sent to the FTP server to be allowed to log in. Default value

548


CHAPTER 7
The default value of the user name is "anonymous". Remark This parameter can be included in a URL if you want to use the URL manager. For example, you can use: "ftp://a_user:a_password@a.host:service/a_directory/a_file" to specify a user and a password.

wxFTP::SetPassword
void SetPassword(const wxString& passwd) Sets the password to be sent to the FTP server to be allowed to log in. Default value The default value of the user name is your email address. For example, it could be "username@userhost.domain". This password is built by getting the current user name and the host name of the local machine from the system. Remark This parameter can be included in a URL if you want to use the URL manager. For example, you can use: "ftp://a_user:a_password@a.host:service/a_directory/a_file" to specify a user and a password.

wxFTP::FileExists
bool FileExists(const wxString& filename) Returns true if the given remote file exists, false otherwise.

wxFTP::GetFileSize
int GetFileSize(const wxString& filename) Returns the file size in bytes or -1 if the file doesn't exist or the size couldn't be determined. Notice that this size can be approximative size only and shouldn't be used for allocating the buffer in which the remote file is copied, for example.

wxFTP::GetDirList
bool GetDirList(wxArrayString& files, const wxString& wildcard = "") The GetList function is quite low-level. It returns the list of the files in the current directory. The list can be filtered using the wildcard string. If wildcard is empty (default), it will return all files in directory. The form of the list can change from one peer system to another. For example, for a

549


CHAPTER 7
UNIX peer system, it will look like this:
-r--r--r--r--r--r--rw-rw-rw-rw-rw-rw-r--r--r--r--r--r-1 1 1 1 1 1 guilhem guilhem guilhem guilhem guilhem guilhem lavaux lavaux lavaux lavaux lavaux lavaux 12738 10866 29967 14342 13890 3989 Jan Jan Dec Jan Jan Feb 16 24 21 22 29 8 20:17 16:41 19:17 19:51 19:18 19:18 cmndata.cpp config.cpp cwlex_yy.c cwy_tab.c date.cpp datstrm.cpp

But on Windows system, it will look like this:
winamp~1 exe 520196 02-25-1999 19:28 winamp204.exe 1 file(s) 520 196 bytes

Return value: true if the file list was successfully retrieved, false otherwise. See also GetFilesList (p. 550)

wxFTP::GetFilesList
bool GetFilesList(wxArrayString& files, const wxString& wildcard = "") This function returns the computer-parsable list of the files in the current directory (optionally only of the files matching the wildcard, all files by default). This list always has the same format and contains one full (including the directory path) file name per line. Return value: true if the file list was successfully retrieved, false otherwise.

wxFTP::GetOutputStream
wxOutputStream * GetOutputStream(const wxString& file) Initializes an output stream to the specified file. The returned stream has all but the seek functionality of wxStreams. When the user finishes writing data, he has to delete the stream to close it. Return value An initialized write-only stream. See also wxOutputStream (p. 958)

wxFTP::GetInputStream
wxInputStream * GetInputStream(const wxString& path) Creates a new input stream on the the specified path. You can use all but the seek functionality of wxStream. Seek isn't available on all streams. For example, http or ftp

550


CHAPTER 7
streams do not deal with it. Other functions like Tell are not available for this sort of stream, at present. You will be notified when the EOF is reached by an error. Return value Returns NULL if an error occurred (it could be a network failure or the fact that the file doesn't exist). Returns the initialized stream. You will have to delete it yourself when you don't need it anymore. The destructor closes the DATA stream connection but will leave the COMMAND stream connection opened. It means that you can still send new commands without reconnecting. Example of a standalone connection (without wxURL)
wxFTP ftp; wxInputStream *in_stream; char *data; ftp.Connect("a.host.domain"); ftp.ChDir("a_directory"); in_stream = ftp.GetInputStream("a_file_to_get"); data = new char[in_stream->GetSize()]; in_stream->Read(data, in_stream->GetSize()); if (in_stream >LastError() != wxStream_NOERROR) { // Do something. } delete in_stream; /* Close the DATA connection */ ftp.Close(); /* Close the COMMAND connection */

See also wxInputStream (p. 762)

wxGauge
A gauge is a horizontal or vertical bar which shows a quantity (often time). There are no user commands for the gauge. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/gauge.h> Window styles wxGA_HORIZONTAL Creates a horizontal gauge.

551


CHAPTER 7
wxGA_VERTICAL wxGA_SMOOTH Creates a vertical gauge. Creates smooth progress bar with one pixel wide update step (not supported by all platforms).

See also window styles overview (p. 1611). Event handling wxGauge is read-only so generates no events. See also wxSlider (p. 1121), wxScrollBar (p. 1079)

wxGauge::wxGauge
wxGauge() Default constructor. wxGauge(wxWindow* parent, wxWindowID id, int range, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxGA_HORIZONTAL, const wxValidator& validator = wxDefaultValidator, const wxString& name = "gauge") Constructor, creating and showing a gauge. Parameters parent Window parent. id Window identifier. range Integer range (maximum value) of the gauge. pos Window position. size Window size. style

552


CHAPTER 7
Gauge style. See wxGauge (p. 551). name Window name. See also wxGauge::Create (p. 553)

wxGauge::~wxGauge
~wxGauge() Destructor, destroying the gauge.

wxGauge::Create
bool Create(wxWindow* parent, wxWindowID id, int range, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxGA_HORIZONTAL, const wxValidator& validator = wxDefaultValidator, const wxString& name = "gauge") Creates the gauge for two-step construction. See wxGauge::wxGauge (p. 552) for further details.

wxGauge::GetBezelFace
int GetBezelFace() const Returns the width of the 3D bezel face. Remarks This method is not implemented (returns 0) for most platforms. See also wxGauge::SetBezelFace (p. 554)

wxGauge::GetRange
int GetRange() const Returns the maximum position of the gauge. Remarks This method is not implemented (doesn't do anything) for most platforms.

553


CHAPTER 7
See also wxGauge::SetRange (p. 555)

wxGauge::GetShadowWidth
int GetShadowWidth() const Returns the 3D shadow margin width. Remarks This method is not implemented (returns 0) for most platforms. See also wxGauge::SetShadowWidth (p. 555)

wxGauge::GetValue
int GetValue() const Returns the current position of the gauge. See also wxGauge::SetValue (p. 555)

wxGauge::IsVertical
bool IsVertical() const Returns true if the gauge is vertical (has wxGA_VERTICAL style) and false otherwise.

wxGauge::SetBezelFace
void SetBezelFace(int width) Sets the 3D bezel face width. Remarks This method is not implemented (doesn't do anything) for most platforms. See also wxGauge::GetBezelFace (p. 553)

554


CHAPTER 7 wxGauge::SetRange
void SetRange(int range) Sets the range (maximum value) of the gauge. See also wxGauge::GetRange (p. 553)

wxGauge::SetShadowWidth
void SetShadowWidth(int width) Sets the 3D shadow width. Remarks This method is not implemented (doesn't do anything) for most platforms.

wxGauge::SetValue
void SetValue(int pos) Sets the position of the gauge. Parameters pos Position for the gauge level. See also wxGauge::GetValue (p. 554)

wxGBPosition
This class represents the position of an item in a virtual grid of rows and columns managed by a wxGridBagSizer (p. 609). Derived from No base class Include files <wx/gbsizer.h>

555


CHAPTER 7 wxGBPosition::wxGBPosition
wxGBPosition() wxGBPosition(int row, int col) Construct a new wxGBPosition, optionally setting the row and column. The default is (0,0).

wxGBPosition::GetCol
int GetCol() const Get the current column value.

wxGBPosition::GetRow
int GetRow() const Get the current row value.

wxGBPosition::SetCol
void SetCol(int col) Set a new column value.

wxGBPosition::SetRow
void SetRow(int row) Set a new row value.

wxGBPosition::operator!
bool operator!(const wxGBPosition& p) const Is the wxGBPosition valid? (An invalid wxGBPosition is (-1,-1). )

wxGBPosition::operator==
bool operator operator==(const wxGBPosition& p) const Compare equality of two wxGBPositions.

556


CHAPTER 7

wxGBSizerItem
The wxGBSizerItem class is used by the wxGridBagSizer (p. 609) for tracking the items in the sizer. It adds grid position and spanning information to the normal wxSizerItem (p. 1116) by addingwxGBPosition (p. 555) and wxGBSpan (p. 558)attrbibutes. Most of the time you will not need to use a wxGBSizerItem directly in your code, but there are a couple of cases where it is handy. Derived from wxSizerItem (p. 1116) Include files <wx/gbsizer.h>

wxGBSizerItem::wxGBSizerItem
wxGBSizerItem(int width, int height, const wxGBPosition& pos, const wxGBSpan& span, int flag, int border, wxObject* userData) Construct a sizer item for tracking a spacer. wxGBSizerItem(wxWindow* window, const wxGBPosition& pos, const wxGBSpan& span, int flag, int border, wxObject* userData) Construct a sizer item for tracking a window. wxGBSizerItem(wxSizer* sizer, const wxGBPosition& pos, const wxGBSpan& span, int flag, int border, wxObject* userData) Construct a sizer item for tracking a subsizer.

wxGBSizerItem::GetEndPos
void GetEndPos(int& row, int& col) Get the row and column of the endpoint of this item

wxGBSizerItem::GetPos
wxGBPosition GetPos() const void GetPos(int& row, int& col) const Get the grid position of the item.

557


CHAPTER 7 wxGBSizerItem::GetSpan
wxGBSpan GetSpan() const void GetSpan(int& rowspan, int& colspan) const Get the row and column spanning of the item.

wxGBSizerItem::Intersects
bool Intersects(const wxGBSizerItem& other) Returns true if this item and the other item instersect bool Intersects(const wxGBPosition& pos, const wxGBSpan& span) Returns true if the given pos/span would intersect with this item.

wxGBSizerItem::SetPos
bool SetPos(const wxGBPosition& pos) If the item is already a member of a sizer then first ensure that there is no other item that would intersect with this one at the new position, then set the new position. Returns true if the change is successful and after the next Layout the item will be moved.

wxGBSizerItem::SetSpan
bool SetSpan(const wxGBSpan& span) If the item is already a member of a sizer then first ensure that there is no other item that would intersect with this one with its new spanning size, then set the new spanning. Returns true if the change is successful and after the next Layout the item will be resized.

wxGBSpan
This class is used to hold the row and column spanning attributes of items in a wxGridBagSizer (p. 609). Derived from No base class Include files <wx/gbsizer.h>

558


CHAPTER 7 wxGBSpan::wxGBSpan
wxGBSpan() wxGBSpan(int rowspan, int colspan) Construct a new wxGBSpan, optionally setting the rowspan and colspan. The default is (1,1). (Meaning that the item occupies one cell in each direction.

wxGBSpan::GetColspan
int GetColspan() const Get the current colspan value.

wxGBSpan::GetRowspan
int GetRowspan() const Get the current rowspan value.

wxGBSpan::SetColspan
void SetColspan(int colspan) Set a new colspan value.

wxGBSpan::SetRowspan
void SetRowspan(int rowspan) Set a new rowspan value.

wxGBSpan::operator!
bool operator!(const wxGBSpan& o) const Is the wxGBSpan valid? (An invalid wxGBPosition is (-1,-1). )

wxGBSpan::operator==
bool operator operator==(const wxGBSpan& o) const Compare equality of two wxGBSpans.

559


CHAPTER 7

wxGDIObject
This class allows platforms to implement functionality to optimise GDI objects, such as wxPen, wxBrush and wxFont. On Windows, the underling GDI objects are a scarce resource and are cleaned up when a usage count goes to zero. On some platforms this class may not have any special functionality. Since the functionality of this class is platform-specific, it is not documented here in detail. Derived from wxObject (p. 954) Include files <wx/gdiobj.h> See also wxPen (p. 976), wxBrush (p. 90), wxFont (p. 510)

wxGDIObject::wxGDIObject
wxGDIObject() Default constructor.

wxGenericDirCtrl
This control can be used to place a directory listing (with optional files) on an arbitrary window. The control contains a wxTreeCtrl (p. 1327) window representing the directory hierarchy, and optionally, a wxChoice (p. 127) window containing a list of filters. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/dirctrl.h> Window styles

560


CHAPTER 7
wxDIRCTRL_DIR_ONLY Only show directories, and not files.

wxDIRCTRL_3D_INTERNAL Use 3D borders for internal controls. wxDIRCTRL_SELECT_FIRST When setting the default path, select the first file in the directory. wxDIRCTRL_SHOW_FILTERS Show the drop-down filter list.

wxDIRCTRL_EDIT_LABELS Allow the folder and file labels to be editable. See also Generic window styles (p. 1611). Data structures

wxGenericDirCtrl::wxGenericDirCtrl
wxGenericDirCtrl() Default constructor. wxGenericDirCtrl(wxWindow* parent, const wxWindowID id = -1, const wxString& dir = wxDirDialogDefaultFolderStr, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDIRCTRL_3D_INTERNAL|wxSUNKEN_BORDER, const wxString& filter = wxEmptyString, int defaultFilter = 0, const wxString& name = wxTreeCtrlNameStr) Main constructor. Parameters parent Parent window. id Window identifier. dir Initial folder. pos Position. size Size. style

561


CHAPTER 7
Window style. Please see wxGenericDirCtrl (p. 560) for a list of possible styles. filter A filter string, using the same syntax as that for wxFileDialog (p. 466). This may be empty if filters are not being used. Example: "All files (*.*)|*.*|JPEG files (*.jpg)|*.jpg" defaultFilter The zero-indexed default filter setting. name The window name.

wxGenericDirCtrl::~wxGenericDirCtrl
~wxGenericDirCtrl() Destructor.

wxGenericDirCtrl::Create
bool Create(wxWindow* parent, const wxWindowID id = -1, const wxString& dir = wxDirDialogDefaultFolderStr, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDIRCTRL_3D_INTERNAL|wxSUNKEN_BORDER, const wxString& filter = wxEmptyString, int defaultFilter = 0, const wxString& name = wxTreeCtrlNameStr) Create function for two-step construction. See wxGenericDirCtrl::wxGenericDirCtrl (p. 561) for details.

wxGenericDirCtrl::Init
void Init() Initializes variables.

wxGenericDirCtrl::ExpandPath
bool ExpandPath(const wxString& path) Tries to expand as much of the given path as possible, so that the filename or directory is visible in the tree control.

wxGenericDirCtrl::GetDefaultPath 562


CHAPTER 7
wxString GetDefaultPath() const Gets the default path.

wxGenericDirCtrl::GetPath
wxString GetPath() const Gets the currently-selected directory or filename.

wxGenericDirCtrl::GetFilePath
wxString GetFilePath() const Gets selected filename path only (else empty string). This function doesn't count a directory as a selection.

wxGenericDirCtrl::GetFilter
wxString GetFilter() const Returns the filter string.

wxGenericDirCtrl::GetFilterIndex
int GetFilterIndex() const Returns the current filter index (zero-based).

wxGenericDirCtrl::GetFilterListCtrl
wxDirFilterListCtrl* GetFilterListCtrl() const Returns a pointer to the filter list control (if present).

wxGenericDirCtrl::GetRootId
wxTreeItemId GetRootId() Returns the root id for the tree control.

wxGenericDirCtrl::GetTreeCtrl
wxTreeCtrl* GetTreeCtrl() const

563


CHAPTER 7
Returns a pointer to the tree control.

wxGenericDirCtrl::SetDefaultPath
void SetDefaultPath(const wxString& path) Sets the default path.

wxGenericDirCtrl::SetFilter
void SetFilter(const wxString& filter) Sets the filter string.

wxGenericDirCtrl::SetFilterIndex
void SetFilterIndex(int n) Sets the current filter index (zero-based).

wxGenericDirCtrl::SetPath
void SetPath(const wxString& path) Sets the current path.

wxGenericValidator
wxGenericValidator performs data transfer (but not validation or filtering) for the following basic controls: wxButton, wxCheckBox, wxListBox, wxStaticText, wxRadioButton, wxRadioBox, wxChoice, wxComboBox, wxGauge, wxSlider, wxScrollBar, wxSpinButton, wxTextCtrl, wxCheckListBox. It checks the type of the window and uses an appropriate type for that window. For example, wxButton and wxTextCtrl transfer data to and from a wxString variable; wxListBox uses a wxArrayInt; wxCheckBox uses a bool. For more information, please see Validator overview (p. 1614). Derived from wxValidator (p. 1358) wxEvtHandler (p. 443) wxObject (p. 954) Include files

564


CHAPTER 7
<wx/valgen.h> See also Validator overview (p. 1614), wxValidator (p. 1358),wxTextValidator (p. 1281)

wxGenericValidator::wxGenericValidator
wxGenericValidator(const wxGenericValidator& validator) Copy constructor. wxGenericValidator(bool* valPtr) Constructor taking a bool pointer. This will be used for wxCheckBox and wxRadioButton. wxGenericValidator(wxString* valPtr) Constructor taking a wxString pointer. This will be used for wxButton, wxComboBox, wxStaticText, wxTextCtrl. wxGenericValidator(int* valPtr) Constructor taking an integer pointer. This will be used for wxGauge, wxScrollBar, wxRadioBox, wxSpinButton, wxChoice. wxGenericValidator(wxArrayInt* valPtr) Constructor taking a wxArrayInt pointer. This will be used for wxListBox, wxCheckListBox. Parameters validator Validator to copy. valPtr A pointer to a variable that contains the value. This variable should have a lifetime equal to or longer than the validator lifetime (which is usually determined by the lifetime of the window).

wxGenericValidator::~wxGenericValidator
~wxGenericValidator() Destructor.

565


CHAPTER 7 wxGenericValidator::Clone
virtual wxValidator* Clone() const Clones the generic validator using the copy constructor.

wxGenericValidator::TransferFromWindow
virtual bool TransferFromWindow() Transfers the value from the window to the appropriate data type.

wxGenericValidator::TransferToWindow
virtual bool TransferToWindow() Transfers the value to the window.

wxGLCanvas
wxGLCanvas is a class for displaying OpenGL graphics. There are wrappers for OpenGL on Windows, and GTK+ and Motif. To use this class, create a wxGLCanvas window, call wxGLCanvas::SetCurrent (p. 569) to direct normal OpenGL commands to the window, and then call wxGLCanvas::SwapBuffers (p. 569) to show the OpenGL buffer on the window. To set up the attributes for the rendering context (number of bits for the depth buffer, number of bits for the stencil buffer and so on) you should set up the correct values of the attribList parameter. The values that should be set up and their meanings will be described below. To switch wxGLCanvas support on under Windows, edit setup.h and setwxUSE_GLCANVAS to 1. You may also need to have to addopengl32.lib to the list of libraries your program is linked with. On Unix, pass --with-opengl to configure to compile using OpenGL or Mesa. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/glcanvas.h> Window styles There are no specific window styles for this class.

566


CHAPTER 7
See also window styles overview (p. 1611). Constants The generic GL implementation doesn't support many of these options, such as stereo, auxiliary buffers, alpha channel, and accum buffer. Other implementations may support them. WX_GL_RGBA WX_GL_BUFFER_SIZE WX_GL_LEVEL Use true colour Bits for buffer if not WX_GL_RGBA 0 for main buffer, >0 for overlay, <0 for underlay

WX_GL_DOUBLEBUFFER Use doublebuffer WX_GL_STEREO WX_GL_AUX_BUFFERS WX_GL_MIN_RED WX_GL_MIN_GREEN WX_GL_MIN_BLUE WX_GL_MIN_ALPHA WX_GL_DEPTH_SIZE WX_GL_STENCIL_SIZE Use stereoscopic display Number of auxiliary buffers (not all implementation support this option) Use red buffer with most bits (> MIN_RED bits) Use green buffer with most bits (> MIN_GREEN bits) Use blue buffer with most bits (> MIN_BLUE bits) Use alpha buffer with most bits (> MIN_ALPHA bits) Bits for Z-buffer (0,16,32) Bits for stencil buffer

WX_GL_MIN_ACCUM_RED Use red accum buffer with most bits (> MIN_ACCUM_RED bits) WX_GL_MIN_ACCUM_GREEN Use green buffer with most bits (> MIN_ACCUM_GREEN bits) WX_GL_MIN_ACCUM_BLUE Use blue buffer with most bits (> MIN_ACCUM_BLUE bits) Use blue buffer with most bits (> WX_GL_MIN_ACCUM_ALPHA MIN_ACCUM_ALPHA bits)

wxGLCanvas::wxGLCanvas
void wxGLCanvas(wxWindow* parent, wxWindowID id = -1, const wxPoint& pos, const wxSize& size, long style=0, const wxString& name="GLCanvas", int* attribList = 0, const wxPalette& palette = wxNullPalette) void wxGLCanvas(wxWindow* parent, wxGLCanvas* sharedCanvas = NULL,

567


CHAPTER 7
wxWindowID id = -1, const wxPoint& pos, const wxSize& size, long style=0, const wxString& name="GLCanvas", int* attribList = 0, const wxPalette& palette = wxNullPalette) void wxGLCanvas(wxWindow* parent, wxGLContext* sharedContext = NULL, wxWindowID id = -1, const wxPoint& pos, const wxSize& size, long style=0, const wxString& name="GLCanvas", int* attribList = 0, const wxPalette& palette = wxNullPalette) Constructor. parent Pointer to a parent window. id Window identifier. If -1, will automatically create an identifier. pos Window position. wxDefaultPosition is (-1, -1) which indicates that wxWindows should generate a default position for the window. size Window size. wxDefaultSize is (-1, -1) which indicates that wxWindows should generate a default size for the window. If no suitable size can be found, the window will be sized to 20x20 pixels so that the window is visible but obviously not correctly sized. style Window style. name Window name. attribList Array of int. With this parameter you can set the device context attributes associated to this window. This array is zero-terminated: it should be set up with constants described in the table above. If a constant should be followed by a value, put it in the next array position. For example, the WX_GL_DEPTH_SIZE should be followed by the value that indicates the number of bits for the depth buffer, so:
attribList[index]= WX_GL_DEPTH_SIZE; attribList[index+1]=32; and so on.

palette

568


CHAPTER 7
If the window has the palette, it should by pass this value. Note: palette and WX_GL_RGBA are mutually exclusive.

wxGLCanvas::SetCurrent
void SetCurrent() Sets this canvas as the current recipient of OpenGL calls. Each canvas contain an OpenGL device context that has been created during the creation of this window. So this call sets the current device context as the target device context for OpenGL operations.

wxGLCanvas::SetColour
void SetColour(const char* colour) Sets the current colour for this window, using the wxWindows colour database to find a named colour.

wxGLCanvas::SwapBuffers
void SwapBuffers() Displays the previous OpenGL commands on the window.

wxGrid
wxGrid and its related classes are used for displaying and editing tabular data. They provide a rich set of features for display, editing, and interacting with a variety of data sources. For simple applications, and to help you get started, wxGrid is the only class you need to refer to directly. It will set up default instances of the other classes and manage them for you. For more complex applications you can derive your own classes for custom grid views, grid data tables, cell editors and renderers. The wxGrid classes overview (p. 1662) has examples of simple and more complex applications, explains the relationship between the various grid classes and has a summary of the keyboard shortcuts and mouse functions provided by wxGrid. wxGrid has been greatly expanded and redesigned for wxWindows 2.2 onwards. If you have been using the old wxGrid class you will probably want to have a look at the wxGrid classes overview (p. 1662) to see how things have changed. The new grid classes are reasonably backward-compatible but there are some exceptions. There are also easier ways of doing many things compared to the previous implementation. Derived from wxScrolledWindow (p. 1085) wxWindow (p. 1386) wxEvtHandler (p. 443)

569


CHAPTER 7
wxObject (p. 954) Include files <wx/grid.h> Window styles There are presently no specific window styles for wxGrid. Event handling The event handler for the following functions takes a wxGridEvent (p. 619) parameter. EVT_GRID_CELL_LEFT_CLICK(func) The user clicked a cell with the left mouse button. Processes a wxEVT_GRID_CELL_LEFT_CLICK. EVT_GRID_CELL_RIGHT_CLICK(func) The user clicked a cell with the right mouse button. Processes a wxEVT_GRID_CELL_RIGHT_CLICK. EVT_GRID_CELL_LEFT_DCLICK(func) The user double-clicked a cell with the left mouse button. Processes a wxEVT_GRID_CELL_LEFT_DCLICK. EVT_GRID_CELL_RIGHT_DCLICK(func) The user double-clicked a cell with the right mouse button. Processes a wxEVT_GRID_CELL_RIGHT_DCLICK. EVT_GRID_LABEL_LEFT_CLICK(func) The user clicked a label with the left mouse button. Processes a wxEVT_GRID_LABEL_LEFT_CLICK. EVT_GRID_LABEL_RIGHT_CLICK(func) The user clicked a label with the right mouse button. Processes a wxEVT_GRID_LABEL_RIGHT_CLICK. EVT_GRID_LABEL_LEFT_DCLICK(func) The user double-clicked a label with the left mouse button. Processes a wxEVT_GRID_LABEL_LEFT_DCLICK. EVT_GRID_LABEL_RIGHT_DCLICK(func) The user double-clicked a label with the right mouse button. Processes a wxEVT_GRID_LABEL_RIGHT_DCLICK. EVT_GRID_CELL_CHANGE(func) EVT_GRID_SELECT_CELL(func) EVT_GRID_EDITOR_HIDDEN(func) The user changed the data in a cell. Processes a wxEVT_GRID_CELL_CHANGE. The user moved to, and selected a cell. Processes a wxEVT_GRID_SELECT_CELL. The editor for a cell was hidden. Processes a wxEVT_GRID_EDITOR_HIDDEN.

570


CHAPTER 7
EVT_GRID_EDITOR_SHOWN(func) The editor for a cell was shown. Processes a wxEVT_GRID_EDITOR_SHOWN.

The event handler for the following functions takes a wxGridSizeEvent (p. 624) parameter. EVT_GRID_COL_SIZE(func) The user resized a column by dragging it. Processes a wxEVT_GRID_COL_SIZE. EVT_GRID_ROW_SIZE(func) The user resized a row by dragging it. Processes a wxEVT_GRID_ROW_SIZE.

The event handler for the following functions takes a wxGridRangeSelectEvent (p. 622) parameter. EVT_GRID_RANGE_SELECT(func) The user selected a group of contiguous cells. Processes a wxEVT_GRID_RANGE_SELECT. The event handler for the following functions takes a wxGridEditorCreatedEvent (p. 618) parameter. EVT_GRID_EDITOR_CREATED(func) The editor for a cell was created. Processes a wxEVT_GRID_EDITOR_CREATED. See also wxGrid overview (p. 1662)

Constructors and initialization
wxGrid (p. 571) ~wxGrid (p. 572) CreateGrid (p. 575) SetTable (p. 597)

Display format Selection functions
wxGrid::ClearSelection (p. 575) wxGrid::IsSelection (p. 586) wxGrid::SelectAll (p. 589) wxGrid::SelectBlock (p. 589) wxGrid::SelectCol (p. 589) wxGrid::SelectRow (p. 589)

wxGrid::wxGrid

571


CHAPTER 7
wxGrid() Default constructor wxGrid(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxWANTS_CHARS, const wxString& name = wxPanelNameStr) Constructor to create a grid object. Call either wxGrid::CreateGrid (p. 575) or wxGrid::SetTable (p. 597) directly after this to initialize the grid before using it.

wxGrid::~wxGrid
~wxGrid() Destructor. This will also destroy the associated grid table unless you passed a table object to the grid and specified that the grid should not take ownership of the table (see wxGrid::SetTable (p. 597)).

wxGrid::AppendCols
bool AppendCols(int numCols = 1, bool updateLabels = true) Appends one or more new columns to the right of the grid and returns true if successful. The updateLabels argument is not used at present. If you are using a derived grid table class you will need to override wxGridTableBase::AppendCols (p. 631). See wxGrid::InsertCols (p. 584) for further information.

wxGrid::AppendRows
bool AppendRows(int numRows = 1, bool updateLabels = true) Appends one or more new rows to the bottom of the grid and returns true if successful. The updateLabels argument is not used at present. If you are using a derived grid table class you will need to override wxGridTableBase::AppendRows (p. 631). See wxGrid::InsertRows (p. 585) for further information.

wxGrid::AutoSize
void AutoSize() Automatically sets the height and width of all rows and columns to fit their contents. Note wxGrid sets up arrays to store individual row and column sizes when non-default sizes

572


CHAPTER 7
are used. The memory requirements for this could become prohibitive if your grid is very large.

wxGrid::AutoSizeColumn
void AutoSizeColumn(int col, bool setAsMin = true) Automatically sizes the column to fit its contents. If setAsMin is true the calculated width will also be set as the minimal width for the column. Note wxGrid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.

wxGrid::AutoSizeColumns
void AutoSizeColumns(bool setAsMin = true) Automatically sizes all columns to fit their contents. If setAsMin is true the calculated widths will also be set as the minimal widths for the columns. Note wxGrid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.

wxGrid::AutoSizeRow
void AutoSizeRow(int row, bool setAsMin = true) Automatically sizes the row to fit its contents. If setAsMin is true the calculated height will also be set as the minimal height for the row. Note wxGrid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.

wxGrid::AutoSizeRows
void AutoSizeRows(bool setAsMin = true) Automatically sizes all rows to fit their contents. If setAsMin is true the calculated heights will also be set as the minimal heights for the rows. Note wxGrid sets up arrays to store individual row and column sizes when non-default sizes

573


CHAPTER 7
are used. The memory requirements for this could become prohibitive if your grid is very large.

wxGrid::BeginBatch
void BeginBatch() Increments the grid's batch count. When the count is greater than zero repainting of the grid is suppressed. Each call to BeginBatch must be matched by a later call to wxGrid::EndBatch (p. 577). Code that does a lot of grid modification can be enclosed between BeginBatch and EndBatch calls to avoid screen flicker. The final EndBatch will cause the grid to be repainted.

wxGrid::CanDragColSize
bool CanDragColSize() Returns true if columns can be resized by dragging with the mouse. Columns can be resized by dragging the edges of their labels. If grid line dragging is enabled they can also be resized by dragging the right edge of the column in the grid cell area (see wxGrid::EnableDragGridSize (p. 577)).

wxGrid::CanDragRowSize
bool CanDragRowSize() Returns true if rows can be resized by dragging with the mouse. Rows can be resized by dragging the edges of their labels. If grid line dragging is enabled they can also be resized by dragging the lower edge of the row in the grid cell area (see wxGrid::EnableDragGridSize (p. 577)).

wxGrid::CanDragGridSize
bool CanDragGridSize() Return true if the dragging of grid lines to resize rows and columns is enabled or false otherwise.

wxGrid::CanEnableCellControl
bool CanEnableCellControl() const Returns true if the in-place edit control for the current grid cell can be used and false otherwise (e.g. if the current cell is read-only).

574


CHAPTER 7 wxGrid::CellToRect
wxRect CellToRect(int row, int col) wxRect CellToRect(const wxGridCellCoords& coords) Return the rectangle corresponding to the grid cell's size and position in logical coordinates.

wxGrid::ClearGrid
void ClearGrid() Clears all data in the underlying grid table and repaints the grid. The table is not deleted by this function. If you are using a derived table class then you need to override wxGridTableBase::Clear (p. 631) for this function to have any effect.

wxGrid::ClearSelection
void ClearSelection() Deselects all cells that are currently selected.

wxGrid::CreateGrid
bool CreateGrid(int numRows, int numCols, wxGrid::wxGridSelectionModes selmode = wxGrid::wxGridSelectCells) Creates a grid with the specified initial number of rows and columns. Call this directly after the grid constructor. When you use this function wxGrid will create and manage a simple table of string values for you. All of the grid data will be stored in memory. For applications with more complex data types or relationships, or for dealing with very large datasets, you should derive your own grid table class and pass a table object to the grid with wxGrid::SetTable (p. 597).

wxGrid::DeleteCols
bool DeleteCols(int pos = 0, int numCols = 1, bool updateLabels = true) Deletes one or more columns from a grid starting at the specified position and returns true if successful. The updateLabels argument is not used at present. If you are using a derived grid table class you will need to override wxGridTableBase::DeleteCols (p. 632). See wxGrid::InsertCols (p. 584) for further information.

575


CHAPTER 7 wxGrid::DeleteRows
bool DeleteRows(int pos = 0, int numRows = 1, bool updateLabels = true) Deletes one or more rows from a grid starting at the specified position and returns true if successful. The updateLabels argument is not used at present. If you are using a derived grid table class you will need to override wxGridTableBase::DeleteRows (p. 631). See wxGrid::InsertRows (p. 585) for further information.

wxGrid::DisableCellEditControl
void DisableCellEditControl() Disables in-place editing of grid cells. Equivalent to calling EnableCellEditControl(false).

wxGrid::DisableDragColSize
void DisableDragColSize() Disables column sizing by dragging with the mouse. Equivalent to passing false to wxGrid::EnableDragColSize (p. 576).

wxGrid::DisableDragGridSize
void DisableDragGridSize() Disable mouse dragging of grid lines to resize rows and columns. Equivalent to passing false to wxGrid::EnableDragGridSize (p. 577)

wxGrid::DisableDragRowSize
void DisableDragRowSize() Disables row sizing by dragging with the mouse. Equivalent to passing false to wxGrid::EnableDragRowSize (p. 577).

wxGrid::EnableCellEditControl
void EnableCellEditControl(bool enable = true) Enables or disables in-place editing of grid cell data. The grid will issue either a wxEVT_GRID_EDITOR_SHOWN or wxEVT_GRID_EDITOR_HIDDEN event.

wxGrid::EnableDragColSize 576


CHAPTER 7
void EnableDragColSize(bool enable = true) Enables or disables column sizing by dragging with the mouse.

wxGrid::EnableDragGridSize
void EnableDragGridSize(bool enable = true) Enables or disables row and column resizing by dragging gridlines with the mouse.

wxGrid::EnableDragRowSize
void EnableDragRowSize(bool enable = true) Enables or disables row sizing by dragging with the mouse.

wxGrid::EnableEditing
void EnableEditing(bool edit) If the edit argument is false this function sets the whole grid as read-only. If the argument is true the grid is set to the default state where cells may be editable. In the default state you can set single grid cells and whole rows and columns to be editable or read-only via wxGridCellAttribute::SetReadOnly (p. 607). For single cells you can also use the shortcut function wxGrid::SetReadOnly (p. 595). For more information about controlling grid cell attributes see the wxGridCellAttr (p. 606) cell attribute class and the wxGrid classes overview (p. 1662).

wxGrid::EnableGridLines
void EnableGridLines(bool enable = true) Turns the drawing of grid lines on or off.

wxGrid::EndBatch
void EndBatch() Decrements the grid's batch count. When the count is greater than zero repainting of the grid is suppressed. Each previous call to wxGrid::BeginBatch (p. 574) must be matched by a later call to EndBatch. Code that does a lot of grid modification can be enclosed between BeginBatch and EndBatch calls to avoid screen flicker. The final EndBatch will cause the grid to be repainted.

wxGrid::ForceRefresh 577


CHAPTER 7
void ForceRefresh() Causes immediate repainting of the grid. Use this instead of the usual wxWindow::Refresh.

wxGrid::GetBatchCount
int GetBatchCount() Returns the number of times that wxGrid::BeginBatch (p. 574) has been called without (yet) matching calls to wxGrid::EndBatch (p. 577). While the grid's batch count is greater than zero the display will not be updated.

wxGrid::GetCellAlignment
void GetCellAlignment(int row, int col, int* horiz, int* vert) Sets the arguments to the horizontal and vertical text alignment values for the grid cell at the specified location. Horizontal alignment will be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT. Vertical alignment will be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM. wxPerl note: This method only takes the parameters row and col and returns a 2element list ( horiz, vert ).

wxGrid::GetCellBackgroundColour
wxColour GetCellBackgroundColour(int row, int col) Returns the background colour of the cell at the specified location.

wxGrid::GetCellEditor
wxGridCellEditor* GetCellEditor(int row, int col) Returns a pointer to the editor for the cell at the specified location. See wxGridCellEditor (p. 613) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::GetCellFont
wxFont GetCellFont(int row, int col)

578


CHAPTER 7
Returns the font for text in the grid cell at the specified location.

wxGrid::GetCellRenderer
wxGridCellRenderer* GetCellRenderer(int row, int col) Returns a pointer to the renderer for the grid cell at the specified location. See wxGridCellRenderer (p. 627) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::GetCellTextColour
wxColour GetCellTextColour(int row, int col) Returns the text colour for the grid cell at the specified location.

wxGrid::GetCellValue
wxString GetCellValue(int row, int col) wxString GetCellValue(const wxGridCellCoords&coords) Returns the string contained in the cell at the specified location. For simple applications where a grid object automatically uses a default grid table of string values you use this function together with wxGrid::SetCellValue (p. 590) to access cell values. For more complex applications where you have derived your own grid table class that contains various data types (e.g. numeric, boolean or user-defined custom types) then you only use this function for those cells that contain string values. See wxGridTableBase::CanGetValueAs (p. 630)and the wxGrid overview (p. 1662) for more information.

wxGrid::GetColLabelAlignment
void GetColLabelAlignment(int* horiz, int* vert) Sets the arguments to the current column label alignment values. Horizontal alignment will be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT. Vertical alignment will be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM. wxPerl note: This method takes no parameters and returns a 2-element list ( horiz, vert ).

579


CHAPTER 7 wxGrid::GetColLabelSize
int GetColLabelSize() Returns the current height of the column labels.

wxGrid::GetColLabelValue
wxString GetColLabelValue(int col) Returns the specified column label. The default grid table class provides column labels of the form A,B...Z,AA,AB...ZZ,AAA... If you are using a custom grid table you can override wxGridTableBase::GetColLabelValue (p. 632) to provide your own labels.

wxGrid::GetColSize
int GetColSize(int col) Returns the width of the specified column.

wxGrid::GetDefaultCellAlignment
void GetDefaultCellAlignment(int* horiz, int* vert) Sets the arguments to the current default horizontal and vertical text alignment values. Horizontal alignment will be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT. Vertical alignment will be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM.

wxGrid::GetDefaultCellBackgroundColour
wxColour GetDefaultCellBackgroundColour() Returns the current default background colour for grid cells.

wxGrid::GetDefaultCellFont
wxFont GetDefaultCellFont() Returns the current default font for grid cell text.

wxGrid::GetDefaultCellTextColour
wxColour GetDefaultCellTextColour()

580


CHAPTER 7
Returns the current default colour for grid cell text.

wxGrid::GetDefaultColLabelSize
int GetDefaultColLabelSize() Returns the default height for column labels.

wxGrid::GetDefaultColSize
int GetDefaultColSize() Returns the current default width for grid columns.

wxGrid::GetDefaultEditor
wxGridCellEditor* GetDefaultEditor() const Returns a pointer to the current default grid cell editor. See wxGridCellEditor (p. 613) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::GetDefaultRenderer
wxGridCellRenderer* GetDefaultRenderer() const Returns a pointer to the current default grid cell renderer. See wxGridCellRenderer (p. 627) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::GetDefaultRowLabelSize
int GetDefaultRowLabelSize() Returns the default width for the row labels.

wxGrid::GetDefaultRowSize
int GetDefaultRowSize() Returns the current default height for grid rows.

wxGrid::GetGridCursorCol 581


CHAPTER 7
int GetGridCursorCol() Returns the current grid cell column position.

wxGrid::GetGridCursorRow
int GetGridCursorRow() Returns the current grid cell row position.

wxGrid::GetGridLineColour
wxColour GetGridLineColour() Returns the colour used for grid lines.

wxGrid::GridLinesEnabled
bool GridLinesEnabled() Returns true if drawing of grid lines is turned on, false otherwise.

wxGrid::GetLabelBackgroundColour
wxColour GetLabelBackgroundColour() Returns the colour used for the background of row and column labels.

wxGrid::GetLabelFont
wxFont GetLabelFont() Returns the font used for row and column labels.

wxGrid::GetLabelTextColour
wxColour GetLabelTextColour() Returns the colour used for row and column label text.

wxGrid::GetNumberCols
int GetNumberCols() Returns the total number of grid columns (actually the number of columns in the

582


CHAPTER 7
underlying grid table).

wxGrid::GetNumberRows
int GetNumberRows() Returns the total number of grid rows (actually the number of rows in the underlying grid table).

wxGrid::GetRowLabelAlignment
void GetRowLabelAlignment(int* horiz, int* vert) Sets the arguments to the current row label alignment values. Horizontal alignment will be one of wxLEFT, wxCENTRE or wxRIGHT. Vertical alignment will be one of wxTOP, wxCENTRE or wxBOTTOM. wxPerl note: This method takes no parameters and returns a 2-element list ( horiz, vert ).

wxGrid::GetRowLabelSize
int GetRowLabelSize() Returns the current width of the row labels.

wxGrid::GetRowLabelValue
wxString GetRowLabelValue(int row) Returns the specified row label. The default grid table class provides numeric row labels. If you are using a custom grid table you can override wxGridTableBase::GetRowLabelValue (p. 632) to provide your own labels.

wxGrid::GetRowSize
int GetRowSize(int row) Returns the height of the specified row.

wxGrid::GetSelectionMode
wxGrid::wxGridSelectionModes GetSelectionMode() const Returns the current selection mode, see wxGrid::SetSelectionMode (p. 597).

583


CHAPTER 7 wxGrid::GetSelectedCells
wxGridCellCoordsArray GetSelectedCells() const Returns an array of singly selected cells.

wxGrid::GetSelectedCols
wxArrayInt GetSelectedCols() const Returns an array of selected cols.

wxGrid::GetSelectedRows
wxArrayInt GetSelectedRows() const Returns an array of selected rows.

wxGrid::GetSelectionBlockTopLeft
wxGridCellCoordsArray GetSelectionBlockTopLeft() const Returns an array of the top left corners of blocks of selected cells, see wxGrid::GetSelectionBlockBottomRight (p. 584).

wxGrid::GetSelectionBlockBottomRight
wxGridCellCoordsArray GetSelectionBlockBottomRight() const Returns an array of the bottom right corners of blocks of selected cells, see wxGrid::GetSelectionBlockTopLeft (p. 584).

wxGrid::GetTable
wxGridTableBase * GetTable() const Returns a base pointer to the current table object.

wxGrid::HideCellEditControl
void HideCellEditControl() Hides the in-place cell edit control.

wxGrid::InsertCols 584


CHAPTER 7
bool InsertCols(int pos = 0, int numCols = 1, bool updateLabels = true) Inserts one or more new columns into a grid with the first new column at the specified position and returns true if successful. The updateLabels argument is not used at present. The sequence of actions begins with the grid object requesting the underlying grid table to insert new columns. If this is successful the table notifies the grid and the grid updates the display. For a default grid (one where you have called wxGrid::CreateGrid (p. 575)) this process is automatic. If you are using a custom grid table (specified with wxGrid::SetTable (p. 597)) then you must override wxGridTableBase::InsertCols (p. 631) in your derived table class.

wxGrid::InsertRows
bool InsertRows(int pos = 0, int numRows = 1, bool updateLabels = true) Inserts one or more new rows into a grid with the first new row at the specified position and returns true if successful. The updateLabels argument is not used at present. The sequence of actions begins with the grid object requesting the underlying grid table to insert new rows. If this is successful the table notifies the grid and the grid updates the display. For a default grid (one where you have called wxGrid::CreateGrid (p. 575)) this process is automatic. If you are using a custom grid table (specified with wxGrid::SetTable (p. 597)) then you must override wxGridTableBase::InsertRows (p. 631) in your derived table class.

wxGrid::IsCellEditControlEnabled
bool IsCellEditControlEnabled() const Returns true if the in-place edit control is currently enabled.

wxGrid::IsCurrentCellReadOnly
bool IsCurrentCellReadOnly() const Returns true if the current cell has been set to read-only (see wxGrid::SetReadOnly (p. 595)).

wxGrid::IsEditable
bool IsEditable() Returns false if the whole grid has been set as read-only or true otherwise. See wxGrid::EnableEditing (p. 577) for more information about controlling the editing status of grid cells.

585


CHAPTER 7 wxGrid::IsInSelection
bool IsInSelection(int row, int col) const bool IsInSelection(const wxGridCellCoords& coords) const Is this cell currently selected.

wxGrid::IsReadOnly
bool IsReadOnly(int row, int col) const Returns true if the cell at the specified location can't be edited. See also wxGrid::IsReadOnly (p. 586).

wxGrid::IsSelection
bool IsSelection() Returns true if there are currently rows, columns or blocks of cells selected.

wxGrid::IsVisible
bool IsVisible(int row, int col, bool wholeCellVisible = true) bool IsVisible(const wxGridCellCoords& coords, bool wholeCellVisible = true) Returns true if a cell is either wholly visible (the default) or at least partially visible in the grid window.

wxGrid::MakeCellVisible
void MakeCellVisible(int row, int col) void MakeCellVisible(const wxGridCellCoords& coords) Brings the specified cell into the visible grid cell area with minimal scrolling. Does nothing if the cell is already visible.

wxGrid::MoveCursorDown
bool MoveCursorDown(bool expandSelection) Moves the grid cursor down by one row. If a block of cells was previously selected it will expand if the argument is true or be cleared if the argument is false. Keyboard This function is called for Down cursor key presses or Shift+Down to expand a selection.

586


CHAPTER 7 wxGrid::MoveCursorLeft
bool MoveCursorLeft(bool expandSelection) Moves the grid cursor left by one column. If a block of cells was previously selected it will expand if the argument is true or be cleared if the argument is false. Keyboard This function is called for Left cursor key presses or Shift+Left to expand a selection.

wxGrid::MoveCursorRight
bool MoveCursorRight(bool expandSelection) Moves the grid cursor right by one column. If a block of cells was previously selected it will expand if the argument is true or be cleared if the argument is false. Keyboard This function is called for Right cursor key presses or Shift+Right to expand a selection.

wxGrid::MoveCursorUp
bool MoveCursorUp(bool expandSelection) Moves the grid cursor up by one row. If a block of cells was previously selected it will expand if the argument is true or be cleared if the argument is false. Keyboard This function is called for Up cursor key presses or Shift+Up to expand a selection.

wxGrid::MoveCursorDownBlock
bool MoveCursorDownBlock(bool expandSelection) Moves the grid cursor down in the current column such that it skips to the beginning or end of a block of non-empty cells. If a block of cells was previously selected it will expand if the argument is true or be cleared if the argument is false. Keyboard This function is called for the Ctrl+Down key combination. Shift+Ctrl+Down expands a selection.

wxGrid::MoveCursorLeftBlock
bool MoveCursorLeftBlock(bool expandSelection) Moves the grid cursor left in the current row such that it skips to the beginning or end of a block of non-empty cells. If a block of cells was previously selected it will expand if the

587


CHAPTER 7
argument is true or be cleared if the argument is false. Keyboard This function is called for the Ctrl+Left key combination. Shift+Ctrl+left expands a selection.

wxGrid::MoveCursorRightBlock
bool MoveCursorRightBlock(bool expandSelection) Moves the grid cursor right in the current row such that it skips to the beginning or end of a block of non-empty cells. If a block of cells was previously selected it will expand if the argument is true or be cleared if the argument is false. Keyboard This function is called for the Ctrl+Right key combination. Shift+Ctrl+Right expands a selection.

wxGrid::MoveCursorUpBlock
bool MoveCursorUpBlock(bool expandSelection) Moves the grid cursor up in the current column such that it skips to the beginning or end of a block of non-empty cells. If a block of cells was previously selected it will expand if the argument is true or be cleared if the argument is false. Keyboard This function is called for the Ctrl+Up key combination. Shift+Ctrl+Up expands a selection.

wxGrid::MovePageDown
bool MovePageDown() Moves the grid cursor down by some number of rows so that the previous bottom visible row becomes the top visible row. Keyboard This function is called for PgDn keypresses.

wxGrid::MovePageUp
bool MovePageUp() Moves the grid cursor up by some number of rows so that the previous top visible row becomes the bottom visible row. Keyboard

588


CHAPTER 7
This function is called for PgUp keypresses.

wxGrid::SaveEditControlValue
void SaveEditControlValue() Sets the value of the current grid cell to the current in-place edit control value. This is called automatically when the grid cursor moves from the current cell to a new cell. It is also a good idea to call this function when closing a grid since any edits to the final cell location will not be saved otherwise.

wxGrid::SelectAll
void SelectAll() Selects all cells in the grid.

wxGrid::SelectBlock
void SelectBlock(int topRow, int leftCol, int bottomRow, int rightCol, bool addToSelected = false) void SelectBlock(const wxGridCellCoords& topLeft, const wxGridCellCoords& bottomRight, bool addToSelected = false) Selects a rectangular block of cells. If addToSelected is false then any existing selection will be deselected; if true the column will be added to the existing selection.

wxGrid::SelectCol
void SelectCol(int col, bool addToSelected = false) Selects the specified column. If addToSelected is false then any existing selection will be deselected; if true the column will be added to the existing selection.

wxGrid::SelectRow
void SelectRow(int row, bool addToSelected = false) Selects the specified row. If addToSelected is false then any existing selection will be deselected; if true the row will be added to the existing selection.

wxGrid::SetCellAlignment
void SetCellAlignment(int row, int col, int horiz, int vert)

589


CHAPTER 7
void SetCellAlignment(int align, int row, int col) void SetCellAlignment(int align) Sets the horizontal and vertical alignment for grid cell text at the specified location. Horizontal alignment should be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT. Vertical alignment should be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM.

wxGrid::SetCellEditor
void SetCellEditor(int row, int col, wxGridCellEditor* editor) Sets the editor for the grid cell at the specified location. The grid will take ownership of the pointer. See wxGridCellEditor (p. 613) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::SetCellFont
void SetCellFont(int row, int col, const wxFont& font) Sets the font for text in the grid cell at the specified location.

wxGrid::SetCellRenderer
void SetCellRenderer(int row, int col, wxGridCellRenderer* renderer) Sets the renderer for the grid cell at the specified location. The grid will take ownership of the pointer. See wxGridCellRenderer (p. 627) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::SetCellTextColour
void SetCellTextColour(int row, int col, const wxColour& colour) void SetCellTextColour(const wxColour& val, int row, int col) void SetCellTextColour(const wxColour& colour) Sets the text colour for the grid cell at the specified location.

wxGrid::SetCellValue 590


CHAPTER 7
void SetCellValue(int row, int col, const wxString& s) void SetCellValue(const wxGridCellCoords& coords, const wxString& s) void SetCellValue(const wxString& val, int row, int col) Sets the string value for the cell at the specified location. For simple applications where a grid object automatically uses a default grid table of string values you use this function together with wxGrid::GetCellValue (p. 579) to access cell values. For more complex applications where you have derived your own grid table class that contains various data types (e.g. numeric, boolean or user-defined custom types) then you only use this function for those cells that contain string values. The last form is for backward compatibility only. See wxGridTableBase::CanSetValueAs (p. 630)and the wxGrid overview (p. 1662) for more information.

wxGrid::SetColAttr
void SetColAttr(int col, wxGridCellAttr* attr) Sets the cell attributes for all cells in the specified column. For more information about controlling grid cell attributes see the wxGridCellAttr (p. 606) cell attribute class and the wxGrid classes overview (p. 1662).

wxGrid::SetColFormatBool
void SetColFormatBool(int col) Sets the specified column to display boolean values. wxGrid displays boolean values with a checkbox.

wxGrid::SetColFormatNumber
void SetColFormatNumber(int col) Sets the specified column to display integer values.

wxGrid::SetColFormatFloat
void SetColFormatFloat(int col, int width = -1, int precision = -1) Sets the specified column to display floating point values with the given width and precision.

591


CHAPTER 7 wxGrid::SetColFormatCustom
void SetColFormatCustom(int col, const wxString& typeName) Sets the specified column to display data in a custom format. See the wxGrid overview (p. 1662) for more information on working with custom data types.

wxGrid::SetColLabelAlignment
void SetColLabelAlignment(int horiz, int vert) Sets the horizontal and vertical alignment of column label text. Horizontal alignment should be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT. Vertical alignment should be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM.

wxGrid::SetColLabelSize
void SetColLabelSize(int height) Sets the height of the column labels.

wxGrid::SetColLabelValue
void SetColLabelValue(int col, const wxString& value) Set the value for the given column label. If you are using a derived grid table you must override wxGridTableBase::SetColLabelValue (p. 632)for this to have any effect.

wxGrid::SetColMinimalWidth
void SetColMinimalWidth(int col, int width) Sets the minimal width for the specified column. This should normally be called when creating the grid because it will not resize a column that is already narrower than the minimal width. The width argument must be higher than the minimimal acceptable column width, seewxGrid::GetColMinimalAcceptableWidth (p. 593).

wxGrid::SetColMinimalAcceptableWidth
void SetColMinimalAcceptableWidth(int width) This modifies the minimum column width that can be handled correctly. Specifying a low value here allows smaller grid cells to be dealt with correctly. Specifying a value here

592


CHAPTER 7
which is much smaller than the actual minimum size will incur a performance penalty in the functions which perform grid cell index lookup on the basis of screen coordinates. This should normally be called when creating the grid because it will not resize existing columns with sizes smaller than the value specified here.

wxGrid::GetColMinimalAcceptableWidth
int GetColMinimalAcceptableWidth() This returns the value of the lowest column width that can be handled correctly. See member SetColMinimalAcceptableWidth (p. 592) for details.

wxGrid::SetColSize
void SetColSize(int col, int width) Sets the width of the specified column. This function does not refresh the grid. If you are calling it outside of a BeginBatch / EndBatch block you can use wxGrid::ForceRefresh (p. 577) to see the changes. Automatically sizes the column to fit its contents. If setAsMin is true the calculated width will also be set as the minimal width for the column. Note wxGrid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.

wxGrid::SetDefaultCellAlignment
void SetDefaultCellAlignment(int horiz, int vert) Sets the default horizontal and vertical alignment for grid cell text. Horizontal alignment should be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT. Vertical alignment should be one of wxALIGN_TOP, wxALIGN_CENTRE or wxALIGN_BOTTOM.

wxGrid::SetDefaultCellBackgroundColour
void SetDefaultCellBackgroundColour(const wxColour& colour) Sets the default background colour for grid cells.

593


CHAPTER 7 wxGrid::SetDefaultCellFont
void SetDefaultCellFont(const wxFont& font) Sets the default font to be used for grid cell text.

wxGrid::SetDefaultEditor
void SetDefaultEditor(wxGridCellEditor* editor) Sets the default editor for grid cells. The grid will take ownership of the pointer. See wxGridCellEditor (p. 613) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::SetDefaultRenderer
void SetDefaultRenderer(wxGridCellRenderer* renderer) Sets the default renderer for grid cells. The grid will take ownership of the pointer. See wxGridCellRenderer (p. 627) and the wxGrid overview (p. 1662) for more information about cell editors and renderers.

wxGrid::SetDefaultColSize
void SetDefaultColSize(int width, bool resizeExistingCols = false) Sets the default width for columns in the grid. This will only affect columns subsequently added to the grid unless resizeExistingCols is true.

wxGrid::SetDefaultRowSize
void SetDefaultRowSize(int height, bool resizeExistingRows = false) Sets the default height for rows in the grid. This will only affect rows subsequently added to the grid unless resizeExistingRows is true.

wxGrid::SetGridCursor
void SetGridCursor(int row, int col) Set the grid cursor to the specified cell. This function calls wxGrid::MakeCellVisible (p. 586).

wxGrid::SetGridLineColour 594


CHAPTER 7
void SetGridLineColour(const wxColour&colour) Sets the colour used to draw grid lines.

wxGrid::SetLabelBackgroundColour
void SetLabelBackgroundColour(const wxColour& colour) Sets the background colour for row and column labels.

wxGrid::SetLabelFont
void SetLabelFont(const wxFont& font) Sets the font for row and column labels.

wxGrid::SetLabelTextColour
void SetLabelTextColour(const wxColour& colour) Sets the colour for row and column label text.

wxGrid::SetReadOnly
void SetReadOnly(int row, int col, bool isReadOnly = true) Makes the cell at the specified location read-only or editable. See also wxGrid::IsReadOnly (p. 586).

wxGrid::SetRowAttr
void SetRowAttr(int row, wxGridCellAttr* attr) Sets the cell attributes for all cells in the specified row. See the wxGridCellAttr (p. 606) class for more information about controlling cell attributes.

wxGrid::SetRowLabelAlignment
void SetRowLabelAlignment(int horiz, int vert) Sets the horizontal and vertical alignment of row label text. Horizontal alignment should be one of wxALIGN_LEFT, wxALIGN_CENTRE or wxALIGN_RIGHT. Vertical alignment should be one of wxALIGN_TOP, wxALIGN_CENTRE or

595


CHAPTER 7
wxALIGN_BOTTOM.

wxGrid::SetRowLabelSize
void SetRowLabelSize(int width) Sets the width of the row labels.

wxGrid::SetRowLabelValue
void SetRowLabelValue(int row, const wxString& value) Set the value for the given row label. If you are using a derived grid table you must override wxGridTableBase::SetRowLabelValue (p. 632) for this to have any effect.

wxGrid::SetRowMinimalHeight
void SetRowMinimalHeight(int row, int height) Sets the minimal height for the specified row. This should normally be called when creating the grid because it will not resize a row that is already shorter than the minimal height. The height argument must be higher than the minimimal acceptable row height, seewxGrid::GetRowMinimalAcceptableHeight (p. 596).

wxGrid::SetRowMinimalAcceptableHeight
void SetRowMinimalAcceptableHeight(int height) This modifies the minimum row width that can be handled correctly. Specifying a low value here allows smaller grid cells to be dealt with correctly. Specifying a value here which is much smaller than the actual minimum size will incur a performance penalty in the functions which perform grid cell index lookup on the basis of screen coordinates. This should normally be called when creating the grid because it will not resize existing rows with sizes smaller than the value specified here.

wxGrid::GetRowMinimalAcceptableHeight
int GetRowMinimalAcceptableHeight() This returns the value of the lowest row width that can be handled correctly. See member SetRowMinimalAcceptableHeight (p. 596) for details.

wxGrid::SetRowSize
void SetRowSize(int row, int height)

596


CHAPTER 7
Sets the height of the specified row. This function does not refresh the grid. If you are calling it outside of a BeginBatch / EndBatch block you can use wxGrid::ForceRefresh (p. 577) to see the changes. Automatically sizes the column to fit its contents. If setAsMin is true the calculated width will also be set as the minimal width for the column. Note wxGrid sets up arrays to store individual row and column sizes when non-default sizes are used. The memory requirements for this could become prohibitive if your grid is very large.

wxGrid::SetSelectionMode
void SetSelectionMode(wxGrid::wxGridSelectionModes selmode) Set the selection behaviour of the grid. Parameters wxGrid::wxGridSelectCells The default mode where individual cells are selected. wxGrid::wxGridSelectRows Selections will consist of whole rows. wxGrid::wxGridSelectionColumns Selections will consist of whole columns.

wxGrid::SetTable
bool SetTable(wxGridTableBase* table, bool takeOwnership = false, wxGrid::wxGridSelectionModes selmode = wxGrid::wxGridSelectCells) Passes a pointer to a custom grid table to be used by the grid. This should be called after the grid constructor and before using the grid object. If takeOwnership is set to true then the table will be deleted by the wxGrid destructor. Use this function instead of wxGrid::CreateGrid (p. 575) when your application involves complex or non-string data or data sets that are too large to fit wholly in memory.

wxGrid::ShowCellEditControl
void ShowCellEditControl() Displays the in-place cell edit control for the current cell.

597


CHAPTER 7 wxGrid::XToCol
int XToCol(int x) Returns the grid column that corresponds to the logical x coordinate. Returns wxNOT_FOUND if there is no column at the x position.

wxGrid::XToEdgeOfCol
int XToEdgeOfCol(int x) Returns the column whose right hand edge is close to the given logical x position. If no column edge is near to this position wxNOT_FOUND is returned.

wxGrid::YToEdgeOfRow
int YToEdgeOfRow(int y) Returns the row whose bottom edge is close to the given logical y position. If no row edge is near to this position wxNOT_FOUND is returned.

wxGrid::YToRow
int YToRow(int y) Returns the grid row that corresponds to the logical y coordinate. Returns wxNOT_FOUND if there is no row at the y position.

wxGrid::BlockToDeviceRect
wxRect BlockToDeviceRect(const wxGridCellCoords & topLeft, const wxGridCellCoords & bottomRight) This function returns the rectangle that encloses the block of cells limited by TopLeft and BottomRight cell in device coords and clipped to the client size of the grid window.

wxGrid::SelectionToDeviceRect
wxRect SelectionToDeviceRect() This function returns the rectangle that encloses the selected cells in device coords and clipped to the client size of the grid window.

wxGrid::GetSelectionBackground
wxColour GetSelectionBackground() const

598


CHAPTER 7
Access or update the selection fore/back colours

wxGrid::GetSelectionForeground
wxColour GetSelectionForeground() const

wxGrid::SetSelectionBackground
void SetSelectionBackground(const wxColour& c)

wxGrid::SetSelectionForeground
void SetSelectionForeground(const wxColour& c)

wxGrid::RegisterDataType
void RegisterDataType(const wxString& typeName, wxGridCellRenderer* renderer, wxGridCellEditor* editor) Methods for a registry for mapping data types to Renderers/Editors

wxGrid::GetDefaultEditorForCell
wxGridCellEditor* GetDefaultEditorForCell(int row, int col) const wxGridCellEditor* GetDefaultEditorForCell(const wxGridCellCoords& c) const

wxGrid::GetDefaultRendererForCell
wxGridCellRenderer* GetDefaultRendererForCell(int row, int col) const

wxGrid::GetDefaultEditorForType
wxGridCellEditor* GetDefaultEditorForType(const wxString& typeName) const

wxGrid::GetDefaultRendererForType
wxGridCellRenderer* GetDefaultRendererForType(const wxString& typeName) const

wxGrid::SetMargins

599


CHAPTER 7
void SetMargins(int extraWidth, int extraHeight) A grid may occupy more space than needed for its rows/columns. This function allows to set how big this extra space is

wxGrid::wxGrid
wxGrid(wxWindow* parent, int x, int y, int w = -1, int h = -1, long style = wxWANTS_CHARS, const wxString& name = wxPanelNameStr) Backward compatibility.

wxGrid::UpdateDimensions
void UpdateDimensions() Backward compatibility.

wxGrid::GetRows
int GetRows() Backward compatibility.

wxGrid::GetCols
int GetCols() Backward compatibility.

wxGrid::GetCursorRow
int GetCursorRow() Backward compatibility.

wxGrid::GetCursorColumn
int GetCursorColumn() Backward compatibility.

wxGrid::GetScrollPosX
int GetScrollPosX()

600


CHAPTER 7
Backward compatibility.

wxGrid::GetScrollPosY
int GetScrollPosY() Backward compatibility.

wxGrid::SetScrollX
void SetScrollX(int x) Backward compatibility.

wxGrid::SetScrollY
void SetScrollY(int y) Backward compatibility.

wxGrid::SetColumnWidth
void SetColumnWidth(int col, int width) Backward compatibility.

wxGrid::GetColumnWidth
int GetColumnWidth(int col) Backward compatibility.

wxGrid::SetRowHeight
void SetRowHeight(int row, int height) Backward compatibility.

wxGrid::GetViewHeight
int GetViewHeight() Backward compatibility.

601


CHAPTER 7 wxGrid::GetViewWidth
int GetViewWidth() Returned number of whole cols visible.

wxGrid::SetLabelSize
void SetLabelSize(int orientation, int sz)

wxGrid::GetLabelSize
int GetLabelSize(int orientation)

wxGrid::SetLabel Alignment
void SetLabelAlignment(int orientation, int align)

wxGrid::GetLabelAlignment
int GetLabelAlignment(int orientation, int align)

wxGrid::SetLabelValue
void SetLabelValue(int orientation, const wxString& val, int pos)

wxGrid::GetLabelValue
wxString GetLabelValue(int orientation, int pos)

wxGrid::GetCellTextFont
wxFont GetCellTextFont() const wxFont GetCellTextFont(int row, int col) const

wxGrid::SetCellTextFont
void SetCellTextFont(const wxFont& fnt) void SetCellTextFont(const wxFont& fnt, int row, int col)

602


CHAPTER 7 wxGrid::SetCellBackgroundColour
void SetCellBackgroundColour(const wxColour& col) void SetCellBackgroundColour(int row, int col, const wxColour& colour) void SetCellBackgroundColour(const wxColour& colour, int row, int col)

wxGrid::GetEditable
bool GetEditable()

wxGrid::SetEditable
void SetEditable(bool edit = true)

wxGrid::GetEditInPlace
bool GetEditInPlace()

wxGrid::SetEditInPlace
void SetEditInPlace(bool edit = true)

wxGrid::SetCellBitmap
void SetCellBitmap(wxBitmap* bitmap, int row, int col)

wxGrid::SetDividerPen
void SetDividerPen(const wxPen& pen)

wxGrid::GetDividerPen
wxPen& GetDividerPen() const

wxGrid::OnActivate
void OnActivate(bool active)

wxGrid::Fit

603


CHAPTER 7
void Fit() Overridden wxWindow methods

wxGrid::DoGetBestSize
wxSize DoGetBestSize() const

wxGrid::InitRowHeights
void InitRowHeights() NB: never access m_row/col arrays directly because they are created on demand, always use accessor functions instead! Init the m_rowHeights/Bottoms arrays with default values.

wxGrid::InitColWidths
void InitColWidths() Init the m_colWidths/Rights arrays

wxGrid::GetColWidth
int GetColWidth(int col) const Get the col/row coords

wxGrid::GetColLeft
int GetColLeft(int col) const

wxGrid::GetColRight
int GetColRight(int col) const

wxGrid::GetRowHeight
int GetRowHeight(int row) const This function must be public for compatibility.

604


CHAPTER 7 wxGrid::GetRowTop
int GetRowTop(int row) const

wxGrid::GetRowBottom
int GetRowBottom(int row) const

wxGrid::SetOrCalcColumnSizes
int SetOrCalcColumnSizes(bool calcOnly, bool setAsMin = true) Common part of AutoSizeColumn/Row() and GetBestSize()

wxGrid::SetOrCalcRowSizes
int SetOrCalcRowSizes(bool calcOnly, bool setAsMin = true)

wxGrid::AutoSizeColOrRow
void AutoSizeColOrRow(int n, bool setAsMin, bool column) Common part of AutoSizeColumn/Row() or row?

wxGrid::GetColMinimalWidth
int GetColMinimalWidth(int col) const get the minimal width of the given column/row

wxGrid::GetRowMinimalHeight
int GetRowMinimalHeight(int col) const

wxGrid::CanHaveAttributes
bool CanHaveAttributes() Do we have some place to store attributes in?

wxGrid::GetOrCreateCellAttr
wxGridCellAttr* GetOrCreateCellAttr(int row, int col) const

605


CHAPTER 7

wxGridCellAttr
This class can be used to alter the cells' appearance in the grid by changing their colour/font/... from default. An object of this class may be returned by wxGridTable::GetAttr(). Derived from No base class Data structures

wxGridCellAttr::wxGridCellAttr
wxGridCellAttr() Default constructor. wxGridCellAttr(const wxColour& colText, const wxColour& colBack, const wxFont& font, int hAlign, int vAlign) VZ: considering the number of members wxGridCellAttr has now, this ctor seems to be pretty useless... may be we should just remove it?

wxGridCellAttr::Clone
wxGridCellAttr* Clone() const Creates a new copy of this object.

wxGridCellAttr::IncRef
void IncRef() This class is ref counted: it is created with ref count of 1, so calling DecRef() once will delete it. Calling IncRef() allows to lock it until the matching DecRef() is called

wxGridCellAttr::DecRef
void DecRef()

wxGridCellAttr::SetTextColour
void SetTextColour(const wxColour& colText) Sets the text colour.

606


CHAPTER 7 wxGridCellAttr::SetBackgroundColour
void SetBackgroundColour(const wxColour& colBack) Sets the background colour.

wxGridCellAttr::SetFont
void SetFont(const wxFont& font) Sets the font.

wxGridCellAttr::SetAlignment
void SetAlignment(int hAlign, int vAlign) Sets the alignment.

wxGridCellAttr::SetReadOnly
void SetReadOnly(bool isReadOnly = true)

wxGridCell Attr::SetRenderer
void SetRenderer(wxGridCellRenderer* renderer) takes ownership of the pointer

wxGridCellAttr::SetEditor
void SetEditor(wxGridCellEditor* editor)

wxGridCellAttr::HasTextColour
bool HasTextColour() const accessors

wxGridCellAttr::HasBackgroundColour
bool HasBackgroundColour() const

wxGridCellAttr::HasFont

607


CHAPTER 7
bool HasFont() const

wxGridCellAttr::HasAlignment
bool HasAlignment() const

wxGridCellAttr::HasRenderer
bool HasRenderer() const

wxGridCellAttr::HasEditor
bool HasEditor() const

wxGridCellAttr::GetTextColour
const wxColour& GetTextColour() const

wxGridCellAttr::GetBackgroundColour
const wxColour& GetBackgroundColour() const

wxGridCellAttr::GetFont
const wxFont& GetFont() const

wxGridCellAttr::GetAlignment
void GetAlignment(int* hAlign, int* vAlign) const wxPerl note: This method takes no parameters and returns a 2-element list ( hAlign, vAlign ).

wxGridCell Attr::GetRenderer
wxGridCellRenderer* GetRenderer(wxGrid* grid, int row, int col) const

wxGridCellAttr::GetEditor
wxGridCellEditor* GetEditor(wxGrid* grid, int row, int col) const

608


CHAPTER 7 wxGridCellAttr::IsReadOnly
bool IsReadOnly() const

wxGridCellAttr::SetDefAttr
void SetDefAttr(wxGridCellAttr* defAttr)

wxGridBagSizer
A wxSizer (p. 1109) that can lay out items in a virtual grid like a wxFlexGridSizer (p. 506) but in this case explicit positioning of the items is allowed using wxGBPosition (p. 555), and items can optionally span more than one row and/or column using wxGBSpan (p. 558). Derived from wxFlexGridSizer (p. 506) wxGridSizer (p. 633) wxSizer (p. 1109) wxObject (p. 954) Include files <wx/gbsizer.h>

wxGridBagSizer::wxGridBagSizer
wxGridBagSizer(int vgap = 0, int hgap = 0) Constructor, with optional parameters to specify the gap between the rows and columns.

wxGridBagSizer::Add
bool Add(wxWindow* window, const wxGBPosition& pos, const wxGBSpan& span = wxDefaultSpan, int flag = 0, int border = 0, wxObject* userData = NULL) bool Add(wxSizer* sizer, const wxGBPosition& pos, const wxGBSpan& span = wxDefaultSpan, int flag = 0, int border = 0, wxObject* userData = NULL) bool Add(int width, int height, const wxGBPosition& pos, const wxGBSpan& span = wxDefaultSpan, int flag = 0, int border = 0, wxObject* userData = NULL) bool Add(wxGBSizerItem* item) The Add methods return true if the item was successfully placed at the given position,

609


CHAPTER 7
false if something was already there.

wxGridBagSizer::CalcMin
wxSize CalcMin() Called when the managed size of the sizer is needed or when layout needs done.

wxGridBagSizer::CheckForIntersection
bool CheckForIntersection(wxGBSizerItem* item, wxGBSizerItem* excludeItem = NULL) bool CheckForIntersection(const wxGBPosition& pos, const wxGBSpan& span, wxGBSizerItem* excludeItem = NULL) Look at all items and see if any intersect (or would overlap) the given item. Returns true if so, false if there would be no overlap. If an excludeItem is given then it will not be checked for intersection, for example it may be the item we are checking the position of.

wxGridBagSizer::FindItem
wxGBSizerItem* FindItem(wxWindow* window) wxGBSizerItem* FindItem(wxSizer* sizer) Find the sizer item for the given window or subsizer, returns NULL if not found. (nonrecursive)

wxGridBagSizer::FindItemAtPoint
wxGBSizerItem* FindItemAtPoint(const wxPoint& pt) Return the sizer item located at the point given in pt, or NULL if there is no item at that point. The (x,y) coordinates in pt correspond to the client coordinates of the window using the sizer for layout. (non-recursive)

wxGridBagSizer::FindItemAtPosition
wxGBSizerItem* FindItemAtPosition(const wxGBPosition& pos) Return the sizer item for the given grid cell, or NULL if there is no item at that position. (non-recursive)

wxGridBagSizer::FindItemWithData

610


CHAPTER 7
wxGBSizerItem* FindItemWithData(const wxObject* userData) Return the sizer item that has a matching user data (it only compares pointer values) or NULL if not found. (non-recursive)

wxGridBagSizer::GetCellSize
wxSize GetCellSize(int row, int col) const Get the size of the specified cell, including hgap and vgap. Only valid after a Layout.

wxGridBagSizer::GetEmptyCellSize
wxSize GetEmptyCellSize() const Get the size used for cells in the grid with no item.

wxGridBagSizer::GetItemPosition
wxGBPosition GetItemPosition(wxWindow* window) wxGBPosition GetItemPosition(wxSizer* sizer) wxGBPosition GetItemPosition(size_t index) Get the grid position of the specified item.

wxGridBagSizer::GetItemSpan
wxGBSpan GetItemSpan(wxWindow* window) wxGBSpan GetItemSpan(wxSizer* sizer) wxGBSpan GetItemSpan(size_t index) Get the row/col spanning of the specified item

wxGridBagSizer::RecalcSizes
void RecalcSizes() Called when the managed size of the sizer is needed or when layout needs done.

wxGridBagSizer::SetEmptyCellSize
void SetEmptyCellSize(const wxSize& sz)

611


CHAPTER 7
Set the size used for cells in the grid with no item.

wxGridBagSizer::SetItemPosition
bool SetItemPosition(wxWindow* window, const wxGBPosition& pos) bool SetItemPosition(wxSizer* sizer, const wxGBPosition& pos) bool SetItemPosition(size_t index, const wxGBPosition& pos) Set the grid position of the specified item. Returns true on success. If the move is not allowed (because an item is already there) then false is returned.

wxGridBagSizer::SetItemSpan
bool SetItemSpan(wxWindow* window, const wxGBSpan& span) bool SetItemSpan(wxSizer* sizer, const wxGBSpan& span) bool SetItemSpan(size_t index, const wxGBSpan& span) Set the row/col spanning of the specified item. Returns true on success. If the move is not allowed (because an item is already there) then false is returned.

wxGridCellBoolEditor
The editor for boolean data. Derived from wxGridCellEditor (p. 613) See also wxGridCellEditor (p. 613), wxGridCellFloatEditor (p. 616), wxGridCellNumberEditor (p. 616), wxGridCellTextEditor (p. 617), wxGridCellChoiceEditor (p. 612)

wxGridCellBoolEditor::wxGridCellBoolEditor
wxGridCellBoolEditor() Default constructor.

wxGridCellChoiceEditor

612


CHAPTER 7
The editor for string data allowing to choose from a list of strings. Derived from wxGridCellEditor (p. 613) See also wxGridCellEditor (p. 613), wxGridCellFloatEditor (p. 616), wxGridCellBoolEditor (p. 612), wxGridCellTextEditor (p. 617), wxGridCellNumberEditor (p. 616)

wxGridCellChoiceEditor::wxGridCellChoiceEditor
wxGridCellChoiceEditor(size_t count = 0, const wxString choices[] = NULL, bool allowOthers = false) wxGridCellChoiceEditor(const wxArrayString&choices, bool allowOthers = false) count Number of strings from which the user can choose. choices An array of strings from which the user can choose. allowOthers If allowOthers if true, the user can type a string not in choices array.

wxGridCellChoiceEditor::SetParameters
void SetParameters(const wxString& params) Parameters string format is "item1[,item2[...,itemN]]"

wxGridCellEditor
This class is responsible for providing and manipulating the in-place edit controls for the grid. Instances of wxGridCellEditor (actually, instances of derived classes since it is an abstract class) can be associated with the cell attributes for individual cells, rows, columns, or even for the entire grid. Derived from wxGridCellWorker See also

613


CHAPTER 7
wxGridCellTextEditor (p. 617), wxGridCellFloatEditor (p. 616), wxGridCellBoolEditor (p. 612), wxGridCellNumberEditor (p. 616), wxGridCellChoiceEditor (p. 612)

wxGridCellEditor::wxGridCellEditor
wxGridCellEditor()

wxGridCellEditor::IsCreated
bool IsCreated()

wxGridCellEditor::Create
void Create(wxWindow* parent, wxWindowID id, wxEvtHandler* evtHandler) Creates the actual edit control.

wxGridCellEditor::SetSize
void SetSize(const wxRect& rect) Size and position the edit control.

wxGridCellEditor::Show
void Show(bool show, wxGridCellAttr* attr = NULL) Show or hide the edit control, use the specified attributes to set colours/fonts for it.

wxGridCellEditor::PaintBackground
void PaintBackground(const wxRect& rectCell, wxGridCellAttr* attr) Draws the part of the cell not occupied by the control: the base class version just fills it with background colour from the attribute.

wxGridCellEditor::BeginEdit
void BeginEdit(int row, int col, wxGrid* grid) Fetch the value from the table and prepare the edit control to begin editing. Set the focus to the edit control.

614


CHAPTER 7 wxGridCellEditor::EndEdit
bool EndEdit(int row, int col, wxGrid* grid) Complete the editing of the current cell. Returns true if the value has changed. If necessary, the control may be destroyed.

wxGridCellEditor::Reset
void Reset() Reset the value in the control back to its starting value.

wxGridCellEditor::StartingKey
void StartingKey(wxKeyEvent& event) If the editor is enabled by pressing keys on the grid, this will be called to let the editor do something about that first key if desired.

wxGridCellEditor::StartingClick
void StartingClick() If the editor is enabled by clicking on the cell, this method will be called.

wxGridCellEditor::HandleReturn
void HandleReturn(wxKeyEvent& event) Some types of controls on some platforms may need some help with the Return key.

wxGridCellEditor::Destroy
void Destroy() Final cleanup.

wxGridCellEditor::Clone
wxGridCellEditor* Clone() const Create a new object which is the copy of this one.

wxGridCellEditor::~wxGridCellEditor 615


CHAPTER 7
~wxGridCellEditor() The dtor is private because only DecRef() can delete us.

wxGridCellFloatEditor
The editor for floating point numbers data. Derived from wxGridCellTextEditor (p. 617) wxGridCellEditor (p. 613) See also wxGridCellEditor (p. 613), wxGridCellNumberEditor (p. 616), wxGridCellBoolEditor (p. 612), wxGridCellTextEditor (p. 617), wxGridCellChoiceEditor (p. 612)

wxGridCellFloatEditor::wxGridCellFloatEditor
wxGridCellFloatEditor(int width = -1, int precision = -1) width Minimum number of characters to be shown. precision Number of digits after the decimal dot.

wxGridCellFloatEditor::SetParameters
void SetParameters(const wxString& params) Parameters string format is "width,precision"

wxGridCellNumberEditor
The editor for numeric integer data. Derived from wxGridCellTextEditor (p. 617) wxGridCellEditor (p. 613) See also

616


CHAPTER 7
wxGridCellEditor (p. 613), wxGridCellFloatEditor (p. 616), wxGridCellBoolEditor (p. 612), wxGridCellTextEditor (p. 617), wxGridCellChoiceEditor (p. 612)

wxGridCellNumberEditor::wxGridCellNumberEditor
wxGridCellNumberEditor(int min = -1, int max = -1) Allows to specify the range for acceptable data; if min == max == -1, no range checking is done

wxGridCellNumberEditor::GetString
wxString GetString() const String representation of the value.

wxGridCellNumberEditor::HasRange
bool HasRange() const If the return value is true, the editor uses a wxSpinCtrl to get user input, otherwise it uses a wxTextCtrl.

wxGridCellNumberEditor::SetParameters
void SetParameters(const wxString& params) Parameters string format is "min,max".

wxGridCellTextEditor
The editor for string/text data. Derived from wxGridCellEditor (p. 613) See also wxGridCellEditor (p. 613), wxGridCellFloatEditor (p. 616), wxGridCellBoolEditor (p. 612), wxGridCellNumberEditor (p. 616), wxGridCellChoiceEditor (p. 612)

617


CHAPTER 7 wxGridCellTextEditor::wxGridCellTextEditor
wxGridCellTextEditor() Default constructor.

wxGridCellTextEditor::SetParameters
void SetParameters(const wxString& params) The parameters string format is "n" where n is a number representing the maximum width.

wxGridEditorCreatedEvent
Derived from wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Event handling The event handler for the following functions takes a wxGridEditorCreatedEvent (p. 618) parameter. EVT_GRID_EDITOR_CREATED(func) The editor for a cell was created. Processes a wxEVT_GRID_EDITOR_CREATED.

wxGridEditorCreatedEvent::wxGridEditorCreatedEvent
wxGridEditorCreatedEvent() Default constructor. wxGridEditorCreatedEvent(int id, wxEventType type, wxObject* obj, int row, int col, wxControl* ctrl)

wxGridEditorCreatedEvent::GetCol
int GetCol() Returns the column at which the event occurred.

wxGridEditorCreatedEvent::GetControl

618


CHAPTER 7
wxControl* GetControl() Returns the edit control.

wxGridEditorCreatedEvent::GetRow
int GetRow() Returns the row at which the event occurred.

wxGridEditorCreatedEvent::SetCol
void SetCol(int col) Sets the column at which the event occurred.

wxGridEditorCreatedEvent::SetControl
void SetControl(wxControl* ctrl) Sets the edit control.

wxGridEditorCreatedEvent::SetRow
void SetRow(int row) Sets the row at which the event occurred.

wxGridEvent
This event class contains information about various grid events. Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/grid.h> Event handling The event handler for the following functions takes a wxGridEvent (p. 619) parameter. EVT_GRID_CELL_LEFT_CLICK(func) The user clicked a cell with the left mouse

619


CHAPTER 7
button. Processes a wxEVT_GRID_CELL_LEFT_CLICK. EVT_GRID_CELL_RIGHT_CLICK(func) The user clicked a cell with the right mouse button. Processes a wxEVT_GRID_CELL_RIGHT_CLICK. EVT_GRID_CELL_LEFT_DCLICK(func) The user double-clicked a cell with the left mouse button. Processes a wxEVT_GRID_CELL_LEFT_DCLICK. EVT_GRID_CELL_RIGHT_DCLICK(func) The user double-clicked a cell with the right mouse button. Processes a wxEVT_GRID_CELL_RIGHT_DCLICK. EVT_GRID_LABEL_LEFT_CLICK(func) The user clicked a label with the left mouse button. Processes a wxEVT_GRID_LABEL_LEFT_CLICK. EVT_GRID_LABEL_RIGHT_CLICK(func) The user clicked a label with the right mouse button. Processes a wxEVT_GRID_LABEL_RIGHT_CLICK. EVT_GRID_LABEL_LEFT_DCLICK(func) The user double-clicked a label with the left mouse button. Processes a wxEVT_GRID_LABEL_LEFT_DCLICK. EVT_GRID_LABEL_RIGHT_DCLICK(func) The user double-clicked a label with the right mouse button. Processes a wxEVT_GRID_LABEL_RIGHT_DCLICK. EVT_GRID_CELL_CHANGE(func) EVT_GRID_SELECT_CELL(func) EVT_GRID_EDITOR_HIDDEN(func) EVT_GRID_EDITOR_SHOWN(func) The user changed the data in a cell. Processes a wxEVT_GRID_CELL_CHANGE. The user moved to, and selected a cell. Processes a wxEVT_GRID_SELECT_CELL. The editor for a cell was hidden. Processes a wxEVT_GRID_EDITOR_HIDDEN. The editor for a cell was shown. Processes a wxEVT_GRID_EDITOR_SHOWN.

wxGridEvent::wxGridEvent
wxGridEvent() Default constructor. wxGridEvent(int id, wxEventType type, wxObject* obj, int row = -1, int col = -1, int x = -1, int y = -1, bool sel = true, bool control = false, bool shift = false, bool alt = false,

620


CHAPTER 7
bool meta = false) Parameters

wxGridEvent::AltDown
bool AltDown() Returns true if the Alt key was down at the time of the event.

wxGridEvent::ControlDown
bool ControlDown() Returns true if the Control key was down at the time of the event.

wxGridEvent::GetCol
int GetCol() Column at which the event occurred.

wxGridEvent::GetPosition
wxPoint GetPosition() Position in pixels at which the event occurred.

wxGridEvent::GetRow
int GetRow() Row at which the event occurred.

wxGridEvent::MetaDown
bool MetaDown() Returns true if the Meta key was down at the time of the event.

wxGridEvent::Selecting
bool Selecting() Returns true if the user deselected a cell, false if the user deselected a cell.

621


CHAPTER 7 wxGridEvent::ShiftDown
bool ShiftDown() Returns true if the Shift key was down at the time of the event.

wxGridRangeSelectEvent
Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Event handling The event handler for the following functions takes a wxGridRangeSelectEvent (p. 622) parameter. EVT_GRID_RANGE_SELECT(func) The user selected a group of contiguous cells. Processes a wxEVT_GRID_RANGE_SELECT.

wxGridRangeSelectEvent::wxGridRangeSelectEvent
wxGridRangeSelectEvent() Default constructor. wxGridRangeSelectEvent(int id, wxEventType type, wxObject* obj, const wxGridCellCoords& topLeft, const wxGridCellCoords& bottomRight, bool sel = true, bool control = false, bool shift = false, bool alt = false, bool meta = false)

wxGridRangeSelectEvent::AltDown
bool AltDown() Returns true if the Alt key was down at the time of the event.

wxGridRangeSelectEvent::ControlDown
bool ControlDown() Returns true if the Control key was down at the time of the event.

wxGridRangeSelectEvent::GetBottomRightCoords 622


CHAPTER 7
wxGridCellCoords GetBottomRightCoords() Top left corner of the rectangular area that was (de)selected.

wxGridRangeSelectEvent::GetBottomRow
int GetBottomRow() Bottom row of the rectangular area that was (de)selected.

wxGridRangeSelectEvent::GetLeftCol
int GetLeftCol() Left column of the rectangular area that was (de)selected.

wxGridRangeSelectEvent::GetRightCol
int GetRightCol() Right column of the rectangular area that was (de)selected.

wxGridRangeSelectEvent::GetTopLeftCoords
wxGridCellCoords GetTopLeftCoords() Top left corner of the rectangular area that was (de)selected.

wxGridRangeSelectEvent::GetTopRow
int GetTopRow() Top row of the rectangular area that was (de)selected.

wxGridRangeSelectEvent::MetaDown
bool MetaDown() Returns true if the Meta key was down at the time of the event.

wxGridRangeSelectEvent::Selecting
bool Selecting() Returns true if the area was selected, false otherwise.

623


CHAPTER 7 wxGridRangeSelectEvent::ShiftDown
bool ShiftDown() Returns true if the Shift key was down at the time of the event.

wxGridSizeEvent
This event class contains information about a row/column resize event. Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/grid.h> Event handling The event handler for the following functions takes a wxGridSizeEvent (p. 624) parameter. EVT_GRID_COL_SIZE(func) EVT_GRID_ROW_SIZE(func) The user resized a column by dragging it. Processes a wxEVT_GRID_COL_SIZE. The user resized a row by dragging it. Processes a wxEVT_GRID_ROW_SIZE.

wxGridSizeEvent::wxGridSizeEvent
wxGridSizeEvent() Default constructor. wxGridSizeEvent(int id, wxEventType type, wxObject* obj, int rowOrCol = -1, int x = -1, int y = -1, bool control = false, bool shift = false, bool alt = false, bool meta = false)

wxGridSizeEvent::AltDown
bool AltDown() Returns true if the Alt key was down at the time of the event.

624


CHAPTER 7 wxGridSizeEvent::ControlDown
bool ControlDown() Returns true if the Control key was down at the time of the event.

wxGridSizeEvent::GetPosition
wxPoint GetPosition() Position in pixels at which the event occurred.

wxGridSizeEvent::GetRowOrCol
int GetRowOrCol() Row or column at that was resized.

wxGridSizeEvent::MetaDown
bool MetaDown() Returns true if the Meta key was down at the time of the event.

wxGridSizeEvent::ShiftDown
bool ShiftDown() Returns true if the Shift key was down at the time of the event.

wxGridCellBoolRenderer
This class may be used to format boolean data in a cell. for string cells. Derived from wxGridCellRenderer (p. 627) See also wxGridCellRenderer (p. 627), wxGridCellStringRenderer (p. 628), wxGridCellFloatRenderer (p. 626), wxGridCellNumberRenderer (p. 627)

wxGridCellBoolRenderer::wxGridCellBoolRenderer 625


CHAPTER 7
wxGridCellBoolRenderer() Default constructor

wxGridCellFloatRenderer
This class may be used to format floating point data in a cell. Derived from wxGridCellStringRenderer (p. 628) wxGridCellRenderer (p. 627) See also wxGridCellRenderer (p. 627), wxGridCellNumberRenderer (p. 627), wxGridCellStringRenderer (p. 628), wxGridCellBoolRenderer (p. 625)

wxGridCellFloatRenderer::wxGridCellFloatRenderer
wxGridCellFloatRenderer(int width = -1, int precision = -1) width Minimum number of characters to be shown. precision Number of digits after the decimal dot.

wxGridCellFloatRenderer::GetPrecision
int GetPrecision() const Returns the precision ( see wxGridCellFloatRenderer (p. 626) ).

wxGridCellFloatRenderer::GetWidth
int GetWidth() const Returns the width ( see wxGridCellFloatRenderer (p. 626) ).

wxGridCellFloatRenderer::SetParameters
void SetParameters(const wxString& params)

626


CHAPTER 7
Parameters string format is "width[,precision]".

wxGridCellFloatRenderer::SetPrecision
void SetPrecision(int precision) Sets the precision ( see wxGridCellFloatRenderer (p. 626) ).

wxGridCellFloatRenderer::SetWidth
void SetWidth(int width) Sets the width ( see wxGridCellFloatRenderer (p. 626) )

wxGridCellNumberRenderer
This class may be used to format integer data in a cell. Derived from wxGridellStringRenderer (p. 628) wxGridCellRenderer (p. 627) See also wxGridCellRenderer (p. 627), wxGridCellStringRenderer (p. 628), wxGridCellFloatRenderer (p. 626), wxGridCellBoolRenderer (p. 625)

wxGridCellNumberRenderer::wxGridCellNumberRenderer
wxGridCellNumberRenderer() Default constructor

wxGridCellRenderer
This class is responsible for actually drawing the cell in the grid. You may pass it to the wxGridCellAttr (below) to change the format of one given cell or to wxGrid::SetDefaultRenderer() to change the view of all cells. This is an abstract class, and you will normally use one of the predefined derived classes or derive your own class from it. Derived from wxGridCellWorker

627


CHAPTER 7
See also wxGridCellStringRenderer (p. 628), wxGridCellNumberRenderer (p. 627), wxGridCellFloatRenderer (p. 626), wxGridCellBoolRenderer (p. 625)

wxGridCellRenderer::Draw
void Draw(wxGrid& grid, wxGridCellAttr& attr, wxDC& dc, const wxRect& rect, int row, int col, bool isSelected) Draw the given cell on the provided DC inside the given rectangle using the style specified by the attribute and the default or selected state corresponding to the isSelected value. This pure virtual function has a default implementation which will prepare the DC using the given attribute: it will draw the rectangle with the background colour from attr and set the text colour and font.

wxGridCellRenderer::GetBestSize
wxSize GetBestSize(wxGrid& grid, wxGridCellAttr& attr, wxDC& dc, int row, int col) Get the preferred size of the cell for its contents.

wxGridCellRenderer::Clone
wxGridCellRenderer* Clone() const

wxGridCellStringRenderer
This class may be used to format string data in a cell; it is the default for string cells. Derived from wxGridCellRenderer (p. 627) See also wxGridCellRenderer (p. 627), wxGridCellNumberRenderer (p. 627), wxGridCellFloatRenderer (p. 626), wxGridCellBoolRenderer (p. 625)

wxGridCellStringRenderer::wxGridCellStringRenderer

628


CHAPTER 7
wxGridCellStringRenderer() Default constructor

wxGridTableBase
Grid table classes. Derived from wxObject (p. 954) Data structures

wxGridTableBase::wxGridTableBase
wxGridTableBase()

wxGridTableBase::~wxGridTableBase
~wxGridTableBase()

wxGridTableBase::GetNumberRows
int GetNumberRows() You must override these functions in a derived table class.

wxGridTableBase::GetNumberCols
int GetNumberCols()

wxGridTableBase::IsEmptyCell
bool IsEmptyCell(int row, int col)

wxGridTableBase::GetValue
wxString GetValue(int row, int col)

wxGridTableBase::SetValue 629


CHAPTER 7
void SetValue(int row, int col, const wxString& value)

wxGridTableBase::GetTypeName
wxString GetTypeName(int row, int col) Data type determination and value access.

wxGridTableBase::CanGetValueAs
bool CanGetValueAs(int row, int col, const wxString& typeName)

wxGridTableBase::CanSetValueAs
bool CanSetValueAs(int row, int col, const wxString& typeName)

wxGridTableBase::GetValueAsLong
long GetValueAsLong(int row, int col)

wxGridTableBase::GetValueAsDouble
double GetValueAsDouble(int row, int col)

wxGridTableBase::GetValueAsBool
bool GetValueAsBool(int row, int col)

wxGridTableBase::SetValueAsLong
void SetValueAsLong(int row, int col, long value)

wxGridTableBase::SetValueAsDouble
void SetValueAsDouble(int row, int col, double value)

wxGridTableBase::SetValueAsBool
void SetValueAsBool(int row, int col, bool value)

630


CHAPTER 7 wxGridTableBase::GetValueAsCustom
void* GetValueAsCustom(int row, int col, const wxString& typeName) For user defined types

wxGridTableBase::SetValueAsCustom
void SetValueAsCustom(int row, int col, const wxString& typeName, void* value)

wxGridTableBase::SetView
void SetView(wxGrid* grid) Overriding these is optional

wxGridTableBase::GetView
wxGrid * GetView() const

wxGridTableBase::Clear
void Clear()

wxGridTableBase::InsertRows
bool InsertRows(size_t pos = 0, size_t numRows = 1)

wxGridTableBase::AppendRows
bool AppendRows(size_t numRows = 1)

wxGridTableBase::DeleteRows
bool DeleteRows(size_t pos = 0, size_t numRows = 1)

wxGridTableBase::InsertCols
bool InsertCols(size_t pos = 0, size_t numCols = 1)

wxGridTableBase::AppendCols

631


CHAPTER 7
bool AppendCols(size_t numCols = 1)

wxGridTableBase::DeleteCols
bool DeleteCols(size_t pos = 0, size_t numCols = 1)

wxGridTableBase::GetRowLabelValue
wxString GetRowLabelValue(int row)

wxGridTableBase::GetColLabelValue
wxString GetColLabelValue(int col)

wxGridTableBase::SetRowLabelValue
void SetRowLabelValue(int WXUNUSED(row), const wxString&)

wxGridTableBase::SetColLabelValue
void SetColLabelValue(int WXUNUSED(col), const wxString&)

wxGridTableBase::SetAttrProvider
void SetAttrProvider(wxGridCellAttrProvider* attrProvider) Attribute handling give us the attr provider to use - we take ownership of the pointer

wxGridTableBase::GetAttrProvider
wxGridCellAttrProvider* GetAttrProvider() const get the currently used attr provider (may be NULL)

wxGridTableBase::CanHaveAttributes
bool CanHaveAttributes() Does this table allow attributes? Default implementation creates a wxGridCellAttrProvider if necessary.

wxGridTableBase::UpdateAttrRows 632


CHAPTER 7
void UpdateAttrRows(size_t pos, int numRows) change row/col number in attribute if needed

wxGridTableBase::UpdateAttrCols
void UpdateAttrCols(size_t pos, int numCols)

wxGridTableBase::GetAttr
wxGridCellAttr* GetAttr(int row, int col) by default forwarded to wxGridCellAttrProvider if any. May be overridden to handle attributes directly in the table.

wxGridTableBase::SetAttr
void SetAttr(wxGridCellAttr* attr, int row, int col) these functions take ownership of the pointer

wxGridTableBase::SetRowAttr
void SetRowAttr(wxGridCellAttr* attr, int row)

wxGridTableBase::SetColAttr
void SetColAttr(wxGridCellAttr* attr, int col)

wxGridSizer
A grid sizer is a sizer which lays out its children in a two-dimensional table with all table fields having the same size, i.e. the width of each field is the width of the widest child, the height of each field is the height of the tallest child. Derived from wxSizer (p. 1109) wxObject (p. 954) See also wxSizer (p. 1109), Sizer overview (p. 1620)

633


CHAPTER 7 wxGridSizer::wxGridSizer
wxGridSizer(int rows, int cols, int vgap, int hgap) wxGridSizer(int cols, int vgap = 0, int hgap = 0) Constructor for a wxGridSizer. rows and cols determine the number of columns and rows in the sizer - if either of the parameters is zero, it will be calculated to form the total number of children in the sizer, thus making the sizer grow dynamically. vgap and hgap define extra space between all children.

wxGridSizer::GetCols
int GetCols() Returns the number of columns in the sizer.

wxGridSizer::GetHGap
int GetHGap() Returns the horizontal gap (in pixels) between cells in the sizer.

wxGridSizer::GetRows
int GetRows() Returns the number of rows in the sizer.

wxGridSizer::GetVGap
int GetVGap() Returns the vertical gap (in pixels) between the cells in the sizer.

wxGridSizer::SetCols
void SetCols(int cols) Sets the number of columns in the sizer.

wxGridSizer::SetHGap
void SetHGap(int gap) Sets the horizontal gap (in pixels) between cells in the sizer.

634


CHAPTER 7 wxGridSizer::SetRows
void SetRows(int rows) Sets the number of rows in the sizer.

wxGridSizer::SetVGap
void SetVGap(int gap) Sets the vertical gap (in pixels) between the cells in the sizer.

wxGzipInputStream
A stream filter to decompress gzipped data. The gzip format is specified in RFC-1952. A gzip stream can contain the original filename and timestamp of the compressed data. These fields can be obtained using the GetName() (p. 636) and GetDateTime() (p. 636) accessors. If the stream turns out not to be a gzip stream (i.e. the signature bytes 0x1f, 0x8b are not found), then the constructor unreads the bytes read and sets the stream state to wxSTREAM_EOF. So given a possibly gzipped stream 'maybe_gzipped' you can construct a decompressed stream 'decompressed' with something like:
wxGzipInputStream gzip(maybe_gzipped); wxInputStream *decompressed = &gzip; if (gzip.Eof()) decompressed = &maybe_gzipped;

The stream will not read past the end of the gzip data, therefore you can read another gzip entry concatenated by creating another wxGzipInputStream on the same underlying stream. The stream is not seekable, SeekI() (p. 763) returns wxInvalidOffset. Also GetSize() (p. 1192) is not supported, it always returns 0. Derived from wxFilterInputStream (p. 501) Include files <wx/gzstream.h> See also wxGzipOutputStream (p. 636), wxZlibInputStream (p. 1457), wxInputStream (p. 762).

635


CHAPTER 7 wxGzipInputStream::wxGzipInputStream
wxGzipInputStream(wxInputStream& stream, wxMBConv& conv = wxConvFile) Constructs an object to decompress a gzipped stream. The constructor reads the gzip header. If the original file name and timestamp are present, then they can be obtained through the GetName() (p. 636) and GetDateTime() (p. 636) accessors. The filename in the header is stored using an 8-bit character set. In a Unicode build conv is used to translate the filename into Unicode (it has no effect on the stream data). RFC1952 specifies that the character set should be ISO-8859-1, however the default here is to use wxConvFile which more closely matches the behaviour of the gzip program. In a non-Unicode build conv is ignored. If the first two bytes are not the gzip signature, then the data is not gzipped after all. The stream state is set to wxSTREAM_EOF, and the two bytes are unread so that the underlying stream can be read directly.

wxGzipInputStream::~wxGzipInputStream
~wxGzipInputStream() Destructor.

wxGzipInputStream::GetDateTime
wxDateTime GetDateTime() const Returns the original modification time of gzipped data, as obtained from the gzip header.

wxGzipInputStream::GetName
wxString GetName() const Returns the original filename of gzipped data, with any directory components removed.

wxGzipOutputStream
A stream filter to compress gzipped data. The gzip format is specified in RFC-1952. The stream is not seekable, SeekO() (p. 959) returns wxInvalidOffset. Derived from wxFilterOutputStream (p. 502)

636


CHAPTER 7
Include files <wx/gzstream.h> See also wxGzipInputStream (p. 635), wxZlibOutputStream (p. 1458), wxOutputStream (p. 958).

wxGzipOutputStream::wxGzipOutputStream
wxGzipOutputStream(wxOutputStream& stream, const wxString& originalName = wxEmptyString, const wxDateTime& originalTime = wxDateTime::Now(), int level = -1, wxMBConv& conv = wxConvFile) If the originalName is given, then it is written to the gzip header with any directory components removed. On a Unicode build it is first converted to an 8-bit encoding using conv. RFC-1952 specifies that the character set should be ISO-8859-1, however the default here is to use wxConvFile which more closely matches the behaviour of the gzip program. In a non-Unicode build conv is ignored. conv has no effect on the stream data. If originalTime is given then it is also written to the gzip header as the timestamp. If omitted the current time is used. level is the compression level. It can be an integer between 0 (no compression) and 9 (most compression). -1 specifies that the default compression should be used, and is currently equivalent to 6. You can also use the following constants from <wx/zstream.h>:
// Compression level enum { wxZ_DEFAULT_COMPRESSION = -1, wxZ_NO_COMPRESSION = 0, wxZ_BEST_SPEED = 1, wxZ_BEST_COMPRESSION = 9 }

wxGzipOutputStream::~wxGzipOutputStream
~wxGzipOutputStream() Destructor.

wxHashMap
This is a simple, type-safe, and reasonably efficient hash map class, whose interface is a subset of the interface of STL containers. In particular, the interface is modelled after std::map, and the various, non standard, std::hash_map.

637


CHAPTER 7
Example
class MyClass { /* ... */ }; // declare a hash map with string keys and int values WX_DECLARE_STRING_HASH_MAP( int, MyHash5 ); // same, with int keys and MyClass* values WX_DECLARE_HASH_MAP( int, MyClass*, wxIntegerHash, wxIntegerEqual, MyHash1 ); // same, with wxString keys and int values WX_DECLARE_STRING_HASH_MAP( int, MyHash3 ); // same, with wxString keys and values WX_DECLARE_STRING_HASH_MAP( wxString, MyHash2 ); MyHash1 h1; MyHash2 h2; // store and retrieve values h1[1] = new MyClass( 1 ); h1[10000000] = NULL; h1[50000] = new MyClass( 2 ); h2["Bill"] = "ABC"; wxString tmp = h2["Bill"]; // since element with key "Joe" is not present, this will return // the default value, which is an empty string in the case of wxString MyClass tmp2 = h2["Joe"]; // iterate over all the elements in the class MyHash2::iterator it; for( it = h2.begin(); it != h2.end(); ++it ) { wxString key = it->first, value = it->second; // do something useful with key and value }

Declaring new hash table types
WX_DECLARE_STRING_HASH_MAP( VALUE_T, // type of the values CLASSNAME ); // name of the class

Declares an hash map class named CLASSNAME, with wxString keys and VALUE_T values.
WX_DECLARE_VOIDPTR_HASH_MAP( VALUE_T, // type of the values CLASSNAME ); // name of the class

Declares an hash map class named CLASSNAME, with void* keys and VALUE_T values.
WX_DECLARE_HASH_MAP( KEY_T, VALUE_T, HASH_T, KEY_EQ_T, CLASSNAME); // // // // // type of the keys type of the values hasher key equality predicate name of the class

The HASH_T and KEY_EQ_T are the types used for the hashing function and key comparison. wxWindows provides three predefined hashing functions: wxIntegerHashfor integer types ( int, long, short, and their unsigned counterparts ), wxStringHash for strings ( wxString, wxChar*, char* ), andwxPointerHash for any kind of pointer. Similarly three equality predicates:wxIntegerEqual, wxStringEqual, wxPointerEqual are provided. Using this you could declare an hash map mapping int values to wxString like this:

638


CHAPTER 7
WX_DECLARE_HASH_MAP( int, wxString, wxIntegerHash, wxIntegerEqual, MyHash ); // using an user-defined class for keys class MyKey { /* ... */ }; // hashing function class MyKeyHash { public: MyKeyHash() { } unsigned long operator()( const MyKey& k ) const { /* compute the hash */ } MyKeyHash& operator=(const MyKeyHash&) { return *this; } }; // comparison operator class MyKeyEqual { public: MyKeyEqual() { } bool operator()( const MyKey& a, const MyKey& b ) const { /* compare for equality */ } MyKeyEqual& operator=(const MyKeyEqual&) { return *this; } }; WX_DECLARE_HASH_MAP( MyKey, SOME_TYPE, MyKeyHash, MyKeyEqual, CLASSNAME); // // // // // type of the keys any type you like hasher key equality predicate name of the class

In the documentation below you should replace wxHashMap with the name you used in the class declaration. wxHashMap::key_type wxHashMap::mapped_type wxHashMap::value_type wxHashMap::iterator wxHashMap::const_iterator Type of the hash keys Type of the values stored in the hash map Equivalent tostruct { key_type first; mapped_type second }; Used to enumerate all the elements in an hash map; it is similar to a value_type* Used to enumerate all the elements in a constant hash map; it is similar to a const value_type* Used for sizes

wxHashMap::size_type Iterators

An iterator is similar to a pointer, and so you can use the usual pointer operations: ++it ( and it++ ) to move to the next element,*it to access the element pointed to, it>first( it->second ) to access the key ( value ) of the element pointed to. Hash

639


CHAPTER 7
maps provide forward only iterators, this means that you can't use --it, it + 3, it1 - it2. Include files <wx/hashmap.h>

wxHashMap::wxHashMap
wxHashMap(size_type size = 10) The size parameter is just an hint, the table will resize automatically to preserve performance. wxHashMap(const wxHashMap& map) Copy constructor.

wxHashMap::begin
const_iterator begin() const iterator begin() Returns an iterator pointing at the first element of the hash map. Please remember that hash maps do not guarantee ordering.

wxHashMap::clear
void clear() Removes all elements from the hash map.

wxHashMap::count
size_type count(const key_type& key) const Counts the number of elements with the given key present in the map. This function can actually return 0 or 1.

wxHashMap::empty
bool empty() const Returns true if the hash map does not contain any element, false otherwise.

640


CHAPTER 7 wxHashMap::end
const_iterator end() const iterator end() Returns an iterator pointing at the one-after-the-last element of the hash map. Please remember that hash maps do not guarantee ordering.

wxHashMap::erase
size_type erase(const key_type& key) Erases the element with the given key, and returns the number of element erased (either 0 or 1). void erase(iterator it) void erase(const_iterator it) Erases the element pointed to by the iterator. After the deletion the iterator is no longer valid and must not be used.

wxHashMap::find
iterator find(const key_type& key) const_iterator find(const key_type& key) const If an element with the given key is present, the functions returns an iterator pointing at that element, otherwise an invalid iterator is returned (i.e. hashmap.find( non_existent_key ) == hashmap.end()).

wxHashMap::insert
void insert(const value_type& v) Inserts the given value in the hash map.

wxHashMap::operator[]
mapped_type& operator[](const key_type& key) Use it as an array subscript. The only difference is that if the given key is not present in the hash map, an element with the default value_type() is inserted in the table.

wxHashMap::size

641


CHAPTER 7
size_type size() const Returns the numbers of elements in the map.

wxHashTable
Please note that this class is retained for backward compatibility reasons; you should use wxHashMap (p. 637). This class provides hash table functionality for wxWindows, and for an application if it wishes. Data can be hashed on an integer or string key. Derived from wxObject (p. 954) Include files <wx/hash.h> Example Below is an example of using a hash table.
wxHashTable table(KEY_STRING); wxPoint *point = new wxPoint(100, 200); table.Put("point 1", point); .... wxPoint *found_point = (wxPoint *)table.Get("point 1");

A hash table is implemented as an array of pointers to lists. When no data has been stored, the hash table takes only a little more space than this array (default size is 1000). When a data item is added, an integer is constructed from the integer or string key that is within the bounds of the array. If the array element is NULL, a new (keyed) list is created for the element. Then the data object is appended to the list, storing the key in case other data objects need to be stored in the list also (when a 'collision' occurs). Retrieval involves recalculating the array index from the key, and searching along the keyed list for the data object whose stored key matches the passed key. Obviously this is quicker when there are fewer collisions, so hashing will become inefficient if the number of items to be stored greatly exceeds the size of the hash table. See also wxList (p. 786)

wxHashTable::wxHashTable

642


CHAPTER 7
wxHashTable(unsigned int key_type, int size = 1000) Constructor. key_type is one of wxKEY_INTEGER, or wxKEY_STRING, and indicates what sort of keying is required. size is optional.

wxHashTable::~wxHashTable
~wxHashTable() Destroys the hash table.

wxHashTable::BeginFind
void BeginFind() The counterpart of Next. If the application wishes to iterate through all the data in the hash table, it can call BeginFind and then loop on Next.

wxHashTable::Clear
void Clear() Clears the hash table of all nodes (but as usual, doesn't delete user data).

wxHashTable::Delete
wxObject * Delete(long key) wxObject * Delete(const wxString& key) Deletes entry in hash table and returns the user's data (if found).

wxHashTable::DeleteContents
void DeleteContents(bool flag) If set to true data stored in hash table will be deleted when hash table object is destroyed.

wxHashTable::Get
wxObject * Get(long key) wxObject * Get(const char* key) Gets data from the hash table, using an integer or string key (depending on which has

643


CHAPTER 7
table constructor was used).

wxHashTable::MakeKey
long MakeKey(const wxString& string) Makes an integer key out of a string. An application may wish to make a key explicitly (for instance when combining two data values to form a key).

wxHashTable::Next
wxHashTable::Node * Next() If the application wishes to iterate through all the data in the hash table, it can call BeginFind and then loop on Next. This function returns a wxHashTable::Node pointer (or NULL if there are no more nodes). The return value is functionally equivalent to wxNode but might not be implemented as a wxNode. The user will probably only wish to use theGetData method to retrieve the data; the node may also be deleted.

wxHashTable::Put
void Put(long key, wxObject *object) void Put(const char* key, wxObject *object) Inserts data into the hash table, using an integer or string key (depending on which has table constructor was used). The key string is copied and stored by the hash table implementation.

wxHashTable::GetCount
size_t GetCount() const Returns the number of elements in the hash table.

wxHelpController
This is a family of classes by which applications may invoke a help viewer to provide online help. A help controller allows an application to display help, at the contents or at a particular topic, and shut the help program down on termination. This avoids proliferation of many instances of the help viewer whenever the user requests a different topic via the application's menus or buttons. Typically, an application will create a help controller instance when it starts, and immediately call Initialize to associate a filename with it. The help viewer will only get

644


CHAPTER 7
run, however, just before the first call to display something. Most help controller classes actually derive from wxHelpControllerBase and have names of the form wxXXXHelpController or wxHelpControllerXXX. An appropriate class is aliased to the name wxHelpController for each platform, as follows:   On Windows, wxWinHelpController is used. On all other platforms, wxHtmlHelpController is used if wxHTML is compiled into wxWindows; otherwise wxExtHelpController is used (for invoking an external browser).

The remaining help controller classes need to be named explicitly by an application that wishes to make use of them. There are currently the following help controller classes defined:   wxW inHelpController, for controlling Windows Help. wxCHMHelpController, for controlling MS HTML Help. To use this, you need to set wxUSE_MS_HTML_HELP to 1 in setup.h and have htmlhelp.h header from Microsoft's HTML Help kit (you don't need VC++ specific htmlhelp.lib because wxWindows loads necessary DLL at runtime and so it works with all compilers). wxBestHelpController, for controlling MS HTML Help or, if Microsoft's runtime is not available, wxHtmlHelpController (p. 672). You need to provideboth CHM and HTB versions of the help file. For 32bit Windows only. wxExtHelpController, for controlling external browsers under Unix. The default browser is Netscape Navigator. The 'help' sample shows its use. wxHtmlHelpController (p. 672), a sophisticated help controller using wxHTML (p. 1691), in a similar style to the Microsoft HTML Help viewer and using some of the same files. Although it has an API compatible with other help controllers, it has more advanced features, so it is recommended that you use the specific API for this class instead. Note that if you use .zip or .htb formats for your books, you must add this line to your application initialization: wxFileSystem::AddHandler(new wxZipFSHandler);or nothing will be shown in your help window.



 

Derived from wxHelpControllerBase wxObject (p. 954) Include files <wx/help.h> (wxWindows chooses the appropriate help controller class) <wx/helpbase.h> (wxHelpControllerBase class) <wx/helpwin.h> (Windows Help controller) <wx/msw/helpchm.h> (MS HTML Help controller) <wx/generic/helpext.h> (external HTML browser controller) <wx/html/helpctrl.h> (wxHTML based help controller: wxHtmlHelpController)

645


CHAPTER 7
See also wxHtmlHelpController (p. 672), wxHTML (p. 1691)

wxHelpController::wxHelpController
wxHelpController() Constructs a help instance object, but does not invoke the help viewer.

wxHelpController::~wxHelpController
~wxHelpController() Destroys the help instance, closing down the viewer if it is running.

wxHelpController::Initialize
virtual void Initialize(const wxString& file) virtual void Initialize(const wxString& file, int server) Initializes the help instance with a help filename, and optionally a server socket number if using wxHelp (now obsolete). Does not invoke the help viewer. This must be called directly after the help instance object is created and before any attempts to communicate with the viewer. You may omit the file extension and a suitable one will be chosen. For wxHtmlHelpController, the extensions zip, htb and hhp will be appended while searching for a suitable file. For WinHelp, the hlp extension is appended.

wxHelpController::DisplayBlock
virtual bool DisplayBlock(long blockNo) If the help viewer is not running, runs it and displays the file at the given block number. WinHelp: Refers to the context number. MS HTML Help: Refers to the context number. External HTML help: the same as for wxHelpController::DisplaySection (p. 647). wxHtmlHelpController: sectionNo is an identifier as specified in the .hhc file. See Help files format (p. 1693). This function is for backward compatibility only, and applications should use

646


CHAPTER 7
wxHelpController (p. 647) instead.

wxHelpController::DisplayContents
virtual bool DisplayContents() If the help viewer is not running, runs it and displays the contents.

wxHelpController::DisplayContextPopup
virtual bool DisplayContextPopup(int contextId) Displays the section as a popup window using a context id. Returns false if unsuccessful or not implemented.

wxHelpController::DisplaySection
virtual bool DisplaySection(const wxString& section) If the help viewer is not running, runs it and displays the given section. The interpretation of section differs between help viewers. For most viewers, this call is equivalent to KeywordSearch. For MS HTML Help, wxHTML help and external HTML help, if section has a .htm or .html extension, that HTML file will be displayed; otherwise a keyword search is done. virtual bool DisplaySection(int sectionNo) If the help viewer is not running, runs it and displays the given section. WinHelp, MS HTML Help sectionNo is a context id. External HTML help: wxExtHelpController implements sectionNo as an id in a map file, which is of the form:
0 1 2 wx.html ; Index wx34.html#classref ; Class reference wx204.html ; Function reference

wxHtmlHelpController: sectionNo is an identifier as specified in the .hhc file. See Help files format (p. 1693). See also the help sample for notes on how to specify section numbers for various help file formats.

wxHelpController::DisplayTextPopup
virtual bool DisplayTextPopup(const wxString& text, const wxPoint& pos)

647


CHAPTER 7
Displays the text in a popup window, if possible. Returns false if unsuccessful or not implemented.

wxHelpController::GetFrameParameters
virtual wxFrame * GetFrameParameters(const wxSize * size = NULL, const wxPoint * pos = NULL, bool *newFrameEachTime = NULL) wxHtmlHelpController returns the frame, size and position. For all other help controllers, this function does nothing and just returns NULL. Parameters viewer This defaults to "netscape" for wxExtHelpController. flags This defaults to wxHELP_NETSCAPE for wxExtHelpController, indicating that the viewer is a variant of Netscape Navigator.

wxHelpController::KeywordSearch
virtual bool KeywordSearch(const wxString& keyWord, wxHelpSearchMode mode = wxHELP_SEARCH_ALL) If the help viewer is not running, runs it, and searches for sections matching the given keyword. If one match is found, the file is displayed at this section. The optional parameter allows the search the index (wxHELP_SEARCH_INDEX) but this currently only supported by the wxHtmlHelpController. WinHelp, MS HTML Help: If more than one match is found, the first topic is displayed. External HTML help, simple wxHTML help: If more than one match is found, a choice of topics is displayed. wxHtmlHelpController: see wxHtmlHelpController::KeywordSearch (p. 675).

wxHelpController::LoadFile
virtual bool LoadFile(const wxString& file = "") If the help viewer is not running, runs it and loads the given file. If the filename is not supplied or is empty, the file specified in Initialize is used. If the viewer is already displaying the specified file, it will not be reloaded. This member function may be used before each display call in case the user has opened another file.

648


CHAPTER 7
wxHtmlHelpController ignores this call.

wxHelpController::OnQuit
virtual bool OnQuit() Overridable member called when this application's viewer is quit by the user. This does not work for all help controllers.

wxHelpController::SetFrameParameters
virtual void SetFrameParameters(const wxString & title, const wxSize & size, const wxPoint & pos = wxDefaultPosition, bool newFrameEachTime = false) For wxHtmlHelpController, the title is set (again with %s indicating the page title) and also the size and position of the frame if the frame is already open. newFrameEachTime is ignored. For all other help controllers this function has no effect.

wxHelpController::SetViewer
virtual void SetViewer(const wxString& viewer, long flags) Sets detailed viewer information. So far this is only relevant to wxExtHelpController. Some examples of usage:
m_help.SetViewer("kdehelp"); m_help.SetViewer("gnome-help-browser"); m_help.SetViewer("netscape", wxHELP_NETSCAPE);

wxHelpController::Quit
virtual bool Quit() If the viewer is running, quits it by disconnecting. For Windows Help, the viewer will only close if no other application is using it.

wxHelpControllerHelpProvider
wxHelpControllerHelpProvider is an implementation of wxHelpProvider which supports both context identifiers and plain text help strings. If the help text is an integer, it is passed to wxHelpController::DisplayContextPopup. Otherwise, it shows the string in a tooltip as per wxSimpleHelpProvider. If you use this with a wxCHMHelpController instance on windows, it will use the native style of tip window instead of wxTipWindow

649


CHAPTER 7
(p. 1305). You can use the convenience function wxContextId to convert an integer context id to a string for passing to wxWindow::SetHelpText (p. 1425). Derived from wxSimpleHelpProvider (p. 1102) wxHelpProvider (p. 652) Include files <wx/cshelp.h> See also wxHelpProvider (p. 652), wxSimpleHelpProvider (p. 1102), wxContextHelp (p. 195), wxWindow::SetHelpText (p. 1425), wxWindow::GetHelpText (p. 1403)

wxHelpControllerHelpProvider::wxHelpControllerHelpProvider
wxHelpControllerHelpProvider(wxHelpControllerBase* hc = NULL) Note that the instance doesn't own the help controller. The help controller should be deleted separately.

wxHelpControllerHelpProvider::SetHelpController
void SetHelpController(wxHelpControllerBase* hc) Sets the help controller associated with this help provider.

wxHelpControllerHelpProvider::GetHelpController
wxHelpControllerBase* GetHelpController() const Returns the help controller associated with this help provider.

wxHelpEvent
A help event is sent when the user has requested context-sensitive help. This can either be caused by the application requesting context-sensitive help mode via wxContextHelp (p. 195), or (on MS Windows) by the system generating a WM_HELP message when the user pressed F1 or clicked on the query button in a dialog caption. A help event is sent to the window that the user clicked on, and is propagated up the window hierarchy until the event is processed or there are no more event handlers. The

650


CHAPTER 7
application should call wxEvent::GetId to check the identity of the clicked-on window, and then either show some suitable help or call wxEvent::Skip if the identifier is unrecognised. Calling Skip is important because it allows wxWindows to generate further events for ancestors of the clicked-on window. Otherwise it would be impossible to show help for container windows, since processing would stop after the first window found. Derived from wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process an activate event, use these event handler macros to direct input to a member function that takes a wxHelpEvent argument. EVT_HELP(id, func) EVT_HELP_RANGE(id1, id2, func) Process a wxEVT_HELP event. Process a wxEVT_HELP event for a range of ids.

See also wxContextHelp (p. 195), wxDialog (p. 367), Event handling overview (p. 1602)

wxHelpEvent::wxHelpEvent
wxHelpEvent(WXTYPE eventType = 0, bool active = true, wxWindowID id = 0, const wxPoint& point) Constructor.

wxHelpEvent::GetPosition
const wxPoint& GetPosition() const Returns the left-click position of the mouse, in screen coordinates. This allows the application to position the help appropriately.

wxHelpEvent::SetPosition
void SetPosition(const wxPoint& pt) Sets the left-click position of the mouse, in screen coordinates.

651


CHAPTER 7

wxHelpProvider
wxHelpProvider is an abstract class used by a program implementing context-sensitive help to show the help text for the given window. The current help provider must be explicitly set by the application using wxHelpProvider::Set(). Derived from No base class Include files <wx/cshelp.h> See also wxContextHelp (p. 195), wxContextHelpButton (p. 196), wxSimpleHelpProvider (p. 1102), wxHelpControllerHelpProvider (p. 649), wxWindow::SetHelpText (p. 1425), wxWindow::GetHelpText (p. 1403)

wxHelpProvider::~wxHelpProvider
~wxHelpProvider() Virtual destructor for any base class.

wxHelpProvider::Set
wxHelpProvider* Set(wxHelpProvider* helpProvider) Get/set the current, application-wide help provider. Returns the previous one.

wxHelpProvider::Get
wxHelpProvider* Get() Unlike some other classes, the help provider is not created on demand. This must be explicitly done by the application.

wxHelpProvider::GetHelp
wxString GetHelp(const wxWindowBase* window) Gets the help string for this window. Its interpretation is dependent on the help provider except that empty string always means that no help is associated with the window.

652


CHAPTER 7 wxHelpProvider::ShowHelp
bool ShowHelp(wxWindowBase* window) Shows help for the given window. Uses GetHelp (p. 652) internally if applicable. Returns true if it was done, or false if no help was available for this window.

wxHelpProvider::AddHelp
void AddHelp(wxWindowBase* window, const wxString& text) Associates the text with the given window or id. Although all help providers have these functions to allow making wxWindow::SetHelpText (p. 1425) work, not all of them implement the functions. void AddHelp(wxWindowID id, const wxString& text) This version associates the given text with all windows with this id. May be used to set the same help string for all Cancel buttons in the application, for example.

wxHelpProvider::RemoveHelp
void RemoveHelp(wxWindowBase* window) Removes the association between the window pointer and the help text. This is called by the wxWindow destructor. Without this, the table of help strings will fill up and when window pointers are reused, the wrong help string will be found.

wxHtmlCell
Internal data structure. It represents fragments of parsed HTML page, the so-called cell - a word, picture, table, horizontal line and so on. It is used by wxHtmlWindow (p. 699) and wxHtmlWinParser (p. 708) to represent HTML page in memory. You can divide cells into two groups : visible cells with non-zero width and height and helper cells (usually with zero width and height) that perform special actions such as color or font change. Derived from wxObject (p. 954) Include files <wx/html/htmlcell.h> See Also Cells Overview (p. 1695),wxHtmlContainerCell (p. 659)

653


CHAPTER 7

wxHtmlCell::wxHtmlCell
wxHtmlCell() Constructor.

wxHtmlCell::AdjustPagebreak
virtual bool AdjustPagebreak(int * pagebreak) This method is used to adjust pagebreak position. The parameter is variable that contains y-coordinate of page break (= horizontal line that should not be crossed by words, images etc.). If this cell cannot be divided into two pieces (each one on another page) then it moves the pagebreak few pixels up. Returns true if pagebreak was modified, false otherwise
Usage: while (container->AdjustPagebreak(&p)) {}

wxHtmlCell::Draw
virtual void Draw(wxDC& dc, int x, int y, int view_y1, int view_y2) Renders the cell. Parameters dc Device context to which the cell is to be drawn x,y Coordinates of parent's upper left corner (origin). You must add this to m_PosX,m_PosY when passing coordinates to dc's methods Example : dc -> DrawText("hello", x + m_PosX, y + m_PosY) view_y1 y-coord of the first line visible in window. This is used to optimize rendering speed view_y2 y-coord of the last line visible in window. This is used to optimize rendering speed

wxHtmlCell::DrawInvisible

654


CHAPTER 7
virtual void DrawInvisible(wxDC& dc, int x, int y) This method is called instead of Draw (p. 654) when the cell is certainly out of the screen (and thus invisible). This is not nonsense - some tags (like wxHtmlColourCell (p. 659)or font setter) must be drawn even if they are invisible! Parameters dc Device context to which the cell is to be drawn x,y Coordinates of parent's upper left corner. You must add this to m_PosX,m_PosY when passing coordinates to dc's methods Example : dc -> DrawText("hello", x + m_PosX, y + m_PosY)

wxHtmlCell::Find
virtual const wxHtmlCell* Find(int condition, const void* param) Returns pointer to itself if this cell matches condition (or if any of the cells following in the list matches), NULL otherwise. (In other words if you call top-level container's Find it will return pointer to the first cell that matches the condition) It is recommended way how to obtain pointer to particular cell or to cell of some type (e.g. wxHtmlAnchorCell reacts on wxHTML_COND_ISANCHOR condition) Parameters condition Unique integer identifier of condition param Optional parameters Defined conditions wxHTML_COND_ISANCHOR wxHTML_COND_USER Finds particular anchor. param is pointer to wxString with name of the anchor. User-defined conditions start from this number.

wxHtmlCell::GetDescent
int GetDescent() const Returns descent value of the cell (m_Descent member). See explanation:

655


CHAPTER 7

wxHtmlCell::GetHeight
int GetHeight() const Returns height of the cell (m_Height member).

wxHtmlCell::GetId
virtual wxString GetId() const Returns unique cell identifier if there is any, empty string otherwise.

wxHtmlCell::GetLink
virtual wxHtmlLinkInfo* GetLink(int x = 0, int y = 0) const Returns hypertext link if associated with this cell or NULL otherwise. See wxHtmlLinkInfo (p. 682). (Note: this makes sense only for visible tags). Parameters x,y Coordinates of position where the user pressed mouse button. These coordinates are used e.g. by COLORMAP. Values are relative to the upper left corner of THIS cell (i.e. from 0 to m_Width or m_Height)

wxHtmlCell::GetNext
wxHtmlCell* GetNext() const Returns pointer to the next cell in list (see htmlcell.h if you're interested in details).

wxHtmlCell::GetParent
wxHtmlContainerCell* GetParent() const Returns pointer to parent container.

656


CHAPTER 7 wxHtmlCell::GetPosX
int GetPosX() const Returns X position within parent (the value is relative to parent's upper left corner). The returned value is meaningful only if parent's Layout (p. 657) was called before!

wxHtmlCell::GetPosY
int GetPosY() const Returns Y position within parent (the value is relative to parent's upper left corner). The returned value is meaningful only if parent's Layout (p. 657) was called before!

wxHtmlCell::GetWidth
int GetWidth() const Returns width of the cell (m_Width member).

wxHtmlCell::Layout
virtual void Layout(int w) This method performs two actions: 1. 2. adjusts the cell's width according to the fact that maximal possible width is w. (this has sense when working with horizontal lines, tables etc.) prepares layout (=fill-in m_PosX, m_PosY (and sometimes m_Height) members) based on actual width w

It must be called before displaying cells structure because m_PosX and m_PosY are undefined (or invalid) before calling Layout.

wxHtmlCell::OnMouseClick
virtual void OnMouseClick(wxWindow* parent, intx, int y, const wxMouseEvent& event) This function is simple event handler. Each time the user clicks mouse button over a cell within wxHtmlWindow (p. 699) this method of that cell is called. Default behavior is that it calls wxHtmlWindow::LoadPage (p. 702). Note If you need more "advanced" event handling you should use wxHtmlBinderCell instead. Parameters

657


CHAPTER 7
parent parent window (always wxHtmlWindow!) x, y coordinates of mouse click (this is relative to cell's origin left, middle, right boolean flags for mouse buttons. true if the left/middle/right button is pressed, false otherwise

wxHtmlCell::SetId
void SetId(const wxString& id) Sets unique cell identifier. Default value is no identifier, i.e. empty string.

wxHtmlCell::SetLink
void SetLink(const wxHtmlLinkInfo& link) Sets the hypertext link associated with this cell. (Default value is wxHtmlLinkInfo (p. 682)("", "") (no link))

wxHtmlCell::SetNext
void SetNext(wxHtmlCell *cell) Sets the next cell in the list. This shouldn't be called by user - it is to be used only by wxHtmlContainerCell::InsertCell (p. 661).

wxHtmlCell::SetParent
void SetParent(wxHtmlContainerCell *p) Sets parent container of this cell. This is called fromwxHtmlContainerCell::InsertCell (p. 661).

wxHtmlCell::SetPos
void SetPos(int x, int y) Sets the cell's position within parent container.

658


CHAPTER 7

wxHtmlColourCell
This cell changes the colour of either the background or the foreground. Derived from wxHtmlCell (p. 653) Include files <wx/html/htmlcell.h>

wxHtmlColourCell::wxHtmlColourCell
wxHtmlColourCell(wxColour clr, int flags = wxHTML_CLR_FOREGROUND) Constructor. Parameters clr The color flags Can be one of following: wxHTML_CLR_FOREGROUND wxHTML_CLR_BACKGROUND change color of text change background color

wxHtmlContainerCell
The wxHtmlContainerCell class is an implementation of a cell that may contain more cells in it. It is heavily used in the wxHTML layout algorithm. Derived from wxHtmlCell (p. 653) Include files <wx/html/htmlcell.h> See Also Cells Overview (p. 1695)

659


CHAPTER 7

wxHtmlContainerCell::wxHtmlContainerCell
wxHtmlContainerCell(wxHtmlContainerCell *parent) Constructor. parent is pointer to parent container or NULL.

wxHtmlContainerCell::GetAlignHor
int GetAlignHor() const Returns container's horizontal alignment.

wxHtmlContainerCell::GetAlignVer
int GetAlignVer() const Returns container's vertical alignment.

wxHtmlContainerCell::GetBackgroundColour
wxColour GetBackgroundColour() Returns the background colour of the container or wxNullColour if no background colour is set.

wxHtmlContainerCell::GetFirstCell
wxHtmlCell* GetFirstCell() Returns pointer to the first cell in the list. You can then use wxHtmlCell's GetNext method to obtain pointer to the next cell in list. Note: This shouldn't be used by the end user. If you need some way of finding particular cell in the list, try Find (p. 655) method instead.

wxHtmlContainerCell::GetIndent
int GetIndent(int ind) const Returns the indentation. ind is one of the wxHTML_INDENT_* constants. Note: You must call GetIndentUnits (p. 661) with same ind parameter in order to correctly interpret the returned integer value. It is NOT always in pixels!

660


CHAPTER 7 wxHtmlContainerCell::GetIndentUnits
int GetIndentUnits(int ind) const Returns the units of indentation for ind where ind is one of the wxHTML_INDENT_* constants.

wxHtmlContainerCell::InsertCell
void InsertCell(wxHtmlCell *cell) Inserts new cell into the container.

wxHtmlContainerCell::SetAlign
void SetAlign(const wxHtmlTag& tag) Sets the container's alignment (both horizontal and vertical) according to the values stored in tag. (Tags ALIGN parameter is extracted.) In fact it is only a front-end to SetAlignHor (p. 661) and SetAlignVer (p. 661).

wxHtmlContainerCell::SetAlignHor
void SetAlignHor(int al) Sets the container's horizontal alignment. During Layout (p. 657) each line is aligned according to al value. Parameters al new horizontal alignment. May be one of these values: wxHTML_ALIGN_LEFT wxHTML_ALIGN_JUSTIFY wxHTML_ALIGN_CENTER wxHTML_ALIGN_RIGHT lines are left-aligned (default) lines are justified lines are centered lines are right-aligned

wxHtmlContainerCell::SetAlignVer
void SetAlignVer(int al) Sets the container's vertical alignment. This is per-line alignment!

661


CHAPTER 7
Parameters al new vertical alignment. May be one of these values: wxHTML_ALIGN_BOTTOM wxHTML_ALIGN_CENTER wxHTML_ALIGN_TOP cells are over the line (default) cells are centered on line cells are under the line

wxHtmlContainerCell::SetBackgroundColour
void SetBackgroundColour(const wxColour& clr) Sets the background colour for this container.

wxHtmlContainerCell::SetBorder
void SetBorder(const wxColour& clr1, const wxColour& clr2) Sets the border (frame) colours. A border is a rectangle around the container.

662


CHAPTER 7
Parameters clr1 Colour of top and left lines clr2 Colour of bottom and right lines

wxHtmlContainerCell::SetIndent
void SetIndent(int i, int what, int units = wxHTML_UNITS_PIXELS) Sets the indentation (free space between borders of container and subcells). Parameters i Indentation value. what Determines which of the four borders we're setting. It is OR combination of following constants: wxHTML_INDENT_TOP wxHTML_INDENT_BOTTOM wxHTML_INDENT_LEFT wxHTML_INDENT_RIGHT wxHTML_INDENT_HORIZONTAL wxHTML_INDENT_VERTICAL wxHTML_INDENT_ALL top border bottom left right left and right top and bottom all 4 borders

663


CHAPTER 7

units Units of i. This parameter affects interpretation of value. wxHTML_UNITS_PIXELS wxHTML_UNITS_PERCENT i is number of pixels i is interpreted as percents of width of parent container

wxHtmlContainerCell::SetMinHeight
void SetMinHeight(int h, int align = wxHTML_ALIGN_TOP) Sets minimal height of the container. When container's Layout (p. 657) is called, m_Height is set depending on layout of subcells to the height of area covered by layed-out subcells. Calling this method guarantees you that the height of container is never smaller than h - even if the subcells cover much smaller area. Parameters h The minimal height. align If height of the container is lower than the minimum height, empty space must be inserted somewhere in order to ensure minimal height. This parameter is one of wxHTML_ALIGN_TOP, wxHTML_ALIGN_BOTTOM, wxHTML_ALIGN_CENTER. It refers to the contents, not to the empty place.

wxHtmlContainerCell::SetWidthFloat 664


CHAPTER 7
void SetWidthFloat(int w, int units) void SetWidthFloat(const wxHtmlTag& tag, double pixel_scale = 1.0) Sets floating width adjustment. The normal behaviour of container is that its width is the same as the width of parent container (and thus you can have only one sub-container per line). You can change this by setting FWA. pixel_scale is number of real pixels that equals to 1 HTML pixel. Parameters w Width of the container. If the value is negative it means complement to full width of parent container (e.g.SetWidthFloat(-50, wxHTML_UNITS_PIXELS) sets the width of container to parent's width minus 50 pixels. This is useful when creating tables - you can call SetWidthFloat(50) and SetWidthFloat(-50)) units Units of w This parameter affects the interpretation of value. wxHTML_UNITS_PIXELS wxHTML_UNITS_PERCENT w is number of pixels w is interpreted as percents of width of parent container

tag In the second version of method, w and unitsinfo is extracted from tag's WIDTH parameter. wxPython note: The second form of this method is named SetWidthFloatFromTag in wxPython.

wxHtmlDCRenderer
This class can render HTML document into a specified area of a DC. You can use it in your own printing code, although use of wxHtmlEasyPrinting (p. 668) or wxHtmlPrintout (p. 690) is strongly recommended. Derived from wxObject (p. 954) Include files <wx/html/htmprint.h>

665


CHAPTER 7

wxHtmlDCRenderer::wxHtmlDCRenderer
wxHtmlDCRenderer() Constructor.

wxHtmlDCRenderer::SetDC
void SetDC(wxDC* dc, double pixel_scale = 1.0) Assign DC instance to the renderer. pixel_scale can be used when rendering to high-resolution DCs (e.g. printer) to adjust size of pixel metrics. (Many dimensions in HTML are given in pixels -- e.g. image sizes. 300x300 image would be only one inch wide on typical printer. With pixel_scale = 3.0 it would be 3 inches.)

wxHtmlDCRenderer::SetFonts
void SetFonts(wxString normal_face, wxString fixed_face, const int *sizes = NULL) Sets fonts. See wxHtmlWindow::SetFonts (p. 706) for detailed description. See also SetSize (p. 666).

wxHtmlDCRenderer::SetSize
void SetSize(int width, int height) Set size of output rectangle, in pixels. Note that you can't change width of the rectangle between calls to Render (p. 667)! (You can freely change height.)

wxHtmlDCRenderer::SetHtmlText
void SetHtmlText(const wxString& html, const wxString& basepath = wxEmptyString, bool isdir = true) Assign text to the renderer. Render (p. 667) then draws the text onto DC. Parameters html HTML text. This is not a filename. basepath

666


CHAPTER 7
base directory (html string would be stored there if it was in file). It is used to determine path for loading images, for example. isdir false if basepath is filename, true if it is directory name (see wxFileSystem (p. 492) for detailed explanation)

wxHtmlDCRenderer::Render
int Render(int x, int y, int from = 0, int dont_render = false) Renders HTML text to the DC. Parameters x,y position of upper-left corner of printing rectangle (see SetSize (p. 666)) from y-coordinate of the very first visible cell dont_render if true then this method only returns y coordinate of the next page and does not output anything Returned value is y coordinate of first cell than didn't fit onto page. Use this value as from in next call to Render in order to print multipages document. Caution! The Following three methods must always be called before any call to Render (preferably in this order):    SetDC (p. 666) SetSize (p. 666) SetHtmlText (p. 666)

Render() changes the DC's user scale and does NOT restore it.

wxHtmlDCRenderer::GetTotalHeight
int GetTotalHeight() Returns the height of the HTML text. This is important if area height (see SetSize (p. 666)) is smaller that total height and thus the page cannot fit into it. In that case you're supposed to call Render (p. 667) as long as its return value is smaller than

667


CHAPTER 7
GetTotalHeight's.

wxHtmlEasyPrinting
This class provides very simple interface to printing architecture. It allows you to print HTML documents using only a few commands. Note Do not create this class on the stack only. You should create an instance on app startup and use this instance for all printing operations. The reason is that this class stores various settings in it. Derived from wxObject (p. 954) Include files <wx/html/htmprint.h>

wxHtmlEasyPrinting::wxHtmlEasyPrinting
wxHtmlEasyPrinting(const wxString& name = "Printing", wxWindow* parentWindow = NULL) Constructor. Parameters name Name of the printing object. Used by preview frames and setup dialogs. parentWindow pointer to the window that will own the preview frame and setup dialogs. May be NULL.

wxHtmlEasyPrinting::PreviewFile
bool PreviewFile(const wxString& htmlfile) Preview HTML file. Returns false in case of error -- callwxPrinter::GetLastError (p. 1008) to get detailed information about the kind of the error.

668


CHAPTER 7 wxHtmlEasyPrinting::PreviewText
bool PreviewText(const wxString& htmltext, const wxString& basepath = wxEmptyString) Preview HTML text (not file!). Returns false in case of error -- callwxPrinter::GetLastError (p. 1008) to get detailed information about the kind of the error. Parameters htmltext HTML text. basepath base directory (html string would be stored there if it was in file). It is used to determine path for loading images, for example.

wxHtmlEasyPrinting::PrintFile
bool PrintFile(const wxString& htmlfile) Print HTML file. Returns false in case of error -- callwxPrinter::GetLastError (p. 1008) to get detailed information about the kind of the error.

wxHtmlEasyPrinting::PrintText
bool PrintText(const wxString& htmltext, const wxString& basepath = wxEmptyString) Print HTML text (not file!). Returns false in case of error -- callwxPrinter::GetLastError (p. 1008) to get detailed information about the kind of the error. Parameters htmltext HTML text. basepath base directory (html string would be stored there if it was in file). It is used to determine path for loading images, for example.

669


CHAPTER 7 wxHtmlEasyPrinting::PrinterSetup
void PrinterSetup() Display printer setup dialog and allows the user to modify settings.

wxHtmlEasyPrinting::PageSetup
void PageSetup() Display page setup dialog and allows the user to modify settings.

wxHtmlEasyPrinting::SetFonts
void SetFonts(wxString normal_face, wxString fixed_face, const int *sizes = NULL) Sets fonts. See wxHtmlWindow::SetFonts (p. 706) for detailed description.

wxHtmlEasyPrinting::SetHeader
void SetHeader(const wxString& header, int pg = wxPAGE_ALL) Set page header. Parameters header HTML text to be used as header. You can use macros in it:   pg one of wxPAGE_ODD, wxPAGE_EVEN and wxPAGE_ALL constants. @PAGENUM@ is replaced by page number @PAGESCNT@ is replaced by total number of pages

wxHtmlEasyPrinting::SetFooter
void SetFooter(const wxString& footer, int pg = wxPAGE_ALL) Set page footer. Parameters footer HTML text to be used as footer. You can use macros in it:

670


CHAPTER 7
  pg one of wxPAGE_ODD, wxPAGE_EVEN and wxPAGE_ALL constants. @PAGENUM@ is replaced by page number @PAGESCNT@ is replaced by total number of pages

wxHtmlEasyPrinting::GetPrintData
wxPrintData* GetPrintData() Returns pointer to wxPrintData (p. 996) instance used by this class. You can set its parameters (via SetXXXX methods).

wxHtmlEasyPrinting::GetPageSetupData
wxPageSetupDialogData* GetPageSetupData() Returns a pointer to wxPageSetupDialogData (p. 961) instance used by this class. You can set its parameters (via SetXXXX methods).

wxHtmlFilter
This class is an input filter for wxHtmlWindow (p. 699). It allows you to read and display files of different file formats. Derived from wxObject (p. 954) Include files <wx/html/htmlfilt.h> See Also Overview (p. 1695)

wxHtmlFilter::wxHtmlFilter
wxHtmlFilter() Constructor.

671


CHAPTER 7 wxHtmlFilter::CanRead
bool CanRead(const wxFSFile& file) Returns true if this filter is capable of reading file file. Example:
bool MyFilter::CanRead(const wxFSFile& file) { return (file.GetMimeType() == "application/x-ugh"); }

wxHtmlFilter::ReadFile
wxString ReadFile(const wxFSFile& file) Reads the file and returns string with HTML document. Example:
wxString MyImgFilter::ReadFile(const wxFSFile& file) { return "<html><body><img src=\"" + file.GetLocation() + "\"></body></html>"; }

wxHtmlHelpController
WARNING! Although this class has an API compatible with other wxWindows help controllers as documented by wxHelpController (p. 644), it is recommended that you use the enhanced capabilities of wxHtmlHelpController's API. This help controller provides an easy way of displaying HTML help in your application (see test sample). The help system is based on books (see AddBook (p. 674)). A book is a logical section of documentation (for example "User's Guide" or "Programmer's Guide" or "C++ Reference" or "wxWindows Reference"). The help controller can handle as many books as you want. wxHTML uses Microsoft's HTML Help Workshop project files (.hhp, .hhk, .hhc) as its native format. The file format is described here (p. 1693). Have a look at docs/html/ directory where sample project files are stored. You can use Tex2RTF to produce these files when generating HTML, if you set htmlWorkshopFiles to true in your tex2rtf.ini file. Note It is strongly recommended to use preprocessed .hhp.cached version of projects. It can be either created on-the-fly (see SetTempDir (p. 676)) or you can use hhp2cached utility from utils/hhp2cached to create it and distribute the cached version together with helpfiles. See samples/html/help sample for demonstration of its use.

672


CHAPTER 7
See also Information about wxBestHelpController (p. 644) Derived from wxHelpControllerBase Include files <wx/html/helpctrl.h>

wxHtmlHelpController::wxHtmlHelpController
wxHtmlHelpController(int style = wxHF_DEFAULT_STYLE) Constructor. Parameters style is combination of these flags: wxHF_TOOLBAR wxHF_FLAT_TOOLBAR wxHF_CONTENTS wxHF_INDEX wxHF_SEARCH wxHF_BOOKMARKS wxHF_OPEN_FILES wxHF_PRINT wxHF_MERGE_BOOKS Help frame has toolbar. Help frame has toolbar with flat buttons (aka coolbar). Help frame has contents panel. Help frame has index panel. Help frame has search panel. Help frame has bookmarks controls. Allow user to open arbitrary HTML document. Toolbar contains "print" button. Contents pane does not show book nodes. All books are merged together and appear as single book to the user. All nodes in contents pane have a book icon. This is how Microsoft's HTML help viewer behaves. Book nodes in contents pane have a book icon, book's sections have a folder icon. This is the default. Both book nodes and nodes of top-level

wxHF_ICONS_BOOK

wxHF_ICONS_FOLDER

wxHF_ICONS_BOOK_CHAPTER

673


CHAPTER 7
sections of a book (i.e. chapters) have a book icon, all other sections (sections, subsections, ...) have a folder icon. wxHF_DEFAULT_STYLE wxHF_TOOLBAR | wxHF_CONTENTS | wxHF_INDEX | wxHF_SEARCH | wxHF_BOOKMARKS | wxHF_PRINT

wxHtmlHelpController::AddBook
bool AddBook(const wxFileName& book_file, bool show_wait_msg) bool AddBook(const wxString& book_url, bool show_wait_msg) Adds book (.hhp file (p. 1693) - HTML Help Workshop project file) into the list of loaded books. This must be called at least once before displaying any help. book_file or book_url may be either .hhp file or ZIP archive that contains arbitrary number of .hhp files in top-level directory. This ZIP archive must have .zip or .htb extension (the latter stands for "HTML book"). In other words,AddBook(wxFileName("help.zip"))is possible and, in fact, recommended way. Parameters show_wait_msg If true then a decoration-less window with progress message is displayed. book_file Help book filename. It is recommended to use this prototype instead of the one taking URL, because it is less error-prone. book_url Help book URL (note that syntax of filename and URL is different on most platforms) Note Don't forget to install wxFileSystem ZIP handler withwxFileSystem::AddHandler(new wxZipFSHandler); before calling this method on a .zip or .htb file!

wxHtmlHelpController::CreateHelpFrame
virtual wxHtmlHelpFrame* CreateHelpFrame(wxHtmlHelpData * data) This protected virtual method may be overridden so that the controller uses slightly different frame. See samples/html/helpview sample for an example.

674


CHAPTER 7 wxHtmlHelpController::Display
void Display(const wxString& x) Displays page x. This is THE important function - it is used to display the help in application. You can specify the page in many ways:     as direct filename of HTML document as chapter name (from contents) or as a book name as some word from index even as any word (will be searched)

Looking for the page runs in these steps: 1. 2. 3. 4. 5. try to locate file named x (if x is for example "doc/howto.htm") try to open starting page of book named x try to find x in contents (if x is for example "How To ...") try to find x in index (if x is for example "How To ...") switch to Search panel and start searching

void Display(const int id) This alternative form is used to search help contents by numeric IDs. wxPython note: The second form of this method is named DisplayId in wxPython.

wxHtmlHelpController::DisplayContents
void DisplayContents() Displays help window and focuses contents panel.

wxHtmlHelpController::DisplayIndex
void DisplayIndex() Displays help window and focuses index panel.

wxHtmlHelpController::KeywordSearch
bool KeywordSearch(const wxString& keyword, wxHelpSearchMode mode = wxHELP_SEARCH_ALL)

675


CHAPTER 7
Displays help window, focuses search panel and starts searching. Returns true if the keyword was found. Optionally it searches through the index (mode = wxHELP_SEARCH_INDEX), default the content (mode = wxHELP_SEARCH_ALL). Important: KeywordSearch searches only pages listed in .hhc file(s). You should list all pages in the contents file.

wxHtmlHelpController::ReadCustomization
void ReadCustomization(wxConfigBase* cfg, wxString path = wxEmptyString) Reads the controller's setting (position of window, etc.)

wxHtmlHelpController::SetTempDir
void SetTempDir(const wxString& path) Sets the path for storing temporary files - cached binary versions of index and contents files. These binary forms are much faster to read. Default value is empty string (empty string means that no cached data are stored). Note that these files are not deleted when program exits. Once created these cached files will be used in all subsequent executions of your application. If cached files become older than corresponding .hhp file (e.g. if you regenerate documentation) it will be refreshed.

wxHtmlHelpController::SetTitleFormat
void SetTitleFormat(const wxString& format) Sets format of title of the frame. Must contain exactly one "%s" (for title of displayed HTML page).

wxHtmlHelpController::UseConfig
void UseConfig(wxConfigBase* config, const wxString& rootpath = wxEmptyString) Associates config object with the controller. If there is associated config object, wxHtmlHelpController automatically reads and writes settings (including wxHtmlWindow's settings) when needed. The only thing you must do is create wxConfig object and call UseConfig. If you do not use UseConfig, wxHtmlHelpController will use default wxConfig object if available (for details see wxConfigBase::Get (p. 185) and wxConfigBase::Set (p. 189)).

676


CHAPTER 7 wxHtmlHelpController::WriteCustomization
void WriteCustomization(wxConfigBase* cfg, wxString path = wxEmptyString) Stores controllers setting (position of window etc.)

wxHtmlHelpData
This class is used by wxHtmlHelpController (p. 672) and wxHtmlHelpFrame (p. 678) to access HTML help items. It is internal class and should not be used directly - except for the case you're writing your own HTML help controller. Derived from wxObject (p. 954) Include files <wx/html/helpdata.h>

wxHtmlHelpData::wxHtmlHelpData
wxHtmlHelpData() Constructor.

wxHtmlHelpData::AddBook
bool AddBook(const wxString& book_url) Adds new book. book is URL (not filename!) of HTML help project (hhp) or ZIP file that contains arbitrary number of .hhp projects (this zip file can have either .zip or .htb extension, htb stands for "html book"). Returns success.

wxHtmlHelpData::FindPageById
wxString FindPageById(int id) Returns page's URL based on integer ID stored in project.

wxHtmlHelpData::FindPageByName
wxString FindPageByName(const wxString& page) Returns page's URL based on its (file)name.

677


CHAPTER 7 wxHtmlHelpData::GetBookRecArray
const wxHtmlBookRecArray& GetBookRecArray() Returns array with help books info.

wxHtmlHelpData::GetContents
wxHtmlContentsItem* GetContents() Returns contents lists pointer.

wxHtmlHelpData::GetContentsCnt
int GetContentsCnt() Returns size of contents list.

wxHtmlHelpData::GetIndex
wxHtmlContentsItem* GetIndex() Returns pointer to index items list.

wxHtmlHelpData::GetIndexCnt
int GetIndexCnt() Returns size of index list.

wxHtmlHelpData::SetTempDir
void SetTempDir(const wxString& path) Sets temporary directory where binary cached versions of MS HTML Workshop files will be stored. (This is turned off by default and you can enable this feature by setting nonempty temp dir.)

wxHtmlHelpFrame
This class is used by wxHtmlHelpController (p. 672) to display help. It is an internal class and should not be used directly - except for the case when you're writing your own HTML help controller. Derived from

678


CHAPTER 7
wxFrame (p. 530) Include files <wx/html/helpfrm.h>

wxHtmlHelpFrame::wxHtmlHelpFrame
wxHtmlHelpFrame(wxHtmlHelpData* data = NULL) wxHtmlHelpFrame(wxWindow* parent, int wxWindowID, const wxString& title = wxEmptyString, int style = wxHF_DEFAULT_STYLE, wxHtmlHelpData* data = NULL) Constructor. style is combination of these flags: wxHF_TOOLBAR wxHF_FLAT_TOOLBAR wxHF_CONTENTS wxHF_INDEX wxHF_SEARCH wxHF_BOOKMARKS wxHF_OPEN_FILES wxHF_PRINT wxHF_MERGE_BOOKS Help frame has toolbar. Help frame has toolbar with flat buttons (aka coolbar). Help frame has contents panel. Help frame has index panel. Help frame has search panel. Help frame has bookmarks controls. Allow user to open arbitrary HTML document. Toolbar contains "print" button. Contents pane does not show book nodes. All books are merged together and appear as single book to the user. All nodes in contents pane have a book icon. This is how Microsoft's HTML help viewer behaves. Book nodes in contents pane have a book icon, book's sections have a folder icon. This is the default. Both book nodes and nodes of top-level sections of a book (i.e. chapters) have a book icon, all other sections (sections, subsections, ...) have a folder icon. wxHF_TOOLBAR | wxHF_CONTENTS |

wxHF_ICONS_BOOK

wxHF_ICONS_FOLDER

wxHF_ICONS_BOOK_CHAPTER

wxHF_DEFAULT_STYLE

679


CHAPTER 7
wxHF_INDEX | wxHF_SEARCH | wxHF_BOOKMARKS | wxHF_PRINT

wxHtmlHelpFrame::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& title = wxEmptyString, int style = wxHF_DEFAULT_STYLE) Creates the frame. See the constructor (p. 679)for parameters description.

wxHtmlHelpFrame::CreateContents
void CreateContents(bool show_progress = false) Creates contents panel. (May take some time.)

wxHtmlHelpFrame::CreateIndex
void CreateIndex(bool show_progress = false) Creates index panel. (May take some time.)

wxHtmlHelpFrame::CreateSearch
void CreateSearch() Creates search panel.

wxHtmlHelpFrame::Display
bool Display(const wxString& x) bool Display(const int id) Displays page x. If not found it will give the user the choice of searching books. Looking for the page runs in these steps: 1. 2. 3. 4. try to locate file named x (if x is for example "doc/howto.htm") try to open starting page of book x try to find x in contents (if x is for example "How To ...") try to find x in index (if x is for example "How To ...")

The second form takes numeric ID as the parameter. (uses extension to MS format, <param name="ID" value=id>)

680


CHAPTER 7
wxPython note: The second form of this method is named DisplayId in wxPython.

wxHtmlHelpFrame::DisplayContents
bool DisplayContents() Displays contents panel.

wxHtmlHelpFrame::DisplayIndex
bool DisplayIndex() Displays index panel.

wxHtmlHelpFrame::GetData
wxHtmlHelpData* GetData() Return wxHtmlHelpData object.

wxHtmlHelpFrame::KeywordSearch
bool KeywordSearch(const wxString& keyword, wxHelpSearchMode mode = wxHELP_SEARCH_ALL) Search for given keyword. Optionally it searches through the index (mode = wxHELP_SEARCH_INDEX), default the content (mode = wxHELP_SEARCH_ALL).

wxHtmlHelpFrame::ReadCustomization
void ReadCustomization(wxConfigBase* cfg, const wxString& path = wxEmptyString) Reads user's settings for this frame (see wxHtmlHelpController::ReadCustomization (p. 676))

wxHtmlHelpFrame::RefreshLists
void RefreshLists(bool show_progress = false) Refresh all panels. This is necessary if a new book was added.

wxHtmlHelpFrame::SetTitleFormat
void SetTitleFormat(const wxString& format)

681


CHAPTER 7
Sets the frame's title format. format must contain exactly one "%s" (it will be replaced by the page title).

wxHtmlHelpFrame::UseConfig
void UseConfig(wxConfigBase* config, const wxString& rootpath = wxEmptyString) Add books to search choice panel.

wxHtmlHelpFrame::WriteCustomization
void WriteCustomization(wxConfigBase* cfg, const wxString& path = wxEmptyString) Saves user's settings for this frame (see wxHtmlHelpController::WriteCustomization (p. 677)).

wxHtmlHelpFrame::AddToolbarButtons
virtual void AddToolbarButtons(wxToolBar *toolBar, int style) You may override this virtual method to add more buttons into help frame's toolbar. toolBar is a pointer to the toolbar and style is the style flag as passed to Create method. wxToolBar::Realize is called immediately after returning from this function. See samples/html/helpview for an example.

wxHtmlLinkInfo
This class stores all necessary information about hypertext links (as represented by <A> tag in HTML documents). In current implementation it stores URL and target frame name. Note that frames are not currently supported by wxHTML! Derived from wxObject (p. 954) Include files <wx/html/htmlcell.h>

wxHtmlLinkInfo::wxHtmlLinkInfo
wxHtmlLinkInfo()

682


CHAPTER 7
Default ctor. wxHtmlLinkInfo(const wxString& href, const wxString& target = wxEmptyString) Construct hypertext link from HREF (aka URL) and TARGET (name of target frame).

wxHtmlLinkInfo::GetEvent
const wxMouseEvent * GetEvent() Return pointer to event that generated OnLinkClicked event. Valid only within wxHtmlWindow::OnLinkClicked (p. 703), NULL otherwise.

wxHtmlLinkInfo::GetHtmlCell
const wxHtmlCell * GetHtmlCell() Return pointer to the cell that was clicked. Valid only within wxHtmlWindow::OnLinkClicked (p. 703), NULL otherwise.

wxHtmlLinkInfo::GetHref
wxString GetHref() Return HREF value of the <A> tag.

wxHtmlLinkInfo::GetTarget
wxString GetTarget() Return TARGET value of the <A> tag (this value is used to specify in which frame should be the page pointed by Href (p. 683) opened).

wxHtmlListBox
wxHtmlListBox is an implementation of wxVListBox (p. 1373) which shows HTML content in the listbox rows. This is still an abstract base class and you will need to derive your own class from it (see htlbox sample for the example) but you will only need to override a single OnGetItem() (p. 685) function. Derived from wxVListBox (p. 1373) Include files <wx/htmllbox.h>

683


CHAPTER 7

wxHtmlListBox::wxHtmlListBox
wxHtmlListBox(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, size_t countItems = 0, long style = 0, const wxString& name = wxVListBoxNameStr) Normal constructor which calls Create() (p. 684)internally. wxHtmlListBox() Default constructor, you must call Create() (p. 684)later.

wxHtmlListBox::~wxHtmlListBox
~wxHtmlListBox() Destructor cleans up whatever resources we use.

wxHtmlListBox::Create
bool Create(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = wxVListBoxNameStr) Creates the control and optionally sets the initial number of items in it (it may also be set or changed later with SetItemCount() (p. 1378)). There are no special styles defined for wxHtmlListBox, in particular the wxListBox styles can not be used here. Returns true on success or false if the control couldn't be created

wxHtmlListBox::GetSelectedTextBgColour
wxColour GetSelectedTextBgColour(const wxColour& colBg) const This virtual function may be overridden to change the appearance of the background of the selected cells in the same way as GetSelectedTextColour (p. 685). It should be rarely, if ever, used because SetSelectionBackground (p. 1379) allows to change the selection background for all cells at once and doing anything more fancy is probably going to look strangely. See also GetSelectedTextColour (p. 685)

684


CHAPTER 7 wxHtmlListBox::GetSelectedTextColour
wxColour GetSelectedTextColour(const wxColour& colFg) const This virtual function may be overridden to customize the appearance of the selected cells. It is used to determine how the colour colFg is going to look inside selection. By default all original colours are completely ignored and the standard, system-dependent, selection colour is used but the program may wish to override this to achieve some custom appearance. See also GetSelectedTextBgColour (p. 684), SetSelectionBackground (p. 1379), wxSystemSettings::GetColour (p. 1230)

wxHtmlListBox::OnGetItem
wxString OnGetItem(size_t n) const This method must be implemented in the derived class and should return the body (i.e. without <html> nor <body> tags) of the HTML fragment for the given item.

wxHtmlListBox::OnGetItemMarkup
wxString OnGetItemMarkup(size_t n) const This function may be overridden to decorate HTML returned byOnGetItem() (p. 685).

wxHtmlParser
This class handles the generic parsing of HTML document: it scans the document and divide it into blocks of tags (where one block consists of beginning and ending tag and of text between these two tags). It is independent from wxHtmlWindow and can be used as stand-alone parser (Julian Smart's idea of speech-only HTML viewer or wget-like utility - see InetGet sample for example). It uses system of tag handlers to parse the HTML document. Tag handlers are not statically shared by all instances but are created for each wxHtmlParser instance. The reason is that the handler may contain document-specific temporary data used during parsing (e.g. complicated structures like tables). Typically the user calls only the Parse (p. 688) method. Derived from wxObject

685


CHAPTER 7
Include files <wx/html/htmlpars.h> See also Cells Overview (p. 1695),Tag Handlers Overview (p. 1696),wxHtmlTag (p. 692)

wxHtmlParser::wxHtmlParser
wxHtmlParser() Constructor.

wxHtmlParser::AddTag
void AddTag(const wxHtmlTag& tag) This may (and may not) be overwritten in derived class. This method is called each time new tag is about to be added. tag contains information about the tag. (See wxHtmlTag (p. 692)for details.) Default (wxHtmlParser) behaviour is this: First it finds a handler capable of handling this tag and then it calls handler's HandleTag method.

wxHtmlParser::AddTagHandler
virtual void AddTagHandler(wxHtmlTagHandler *handler) Adds handler to the internal list (& hash table) of handlers. This method should not be called directly by user but rather by derived class' constructor. This adds the handler to this instance of wxHtmlParser, not to all objects of this class! (Static front-end to AddTagHandler is provided by wxHtmlWinParser). All handlers are deleted on object deletion.

wxHtmlParser::AddText
virtual void AddWord(const char* txt) Must be overwritten in derived class. This method is called by DoParsing (p. 687)each time a part of text is parsed. txt is NOT only one word, it is substring of input. It is not formatted or preprocessed (so white spaces are unmodified).

686


CHAPTER 7 wxHtmlParser::DoParsing
void DoParsing(int begin_pos, int end_pos) void DoParsing() Parses the m_Source from begin_pos to end_pos-1. (in noparams version it parses whole m_Source)

wxHtmlParser::DoneParser
virtual void DoneParser() This must be called after DoParsing().

wxHtmlParser::GetFS
wxFileSystem* GetFS() const Returns pointer to the file system. Because each tag handler has reference to it is parent parser it can easily request the file by calling
wxFSFile *f = m_Parser -> GetFS() -> OpenFile("image.jpg");

wxHtmlParser::GetProduct
virtual wxObject* GetProduct() Returns product of parsing. Returned value is result of parsing of the document. The type of this result depends on internal representation in derived parser (but it must be derived from wxObject!). See wxHtmlWinParser for details.

wxHtmlParser::GetSource
wxString* GetSource() Returns pointer to the source being parsed.

wxHtmlParser::InitParser
virtual void InitParser(const wxString& source) Setups the parser for parsing the source string. (Should be overridden in derived class)

687


CHAPTER 7 wxHtmlParser::OpenURL
virtual wxFSFile* OpenURL(wxHtmlURLType type, const wxString& url) Opens given URL and returns wxFSFile object that can be used to read data from it. This method may return NULL in one of two cases: either the URL doesn't point to any valid resource or the URL is blocked by overridden implementation of OpenURL in derived class. Parameters type Indicates type of the resource. Is one of: wxHTML_URL_PAGE wxHTML_URL_IMAGE wxHTML_URL_OTHER Opening a HTML page. Opening an image. Opening a resource that doesn't fall into any other category.

url URL being opened. Notes Always use this method in tag handlers instead of GetFS()->OpenFile() because it can block the URL and is thus more secure. Default behaviour is to call wxHtmlWindow::OnOpeningURL (p. 704)of the associated wxHtmlWindow object (which may decide to block the URL or redirect it to another one),if there's any, and always open the URL if the parser is not used with wxHtmlWindow. Returned wxFSFile object is not guaranteed to point to url, it might have been redirected!

wxHtmlParser::Parse
wxObject* Parse(const wxString& source) Proceeds parsing of the document. This is end-user method. You can simply call it when you need to obtain parsed output (which is parser-specific) The method does these things: 1. 2. calls InitParser(source) (p. 687) calls DoParsing (p. 687)

688


CHAPTER 7
3. 4. 5. calls GetProduct (p. 687) calls DoneParser (p. 687) returns value returned by GetProduct

You shouldn't use InitParser, DoParsing, GetProduct or DoneParser directly.

wxHtmlParser::PushTagHandler
void PushTagHandler(wxHtmlTagHandler* handler, wxString tags) Forces the handler to handle additional tags (not returned by GetSupportedTags (p. 696)). The handler should already be added to this parser. Parameters handler the handler tags List of tags (in same format as GetSupportedTags's return value). The parser will redirect these tags to handler (until call to PopTagHandler (p. 690)). Example Imagine you want to parse following pseudo-html structure:
<myitems> <param name="one" value="1"> <param name="two" value="2"> </myitems> <execute> <param program="text.exe"> </execute>

It is obvious that you cannot use only one tag handler for <param> tag. Instead you must use context-sensitive handlers for <param> inside <myitems> and <param> inside <execute>. This is the preferred solution:
TAG_HANDLER_BEGIN(MYITEM, "MYITEMS") TAG_HANDLER_PROC(tag) { // ...something... m_Parser -> PushTagHandler(this, "PARAM"); ParseInner(tag); m_Parser -> PopTagHandler(); // ...something... } TAG_HANDLER_END(MYITEM)

689


CHAPTER 7

wxHtmlParser::PopTagHandler
void PopTagHandler() Restores parser's state before last call to PushTagHandler (p. 689).

wxHtmlParser::SetFS
void SetFS(wxFileSystem *fs) Sets the virtual file system that will be used to request additional files. (For example <IMG> tag handler requests wxFSFile with the image data.)

wxHtmlParser::StopParsing
void StopParsing() Call this function to interrupt parsing from a tag handler. No more tags will be parsed afterward. This function may only be called fromwxHtmlParser::Parse (p. 688) or any function called by it (i.e. from tag handlers).

wxHtmlPrintout
This class serves as printout class for HTML documents. Derived from wxPrintout (p. 1010) Include files <wx/html/htmprint.h>

wxHtmlPrintout::wxHtmlPrintout
wxHtmlPrintout(const wxString& title = "Printout") Constructor.

wxHtmlPrintout::AddFilter
static void AddFilter(wxHtmlFilter* filter) Adds a filter to the static list of filters for wxHtmlPrintout. See wxHtmlFilter (p. 671) for

690


CHAPTER 7
further information.

wxHtmlPrintout::SetFonts
void SetFonts(wxString normal_face, wxString fixed_face, const int *sizes = NULL) Sets fonts. See wxHtmlWindow::SetFonts (p. 706) for detailed description.

wxHtmlPrintout::SetFooter
void SetFooter(const wxString& footer, int pg = wxPAGE_ALL) Sets page footer. Parameters footer HTML text to be used as footer. You can use macros in it:   pg one of wxPAGE_ODD, wxPAGE_EVEN and wxPAGE_ALL constants. @PAGENUM@ is replaced by page number @PAGESCNT@ is replaced by total number of pages

wxHtmlPrintout::SetHeader
void SetHeader(const wxString& header, int pg = wxPAGE_ALL) Sets page header. Parameters header HTML text to be used as header. You can use macros in it:   pg one of wxPAGE_ODD, wxPAGE_EVEN and wxPAGE_ALL constants. @PAGENUM@ is replaced by page number @PAGESCNT@ is replaced by total number of pages

wxHtmlPrintout::SetHtmlFile

691


CHAPTER 7
void SetHtmlFile(const wxString& htmlfile) Prepare the class for printing this HTML file. The file may be located on any virtual file system or it may be normal file.

wxHtmlPrintout::SetHtmlText
void SetHtmlText(const wxString& html, const wxString& basepath = wxEmptyString, bool isdir = true) Prepare the class for printing this HTML text. Parameters html HTML text. (NOT file!) basepath base directory (html string would be stored there if it was in file). It is used to determine path for loading images, for example. isdir false if basepath is filename, true if it is directory name (see wxFileSystem (p. 492) for detailed explanation)

wxHtmlPrintout::SetMargins
void SetMargins(float top = 25.2, float bottom = 25.2, float left = 25.2, float right = 25.2, float spaces = 5) Sets margins in millimeters. Defaults to 1 inch for margins and 0.5cm for space between text and header and/or footer

wxHtmlTag
This class represents a single HTML tag. It is used by tag handlers (p. 1696). Derived from wxObject Include files <wx/html/htmltag.h>

692


CHAPTER 7 wxHtmlTag::wxHtmlTag
wxHtmlTag(const wxString& source, int pos, int end_pos, wxHtmlTagsCache* cache) Constructor. You will probably never have to construct a wxHtmlTag object yourself. Feel free to ignore the constructor parameters. Have a look at src/html/htmlpars.cpp if you're interested in creating it.

wxHtmlTag::GetAllParams
const wxString& GetAllParams() const Returns a string containing all parameters. Example : tag contains <FONT SIZE=+2 COLOR="#000000">. Call to tag.GetAllParams() would return SIZE=+2 COLOR="#000000".

wxHtmlTag::GetBeginPos
int GetBeginPos() const Returns beginning position of the text between this tag and paired ending tag. See explanation (returned position is marked with '|'):
bla bla bla <MYTAG> bla bla internal text</MYTAG> bla bla |

wxHtmlTag::GetEndPos1
int GetEndPos1() const Returns ending position of the text between this tag and paired ending tag. See explanation (returned position is marked with '|'):
bla bla bla <MYTAG> bla bla internal text</MYTAG> bla bla |

wxHtmlTag::GetEndPos2
int GetEndPos2() const Returns ending position 2 of the text between this tag and paired ending tag. See explanation (returned position is marked with '|'):
bla bla bla <MYTAG> bla bla internal text</MYTAG> bla bla |

693


CHAPTER 7 wxHtmlTag::GetName
wxString GetName() const Returns tag's name. The name is always in uppercase and it doesn't contain '<' or '/' characters. (So the name of <FONT SIZE=+2> tag is "FONT" and name of </table> is "TABLE")

wxHtmlTag::GetParam
wxString GetParam(const wxString& par, bool with_commas = false) const Returns the value of the parameter. You should check whether the parameter exists or not (use HasParam (p. 695)) first. Parameters par The parameter's name. with_commas true if you want to get commas as well. See example. Example
... /* you have wxHtmlTag variable tag which is equal to HTML tag <FONT SIZE=+2 COLOR="#0000FF"> */ dummy = tag.GetParam("SIZE"); // dummy == "+2" dummy = tag.GetParam("COLOR"); // dummy == "#0000FF" dummy = tag.GetParam("COLOR", true); // dummy == "\"#0000FF\"" -- see the difference!!

wxHtmlTag::GetParamAsColour
bool GetParamAsColour(const wxString& par, wxColour *clr) const Interprets tag parameter par as colour specification and saves its value into wxColour variable pointed by clr. Returns true on success and false if par is not colour specification or if the tag has no such parameter.

wxHtmlTag::GetParamAsInt
bool GetParamAsInt(const wxString& par, int *value) const Interprets tag parameter par as an integer and saves its value into int variable pointed by

694


CHAPTER 7
value. Returns true on success and false if par is not an integer or if the tag has no such parameter.

wxHtmlTag::HasEnding
bool HasEnding() const Returns true if this tag is paired with ending tag, false otherwise. See the example of HTML document:
<html><body> Hello<p> How are you? <p align=center>This is centered...</p> Oops<br>Oooops! </body></html>

In this example tags HTML and BODY have ending tags, first P and BR doesn't have ending tag while the second P has. The third P tag (which is ending itself) of course doesn't have ending tag.

wxHtmlTag::HasParam
bool HasParam(const wxString& par) const Returns true if the tag has a parameter of the given name. Example : <FONT SIZE=+2 COLOR="#FF00FF"> has two parameters named "SIZE" and "COLOR". Parameters par the parameter you're looking for.

wxHtmlTag::IsEnding
bool IsEnding() const Returns true if this tag is ending one. (</FONT> is ending tag, <FONT> is not)

wxHtmlTag::ScanParam
wxString ScanParam(const wxString& par, const wxChar *format, void *value) const This method scans the given parameter. Usage is exactly the same as sscanf's usage except that you don't pass a string but a parameter name as the first argument and you

695


CHAPTER 7
can only retrieve one value (i.e. you can use only one "%" element in format). Parameters par The name of the tag you want to query format scanf()-like format string. value pointer to a variable to store the value in

wxHtmlTagHandler
Derived from wxObject (p. 954) Include files <wx/html/htmlpars.h> See Also Overview (p. 1696),wxHtmlTag (p. 692)

wxHtmlTagHandler::m_Parser
wxHtmlParser* m_Parser This attribute is used to access parent parser. It is protected so that it can't be accessed by user but can be accessed from derived classes.

wxHtmlTagHandler::wxHtmlTagHandler
wxHtmlTagHandler() Constructor.

wxHtmlTagHandler::GetSupportedTags
virtual wxString GetSupportedTags()

696


CHAPTER 7
Returns list of supported tags. The list is in uppercase and tags are delimited by ','. Example : "I,B,FONT,P"

wxHtmlTagHandler::HandleTag
virtual bool HandleTag(const wxHtmlTag& tag) This is the core method of each handler. It is called each time one of supported tags is detected. tag contains all necessary info (see wxHtmlTag (p. 692) for details). Return value true if ParseInner (p. 697) was called, false otherwise. Example
bool MyHandler::HandleTag(const wxHtmlTag& tag) { ... // change state of parser (e.g. set bold face) ParseInner(tag); ... // restore original state of parser }

You shouldn't call ParseInner if the tag is not paired with an ending one.

wxHtmlTagHandler::ParseInner
void ParseInner(const wxHtmlTag& tag) This method calls parser's DoParsing (p. 687) method for the string between this tag and the paired ending tag:
...<A HREF="x.htm">Hello, world!</A>...

In this example, a call to ParseInner (with tag pointing to A tag) will parse 'Hello, world!'.

wxHtmlTagHandler::SetParser
virtual void SetParser(wxHtmlParser *parser) Assigns parser to this handler. Each instance of handler is guaranteed to be called only from the parser.

wxHtmlTagsModule
This class provides easy way of filling wxHtmlWinParser's table of tag handlers. It is used almost exclusively together with the set ofTAGS_MODULE_* macros (p. 1696) Derived from

697


CHAPTER 7
wxModule (p. 925) Include files <wx/html/winpars.h> See Also Tag Handlers (p. 1696),wxHtmlTagHandler (p. 696),wxHtmlWinTagHandler (p. 714),

wxHtmlTagsModule::FillHandlersTable
virtual void FillHandlersTable(wxHtmlWinParser *parser) You must override this method. In most common case its body consists only of lines of the following type:
parser -> AddTagHandler(new MyHandler);

I recommend using the TAGS_MODULE_* macros. Paremeters parser Pointer to the parser that requested tables filling.

wxHtmlWidgetCell
wxHtmlWidgetCell is a class that provides a connection between HTML cells and widgets (an object derived from wxWindow). You can use it to display things like forms, input boxes etc. in an HTML window. wxHtmlWidgetCell takes care of resizing and moving window. Derived from wxHtmlCell (p. 653) Include files <wx/html/htmlcell.h>

wxHtmlWidgetCell::wxHtmlWidgetCell
wxHtmlWidgetCell(wxWindow* wnd, int w = 0)

698


CHAPTER 7
Constructor. Parameters wnd Connected window. It is parent window must be the wxHtmlWindow object within which it is displayed! w Floating width. If non-zero width of wnd window is adjusted so that it is always w percents of parent container's width. (For example w = 100 means that the window will always have same width as parent container)

wxHtmlWindow
wxHtmlWindow is probably the only class you will directly use unless you want to do something special (like adding new tag handlers or MIME filters). The purpose of this class is to display HTML pages (either local file or downloaded via HTTP protocol) in a window. The width of the window is constant - given in the constructor - and virtual height is changed dynamically depending on page size. Once the window is created you can set its content by calling SetPage(text) (p. 707),LoadPage(filename) (p. 702) orLoadFile (p. 702). Note wxHtmlWindow uses the wxImage (p. 728) class for displaying images. Don't forget to initialize all image formats you need before loading any page! (See wxInitAllImageHandlers (p. 1467) andwxImage::AddHandler (p. 733).) Derived from wxScrolledWindow (p. 1085) Include files <wx/html/htmlwin.h> Window styles wxHW_SCROLLBAR_NEVER Never display scrollbars, not even when the page is larger than the window. wxHP_SCROLLBAR_AUTO Display scrollbars only if page's size exceeds window's size. wxHP_NO_SELECTION Don't allow the user to select text.

wxHtmlWindow::wxHtmlWindow

699


CHAPTER 7
wxHtmlWindow() Default constructor. wxHtmlWindow(wxWindow *parent, wxWindowID id = -1, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxHW_SCROLLBAR_AUTO, const wxString& name = "htmlWindow") Constructor. The parameters are the same as for the wxScrolledWindow (p. 1085) constructor. Parameters style Window style. See wxHtmlWindow (p. 699).

wxHtmlWindow::AddFilter
static void AddFilter(wxHtmlFilter *filter) Adds input filter (p. 1695) to the static list of available filters. These filters are present by default:    text/html MIME type image/* MIME types Plain Text filter (this filter is used if no other filter matches)

wxHtmlWindow::AppendToPage
bool AppendToPage(const wxString& source) Appends HTML fragment to currently displayed text and refreshes the window. Parameters source HTML code fragment Return value false if an error occurred, true otherwise.

wxHtmlWindow::GetInternalRepresentation
wxHtmlContainerCell* GetInternalRepresentation() const Returns pointer to the top-level container.

700


CHAPTER 7
See also: Cells Overview (p. 1695), Printing Overview (p. 1693)

wxHtmlWindow::GetOpenedAnchor
wxString GetOpenedAnchor() Returns anchor within currently opened page (see GetOpenedPage (p. 701)). If no page is opened or if the displayed page wasn't produced by call to LoadPage, empty string is returned.

wxHtmlWindow::GetOpenedPage
wxString GetOpenedPage() Returns full location of the opened page. If no page is opened or if the displayed page wasn't produced by call to LoadPage, empty string is returned.

wxHtmlWindow::GetOpenedPageTitle
wxString GetOpenedPageTitle() Returns title of the opened page or wxEmptyString if current page does not contain <TITLE> tag.

wxHtmlWindow::GetRelatedFrame
wxFrame* GetRelatedFrame() const Returns the related frame.

wxHtmlWindow::HistoryBack
bool HistoryBack() Moves back to the previous page. (each page displayed using LoadPage (p. 702) is stored in history list.)

wxHtmlWindow::HistoryCanBack
bool HistoryCanBack() Returns true if it is possible to go back in the history (i.e. HistoryBack() won't fail).

wxHtmlWindow::HistoryCanForward

701


CHAPTER 7
bool HistoryCanForward() Returns true if it is possible to go forward in the history (i.e. HistoryBack() won't fail).

wxHtmlWindow::HistoryClear
void HistoryClear() Clears history.

wxHtmlWindow::HistoryForward
bool HistoryForward() Moves to next page in history.

wxHtmlWindow::LoadFile
virtual bool LoadFile(const wxFileName& filename) Loads HTML page from file and displays it. Return value false if an error occurred, true otherwise See also LoadPage (p. 702)

wxHtmlWindow::LoadPage
virtual bool LoadPage(const wxString& location) Unlike SetPage this function first loads HTML page from location and then displays it. See example:
htmlwin->LoadPage("help/myproject/index.htm");

Parameters location The address of document. See wxFileSystem (p. 492) for details on address format and behaviour of "opener". Return value false if an error occurred, true otherwise

702


CHAPTER 7
See also LoadFile (p. 702)

wxHtmlWindow::OnCellClicked
virtual void OnCellClicked(wxHtmlCell *cell, wxCoord x, wxCoord y, const wxMouseEvent& event) This method is called when a mouse button is clicked inside wxHtmlWindow. The default behaviour is to call OnLinkClicked (p. 703) if the cell contains a hypertext link. Parameters cell The cell inside which the mouse was clicked, always a simple (i.e. non container) cell x, y The logical coordinates of the click point event The mouse event containing other information about the click

wxHtmlWindow::OnCellMouseHover
virtual void OnCellMouseHover(wxHtmlCell *cell, wxCoord x, wxCoord y) This method is called when a mouse moves over an HTML cell. Parameters cell The cell inside which the mouse is currently, always a simple (i.e. non container) cell x, y The logical coordinates of the click point

wxHtmlWindow::OnLinkClicked
virtual void OnLinkClicked(const wxHtmlLinkInfo& link) Called when user clicks on hypertext link. Default behaviour is to call LoadPage (p. 702) and do nothing else.

703


CHAPTER 7
Also see wxHtmlLinkInfo (p. 682).

wxHtmlWindow::OnOpeningURL
virtual wxHtmlOpeningStatus OnOpeningURL(wxHtmlURLType type,const wxString& url, wxString *redirect) Called when an URL is being opened (either when the user clicks on a link or an image is loaded). The URL will be opened only if OnOpeningURL returns wxHTML_OPEN. This method is called bywxHtmlParser::OpenURL (p. 688). You can override OnOpeningURL to selectively block some URLs (e.g. for security reasons) or to redirect them elsewhere. Default behaviour is to always return wxHTML_OPEN. Parameters type Indicates type of the resource. Is one ofwxHTML_URL_PAGE HTML page. wxHTML_URL_IMAGE wxHTML_URL_OTHER Opening an image. Opening a resource that doesn't fall into any other category. Opening a

url URL being opened. redirect Pointer to wxString variable that must be filled with an URL if OnOpeningURL returns wxHTML_REDIRECT. Return valuewxHTML_OPEN wxHTML_BLOCK wxHTML_REDIRECT Open the URL.

Deny access to the URL, wxHtmlParser::OpenURL (p. 688) will return NULL. Don't open url, redirect to another URL. OnOpeningURL must fill *redirect with the new URL. OnOpeningURL will be called again on returned URL.

wxHtmlWindow::OnSetTitle
virtual void OnSetTitle(const wxString& title) Called on parsing <TITLE> tag.

704


CHAPTER 7 wxHtmlWindow::ReadCustomization
virtual void ReadCustomization(wxConfigBase *cfg, wxString path = wxEmptyString) This reads custom settings from wxConfig. It uses the path 'path' if given, otherwise it saves info into currently selected path. The values are stored in sub-path wxHtmlWindow Read values: all things set by SetFonts, SetBorders. Parameters cfg wxConfig from which you want to read the configuration. path Optional path in config tree. If not given current path is used.

wxHtmlWindow::SelectAll
void SelectAll() Selects all text in the window. See also SelectLine (p. 705),SelectWord (p. 705)

wxHtmlWindow::SelectLine
void SelectLine(const wxPoint& pos) Selects the line of text that pos points at. Note that posis relative to the top of displayed page, not to window's origin, useCalcUnscrolledPosition (p. 1088)to convert physical coordinate. See also SelectAll (p. 705),SelectWord (p. 705)

wxHtmlWindow::SelectWord
void SelectWord(const wxPoint& pos) Selects the word at position pos. Note that posis relative to the top of displayed page, not to window's origin, useCalcUnscrolledPosition (p. 1088)to convert physical coordinate.

705


CHAPTER 7
See also SelectAll (p. 705),SelectLine (p. 705)

wxHtmlWindow::SetBorders
void SetBorders(int b) This function sets the space between border of window and HTML contents. See image:

Parameters b indentation from borders in pixels

wxHtmlWindow::SetFonts
void SetFonts(wxString normal_face, wxString fixed_face, const int *sizes = NULL) This function sets font sizes and faces. Parameters normal_face This is face name for normal (i.e. non-fixed) font. It can be either empty string (then the default face is chosen) or platform-specific face name. Examples are "helvetica" under Unix or "Times New Roman" under Windows.

706


CHAPTER 7
fixed_face The same thing for fixed face ( <TT>..</TT> ) sizes This is an array of 7 items of int type. The values represent size of font with HTML size from -2 to +4 ( <FONT SIZE=-2> to <FONT SIZE=+4> ). Default sizes are used if sizesis NULL. Defaults Default font sizes are defined by constants wxHTML_FONT_SIZE_1, wxHTML_FONT_SIZE_2, ..., wxHTML_FONT_SIZE_7. Note that they differ among platforms. Default face names are empty strings.

wxHtmlWindow::SetPage
bool SetPage(const wxString& source) Sets HTML page and display it. This won't load the page!! It will display the source. See example:
htmlwin -> SetPage("<html><body>Hello, world!</body></html>");

If you want to load a document from some location use LoadPage (p. 702) instead. Parameters source The HTML document source to be displayed. Return value false if an error occurred, true otherwise.

wxHtmlWindow::SetRelatedFrame
void SetRelatedFrame(wxFrame* frame, const wxString& format) Sets the frame in which page title will be displayed. format is format of frame title, e.g. "HtmlHelp : %s". It must contain exactly one %s. This%s is substituted with HTML page title.

wxHtmlWindow::SetRelatedStatusBar
void SetRelatedStatusBar(int bar) After calling SetRelatedFrame (p. 707), this sets statusbar slot where messages will be displayed. (Default is -1 = no messages.)

707


CHAPTER 7
Parameters bar statusbar slot number (0..n)

wxHtmlWindow::WriteCustomization
virtual void WriteCustomization(wxConfigBase *cfg, wxString path = wxEmptyString) Saves custom settings into wxConfig. It uses the path 'path' if given, otherwise it saves info into currently selected path. Regardless of whether the path is given or not, the function creates sub-path wxHtmlWindow. Saved values: all things set by SetFonts, SetBorders. Parameters cfg wxConfig to which you want to save the configuration. path Optional path in config tree. If not given, the current path is used.

wxHtmlWinParser
This class is derived from wxHtmlParser (p. 685) and its main goal is to parse HTML input so that it can be displayed inwxHtmlWindow (p. 699). It uses a special wxHtmlWinTagHandler (p. 714). Notes The product of parsing is a wxHtmlCell (resp. wxHtmlContainer) object. Derived from wxHtmlParser (p. 685) Include files <wx/html/winpars.h> See Also Handlers overview (p. 1696)

708


CHAPTER 7 wxHtmlWinParser::wxHtmlWinParser
wxHtmlWinParser() wxHtmlWinParser(wxHtmlWindow *wnd) Constructor. Don't use the default one, use constructor withwnd parameter (wnd is pointer to associated wxHtmlWindow (p. 699))

wxHtmlWinParser::AddModule
static void AddModule(wxHtmlTagsModule *module) Adds module (p. 1696) to the list of wxHtmlWinParser tag handler.

wxHtmlWinParser::CloseContainer
wxHtmlContainerCell* CloseContainer() Closes the container, sets actual container to the parent one and returns pointer to it (see Overview (p. 1695)).

wxHtmlWinParser::CreateCurrentFont
virtual wxFont* CreateCurrentFont() Creates font based on current setting (see SetFontSize (p. 713), SetFontBold (p. 713), SetFontItalic (p. 713), SetFontFixed (p. 713), SetFontUnderlined (p. 713)) and returns pointer to it. If the font was already created only a pointer is returned.

wxHtmlWinParser::GetActualColor
const wxColour& GetActualColor() const Returns actual text colour.

wxHtmlWinParser::GetAlign
int GetAlign() const Returns default horizontal alignment.

wxHtmlWinParser::GetCharHeight
int GetCharHeight() const

709


CHAPTER 7
Returns (average) char height in standard font. It is used as DC-independent metrics. Note: This function doesn't return the actual height. If you want to know the height of the current font, call GetDC -> GetCharHeight().

wxHtmlWinParser::GetCharWidth
int GetCharWidth() const Returns average char width in standard font. It is used as DC-independent metrics. Note: This function doesn't return the actual width. If you want to know the height of the current font, call GetDC -> GetCharWidth()

wxHtmlWinParser::GetContainer
wxHtmlContainerCell* GetContainer() const Returns pointer to the currently opened container (see Overview (p. 1695)). Common use:
m_WParser- > GetContainer() -> InsertCell(new ...);

wxHtmlWinParser::GetDC
wxDC* GetDC() Returns pointer to the DC used during parsing.

wxHtmlWinParser::GetEncodingConverter
wxEncodingConverter * GetEncodingConverter() const Returns wxEncodingConverter (p. 435) class used to do conversion between input encoding (p. 711) and output encoding (p. 712).

wxHtmlWinParser::GetFontBold
int GetFontBold() const Returns true if actual font is bold, false otherwise.

wxHtmlWinParser::GetFontFace
wxString GetFontFace() const

710


CHAPTER 7
Returns actual font face name.

wxHtmlWinParser::GetFontFixed
int GetFontFixed() const Returns true if actual font is fixed face, false otherwise.

wxHtmlWinParser::GetFontItalic
int GetFontItalic() const Returns true if actual font is italic, false otherwise.

wxHtmlWinParser::GetFontSize
int GetFontSize() const Returns actual font size (HTML size varies from -2 to +4)

wxHtmlWinParser::GetFontUnderlined
int GetFontUnderlined() const Returns true if actual font is underlined, false otherwise.

wxHtmlWinParser::GetInputEncoding
wxFontEncoding GetInputEncoding() const Returns input encoding.

wxHtmlWinParser::GetLink
const wxHtmlLinkInfo& GetLink() const Returns actual hypertext link. (This value has a non-empty Href (p. 683) string if the parser is between <A> and </A> tags, wxEmptyString otherwise.)

wxHtmlWinParser::GetLinkColor
const wxColour& GetLinkColor() const Returns the colour of hypertext link text.

711


CHAPTER 7 wxHtmlWinParser::GetOutputEncoding
wxFontEncoding GetOutputEncoding() const Returns output encoding, i.e. closest match to document's input encoding that is supported by operating system.

wxHtmlWinParser::GetWindow
wxHtmlWindow* GetWindow() Returns associated window (wxHtmlWindow). This may be NULL! (You should always test if it is non-NULL. For example TITLE handler sets window title only if some window is associated, otherwise it does nothing)

wxHtmlWinParser::OpenContainer
wxHtmlContainerCell* OpenContainer() Opens new container and returns pointer to it (see Overview (p. 1695)).

wxHtmlWinParser::SetActualColor
void SetActualColor(const wxColour& clr) Sets actual text colour. Note: this DOESN'T change the colour! You must create wxHtmlColourCell (p. 659) yourself.

wxHtmlWinParser::SetAlign
void SetAlign(int a) Sets default horizontal alignment (see wxHtmlContainerCell::SetAlignHor (p. 661).) Alignment of newly opened container is set to this value.

wxHtmlWinParser::SetContainer
wxHtmlContainerCell* SetContainer(wxHtmlContainerCell *c) Allows you to directly set opened container. This is not recommended - you should use OpenContainer wherever possible.

wxHtmlWinParser::SetDC
virtual void SetDC(wxDC *dc, double pixel_scale = 1.0)

712


CHAPTER 7
Sets the DC. This must be called before Parse (p. 688)!pixel_scale can be used when rendering to high-resolution DCs (e.g. printer) to adjust size of pixel metrics. (Many dimensions in HTML are given in pixels -- e.g. image sizes. 300x300 image would be only one inch wide on typical printer. With pixel_scale = 3.0 it would be 3 inches.)

wxHtmlWinParser::SetFontBold
void SetFontBold(int x) Sets bold flag of actualfont. x is either true of false.

wxHtmlWinParser::SetFontFace
void SetFontFace(const wxString& face) Sets current font face to face. This affects either fixed size font or proportional, depending on context (whether the parser is inside <TT> tag or not).

wxHtmlWinParser::SetFontFixed
void SetFontFixed(int x) Sets fixed face flag of actualfont. x is either true of false.

wxHtmlWinParser::SetFontItalic
void SetFontItalic(int x) Sets italic flag of actualfont. x is either true of false.

wxHtmlWinParser::SetFontSize
void SetFontSize(int s) Sets actual font size (HTML size varies from 1 to 7)

wxHtmlWinParser::SetFontUnderlined
void SetFontUnderlined(int x) Sets underlined flag of actualfont. x is either true of false.

wxHtmlWinParser::SetFonts
void SetFonts(wxString normal_face, wxString fixed_face, const int *sizes = NULL)

713


CHAPTER 7
Sets fonts. See wxHtmlWindow::SetFonts (p. 706) for detailed description.

wxHtmlWinParser::SetInputEncoding
void SetInputEncoding(wxFontEncoding enc) Sets input encoding. The parser uses this information to build conversion tables from document's encoding to some encoding supported by operating system.

wxHtmlWinParser::SetLink
void SetLink(const wxHtmlLinkInfo& link) Sets actual hypertext link. Empty link is represented by wxHtmlLinkInfo (p. 682) with Href equal to wxEmptyString.

wxHtmlWinParser::SetLinkColor
void SetLinkColor(const wxColour& clr) Sets colour of hypertext link.

wxHtmlWinTagHandler
This is basically wxHtmlTagHandler except that it is extended with protected member m_WParser pointing to the wxHtmlWinParser object (value of this member is identical to wxHtmlParser's m_Parser). Derived from wxHtmlTagHandler (p. 696) Include files <wx/html/winpars.h>

wxHtmlWinTagHandler::m_WParser
wxHtmlWinParser* m_WParser Value of this attribute is identical to value of m_Parser. The only different is that m_WParser points to wxHtmlWinParser object while m_Parser points to wxHtmlParser object. (The same object, but overcast.)

714


CHAPTER 7

wxHTTP
Derived from wxProtocol (p. 1027) Include files <wx/protocol/http.h> See also wxSocketBase (p. 1131), wxURL (p. 1355)

wxHTTP::GetResponse
int GetResponse() const Returns the HTTP response code returned by the server. Please refer to the RFC 2616 for the list of the responses.

wxHTTP::GetInputStream
wxInputStream * GetInputStream(const wxString& path) Creates a new input stream on the the specified path. You can use all except the seek functionality of wxStream. Seek isn't available on all streams. For example, http or ftp streams doesn't deal with it. Other functions like Tell and SeekI for this sort of stream. You will be notified when the EOF is reached by an error. Note You can know the size of the file you are getting using wxStreamBase::GetSize() (p. 1192). But there is a limitation: as HTTP servers aren't obliged to pass the size of the file, in some case, you will be returned 0xfffffff by GetSize(). In these cases, you should use the value returned by wxInputStream::LastRead() (p. 762): this value will be 0 when the stream is finished. Return value Returns the initialized stream. You will have to delete it yourself once you don't use it anymore. The destructor closes the network connection. The next time you will try to get a file the network connection will have to be reestablished: but you don't have to take care of this wxHTTP reestablishes it automatically. See also wxInputStream (p. 762)

wxHTTP::SetHeader 715


CHAPTER 7
void SetHeader(const wxString& header, const wxString& h_data) It sets data of a field to be sent during the next request to the HTTP server. The field name is specified by header and the content by h_data. This is a low level function and it assumes that you know what you are doing.

wxHTTP::GetHeader
wxString GetHeader(const wxString& header) Returns the data attached with a field whose name is specified by header. If the field doesn't exist, it will return an empty string and not a NULL string. Note The header is not case-sensitive: I mean that "CONTENT-TYPE" and "content-type" represent the same header.

wxIcon
An icon is a small rectangular bitmap usually used for denoting a minimized application. It differs from a wxBitmap in always having a mask associated with it for transparent drawing. On some platforms, icons and bitmaps are implemented identically, since there is no real distinction between a wxBitmap with a mask and an icon; and there is no specific icon format on some platforms (X-based applications usually standardize on XPMs for small bitmaps and icons). However, some platforms (such as Windows) make the distinction, so a separate class is provided. Derived from wxBitmap (p. 67) wxGDIObject (p. 560) wxObject (p. 954) Include files <wx/icon.h> Predefined objects Objects: wxNullIcon Remarks It is usually desirable to associate a pertinent icon with a frame. Icons can also be used for other purposes, for example with wxTreeCtrl (p. 1327) and wxListCtrl (p. 799). Icons have different formats on different platforms. Therefore, separate icons will usually be created for the different environments. Platform-specific methods for creating a

716


CHAPTER 7
wxIcon structure are catered for, and this is an occasion where conditional compilation will probably be required. Note that a new icon must be created for every time the icon is to be used for a new window. In Windows, the icon will not be reloaded if it has already been used. An icon allocated to a frame will be deleted when the frame is deleted. For more information please see Bitmap and icon overview (p. 1638). See also Bitmap and icon overview (p. 1638), supported bitmap file formats (p. 1639), wxDC::DrawIcon (p. 353), wxCursor (p. 209)

wxIcon::wxIcon
wxIcon() Default constructor. wxIcon(const wxIcon& icon) Copy constructor. wxIcon(void* data, int type, int width, int height, int depth = -1) Creates an icon from the given data, which can be of arbitrary type. wxIcon(const char bits[], int width, int height int depth = 1) Creates an icon from an array of bits. wxIcon(int width, int height, int depth = -1) Creates a new icon. wxIcon(char** bits) wxIcon(const char** bits) Creates an icon from XPM data. wxIcon(const wxString& name, long type, int desiredWidth = -1, int desiredHeight = -1) Loads an icon from a file or resource. wxIcon(const wxIconLocation& loc) Loads an icon from the specified location (p. 725).

717


CHAPTER 7
Parameters bits Specifies an array of pixel values. width Specifies the width of the icon. height Specifies the height of the icon. desiredWidth Specifies the desired width of the icon. This parameter only has an effect in Windows (32-bit) where icon resources can contain several icons of different sizes. desiredWidth Specifies the desired height of the icon. This parameter only has an effect in Windows (32-bit) where icon resources can contain several icons of different sizes. depth Specifies the depth of the icon. If this is omitted, the display depth of the screen is used. name This can refer to a resource name under MS Windows, or a filename under MS Windows and X. Its meaning is determined by the flags parameter. loc The object describing the location of the native icon, see wxIconLocation (p. 725). type May be one of the following: wxBITMAP_TYPE_ICO Load a Windows icon file.

wxBITMAP_TYPE_ICO_RESOURCE Load a Windows icon from the resource database. wxBITMAP_TYPE_GIF wxBITMAP_TYPE_XBM wxBITMAP_TYPE_XPM Load a GIF bitmap file. Load an X bitmap file. Load an XPM bitmap file.

The validity of these flags depends on the platform and wxWindows configuration. If all possible wxWindows settings are used, the Windows platform supports ICO file, ICO resource, XPM data, and XPM file. Under wxGTK, the available formats

718


CHAPTER 7
are BMP file, XPM data, XPM file, and PNG file. Under wxMotif, the available formats are XBM data, XBM file, XPM data, XPM file. Remarks The first form constructs an icon object with no data; an assignment or another member function such as Create or LoadFile must be called subsequently. The second and third forms provide copy constructors. Note that these do not copy the icon data, but instead a pointer to the data, keeping a reference count. They are therefore very efficient operations. The fourth form constructs an icon from data whose type and value depends on the value of the type argument. The fifth form constructs a (usually monochrome) icon from an array of pixel values, under both X and Windows. The sixth form constructs a new icon. The seventh form constructs an icon from pixmap (XPM) data, if wxWindows has been configured to incorporate this feature. To use this constructor, you must first include an XPM file. For example, assuming that the file mybitmap.xpm contains an XPM array of character pointers called mybitmap:
#include "mybitmap.xpm" ... wxIcon *icon = new wxIcon(mybitmap);

A macro, wxICON, is available which creates an icon using an XPM on the appropriate platform, or an icon resource on Windows.
wxIcon icon(wxICON(mondrian)); // Equivalent to: #if defined(__WXGTK__) || defined(__WXMOTIF__) wxIcon icon(mondrian_xpm); #endif #if defined(__WXMSW__) wxIcon icon("mondrian"); #endif

The eighth form constructs an icon from a file or resource. name can refer to a resource name under MS Windows, or a filename under MS Windows and X. Under Windows, type defaults to wxBITMAP_TYPE_ICO_RESOURCE. Under X, type defaults to wxBITMAP_TYPE_XPM. See also

wxIcon::CopyFromBitmap

719


CHAPTER 7
void CopyFromBitmap(const wxBitmap& bmp) Copies bmp bitmap to this icon. Under MS Windows the bitmap must have mask colour set. wxIcon::LoadFile (p. 721) wxPerl note: Constructors supported by wxPerl are: ::Icon->new( width, height, depth = -1 ) ::Icon->new( name, type, desiredWidth = -1, desiredHeight = -1 ) ::Icon->newFromBits( bits, width, height, depth = 1 ) ::Icon->newFromXPM( data )

wxIcon::~wxIcon
~wxIcon() Destroys the wxIcon object and possibly the underlying icon data. Because reference counting is used, the icon may not actually be destroyed at this point - only when the reference count is zero will the data be deleted. If the application omits to delete the icon explicitly, the icon will be destroyed automatically by wxWindows when the application exits. Do not delete an icon that is selected into a memory device context.

wxIcon::GetDepth
int GetDepth() const Gets the colour depth of the icon. A value of 1 indicates a monochrome icon.

wxIcon::GetHeight
int GetHeight() const Gets the height of the icon in pixels.

wxIcon::GetWidth
int GetWidth() const Gets the width of the icon in pixels. See also

720


CHAPTER 7
wxIcon::GetHeight (p. 720)

wxIcon::LoadFile
bool LoadFile(const wxString& name, long type) Loads an icon from a file or resource. Parameters name Either a filename or a Windows resource name. The meaning of name is determined by the type parameter. type One of the following values: wxBITMAP_TYPE_ICO Load a Windows icon file.

wxBITMAP_TYPE_ICO_RESOURCE Load a Windows icon from the resource database. wxBITMAP_TYPE_GIF wxBITMAP_TYPE_XBM wxBITMAP_TYPE_XPM Load a GIF bitmap file. Load an X bitmap file. Load an XPM bitmap file.

The validity of these flags depends on the platform and wxWindows configuration. Return value true if the operation succeeded, false otherwise. See also wxIcon::wxIcon (p. 717)

wxIcon::Ok
bool Ok() const Returns true if icon data is present.

wxIcon::SetDepth
void SetDepth(int depth) Sets the depth member (does not affect the icon data).

721


CHAPTER 7
Parameters depth Icon depth.

wxIcon::SetHeight
void SetHeight(int height) Sets the height member (does not affect the icon data). Parameters height Icon height in pixels.

wxIcon::SetOk
void SetOk(int isOk) Sets the validity member (does not affect the icon data). Parameters isOk Validity flag.

wxIcon::SetWidth
void SetWidth(int width) Sets the width member (does not affect the icon data). Parameters width Icon width in pixels.

wxIcon::operator =
wxIcon& operator =(const wxIcon& icon) Assignment operator. This operator does not copy any data, but instead passes a pointer to the data in icon and increments a reference counter. It is a fast operation. Parameters

722


CHAPTER 7
icon Icon to assign. Return value Returns 'this' object.

wxIcon::operator ==
bool operator ==(const wxIcon& icon) Equality operator. This operator tests whether the internal data pointers are equal (a fast test). Parameters icon Icon to compare with 'this' Return value Returns true if the icons were effectively equal, false otherwise.

wxIcon::operator !=
bool operator !=(const wxIcon& icon) Inequality operator. This operator tests whether the internal data pointers are unequal (a fast test). Parameters icon Icon to compare with 'this' Return value Returns true if the icons were unequal, false otherwise.

wxIconBundle
This class contains multiple copies of an icon in different sizes, see also wxDialog::SetIcons (p. 374) andwxFrame::SetIcons (p. 539). Derived from No base class

723


CHAPTER 7

wxIconBundle::wxIconBundle
wxIconBundle() Default constructor. wxIconBundle(const wxString& file, long type) Initializes the bundle with the icon(s) found in the file. wxIconBundle(const wxIcon& icon) Initializes the bundle with a single icon. wxIconBundle(const wxIconBundle& ic) Copy constructor.

wxIconBundle::~wxIconBundle
~wxIconBundle() Destructor.

wxIconBundle::AddIcon
void AddIcon(const wxString& file, long type) Adds all the icons contained in the file to the bundle; if the collection already contains icons with the same width and height, they are replaced by the new ones. void AddIcon(const wxIcon& icon) Adds the icon to the collection; if the collection already contains an icon with the same width and height, it is replaced by the new one.

wxIconBundle::GetIcon
const wxIcon& GetIcon(const wxSize& size) const Returns the icon with the given size; if no such icon exists, returns the icon with size wxSYS_ICON_X/wxSYS_ICON_Y; if no such icon exists, returns the first icon in the bundle. If size = wxSize( -1, -1 ), returns the icon with size wxSYS_ICON_X/wxSYS_ICON_Y. const wxIcon& GetIcon(wxCoord size = -1) const

724


CHAPTER 7
Same as GetIcon( wxSize( size, size ) ).

wxIconBundle::operator=
const wxIconBundle& operator=(const wxIconBundle& ic) Assignment operator.

wxIconLocation
wxIconLocation is a tiny class describing the location of an (external, i.e. not embedded into the application resources) icon. For most platforms it simply contains the file name but under some others (notably Windows) the same file may contain multiple icons and so this class also stores the index of the icon inside the file. In any case, its details should be of no interest to the application code and most of them are not even documented here (on purpose) as it is only meant to be used as an opaque class: the application may get the object of this class from somewhere and the only reasonable thing to do with it later is to create a wxIcon (p. 716) from it. Derived from None. Include files <wx/iconloc.h> See also wxFileType::GetIcon() (p. 500)

wxIconLocation::IsOk
bool IsOk() const Returns true if the object is valid, i.e. was properly initialized, and false otherwise.

wxIconizeEvent
An event being sent when the frame is iconized (minimized) or restored. Currently only wxMSW and wxGTK generate such events. Derived from

725


CHAPTER 7
wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process an iconize event, use this event handler macro to direct input to a member function that takes a wxIconizeEvent argument. EVT_ICONIZE(func) Process a wxEVT_ICONIZE event.

See also Event handling overview (p. 1602), wxFrame::Iconize (p. 536), wxFrame::IsIconized (p. 537)

wxIconizeEvent::wxIconizeEvent
wxIconizeEvent(int id = 0, bool iconized = true) Constructor.

wxIconizeEvent::Iconized
bool Iconized() const Returns true if the frame has been iconized, false if it has been restored.

wxIdleEvent
This class is used for idle events, which are generated when the system is idle. By default, idle events are sent to all windows. If this is causing a significant overhead in your application, you can call wxIdleEvent::SetMode (p. 728) with the value wxIDLE_PROCESS_SPECIFIED, and set the wxWS_EX_PROCESS_IDLE extra window style for every window which should receive idle events. The function wxWindow::OnInternalIdle (p. 1412) is also provided for internal purposes, and cannot be disabled. wxUpdateUIEvents are sent from OnInternalIdle. Derived from wxEvent (p. 439) wxObject (p. 954) Include files

726


CHAPTER 7
<wx/event.h> Event table macros To process an idle event, use this event handler macro to direct input to a member function that takes a wxIdleEvent argument. EVT_IDLE(func) Process a wxEVT_IDLE event.

Remarks Idle events can be caught by the wxApp class, or by top-level window classes. See also Event handling overview (p. 1602), wxUpdateUIEvent (p. 1350), wxWindow::OnInternalIdle (p. 1412)

wxIdleEvent::wxIdleEvent
wxIdleEvent() Constructor.

wxIdleEvent::CanSend
static bool CanSend(wxWindow* window) Returns true if it is appropriate to send idle events to this window. This function looks at the mode used (see wxIdleEvent::SetMode (p. 728)), and the wxWS_EX_PROCESS_IDLE style in window to determine whether idle events should be sent to this window now. By default this will always return true because the update mode is initially wxIDLE_PROCESS_ALL. You can change the mode to only send idle events to windows with the wxWS_EX_PROCESS_IDLE extra window style set. See also wxIdleEvent::SetMode (p. 728)

wxIdleEvent::GetMode
static wxIdleMode GetMode() Static function returning a value specifying how wxWindows will send idle events: to all windows, or only to those which specify that they will process the events. See wxIdleEvent::SetMode (p. 728).

727


CHAPTER 7 wxIdleEvent::RequestMore
void RequestMore(bool needMore = true) Tells wxWindows that more processing is required. This function can be called by an OnIdle handler for a window or window event handler to indicate that wxApp::OnIdle should forward the OnIdle event once more to the application windows. If no window calls this function during OnIdle, then the application will remain in a passive event loop (not calling OnIdle) until a new event is posted to the application by the windowing system. See also wxIdleEvent::MoreRequested (p. 728)

wxIdleEvent::MoreRequested
bool MoreRequested() const Returns true if the OnIdle function processing this event requested more processing time. See also wxIdleEvent::RequestMore (p. 728)

wxIdleEvent::SetMode
static void SetMode(wxIdleMode mode) Static function for specifying how wxWindows will send idle events: to all windows, or only to those which specify that they will process the events. mode can be one of the following values. The default is wxIDLE_PROCESS_ALL.
enum wxIdleMode { // Send idle events to all windows wxIDLE_PROCESS_ALL, // Send idle events to windows that have // the wxWS_EX_PROCESS_IDLE flag specified wxIDLE_PROCESS_SPECIFIED };

wxImage
This class encapsulates a platform-independent image. An image can be created from data, or using wxBitmap::ConvertToImage (p. 71). An image can be loaded from a file in a variety of formats, and is extensible to new formats via image format handlers. Functions are available to set and get image bits, so it can be used for basic image

728


CHAPTER 7
manipulation. A wxImage cannot (currently) be drawn directly to a wxDC (p. 347). Instead, a platformspecific wxBitmap (p. 67) object must be created from it using the wxBitmap::wxBitmap(wxImage,int depth) (p. 67) constructor. This bitmap can then be drawn in a device context, using wxDC::DrawBitmap (p. 352). One colour value of the image may be used as a mask colour which will lead to the automatic creation of a wxMask (p. 860) object associated to the bitmap object. Alpha channel support Starting from wxWindows 2.5.0 wxImage supports alpha channel data, that is in addition to a byte for the red, green and blue colour components for each pixel it also stores a byte representing the pixel opacity. The alpha value of 0corresponds to a transparent pixel (null opacity) while the value of 255means that the pixel is 100% opaque. Unlike the RGB data, not all images have the alpha channel and before using GetAlpha (p. 736) you should check if this image contains alpha value with HasAlpha (p. 740). In fact, currently only images loaded from PNG files with transparency information will have alpha channel but support for it will be added to the other formats as well (as well as support for saving images with alpha channel which is not still implemented either). Available image handlers The following image handlers are available. wxBMPHandler is always installed by default. To use other image formats, install the appropriate handler with wxImage::AddHandler (p. 733) or wxInitAllImageHandlers (p. 1467). wxBMPHandler wxPNGHandler wxJPEGHandler wxGIFHandler wxPCXHandler wxPNMHandler wxTIFFHandler wxIFFHandler wxXPMHandler wxICOHandler wxCURHandler wxANIHandler For loading and saving, always installed. For loading (including alpha support) and saving. For loading and saving. Only for loading, due to legal issues. For loading and saving (see below). For loading and saving (see below). For loading and saving. For loading only. For loading and saving. For loading and saving. For loading and saving. For loading only.

When saving in PCX format, wxPCXHandler will count the number of different colours in the image; if there are 256 or less colours, it will save as 8 bit, else it will save as 24 bit.

729


CHAPTER 7
Loading PNMs only works for ASCII or raw RGB images. When saving in PNM format, wxPNMHandler will always save as raw RGB. Derived from wxObject (p. 954) Include files <wx/image.h> See also wxBitmap (p. 67), wxInitAllImageHandlers (p. 1467)

wxImage::wxImage
wxImage() Default constructor. wxImage(const wxImage& image) Copy constructor. wxImage(const wxBitmap& bitmap) (Deprecated form, use wxBitmap::ConvertToImage (p. 71)instead.) Constructs an image from a platform-dependent bitmap. This preserves mask information so that bitmaps and images can be converted back and forth without loss in that respect. wxImage(int width, int height, bool clear=true) Creates an image with the given width and height. If clear is true, the new image will be initialized to black. Otherwise, the image data will be uninitialized. wxImage(int width, int height, unsigned char* data, bool static_data=false) Creates an image from given data with the given width and height. If static_data is true, then wxImage will not delete the actual image data in its destructor, otherwise it will free it by callingfree(). wxImage(const wxString& name, long type = wxBITMAP_TYPE_ANY, int index = -1) wxImage(const wxString& name, const wxString& mimetype, int index = -1) Loads an image from a file. wxImage(wxInputStream& stream, long type = wxBITMAP_TYPE_ANY, int index = 1) wxImage(wxInputStream& stream, const wxString& mimetype, int index = -1)

730


CHAPTER 7
Loads an image from an input stream. Parameters width Specifies the width of the image. height Specifies the height of the image. name Name of the file from which to load the image. stream Opened input stream from which to load the image. Currently, the stream must support seeking. type May be one of the following: wxBITMAP_TYPE_BMP wxBITMAP_TYPE_GIF wxBITMAP_TYPE_JPEG wxBITMAP_TYPE_PNG wxBITMAP_TYPE_PCX wxBITMAP_TYPE_PNM wxBITMAP_TYPE_TIF wxBITMAP_TYPE_XPM wxBITMAP_TYPE_ICO wxBITMAP_TYPE_CUR wxBITMAP_TYPE_ANI wxBITMAP_TYPE_ANY mimetype MIME type string (for example 'image/jpeg') index Load a Windows bitmap file. Load a GIF bitmap file. Load a JPEG bitmap file. Load a PNG bitmap file. Load a PCX bitmap file. Load a PNM bitmap file. Load a TIFF bitmap file. Load a XPM bitmap file. Load a Windows icon file (ICO). Load a Windows cursor file (CUR). Load a Windows animated cursor file (ANI). Will try to autodetect the format.

731


CHAPTER 7
Index of the image to load in the case that the image file contains multiple images. This is only used by GIF, ICO and TIFF handlers. The default value (-1) means "choose the default image" and is interpreted as the first image (index=0) by the GIF and TIFF handler and as the largest and most colourful one by the ICO handler. Remarks Depending on how wxWindows has been configured, not all formats may be available. Note: any handler other than BMP must be previously initialized with wxImage::AddHandler (p. 733) or wxInitAllImageHandlers (p. 1467).
Note: you can use GetOptionInt (p. 740) to get the hotspot for loaded cursor file: int hotspot_x = image.GetOptionInt(wxIMAGE_OPTION_CUR_HOTSPOT_X); int hotspot_y = image.GetOptionInt(wxIMAGE_OPTION_CUR_HOTSPOT_Y);

See also wxImage::LoadFile (p. 741) wxPython note: Constructors supported by wxPython are: wxImage(name, flag) wxNullImage() Loads an image from a file Create a null image (has no size or image data)

wxEmptyImage(width, height) Creates an empty image of the given size wxImageFromMime(name, mimetype Creates an image from the given file of the given mimetype wxImageFromBitmap(bitmap) Creates an image from a platformdependent bitmap wxPerl note: Constructors supported by wxPerl are: ::Image->new( bitmap ) ::Image->new( icon ) ::Image->new( width, height ) ::Image->new( width, height, data ) ::Image->new( file, type, index ) ::Image->new( file, mimetype, index ) ::Image->new( stream, type, index ) ::Image->new( stream, mimetype, index )

732


CHAPTER 7 wxImage::~wxImage
~wxImage() Destructor.

wxImage::AddHandler
static void AddHandler(wxImageHandler* handler) Adds a handler to the end of the static list of format handlers. handler A new image format handler object. There is usually only one instance of a given handler class in an application session. See also wxImageHandler (p. 750) bool CanRead(const wxString& filename) returns true if the current image handlers can read this file

wxPython note: In wxPython this static method is named wxImage_AddHandler.wxImage::CleanUpHandlers
static void CleanUpHandlers() Deletes all image handlers. This function is called by wxWindows on exit.

wxImage::ComputeHistogram
unsigned long ComputeHistogram(wxImageHistogram& histogram) const Computes the histogram of the image. histogram is a reference to wxImageHistogram object. wxImageHistogram is a specialization of wxHashMap (p. 637) "template" and is defined as follows:
class WXDLLEXPORT wxImageHistogramEntry { public: wxImageHistogramEntry() : index(0), value(0) {} unsigned long index; unsigned long value; }; WX_DECLARE_EXPORTED_HASH_MAP(unsigned long, wxImageHistogramEntry, wxIntegerHash, wxIntegerEqual, wxImageHistogram);

733


CHAPTER 7

Return value Returns number of colours in the histogram.

wxImage::ConvertToBitmap
wxBitmap ConvertToBitmap() const Deprecated, use equivalent wxBitmap constructor (p. 67)(which takes wxImage and depth as its arguments) instead.

wxImage::ConvertToMono
wxImage ConvertToMono(unsigned char r, unsigned char g, unsigned char b) const Returns monochromatic version of the image. The returned image has white colour where the original has (r,g,b) colour and black colour everywhere else.

wxImage::Copy
wxImage Copy() const Returns an identical copy of the image.

wxImage::Create
bool Create(int width, int height, bool clear=true) Creates a fresh image. If clear is true, the new image will be initialized to black. Otherwise, the image data will be uninitialized. Parameters width The width of the image in pixels. height The height of the image in pixels. Return value true if the call succeeded, false otherwise.

wxImage::Destroy 734


CHAPTER 7
bool Destroy() Destroys the image data.

wxImage::FindFirstUnusedColour
bool FindFirstUnusedColour(unsigned char * r, unsigned char * g, unsigned char * b, unsigned char startR = 1, unsigned char startG = 0, unsigned char startB = 0) Parameters r,g,b Pointers to variables to save the colour. startR,startG,startB Initial values of the colour. Returned colour will have RGB values equal to or greater than these. Finds the first colour that is never used in the image. The search begins at given initial colour and continues by increasing R, G and B components (in this order) by 1 until an unused colour is found or the colour space exhausted. Return value Returns false if there is no unused colour left, true on success. Notes Note that this method involves computing the histogram, which is computationally intensive operation.

wxImage::FindHandler
static wxImageHandler* FindHandler(const wxString& name) Finds the handler with the given name. static wxImageHandler* FindHandler(const wxString& extension, long imageType) Finds the handler associated with the given extension and type. static wxImageHandler* FindHandler(long imageType) Finds the handler associated with the given image type. static wxImageHandler* FindHandlerMime(const wxString& mimetype) Finds the handler associated with the given MIME type. name

735


CHAPTER 7
The handler name. extension The file extension, such as "bmp". imageType The image type, such as wxBITMAP_TYPE_BMP. mimetype MIME type. Return value A pointer to the handler if found, NULL otherwise. See also wxImageHandler (p. 750)

wxImage::GetImageExtWildcard
static wxString GetImageExtWildcard() Iterates all registered wxImageHandler objects, and returns a string containing file extension masks suitable for passing to file open/save dialog boxes. Return value The format of the returned string is "(*.ext1;*.ext2)|*.ext1;*.ext2". It is usually a good idea to prepend a description before passing the result to the dialog. Example:
wxFileDialog FileDlg( this, "Choose Image", ::wxGetWorkingDirectory(), "", _("Image Files ") + wxImage::GetImageExtWildcard(), wxOPN ); E

See also wxImageHandler (p. 750)

wxImage::GetAlpha
unsigned char GetAlpha(int x, int y) const Returns the alpha value for the given pixel. This function may only be called for the images with alpha channel, use HasAlpha (p. 740) to check for this. The returned value is the opacity of the image, i.e. the value of 0corresponds to the transparent pixels while the value of 255 -- to the opaque ones.

736


CHAPTER 7
unsigned char * GetAlpha() const Returns pointer to the array storing the alpha values for this image. This pointer is NULL for the images without the alpha channel. If the image does have it, this pointer may be used to directly manipulate the alpha values which are stored as the RGB (p. 737) ones.

wxImage::GetBlue
unsigned char GetBlue(int x, int y) const Returns the blue intensity at the given coordinate.

wxImage::GetData
unsigned char* GetData() const Returns the image data as an array. This is most often used when doing direct image manipulation. The return value points to an array of characters in RGBRGBRGB... format in the top-to-bottom, left-to-right order, that is the first RGB triplet corresponds to the pixel (0, 0), the second one --- to (0, 1) and so on. You should not delete the returned pointer nor pass it towxImage::SetData (p. 747).

wxImage::GetGreen
unsigned char GetGreen(int x, int y) const Returns the green intensity at the given coordinate.

wxImage::GetImageCount
static int GetImageCount(const wxString& filename, long type = wxBITMAP_TYPE_ANY) static int GetImageCount(wxInputStream& stream, long type = wxBITMAP_TYPE_ANY) If the image file contains more than one image and the image handler is capable of retrieving these individually, this function will return the number of available images. name Name of the file to query. stream Opened input stream with image data. Currently, the stream must support seeking. type

737


CHAPTER 7
May be one of the following: wxBITMAP_TYPE_BMP wxBITMAP_TYPE_GIF wxBITMAP_TYPE_JPEG wxBITMAP_TYPE_PNG wxBITMAP_TYPE_PCX wxBITMAP_TYPE_PNM wxBITMAP_TYPE_TIF wxBITMAP_TYPE_XPM wxBITMAP_TYPE_ICO wxBITMAP_TYPE_CUR wxBITMAP_TYPE_ANI wxBITMAP_TYPE_ANY Return value Number of available images. For most image handlers, this is 1 (exceptions are TIFF and ICO formats). Load a Windows bitmap file. Load a GIF bitmap file. Load a JPEG bitmap file. Load a PNG bitmap file. Load a PCX bitmap file. Load a PNM bitmap file. Load a TIFF bitmap file. Load a XPM bitmap file. Load a Windows icon file (ICO). Load a Windows cursor file (CUR). Load a Windows animated cursor file (ANI). Will try to autodetect the format.

wxImage::GetHandlers
static wxList& GetHandlers() Returns the static list of image format handlers. See also wxImageHandler (p. 750)

wxImage::GetHeight
int GetHeight() const Gets the height of the image in pixels.

wxImage::GetMaskBlue
unsigned char GetMaskBlue() const

738


CHAPTER 7
Gets the blue value of the mask colour.

wxImage::GetMaskGreen
unsigned char GetMaskGreen() const Gets the green value of the mask colour.

wxImage::GetMaskRed
unsigned char GetMaskRed() const Gets the red value of the mask colour.

wxImage::GetPalette
const wxPalette& GetPalette() const Returns the palette associated with the image. Currently the palette is only used when converting to wxBitmap under Windows. Eventually wxImage handlers will set the palette if one exists in the image file.

wxImage::GetRed
unsigned char GetRed(int x, int y) const Returns the red intensity at the given coordinate.

wxImage::GetSubImage
wxImage GetSubImage(const wxRect& rect) const Returns a sub image of the current one as long as the rect belongs entirely to the image.

wxImage::GetWidth
int GetWidth() const Gets the width of the image in pixels. See also wxImage::GetHeight (p. 738)

739


CHAPTER 7 wxImage::HasAlpha
bool HasAlpha() const Returns true if this image has alpha channel, false otherwise. See also GetAlpha (p. 736), SetAlpha (p. 747)

wxImage::HasMask
bool HasMask() const Returns true if there is a mask active, false otherwise.

wxImage::GetOption
wxString GetOption(const wxString& name) const Gets a user-defined option. The function is case-insensitive to name. For example, when saving as a JPEG file, the option quality is used, which is a number between 0 and 100 (0 is terrible, 100 is very good). See also wxImage::SetOption (p. 748), wxImage::GetOptionInt (p. 740), wxImage::HasOption (p. 740)

wxImage::GetOptionInt
int GetOptionInt(const wxString& name) const Gets a user-defined option as an integer. The function is case-insensitive to name. See also wxImage::SetOption (p. 748), wxImage::GetOption (p. 740), wxImage::HasOption (p. 740)

wxImage::HasOption
bool HasOption(const wxString& name) const Returns true if the given option is present. The function is case-insensitive to name. See also

740


CHAPTER 7
wxImage::SetOption (p. 748), wxImage::GetOption (p. 740), wxImage::GetOptionInt (p. 740)

wxImage::InitStandardHandlers
static void InitStandardHandlers() Internal use only. Adds standard image format handlers. It only install BMP for the time being, which is used by wxBitmap. This function is called by wxWindows on startup, and shouldn't be called by the user. See also wxImageHandler (p. 750), wxInitAllImageHandlers (p. 1467)

wxImage::InsertHandler
static void InsertHandler(wxImageHandler* handler) Adds a handler at the start of the static list of format handlers. handler A new image format handler object. There is usually only one instance of a given handler class in an application session. See also wxImageHandler (p. 750)

wxImage::LoadFile
bool LoadFile(const wxString& name, long type = wxBITMAP_TYPE_ANY, int index = -1) bool LoadFile(const wxString& name, const wxString& mimetype, int index = -1) Loads an image from a file. If no handler type is provided, the library will try to autodetect the format. bool LoadFile(wxInputStream& stream, long type, int index = -1) bool LoadFile(wxInputStream& stream, const wxString& mimetype, int index = -1) Loads an image from an input stream. Parameters name

741


CHAPTER 7
Name of the file from which to load the image. stream Opened input stream from which to load the image. Currently, the stream must support seeking. type One of the following values: wxBITMAP_TYPE_BMP wxBITMAP_TYPE_GIF wxBITMAP_TYPE_JPEG wxBITMAP_TYPE_PCX wxBITMAP_TYPE_PNG wxBITMAP_TYPE_PNM wxBITMAP_TYPE_TIF wxBITMAP_TYPE_XPM wxBITMAP_TYPE_ICO wxBITMAP_TYPE_CUR wxBITMAP_TYPE_ANI wxBITMAP_TYPE_ANY mimetype MIME type string (for example 'image/jpeg') index Index of the image to load in the case that the image file contains multiple images. This is only used by GIF, ICO and TIFF handlers. The default value (-1) means "choose the default image" and is interpreted as the first image (index=0) by the GIF and TIFF handler and as the largest and most colourful one by the ICO handler. Remarks Depending on how wxWindows has been configured, not all formats may be available.
Note: you can use GetOptionInt (p. 740) to get the hotspot for loaded cursor file: int hotspot_x = image.GetOptionInt(wxIMAGE_OPTION_CUR_HOTSPOT_X); int hotspot_y = image.GetOptionInt(wxIMAGE_OPTION_CUR_HOTSPOT_Y);

Load a Windows image file. Load a GIF image file. Load a JPEG image file. Load a PCX image file. Load a PNG image file. Load a PNM image file. Load a TIFF image file. Load a XPM image file. Load a Windows icon file (ICO). Load a Windows cursor file (CUR). Load a Windows animated cursor file (ANI). Will try to autodetect the format.

742


CHAPTER 7

Return value true if the operation succeeded, false otherwise. If the optional index parameter is out of range, false is returned and a call to wxLogError() takes place. See also wxImage::SaveFile (p. 743) wxPython note: In place of a single overloaded method name, wxPython implements the following methods: LoadFile(filename, type) Loads an image of the given type from a file

LoadMimeFile(filename, mimetype) Loads an image of the given mimetype from a file wxPerl note: Methods supported by wxPerl are: >LoadFile( name, type ) >LoadFile( name, mimetype )

wxImage::Ok
bool Ok() const Returns true if image data is present.

wxImage::RemoveHandler
static bool RemoveHandler(const wxString& name) Finds the handler with the given name, and removes it. The handler is not deleted. name The handler name. Return value true if the handler was found and removed, false otherwise. See also wxImageHandler (p. 750)

wxImage::SaveFile

743


CHAPTER 7
bool SaveFile(const wxString& name, int type) const bool SaveFile(const wxString& name, const wxString& mimetype) const Saves an image in the named file. bool SaveFile(const wxString& name) const Saves an image in the named file. File type is determined from the extension of the file name. Note that this function may fail if the extension is not recognized! You can use one of the forms above to save images to files with non-standard extensions. bool SaveFile(wxOutputStream& stream, int type) const bool SaveFile(wxOutputStream& stream, const wxString& mimetype) const Saves an image in the given stream. Parameters name Name of the file to save the image to. stream Opened output stream to save the image to. type Currently these types can be used: wxBITMAP_TYPE_BMP wxBITMAP_TYPE_JPEG wxBITMAP_TYPE_PNG wxBITMAP_TYPE_PCX wxBITMAP_TYPE_PNM wxBITMAP_TYPE_TIFF wxBITMAP_TYPE_XPM wxBITMAP_TYPE_ICO Save a BMP image file. Save a JPEG image file. Save a PNG image file. Save a PCX image file (tries to save as 8-bit if possible, falls back to 24-bit otherwise). Save a PNM image file (as raw RGB always). Save a TIFF image file. Save a XPM image file. Save a Windows icon file (ICO) (the size may be up to 255 wide by 127 high. A single image is saved in 8 colors at the size supplied). Save a Windows cursor file (CUR).

wxBITMAP_TYPE_CUR mimetype

744


CHAPTER 7
MIME type. Return value true if the operation succeeded, false otherwise. Remarks Depending on how wxWindows has been configured, not all formats may be available.
Note: you can use GetOptionInt (p. 740) to set the hotspot before saving an image into a cursor file (default hotspot is in the centre of the image): image.SetOption(wxIMAGE_OPTION_CUR_HOTSPOT_X, hotspotX); image.SetOption(wxIMAGE_OPTION_CUR_HOTSPOT_Y, hotspotY);

See also wxImage::LoadFile (p. 741) wxPython note: In place of a single overloaded method name, wxPython implements the following methods: SaveFile(filename, type) Saves the image using the given type to the named file

SaveMimeFile(filename, mimetype) Saves the image using the given mimetype to the named file wxPerl note: Methods supported by wxPerl are: >SaveFile( name, type ) >SaveFile( name, mimetype )

wxImage::Mirror
wxImage Mirror(bool horizontally = true) const Returns a mirrored copy of the image. The parameter horizontallyindicates the orientation.

wxImage::Replace
void Replace(unsigned char r1, unsigned char g1, unsigned char b1,unsigned char r2, unsigned char g2, unsigned char b2) Replaces the colour specified by r1,g1,b1 by the colour r2,g2,b2.

wxImage::Rescale

745


CHAPTER 7
wxImage & Rescale(int width, int height) Changes the size of the image in-place: after a call to this function, the image will have the given width and height. Returns the (modified) image itself. See also Scale (p. 746)

wxImage::Rotate
wxImage Rotate(double angle, const wxPoint& rotationCentre, bool interpolating = true, wxPoint* offsetAfterRotation = NULL) Rotates the image about the given point, by angle radians. Passing true to interpolating results in better image quality, but is slower. If the image has a mask, then the mask colour is used for the uncovered pixels in the rotated image background. Else, black (rgb 0, 0, 0) will be used. Returns the rotated image, leaving this image intact.

wxImage::Rotate90
wxImage Rotate90(bool clockwise = true) const Returns a copy of the image rotated 90 degrees in the direction indicated by clockwise.

wxImage::Scale
wxImage Scale(int width, int height) const Returns a scaled version of the image. This is also useful for scaling bitmaps in general as the only other way to scale bitmaps is to blit a wxMemoryDC into another wxMemoryDC. It may be mentioned that the GTK port uses this function internally to scale bitmaps when using mapping modes in wxDC. Example:
// get the bitmap from somewhere wxBitmap bmp = ...; // rescale it to have size of 32*32 if ( bmp.GetWidth() != 32 || bmp.GetHeight() != 32 ) { wxImage image = bmp.ConvertToImage(); bmp = wxBitmap(image.Scale(32, 32)); // another possibility: image.Rescale(32, 32);

746


CHAPTER 7
bmp = image; }

See also Rescale (p. 745)

wxImage::SetAlpha
void SetAlpha(unsigned char *alpha = NULL) This function is similar to SetData (p. 747) and has similar restrictions. The pointer passed to it may however be NULL in which case the function will allocate the alpha array internally -- this is useful to add alpha channel data to an image which doesn't have any. If the pointer is not NULL, it must have one byte for each image pixel and be allocated with malloc(). wxImage takes ownership of the pointer and will free it. void SetAlpha(int x, int y, unsigned char alpha) Sets the alpha value for the given pixel. This function should only be called if the image has alpha channel data, use HasAlpha (p. 740) to check for this.

wxImage::SetData
void SetData(unsigned char*data) Sets the image data without performing checks. The data given must have the size (width*height*3) or results will be unexpected. Don't use this method if you aren't sure you know what you are doing. The data must have been allocated with malloc(), NOT withoperator new. After this call the pointer to the data is owned by the wxImage object, that will be responsible for deleting it. Do not pass to this function a pointer obtained throughwxImage::GetData (p. 737).

wxImage::SetMask
void SetMask(bool hasMask = true) Specifies whether there is a mask or not. The area of the mask is determined by the current mask colour.

wxImage::SetMaskColour
void SetMaskColour(unsigned char red, unsigned char green, unsigned char blue) Sets the mask colour for this image (and tells the image to use the mask).

747


CHAPTER 7 wxImage::SetMaskFromImage
bool SetMaskFromImage(const wxImage& mask, unsigned char mr, unsigned char mg, unsigned char mb) Parameters mask The mask image to extract mask shape from. Must have same dimensions as the image. mr,mg,mb RGB value of pixels in mask that will be used to create the mask. Sets image's mask so that the pixels that have RGB value of mr,mg,mbin mask will be masked in the image. This is done by first finding an unused colour in the image, setting this colour as the mask colour and then using this colour to draw all pixels in the image who corresponding pixel in mask has given RGB value. Return value Returns false if mask does not have same dimensions as the image or if there is no unused colour left. Returns true if the mask was successfully applied. Notes Note that this method involves computing the histogram, which is computationally intensive operation.

wxImage::SetOption
void SetOption(const wxString& name, const wxString& value) void SetOption(const wxString& name, int value) Sets a user-defined option. The function is case-insensitive to name. For example, when saving as a JPEG file, the option quality is used, which is a number between 0 and 100 (0 is terrible, 100 is very good). See also wxImage::GetOption (p. 740), wxImage::GetOptionInt (p. 740), wxImage::HasOption (p. 740)

wxImage::SetPalette
void SetPalette(const wxPalette& palette) Associates a palette with the image. The palette may be used when converting wxImage

748


CHAPTER 7
to wxBitmap (MSW only at present) or in file save operations (none as yet).

wxImage::SetRGB
void SetRGB(int x, int y, unsigned char red, unsigned char green, unsigned char blue) Sets the pixel at the given coordinate. This routine performs bounds-checks for the coordinate so it can be considered a safe way to manipulate the data, but in some cases this might be too slow so that the data will have to be set directly. In that case you will have to get access to the image data using the GetData (p. 737) method.

wxImage::operator =
wxImage& operator =(const wxImage& image) Assignment operator. This operator does not copy any data, but instead passes a pointer to the data in image and increments a reference counter. It is a fast operation. Parameters image Image to assign. Return value Returns 'this' object.

wxImage::operator ==
bool operator ==(const wxImage& image) const Equality operator. This operator tests whether the internal data pointers are equal (a fast test). Parameters image Image to compare with 'this' Return value Returns true if the images were effectively equal, false otherwise.

wxImage::operator !=
bool operator !=(const wxImage& image) const

749


CHAPTER 7
Inequality operator. This operator tests whether the internal data pointers are unequal (a fast test). Parameters image Image to compare with 'this' Return value Returns true if the images were unequal, false otherwise.

wxImageHandler
This is the base class for implementing image file loading/saving, and image creation from data. It is used within wxImage and is not normally seen by the application. If you wish to extend the capabilities of wxImage, derive a class from wxImageHandler and add the handler using wxImage::AddHandler (p. 733) in your application initialisation. Note (Legal Issue) This software is based in part on the work of the Independent JPEG Group. (Applies when wxWindows is linked with JPEG support. wxJPEGHandler uses libjpeg created by IJG.) Derived from wxObject (p. 954) Include files <wx/image.h> See also wxImage (p. 728), wxInitAllImageHandlers (p. 1467)

wxImageHandler::wxImageHandler
wxImageHandler() Default constructor. In your own default constructor, initialise the members m_name, m_extension and m_type.

wxImageHandler::~wxImageHandler 750


CHAPTER 7
~wxImageHandler() Destroys the wxImageHandler object.

wxImageHandler::GetName
wxString GetName() const Gets the name of this handler.

wxImageHandler::GetExtension
wxString GetExtension() const Gets the file extension associated with this handler.

wxImageHandler::GetImageCount
int GetImageCount(wxInputStream& stream) If the image file contains more than one image and the image handler is capable of retrieving these individually, this function will return the number of available images. stream Opened input stream for reading image data. Currently, the stream must support seeking. Return value Number of available images. For most image handlers, this is 1 (exceptions are TIFF and ICO formats).

wxImageHandler::GetType
long GetType() const Gets the image type associated with this handler.

wxImageHandler::GetMimeType
wxString GetMimeType() const Gets the MIME type associated with this handler.

wxImageHandler::LoadFile

751


CHAPTER 7
bool LoadFile(wxImage* image, wxInputStream& stream, bool verbose=true, int index=0) Loads a image from a stream, putting the resulting data into image. If the image file contains more than one image and the image handler is capable of retrieving these individually, indexindicates which image to read from the stream. Parameters image The image object which is to be affected by this operation. stream Opened input stream for reading image data. verbose If set to true, errors reported by the image handler will produce wxLogMessages. index The index of the image in the file (starting from zero). Return value true if the operation succeeded, false otherwise. See also wxImage::LoadFile (p. 741), wxImage::SaveFile (p. 743), wxImageHandler::SaveFile (p. 752)

wxImageHandler::SaveFile
bool SaveFile(wxImage* image, wxOutputStream& stream) Saves a image in the output stream. Parameters image The image object which is to be affected by this operation. stream Opened output stream for writing the data. Return value true if the operation succeeded, false otherwise.

752


CHAPTER 7
See also wxImage::LoadFile (p. 741), wxImage::SaveFile (p. 743), wxImageHandler::LoadFile (p. 751)

wxImageHandler::SetName
void SetName(const wxString& name) Sets the handler name. Parameters name Handler name.

wxImageHandler::SetExtension
void SetExtension(const wxString& extension) Sets the handler extension. Parameters extension Handler extension.

wxImageHandler::SetMimeType
void SetMimeType(const wxString& mimetype) Sets the handler MIME type. Parameters mimename Handler MIME type.

wxImageHandler::SetType
void SetType(long type) Sets the handler type. Parameters name

753


CHAPTER 7
Handler type.

wxImageList
A wxImageList contains a list of images, which are stored in an unspecified form. Images can have masks for transparent drawing, and can be made from a variety of sources including bitmaps and icons. wxImageList is used principally in conjunction with wxTreeCtrl (p. 1327) and wxListCtrl (p. 799) classes. Derived from wxObject (p. 954) Include files <wx/imaglist.h> See also wxTreeCtrl (p. 1327), wxListCtrl (p. 799)

wxImageList::wxImageList
wxImageList() Default constructor. wxImageList(int width, int height, const bool mask = true, int initialCount = 1) Constructor specifying the image size, whether image masks should be created, and the initial size of the list. Parameters width Width of the images in the list. height Height of the images in the list. mask true if masks should be created for all images. initialCount

754


CHAPTER 7
The initial size of the list. See also wxImageList::Create (p. 756)

wxImageList::Add
int Add(const wxBitmap& bitmap, const wxBitmap& mask = wxNullBitmap) Adds a new image using a bitmap and optional mask bitmap. int Add(const wxBitmap& bitmap, const wxColour& maskColour) Adds a new image using a bitmap and mask colour. int Add(const wxIcon& icon) Adds a new image using an icon. Parameters bitmap Bitmap representing the opaque areas of the image. mask Monochrome mask bitmap, representing the transparent areas of the image. maskColour Colour indicating which parts of the image are transparent. icon Icon to use as the image. Return value The new zero-based image index. Remarks The original bitmap or icon is not affected by the Add operation, and can be deleted afterwards. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: Add(bitmap, mask=wxNullBitmap) AddWithColourMask(bitmap, colour) AddIcon(icon)

755


CHAPTER 7

wxImageList::Create
bool Create(int width, int height, const bool mask = true, int initialCount = 1) Initializes the list. See wxImageList::wxImageList (p. 754) for details.

wxImageList::Draw
bool Draw(int index, wxDC& dc, int x, int x, int flags = wxIMAGELIST_DRAW_NORMAL, const bool solidBackground = false) Draws a specified image onto a device context. Parameters index Image index, starting from zero. dc Device context to draw on. x X position on the device context. y Y position on the device context. flags How to draw the image. A bitlist of a selection of the following: wxIMAGELIST_DRAW_NORMAL Draw the image normally. Draw the image with transparency.

wxIMAGELIST_DRAW_TRANSPARENT

wxIMAGELIST_DRAW_SELECTED Draw the image in selected state. wxIMAGELIST_DRAW_FOCUSED solidBackground For optimisation - drawing can be faster if the function is told that the background is solid. Draw the image in a focused state.

wxImageList::GetImageCount

756


CHAPTER 7
int GetImageCount() const Returns the number of images in the list.

wxImageList::GetSize
bool GetSize(int index, int& width, int &height) const Retrieves the size of the images in the list. Currently, the index parameter is ignored as all images in the list have the same size. Parameters index currently unused, should be 0 width receives the width of the images in the list height receives the height of the images in the list Return value true if the function succeeded, false if it failed (for example, if the image list was not yet initialized).

wxImageList::Remove
bool Remove(int index) Removes the image at the given position.

wxImageList::RemoveAll
bool RemoveAll() Removes all the images in the list.

wxImageList::Replace
bool Replace(int index, const wxBitmap& bitmap, const wxBitmap& mask = wxNullBitmap) Replaces the existing image with the new image. bool Replace(int index, const wxIcon& icon)

757


CHAPTER 7
Replaces the existing image with the new image. Parameters bitmap Bitmap representing the opaque areas of the image. mask Monochrome mask bitmap, representing the transparent areas of the image. icon Icon to use as the image. Return value true if the replacement was successful, false otherwise. Remarks The original bitmap or icon is not affected by the Replace operation, and can be deleted afterwards. wxPython note: The second form is called ReplaceIcon in wxPython.

wxIndividualLayoutConstraint
Objects of this class are stored in the wxLayoutConstraint class as one of eight possible constraints that a window can be involved in. Constraints are initially set to have the relationship wxUnconstrained, which means that their values should be calculated by looking at known constraints. Derived from wxObject (p. 954) Include files <wx/layout.h> See also Overview and examples (p. 1616), wxLayoutConstraints (p. 784), wxWindow::SetConstraints (p. 1421).

Edges and relationships

758


CHAPTER 7
The wxEdge enumerated type specifies the type of edge or dimension of a window. wxLeft wxTop wxRight wxBottom wxCentreX wxCentreY The left edge. The top edge. The right edge. The bottom edge. The x-coordinate of the centre of the window. The y-coordinate of the centre of the window.

The wxRelationship enumerated type specifies the relationship that this edge or dimension has with another specified edge or dimension. Normally, the user doesn't use these directly because functions such as Below and RightOf are a convenience for using the more general Set function. wxUnconstrained wxAsIs wxAbove wxBelow wxLeftOf wxRightOf wxSameAs wxPercentOf wxAbsolute The edge or dimension is unconstrained (the default for edges. The edge or dimension is to be taken from the current window position or size (the default for dimensions. The edge should be above another edge. The edge should be below another edge. The edge should be to the left of another edge. The edge should be to the right of another edge. The edge or dimension should be the same as another edge or dimension. The edge or dimension should be a percentage of another edge or dimension. The edge or dimension should be a given absolute value.

wxIndividualLayoutConstraint::wxIndividualLayoutConstraint
void wxIndividualLayoutConstraint() Constructor. Not used by the end-user.

wxIndividualLayoutConstraint::Above
void Above(wxWindow *otherWin, int margin = 0) Constrains this edge to be above the given window, with an optional margin. Implicitly,

759


CHAPTER 7
this is relative to the top edge of the other window.

wxIndividualLayoutConstraint::Absolute
void Absolute(int value) Constrains this edge or dimension to be the given absolute value.

wxIndividualLayoutConstraint::AsIs
void AsIs() Sets this edge or constraint to be whatever the window's value is at the moment. If either of the width and height constraints are as is, the window will not be resized, but moved instead. This is important when considering panel items which are intended to have a default size, such as a button, which may take its size from the size of the button label.

wxIndividualLayoutConstraint::Below
void Below(wxWindow *otherWin, int margin = 0) Constrains this edge to be below the given window, with an optional margin. Implicitly, this is relative to the bottom edge of the other window.

wxIndividualLayoutConstraint::Unconstrained
void Unconstrained() Sets this edge or dimension to be unconstrained, that is, dependent on other edges and dimensions from which this value can be deduced.

wxIndividualLayoutConstraint::LeftOf
void LeftOf(wxWindow *otherWin, int margin = 0) Constrains this edge to be to the left of the given window, with an optional margin. Implicitly, this is relative to the left edge of the other window.

wxIndividualLayoutConstraint::PercentOf
void PercentOf(wxWindow *otherWin, wxEdge edge, int per) Constrains this edge or dimension to be to a percentage of the given window, with an optional margin.

760


CHAPTER 7 wxIndividualLayoutConstraint::RightOf
void RightOf(wxWindow *otherWin, int margin = 0) Constrains this edge to be to the right of the given window, with an optional margin. Implicitly, this is relative to the right edge of the other window.

wxIndividualLayoutConstraint::SameAs
void SameAs(wxWindow *otherWin, wxEdge edge, int margin = 0) Constrains this edge or dimension to be to the same as the edge of the given window, with an optional margin.

wxIndividualLayoutConstraint::Set
void Set(wxRelationship rel, wxWindow *otherWin, wxEdge otherEdge, int value = 0, int margin = 0) Sets the properties of the constraint. Normally called by one of the convenience functions such as Above, RightOf, SameAs.

wxInitDialogEvent
A wxInitDialogEvent is sent as a dialog or panel is being initialised. Handlers for this event can transfer data to the window. The default handler calls wxWindow::TransferDataToWindow (p. 1433). Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process an activate event, use these event handler macros to direct input to a member function that takes a wxInitDialogEvent argument. EVT_INIT_DIALOG(func) See also Event handling overview (p. 1602) Process a wxEVT_INIT_DIALOG event.

761


CHAPTER 7 wxInitDialogEvent::wxInitDialogEvent
wxInitDialogEvent(int id = 0) Constructor.

wxInputStream
wxInputStream is an abstract base class which may not be used directly. Derived from wxStreamBase (p. 1191) Include files <wx/stream.h>

wxInputStream::wxInputStream
wxInputStream() Creates a dummy input stream.

wxInputStream::~wxInputStream
~wxInputStream() Destructor.

wxInputStream::GetC
char GetC() Returns the first character in the input queue and removes it.

wxInputStream::Eof
wxInputStream Eof() const Returns true if the end of stream has been reached.

wxInputStream::LastRead

762


CHAPTER 7
size_t LastRead() const Returns the last number of bytes read.

wxInputStream::Peek
char Peek() Returns the first character in the input queue without removing it.

wxInputStream::Read
wxInputStream& Read(void *buffer, size_t size) Reads the specified amount of bytes and stores the data in buffer. Warning The buffer absolutely needs to have at least the specified size. Return value This function returns a reference on the current object, so the user can test any states of the stream right away. wxInputStream& Read(wxOutputStream& stream_out) Reads data from the input queue and stores it in the specified output stream. The data is read until an error is raised by one of the two streams. Return value This function returns a reference on the current object, so the user can test any states of the stream right away.

wxInputStream::SeekI
off_t SeekI(off_t pos, wxSeekMode mode = wxFromStart) Changes the stream current position.

wxInputStream::TellI
off_t TellI() const Returns the current stream position.

wxInputStream::Ungetch 763


CHAPTER 7
size_t Ungetch(const char* buffer, size_t size) This function is only useful in read mode. It is the manager of the "Write-Back" buffer. This buffer acts like a temporary buffer where data which has to be read during the next read IO call are put. This is useful when you get a big block of data which you didn't want to read: you can replace them at the top of the input queue by this way. Be very careful about this call in connection with calling SeekI() on the same stream. Any call to SeekI() will invalidate any previous call to this method (otherwise you could SeekI() to one position, "unread" a few bytes there, SeekI() to another position and data would be either lost or corrupted). Return value Returns the amount of bytes saved in the Write-Back buffer. bool Ungetch(char c) This function acts like the previous one except that it takes only one character: it is sometimes shorter to use than the generic function.

wxIPaddress
wxIPaddress is an abstract base class for all internet protocol address objects. Currently, only wxIPV4address (p. 766) is implemented. An experimental implementation for IPV6, wxIPV6address, is being developed. Derived from wxSockAddress (p. 1130) Include files <wx/socket.h>

wxIPaddress::Hostname
virtual bool Hostname(const wxString& hostname) Set the address to hostname, which can be a host name or an IP-style address in a format dependent on implementation. Return value Returns true on success, false if something goes wrong (invalid hostname or invalid IP address).

wxIPaddress::Hostname 764


CHAPTER 7
virtual wxString Hostname() Returns the hostname which matches the IP address.

wxIPaddress::IPAddress
virtual wxString IPAddress() Returns a wxString containing the IP address.

wxIPaddress::Service
virtual bool Service(const wxString& service) Set the port to that corresponding to the specified service. Return value Returns true on success, false if something goes wrong (invalid service).

wxIPaddress::Service
virtual bool Service(unsigned short service) Set the port to that corresponding to the specified service. Return value Returns true on success, false if something goes wrong (invalid service).

wxIPaddress::Service
virtual unsigned short Service() Returns the current service.

wxIPaddress::AnyAddress
virtual bool AnyAddress() Internally, this is the same as setting the IP address to INADDR_ANY. On IPV4 implementations, 0.0.0.0 On IPV6 implementations, :: Return value

765


CHAPTER 7
Returns true on success, false if something went wrong.

wxIPaddress::LocalHost
virtual bool LocalHost() Set address to localhost. On IPV4 implementations, 127.0.0.1 On IPV6 implementations, ::1 Return value Returns true on success, false if something went wrong.

wxIPaddress::IsLocalHost
virtual bool IsLocalHost() Determines if current address is set to localhost. Return value Returns true if address is localhost, false if internet address.

wxIPV4address
Derived from wxIPaddress (p. 764) Include files <wx/socket.h>

wxIPV4address::Hostname
bool Hostname(const wxString& hostname) Set the address to hostname, which can be a host name or an IP-style address in dot notation (a.b.c.d) Return value Returns true on success, false if something goes wrong (invalid hostname or invalid IP address).

766


CHAPTER 7 wxIPV4address::Hostname
wxString Hostname() Returns the hostname which matches the IP address.

wxIPV4address::IPAddress
wxString IPAddress() Returns a wxString containing the IP address in dot quad (127.0.0.1) format.

wxIPV4address::Service
bool Service(const wxString& service) Set the port to that corresponding to the specified service. Return value Returns true on success, false if something goes wrong (invalid service).

wxIPV4address::Service
bool Service(unsigned short service) Set the port to that corresponding to the specified service. Return value Returns true on success, false if something goes wrong (invalid service).

wxIPV4address::Service
unsigned short Service() Returns the current service.

wxIPV4address::AnyAddress
bool AnyAddress() Set address to any of the addresses of the current machine. Whenever possible, use this function instead of wxIPV4address::LocalHost (p. 768), as this correctly handles multi-homed hosts and avoids other small problems. Internally, this is the same as setting the IP address to INADDR_ANY. Return value

767


CHAPTER 7
Returns true on success, false if something went wrong.

wxIPV4address::LocalHost
bool LocalHost() Set address to localhost (127.0.0.1). Whenever possible, use the wxIPV4address::AnyAddress (p. 767), function instead of this one, as this will correctly handle multi-homed hosts and avoid other small problems. Return value Returns true on success, false if something went wrong.

wxJoystick
wxJoystick allows an application to control one or more joysticks. Derived from wxObject (p. 954) Include files <wx/joystick.h> See also wxJoystickEvent (p. 774)

wxJoystick::wxJoystick
wxJoystick(int joystick = wxJOYSTICK1) Constructor. joystick may be one of wxJOYSTICK1, wxJOYSTICK2, indicating the joystick controller of interest.

wxJoystick::~wxJoystick
~wxJoystick() Destroys the wxJoystick object.

wxJoystick::GetButtonState
int GetButtonState() const

768


CHAPTER 7
Returns the state of the joystick buttons. Every button is mapped to a single bit in the returned integer, with the first button being mapped to the least significant bit, and so on. A bitlist of wxJOY_BUTTONn identifiers, where n is 1, 2, 3 or 4 is available for historical reasons.

wxJoystick::GetManufacturerId
int GetManufacturerId() const Returns the manufacturer id.

wxJoystick::GetMovementThreshold
int GetMovementThreshold() const Returns the movement threshold, the number of steps outside which the joystick is deemed to have moved.

wxJoystick::GetNumberAxes
int GetNumberAxes() const Returns the number of axes for this joystick.

wxJoystick::GetNumberButtons
int GetNumberButtons() const Returns the number of buttons for this joystick.

wxJoystick::GetNumberJoysticks
int GetNumberJoysticks() const Returns the number of joysticks currently attached to the computer.

wxJoystick::GetPollingMax
int GetPollingMax() const Returns the maximum polling frequency.

wxJoystick::GetPollingMin
int GetPollingMin() const

769


CHAPTER 7
Returns the minimum polling frequency.

wxJoystick::GetProductId
int GetProductId() const Returns the product id for the joystick.

wxJoystick::GetProductName
wxString GetProductName() const Returns the product name for the joystick.

wxJoystick::GetPosition
wxPoint GetPosition() const Returns the x, y position of the joystick.

wxJoystick::GetPOVPosition
int GetPOVPosition() const Returns the point-of-view position, expressed in continuous, one-hundredth of a degree units, but limited to return 0, 9000, 18000 or 27000. Returns -1 on error.

wxJoystick::GetPOVCTSPosition
int GetPOVCTSPosition() const Returns the point-of-view position, expressed in continuous, one-hundredth of a degree units. Returns -1 on error.

wxJoystick::GetRudderMax
int GetRudderMax() const Returns the maximum rudder position.

wxJoystick::GetRudderMin
int GetRudderMin() const Returns the minimum rudder position.

770


CHAPTER 7 wxJoystick::GetRudderPosition
int GetRudderPosition() const Returns the rudder position.

wxJoystick::GetUMax
int GetUMax() const Returns the maximum U position.

wxJoystick::GetUMin
int GetUMin() const Returns the minimum U position.

wxJoystick::GetUPosition
int GetUPosition() const Gets the position of the fifth axis of the joystick, if it exists.

wxJoystick::GetVMax
int GetVMax() const Returns the maximum V position.

wxJoystick::GetVMin
int GetVMin() const Returns the minimum V position.

wxJoystick::GetVPosition
int GetVPosition() const Gets the position of the sixth axis of the joystick, if it exists.

wxJoystick::GetXMax
int GetXMax() const

771


CHAPTER 7
Returns the maximum x position.

wxJoystick::GetXMin
int GetXMin() const Returns the minimum x position.

wxJoystick::GetYMax
int GetYMax() const Returns the maximum y position.

wxJoystick::GetYMin
int GetYMin() const Returns the minimum y position.

wxJoystick::GetZMax
int GetZMax() const Returns the maximum z position.

wxJoystick::GetZMin
int GetXMin() const Returns the minimum z position.

wxJoystick::GetZPosition
int GetZPosition() const Returns the z position of the joystick.

wxJoystick::HasPOV
bool HasPOV() const Returns true if the joystick has a point of view control.

772


CHAPTER 7 wxJoystick::HasPOV4Dir
bool HasPOV4Dir() const Returns true if the joystick point-of-view supports discrete values (centered, forward, backward, left, and right).

wxJoystick::HasPOVCTS
bool HasPOVCTS() const Returns true if the joystick point-of-view supports continuous degree bearings.

wxJoystick::HasRudder
bool HasRudder() const Returns true if there is a rudder attached to the computer.

wxJoystick::HasU
bool HasU() const Returns true if the joystick has a U axis.

wxJoystick::HasV
bool HasV() const Returns true if the joystick has a V axis.

wxJoystick::HasZ
bool HasZ() const Returns true if the joystick has a Z axis.

wxJoystick::IsOk
bool IsOk() const Returns true if the joystick is functioning.

wxJoystick::ReleaseCapture

773


CHAPTER 7
bool ReleaseCapture() Releases the capture set by SetCapture. Return value true if the capture release succeeded. See also wxJoystick::SetCapture (p. 774), wxJoystickEvent (p. 774)

wxJoystick::SetCapture
bool SetCapture(wxWindow* win, int pollingFreq = 0) Sets the capture to direct joystick events to win. Parameters win The window that will receive joystick events. pollingFreq If zero, movement events are sent when above the threshold. If greater than zero, events are received every pollingFreq milliseconds. Return value true if the capture succeeded. See also wxJoystick::ReleaseCapture (p. 773), wxJoystickEvent (p. 774)

wxJoystick::SetMovementThreshold
void SetMovementThreshold(int threshold) Sets the movement threshold, the number of steps outside which the joystick is deemed to have moved.

wxJoystickEvent
This event class contains information about mouse events, particularly events received by windows. Derived from

774


CHAPTER 7
wxEvent (p. 439) Include files <wx/event.h> Event table macros To process a mouse event, use these event handler macros to direct input to member functions that take a wxJoystickEvent argument. EVT_JOY_BUTTON_DOWN(func) EVT_JOY_BUTTON_UP(func) EVT_JOY_MOVE(func) EVT_JOY_ZMOVE(func) See also wxJoystick (p. 768) Process a wxEVT_JOY_BUTTON_DOWN event. Process a wxEVT_JOY_BUTTON_UP event. Process a wxEVT_JOY_MOVE event. Process a wxEVT_JOY_ZMOVE event.

wxJoystickEvent::wxJoystickEvent
wxJoystickEvent(WXTYPE eventType = 0, int state = 0, int joystick = wxJOYSTICK1, int change = 0) Constructor.

wxJoystickEvent::ButtonDown
bool ButtonDown(int button = wxJOY_BUTTON_ANY) const Returns true if the event was a down event from the specified button (or any button). Parameters button Can be wxJOY_BUTTONn where n is 1, 2, 3 or 4; or wxJOY_BUTTON_ANY to indicate any button down event.

wxJoystickEvent::ButtonIsDown
bool ButtonIsDown(int button = wxJOY_BUTTON_ANY) const

775


CHAPTER 7
Returns true if the specified button (or any button) was in a down state. Parameters button Can be wxJOY_BUTTONn where n is 1, 2, 3 or 4; or wxJOY_BUTTON_ANY to indicate any button down event.

wxJoystickEvent::ButtonUp
bool ButtonUp(int button = wxJOY_BUTTON_ANY) const Returns true if the event was an up event from the specified button (or any button). Parameters button Can be wxJOY_BUTTONn where n is 1, 2, 3 or 4; or wxJOY_BUTTON_ANY to indicate any button down event.

wxJoystickEvent::GetButtonChange
int GetButtonChange() const Returns the identifier of the button changing state. This is a wxJOY_BUTTONn identifier, where n is one of 1, 2, 3, 4.

wxJoystickEvent::GetButtonState
int GetButtonState() const Returns the down state of the buttons. This is a bitlist of wxJOY_BUTTONn identifiers, where n is one of 1, 2, 3, 4.

wxJoystickEvent::GetJoystick
int GetJoystick() const Returns the identifier of the joystick generating the event - one of wxJOYSTICK1 and wxJOYSTICK2.

wxJoystickEvent::GetPosition
wxPoint GetPosition() const Returns the x, y position of the joystick event.

776


CHAPTER 7 wxJoystickEvent::GetZPosition
int GetZPosition() const Returns the z position of the joystick event.

wxJoystickEvent::IsButton
bool IsButton() const Returns true if this was a button up or down event (not 'is any button down?').

wxJoystickEvent::IsMove
bool IsMove() const Returns true if this was an x, y move event.

wxJoystickEvent::IsZMove
bool IsZMove() const Returns true if this was a z move event.

wxKeyEvent
This event class contains information about keypress (character) events. Notice that there are three different kinds of keyboard events in wxWindows: key down and up events and char events. The difference between the first two is clear - the first corresponds to a key press and the second to a key release - otherwise they are identical. Just note that if the key is maintained in a pressed state you will typically get a lot of (automatically generated) down events but only one up so it is wrong to assume that there is one up event corresponding to each down one. Both key events provide untranslated key codes while the char event carries the translated one. The untranslated code for alphanumeric keys is always an upper case value. For the other keys it is one of WXK_XXX values from the keycodes table (p. 1539). The translated key is, in general, the character the user expects to appear as the result of the key combination when typing the text into a text entry zone, for example. A few examples to clarify this (all assume that CAPS LOCK is unpressed and the standard US keyboard): when the 'A' key is pressed, the key down event key code is equal to ASCII A == 65. But the char event key code is ASCII a == 97. On the other hand, if you press both SHIFT and'A' keys simultaneously , the key code in key down event will still be just 'A' while the char event key code parameter will now be 'A'as well.

777


CHAPTER 7
Although in this simple case it is clear that the correct key code could be found in the key down event handler by checking the value returned byShiftDown() (p. 781), in general you should useEVT_CHAR for this as for non alphanumeric keys the translation is keyboard-layout dependent and can only be done properly by the system itself. Another kind of translation is done when the control key is pressed: for example, for CTRL-A key press the key down event still carries the same key code 'a' as usual but the char event will have key code of1, the ASCII value of this key combination. You may discover how the other keys on your system behave interactively by running the text (p. 1568) wxWindows sample and pressing some keys in any of the text controls shown in it. Note: If a key down (EVT_KEY_DOWN) event is caught and the event handler does not call event.Skip() then the coresponding char event (EVT_CHAR) will not happen. This is by design and enables the programs that handle both types of events to be a bit simpler. Note for Windows programmers: The key and char events in wxWindows are similar to but slightly different from Windows WM_KEYDOWN andWM_CHAR events. In particular, Alt-x combination will generate a char event in wxWindows (unless it is used as an accelerator). Tip: be sure to call event.Skip() for events that you don't process in key event function, otherwise menu shortcuts may cease to work under Windows. Derived from wxEvent (p. 439) Include files <wx/event.h> Event table macros To process a key event, use these event handler macros to direct input to member functions that take a wxKeyEvent argument. EVT_KEY_DOWN(func) EVT_KEY_UP(func) EVT_CHAR(func) Process a wxEVT_KEY_DOWN event (any key has been pressed). Process a wxEVT_KEY_UP event (any key has been released). Process a wxEVT_CHAR event.

wxKeyEvent::m_altDown
bool m_altDown true if the Alt key is pressed down.

778


CHAPTER 7 wxKeyEvent::m_controlDown
bool m_controlDown true if control is pressed down.

wxKeyEvent::m_keyCode
long m_keyCode Virtual keycode. See Keycodes (p. 1539) for a list of identifiers.

wxKeyEvent::m_metaDown
bool m_metaDown true if the Meta key is pressed down.

wxKeyEvent::m_shiftDown
bool m_shiftDown true if shift is pressed down.

wxKeyEvent::m_x
int m_x X position of the event.

wxKeyEvent::m_y
int m_y Y position of the event.

wxKeyEvent::wxKeyEvent
wxKeyEvent(WXTYPE keyEventType) Constructor. Currently, the only valid event types are wxEVT_CHAR and wxEVT_CHAR_HOOK.

wxKeyEvent::AltDown

779


CHAPTER 7
bool AltDown() const Returns true if the Alt key was down at the time of the key event.

wxKeyEvent::ControlDown
bool ControlDown() const Returns true if the control key was down at the time of the key event.

wxKeyEvent::GetKeyCode
int GetKeyCode() const Returns the virtual key code. ASCII events return normal ASCII values, while non-ASCII events return values such as WXK_LEFT for the left cursor key. See Keycodes (p. 1539) for a full list of the virtual key codes.

wxKeyEvent::GetRawKeyCode
wxUint32 GetRawKeyCode() const Returns the raw key code for this event. This is a platform-dependent scan code which should only be used in advanced applications. NB: Currently the raw key codes are not supported by all ports, use#ifdef wxHAS_RAW_KEY_CODES to determine if this feature is available.

wxKeyEvent::GetRawKeyFlags
wxUint32 GetRawKeyFlags() const Returns the low level key flags for this event. The flags are platform-dependent and should only be used in advanced applications. NB: Currently the raw key flags are not supported by all ports, use#ifdef wxHAS_RAW_KEY_CODES to determine if this feature is available.

wxKeyEvent::GetX
long GetX() const Returns the X position (in client coordinates) of the event.

wxKeyEvent::GetY

780


CHAPTER 7
long GetY() const Returns the Y (in client coordinates) position of the event.

wxKeyEvent::MetaDown
bool MetaDown() const Returns true if the Meta key was down at the time of the key event.

wxKeyEvent::GetPosition
wxPoint GetPosition() const void GetPosition(long *x, long *y) const Obtains the position (in client coordinates) at which the key was pressed.

wxKeyEvent::HasModifiers
bool HasModifiers() const Returns true if either CTRL or ALT keys was down at the time of the key event. Note that this function does not take into account neither SHIFT nor META key states (the reason for ignoring the latter is that it is common for NUMLOCK key to be configured asMETA under X but the key presses even while NUMLOCK is on should be still processed normally).

wxKeyEvent::ShiftDown
bool ShiftDown() const Returns true if the shift key was down at the time of the key event.

wxLayoutAlgorithm
wxLayoutAlgorithm implements layout of subwindows in MDI or SDI frames. It sends a wxCalculateLayoutEvent event to children of the frame, asking them for information about their size. For MDI parent frames, the algorithm allocates the remaining space to the MDI client window (which contains the MDI child frames). For SDI (normal) frames, a 'main' window is specified as taking up the remaining space. Because the event system is used, this technique can be applied to any windows, which are not necessarily 'aware' of the layout classes (no virtual functions in wxWindow refer to wxLayoutAlgorithm or its events). However, you may wish to use wxSashLayoutWindow (p. 1065) for your subwindows since this class provides handlers for the required events, and accessors to specify the desired size of the window. The

781


CHAPTER 7
sash behaviour in the base class can be used, optionally, to make the windows userresizable. wxLayoutAlgorithm is typically used in IDE (integrated development environment) applications, where there are several resizable windows in addition to the MDI client window, or other primary editing window. Resizable windows might include toolbars, a project window, and a window for displaying error and warning messages. When a window receives an OnCalculateLayout event, it should call SetRect in the given event object, to be the old supplied rectangle minus whatever space the window takes up. It should also set its own size accordingly. wxSashLayoutWindow::OnCalculateLayout generates an OnQueryLayoutInfo event which it sends to itself to determine the orientation, alignment and size of the window, which it gets from internal member variables set by the application. The algorithm works by starting off with a rectangle equal to the whole frame client area. It iterates through the frame children, generating OnCalculateLayout events which subtract the window size and return the remaining rectangle for the next window to process. It is assumed (by wxSashLayoutWindow::OnCalculateLayout) that a window stretches the full dimension of the frame client, according to the orientation it specifies. For example, a horizontal window will stretch the full width of the remaining portion of the frame client area. In the other orientation, the window will be fixed to whatever size was specified by OnQueryLayoutInfo. An alignment setting will make the window 'stick' to the left, top, right or bottom of the remaining client area. This scheme implies that order of window creation is important. Say you wish to have an extra toolbar at the top of the frame, a project window to the left of the MDI client window, and an output window above the status bar. You should therefore create the windows in this order: toolbar, output window, project window. This ensures that the toolbar and output window take up space at the top and bottom, and then the remaining height in-between is used for the project window. wxLayoutAlgorithm is quite independent of the way in which OnCalculateLayout chooses to interpret a window's size and alignment. Therefore you could implement a different window class with a new OnCalculateLayout event handler, that has a more sophisticated way of laying out the windows. It might allow specification of whether stretching occurs in the specified orientation, for example, rather than always assuming stretching. (This could, and probably should, be added to the existing implementation). Note: wxLayoutAlgorithm has nothing to do with wxLayoutConstraints. It is an alternative way of specifying layouts for which the normal constraint system is unsuitable. Derived from wxObject (p. 954) Include files <wx/laywin.h> Event handling The algorithm object does not respond to events, but itself generates the following events in order to calculate window sizes.

782


CHAPTER 7
EVT_QUERY_LAYOUT_INFO(func) Process a wxEVT_QUERY_LAYOUT_INFO event, to get size, orientation and alignment from a window. See wxQueryLayoutInfoEvent (p. 1030). Process a wxEVT_CALCULATE_LAYOUT event, which asks the window to take a 'bite' out of a rectangle provided by the algorithm. See wxCalculateLayoutEvent (p. 107).

EVT_CALCULATE_LAYOUT(func)

Data types
enum wxLayoutOrientation { wxLAYOUT_HORIZONTAL, wxLAYOUT_VERTICAL }; enum wxLayoutAlignment { wxLAYOUT_NONE, wxLAYOUT_TOP, wxLAYOUT_LEFT, wxLAYOUT_RIGHT, wxLAYOUT_BOTTOM, };

See also wxSashEvent (p. 1063), wxSashLayoutWindow (p. 1065), Event handling overview (p. 1602) wxCalculateLayoutEvent (p. 107), wxQueryLayoutInfoEvent (p. 1030), wxSashLayoutWindow (p. 1065), wxSashWindow (p. 1068)

wxLayoutAlgorithm::wxLayoutAlgorithm
wxLayoutAlgorithm() Default constructor.

wxLayoutAlgorithm::~wxLayoutAlgorithm
~wxLayoutAlgorithm() Destructor.

wxLayoutAlgorithm::LayoutFrame
bool LayoutFrame(wxFrame* frame, wxWindow* mainWindow = NULL) const

783


CHAPTER 7
Lays out the children of a normal frame. mainWindow is set to occupy the remaining space. This function simply calls wxLayoutAlgorithm::LayoutWindow (p. 784).

wxLayoutAlgorithm::LayoutMDIFrame
bool LayoutMDIFrame(wxMDIParentFrame* frame, wxRect* rect = NULL) const Lays out the children of an MDI parent frame. If rect is non-NULL, the given rectangle will be used as a starting point instead of the frame's client area. The MDI client window is set to occupy the remaining space.

wxLayoutAlgorithm::LayoutWindow
bool LayoutWindow(wxWindow* parent, wxWindow* mainWindow = NULL) const Lays out the children of a normal frame or other window. mainWindow is set to occupy the remaining space. If this is not specified, then the last window that responds to a calculate layout event in query mode will get the remaining space (that is, a non-query OnCalculateLayout event will not be sent to this window and the window will be set to the remaining size).

wxLayoutConstraints
Note: constraints are now deprecated and you should use sizers (p. 1620) instead. Objects of this class can be associated with a window to define its layout constraints, with respect to siblings or its parent. The class consists of the following eight constraints of class wxIndividualLayoutConstraint, some or all of which should be accessed directly to set the appropriate constraints.        left: represents the left hand edge of the window right: represents the right hand edge of the window top: represents the top edge of the window bottom: represents the bottom edge of the window width: represents the width of the window height: represents the height of the window centreX: represents the horizontal centre point of the window

784


CHAPTER 7
 centreY: represents the vertical centre point of the window

Most constraints are initially set to have the relationship wxUnconstrained, which means that their values should be calculated by looking at known constraints. The exceptions are width and height, which are set to wxAsIs to ensure that if the user does not specify a constraint, the existing width and height will be used, to be compatible with panel items which often have take a default size. If the constraint is wxAsIs, the dimension will not be changed.
wxPerl note: In wxPerl the constraints are accessed as Wx::LayoutConstraints->new(); constraint->centreX->AsIs(); constraint->centreY->Unconstrained(); constraint =

Derived from wxObject (p. 954) Include files <wx/layout.h> See also Overview and examples (p. 1616), wxIndividualLayoutConstraint (p. 758), wxWindow::SetConstraints (p. 1421)

wxLayoutConstraints::wxLayoutConstraints
wxLayoutConstraints() Constructor.

wxLayoutConstraints::bottom
wxIndividualLayoutConstraint bottom Constraint for the bottom edge.

wxLayoutConstraints::centreX
wxIndividualLayoutConstraint centreX Constraint for the horizontal centre point.

wxLayoutConstraints::centreY 785


CHAPTER 7
wxIndividualLayoutConstraint centreY Constraint for the vertical centre point.

wxLayoutConstraints::height
wxIndividualLayoutConstraint height Constraint for the height.

wxLayoutConstraints::left
wxIndividualLayoutConstraint left Constraint for the left-hand edge.

wxLayoutConstraints::right
wxIndividualLayoutConstraint right Constraint for the right-hand edge.

wxLayoutConstraints::top
wxIndividualLayoutConstraint top Constraint for the top edge.

wxLayoutConstraints::width
wxIndividualLayoutConstraint width Constraint for the width.

wxList
wxList classes provide linked list functionality for wxWindows, and for an application if it wishes. Depending on the form of constructor used, a list can be keyed on integer or string keys to provide a primitive look-up ability, but please note that this feature is deprecated. See wxHashMap (p. 637) for a faster method of storage when random access is required. While wxList class in the previous versions of wxWindows only could contain elements of type wxObject and had essentially untyped interface (thus allowing you to put apples in the list and read back oranges from it), the new wxList classes family may contain

786


CHAPTER 7
elements of any type and has much more strict type checking. Unfortunately, it also requires an additional line to be inserted in your program for each list class you use (which is the only solution short of using templates which is not done in wxWindows because of portability issues). The general idea is to have the base class wxListBase working with void *data but make all of its dangerous (because untyped) functions protected, so that they can only be used from derived classes which, in turn, expose a type safe interface. With this approach a new wxList-like class must be defined for each list type (i.e. list of ints, of wxStrings or of MyObjects). This is done with WX_DECLARE_LIST and WX_DEFINE_LIST macros like this (notice the similarity with WX_DECLARE_OBJARRAY and WX_IMPLEMENT_OBJARRAY macros): Example
// this part might be in a header or source (.cpp) file class MyListElement { ... // whatever }; // decare our list class: this macro declares and partly implements l MyList // class (which derives from wxListBase) WX_DECLARE_LIST(MyListElement, MyList); ... // the only requirement for the rest is to be AFTER the full declaration of // MyListElement (for WX_DECLARE_LIST forward declaration is enough), but // usually it will be found in the source file and not in the header #include <wx/listimpl.cpp> WX_DEFINE_LIST(MyList); // now MyList class may be used as a usual wxList, but all of its methods // will take/return the objects of the right (i.e. MyListElement) type. You // also have MyList::Node type which is the type-safe version of wxNode. MyList list; MyListElement element; list.Append(element); // ok list.Append(17); // error: incorrect type // let's iterate over the list for ( MyList::Node *node = list.GetFirst(); node; node = node>GetNext() ) { MyListElement *current = node->GetData(); ...process the current element... }

For compatibility with previous versions wxList and wxStringList classes are still defined, but their usage is deprecated and they will disappear in the future versions completely. The use of the latter is especially discouraged as it is not only unsafe but is also much less efficient than wxArrayString (p. 53) class. In the documentation of the list classes below, the template notations are used even

787


CHAPTER 7
though these classes are not really templates at all -- but it helps to think about them as if they were. You should replace wxNode<T> with wxListName::Node and T itself with the list element type (i.e. the first parameter of WX_DECLARE_LIST). Derived from wxObject (p. 954) Include files <wx/list.h> Example It is very common to iterate on a list as follows:
... wxWindow *win1 = new wxWindow(...); wxWindow *win2 = new wxWindow(...); wxList SomeList; SomeList.Append(win1); SomeList.Append(win2); ... wxNode *node = SomeList.GetFirst(); while (node) { wxWindow *win = node->GetData(); ... node = node >GetNext(); }

To delete nodes in a list as the list is being traversed, replace
... node = node >GetNext(); ...

with
... delete win; delete node; node = SomeList.GetFirst(); ...

See wxNode (p. 942) for members that retrieve the data associated with a node, and members for getting to the next or previous node. See also wxNode (p. 942), wxStringList (p. 1223),wxArray (p. 42)

wxList::wxList

788


CHAPTER 7
wxList() wxList(int n, T *objects[]) wxList(T *object, ...) Note: keyed lists are deprecated and should not be used in new code. wxList(unsigned int key_type) Constructors. key_type is one of wxKEY_NONE, wxKEY_INTEGER, or wxKEY_STRING, and indicates what sort of keying is required (if any). objects is an array of n objects with which to initialize the list. The variable-length argument list constructor must be supplied with a terminating NULL.

wxList::~wxList
~wxList() Destroys the list. Also destroys any remaining nodes, but does not destroy client data held in the nodes.

wxList::Append
wxNode<T> * Append(T *object) Note: keyed lists are deprecated and should not be used in new code. wxNode<T> * Append(long key, T *object) wxNode<T> * Append(const wxString& key, T *object) Appends a new wxNode (p. 942) to the end of the list and puts a pointer to the object in the node. The last two forms store a key with the object for later retrieval using the key. The new node is returned in each case. The key string is copied and stored by the list implementation.

wxList::Clear
void Clear() Clears the list (but does not delete the client data stored with each node unless you called DeleteContents(true), in which case it deletes data).

wxList::DeleteContents

789


CHAPTER 7
void DeleteContents(bool destroy) If destroy is true, instructs the list to call delete on the client contents of a node whenever the node is destroyed. The default is false.

wxList::DeleteNode
bool DeleteNode(wxNode<T> *node) Deletes the given node from the list, returning true if successful.

wxList::DeleteObject
bool DeleteObject(T *object) Finds the given client object and deletes the appropriate node from the list, returningtrue if successful. The application must delete the actual object separately.

wxList::Find
wxNode<T> * Find(T * object) Returns the node whose client date is object or NULL if none found. Note: keyed lists are deprecated and should not be used in new code. wxNode<T> * Find(long key) wxNode<T> * Find(const wxString& key) Returns the node whose stored key matches key. Use on a keyed list only.

wxList::GetCount
size_t GetCount() const Returns the number of elements in the list.

wxList::GetFirst
wxNode<T> * GetFirst() Returns the first node in the list (NULL if the list is empty).

wxList::GetLast

790


CHAPTER 7
wxNode<T> * GetLast() Returns the last node in the list (NULL if the list is empty).

wxList::IndexOf
int IndexOf(T* obj ) Returns the index of obj within the list or wxNOT_FOUND if obj is not found in the list.

wxList::Insert
wxNode<T> * Insert(T *object) Insert object at front of list. wxNode<T> * Insert(size_t position, T *object) Insert object before position, i.e. the index of the new item in the list will be equal to position. position should be less than or equal to GetCount (p. 790); if it is equal to it, this is the same as calling Append (p. 789). wxNode<T> * Insert(wxNode<T> *node, T *object) Inserts the object before the given node.

wxList::IsEmpty
bool IsEmpty() const Returns true if the list is empty, false otherwise.

wxList::Item
wxNode<T> * Item(size_t index) const Returns the node at given position in the list.

wxList::Member
wxNode<T> * Member(T *object) NB: This function is deprecated, use Find (p. 790) instead. Returns the node associated with object if it is in the list, NULL otherwise.

791


CHAPTER 7 wxList::Nth
wxNode<T> * Nth(int n) NB: This function is deprecated, use Item (p. 791) instead. Returns the nth node in the list, indexing from zero (NULL if the list is empty or the nth node could not be found).

wxList::Number
int Number() NB: This function is deprecated, use GetCount (p. 790) instead. Returns the number of elements in the list.

wxList::Sort
void Sort(wxSortCompareFunction compfunc)
// Type of compare function for list sort operation (as in 'qsort') typedef int (*wxSortCompareFunction)(const void *elem1, const void *elem2);

Allows the sorting of arbitrary lists by giving a function to compare two list elements. We use the system qsort function for the actual sorting process. If you use untyped wxList the sort function receives pointers to wxObject pointers (wxObject **), so be careful to dereference appropriately - but, of course, a better solution is to use list of appropriate type defined withWX_DECLARE_LIST. Example:
int listcompare(const void *arg1, const void *arg2) { return(compare(**(wxString **)arg1, // use the wxString 'compare' **(wxString **)arg2)); // function } void main() { wxList list; list.Append(new wxString("DEF")); list.Append(new wxString("GHI")); list.Append(new wxString("ABC")); list.Sort(listcompare); }

wxListbook
wxListbook is a class similar to wxNotebook (p. 943) but which uses a wxListCtrl (p. 799) to show the labels instead of the tabs.

792


CHAPTER 7
There is no documentation for this class yet but its usage is identical to wxNotebook (except for the features clearly related to tabs only), so please refer to that class documentation for now. You can also use the notebook sample (p. 1567) to see wxListbook in action. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/listbook.h> Window styles wxLB_DEFAULT Choose the default location for the labels depending on the current platform (left everywhere except Mac where it is top). Place labels above the page area. Place labels on the left side. Place labels on the right side. Place labels below the page area.

wxLB_TOP wxLB_LEFT wxLB_RIGHT wxLB_BOTTOM See also

wxNotebook (p. 943), notebook sample (p. 1567)

wxListBox
A listbox is used to select one or more of a list of strings. The strings are displayed in a scrolling box, with the selected string(s) marked in reverse video. A listbox can be single selection (if an item is selected, the previous selection is removed) or multiple selection (clicking an item toggles the item on or off independently of other selections). List box elements are numbered from zero. Their number is limited in some platforms (e.g. ca. 2000 on GTK). A listbox callback gets an event wxEVT_COMMAND_LISTBOX_SELECT for single clicks, and wxEVT_COMMAND_LISTBOX_DOUBLE_CLICKED for double clicks. Derived from wxControlWithItems (p. 199) wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443)

793


CHAPTER 7
wxObject (p. 954) Include files <wx/listbox.h> Window styles wxLB_SINGLE wxLB_MULTIPLE wxLB_EXTENDED Single-selection list. Multiple-selection list: the user can toggle multiple items on and off. Extended-selection list: the user can select multiple items using the SHIFT key and the mouse or special key combinations. Create horizontal scrollbar if contents are too wide (Windows only). Always show a vertical scrollbar. Only create a vertical scrollbar if needed. The listbox contents are sorted in alphabetical order.

wxLB_HSCROLL wxLB_ALWAYS_SB wxLB_NEEDED_SB wxLB_SORT

Note that wxLB_SINGLE, wxLB_MULTIPLE and wxLB_EXTENDEDstyles are mutually exclusive and you can specify at most one of them (single selection is the default). See also window styles overview (p. 1611). Event handling EVT_LISTBOX(id, func) Process a wxEVT_COMMAND_LISTBOX_SELECTED event, when an item on the list is selected. Process a wxEVT_COMMAND_LISTBOX_DOUBLECLIC KED event, when the listbox is double-clicked.

EVT_LISTBOX_DCLICK(id, func)

See also wxChoice (p. 127), wxComboBox (p. 158), wxListCtrl (p. 799), wxCommandEvent (p. 164)

wxListBox::wxListBox
wxListBox() Default constructor.

794


CHAPTER 7
wxListBox(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, int n, const wxString choices[] = NULL, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listBox") wxListBox(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, const wxArrayString& choices, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listBox") Constructor, creating and showing a list box. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. pos Window position. size Window size. If the default size (-1, -1) is specified then the window is sized appropriately. n Number of strings with which to initialise the control. choices An array of strings with which to initialise the control. style Window style. See wxListBox (p. 793). validator Window validator. name Window name. See also wxListBox::Create (p. 796), wxValidator (p. 1358) wxPython note: The wxListBox constructor in wxPython reduces the nand choices arguments are to a single argument, which is a list of strings.

795


CHAPTER 7
wxPerl note: In wxPerl there is just an array reference in place of nand choices.

wxListBox::~wxListBox
void ~wxListBox() Destructor, destroying the list box.

wxListBox::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, int n, const wxString choices[] = NULL, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listBox") bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, const wxArrayString& choices, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listBox") Creates the listbox for two-step construction. See wxListBox::wxListBox (p. 794) for further details.

wxListBox::Deselect
void Deselect(int n) Deselects an item in the list box. Parameters n The zero-based item to deselect. Remarks This applies to multiple selection listboxes only.

wxListBox::GetSelections
int GetSelections(wxArrayInt& selections) const Fill an array of ints with the positions of the currently selected items. Parameters selections A reference to an wxArrayInt instance that is used to store the result of the query.

796


CHAPTER 7
Return value The number of selections. Remarks Use this with a multiple selection listbox. See also wxControlWithItems::GetSelection (p. 202), wxControlWithItems::GetStringSelection (p. 202), wxControlWithItems::SetSelection (p. 204) wxPython note: The wxPython version of this method takes no parameters and returns a tuple of the selected items. wxPerl note: In wxPerl this method takes no parameters and return the selected items as a list.

wxListBox::InsertItems
void InsertItems(int nItems, const wxString *items, int pos) Insert the given number of strings before the specified position. Parameters nItems Number of items in the array items items Labels of items to be inserted pos Position before which to insert the items: for example, if pos is 0 the items will be inserted in the beginning of the listbox wxPython note: The first two parameters are collapsed into a single parameter for wxPython, which is a list of strings. wxPerl note: In wxPerl there is just an array reference in place of nItemsand items.

wxListBox::Selected
bool Selected(int n) const Determines whether an item is selected. Parameters

797


CHAPTER 7
n The zero-based item index. Return value true if the given item is selected, false otherwise.

wxListBox::Set
void Set(int n, const wxString* choices, void **clientData = NULL) void Set(const wxArrayString& choices, void **clientData = NULL) Clears the list box and adds the given strings to it. Parameters n The number of strings to set. choices An array of strings to set. clientData Options array of client data pointers Remarks You may free the array from the calling program after this function has been called.

wxListBox::SetFirstItem
void SetFirstItem(int n) void SetFirstItem(const wxString& string) Set the specified item to be the first visible item. Windows only. Parameters n The zero-based item index. string The string that should be visible.

798


CHAPTER 7

wxListCtrl
A list control presents lists in a number of formats: list view, report view, icon view and small icon view. In any case, elements are numbered from zero. For all these modes, the items are stored in the control and must be added to it using InsertItem (p. 810) method. A special case of report view quite different from the other modes of the list control is a virtual control in which the items data (including text, images and attributes) is managed by the main program and is requested by the control itself only when needed which allows to have controls with millions of items without consuming much memory. To use virtual list control you must use SetItemCount (p. 815) first and overload at least OnGetItemText (p. 812) (and optionally OnGetItemImage (p. 812) and OnGetItemAttr (p. 811)) to return the information about the items when the control requests it. Virtual list control can be used as a normal one except that no operations which can take time proportional to the number of items in the control happen -- this is required to allow having a practically infinite number of items. For example, in a multiple selection virtual list control, the selections won't be sent when many items are selected at once because this could mean iterating over all the items. Using many of wxListCtrl features is shown in thecorresponding sample (p. 1566). To intercept events from a list control, use the event table macros described in wxListEvent (p. 818). Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/listctrl.h> Window styles wxLC_LIST multicolumn list view, with optional small icons. Columns are computed automatically, i.e. you don't set columns as in wxLC_REPORT. In other words, the list wraps, unlike a wxListBox. single or multicolumn report view, with optional header. virtual control, may only be used with wxLC_REPORT Large icon view, with optional labels. Small icon view, with optional labels.

wxLC_REPORT wxLC_VIRTUAL wxLC_ICON wxLC_SMALL_ICON

799


CHAPTER 7
wxLC_ALIGN_TOP wxLC_ALIGN_LEFT wxLC_AUTOARRANGE wxLC_VIRTUAL wxLC_EDIT_LABELS wxLC_NO_HEADER wxLC_SINGLE_SEL wxLC_SORT_ASCENDING wxLC_SORT_DESCENDING wxLC_HRULES wxLC_VRULES Icons align to the top. Win32 default, Win32 only. Icons align to the left. Icons arrange themselves. Win32 only. The application provides items text on demand. Labels are editable: the application will be notified when editing starts. No header in report mode. Single selection (default is multiple). Sort in ascending order (must still supply a comparison callback in SortItems. Sort in descending order (must still supply a comparison callback in SortItems. Draws light horizontal rules between rows in report mode. Draws light vertical rules between columns in report mode.

See also window styles overview (p. 1611). Event handling To process input from a list control, use these event handler macros to direct input to member functions that take a wxListEvent (p. 818) argument. EVT_LIST_BEGIN_DRAG(id, func) EVT_LIST_BEGIN_RDRAG(id, func) Begin dragging with the left mouse button. Begin dragging with the right mouse button.

EVT_LIST_BEGIN_LABEL_EDIT(id, func) Begin editing a label. This can be prevented by calling Veto() (p. 954). EVT_LIST_END_LABEL_EDIT(id, func) Finish editing a label. This can be prevented by calling Veto() (p. 954). EVT_LIST_DELETE_ITEM(id, func) Delete an item.

EVT_LIST_DELETE_ALL_ITEMS(id, func) Delete all items. EVT_LIST_ITEM_SELECTED(id, func) The item has been selected. EVT_LIST_ITEM_DESELECTED(id, func) The item has been deselected. EVT_LIST_ITEM_ACTIVATED(id, func) The item has been activated (ENTER or double click).

800


CHAPTER 7
EVT_LIST_ITEM_FOCUSED(id, func) The currently focused item has changed. EVT_LIST_ITEM_MIDDLE_CLICK(id, func) The middle mouse button has been clicked on an item. EVT_LIST_ITEM_RIGHT_CLICK(id, func) The right mouse button has been clicked on an item. EVT_LIST_KEY_DOWN(id, func) EVT_LIST_INSERT_ITEM(id, func) EVT_LIST_COL_CLICK(id, func) A key has been pressed. An item has been inserted. A column (m_col) has been left-clicked.

EVT_LIST_COL_RIGHT_CLICK(id, func) A column (m_col) has been right-clicked. EVT_LIST_COL_BEGIN_DRAG(id, func) The user started resizing a column - can be vetoed. EVT_LIST_COL_DRAGGING(id, func) The divider between columns is being dragged. EVT_LIST_COL_END_DRAG(id, func) A column has been resized by the user. EVT_LIST_CACHE_HINT(id, func) See also wxListCtrl overview (p. 1647), wxListBox (p. 793), wxTreeCtrl (p. 1327), wxImageList (p. 754), wxListEvent (p. 818),wxListItem (p. 821) Prepare cache for a virtual list control

wxListCtrl::wxListCtrl
wxListCtrl() Default constructor. wxListCtrl(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxLC_ICON, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listCtrl") Constructor, creating and showing a list control. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value.

801


CHAPTER 7
pos Window position. size Window size. If the default size (-1, -1) is specified then the window is sized appropriately. style Window style. See wxListCtrl (p. 799). validator Window validator. name Window name. See also wxListCtrl::Create (p. 803), wxValidator (p. 1358)

wxListCtrl::~wxListCtrl
void ~wxListCtrl() Destructor, destroying the list control.

wxListCtrl::Arrange
bool Arrange(int flag = wxLIST_ALIGN_DEFAULT) Arranges the items in icon or small icon view. This only has effect on Win32. flag is one of: wxLIST_ALIGN_DEFAULT Default alignment. wxLIST_ALIGN_LEFT wxLIST_ALIGN_TOP Align to the left side of the control. Align to the top side of the control. Snap to grid.

wxLIST_ALIGN_SNAP_TO_GRID

wxListCtrl::AssignImageList
void AssignImageList(wxImageList* imageList, int which) Sets the image list associated with the control and takes ownership of it (i.e. the control

802


CHAPTER 7
will, unlike when using SetImageList, delete the list when destroyed). which is one of wxIMAGE_LIST_NORMAL, wxIMAGE_LIST_SMALL, wxIMAGE_LIST_STATE (the last is unimplemented). See also wxListCtrl::SetImageList (p. 813)

wxListCtrl::ClearAll
void ClearAll() Deletes all items and all columns.

wxListCtrl::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxLC_ICON, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listCtrl") Creates the list control. See wxListCtrl::wxListCtrl (p. 801) for further details.

wxListCtrl::DeleteAllItems
bool DeleteAllItems() Deletes all the items in the list control. NB: This function does not send thewxEVT_COMMAND_LIST_DELETE_ITEM event because deleting many items from the control would be too slow then (unlike DeleteItem (p. 803)).

wxListCtrl::DeleteColumn
bool DeleteColumn(int col) Deletes a column.

wxListCtrl::DeleteItem
bool DeleteItem(long item) Deletes the specified item. This function sends thewxEVT_COMMAND_LIST_DELETE_ITEM event for the item being deleted. See also: DeleteAllItems (p. 803)

803


CHAPTER 7 wxListCtrl::EditLabel
void EditLabel(long item) Starts editing the label of the given item. This function generates a EVT_LIST_BEGIN_LABEL_EDIT event which can be vetoed so that no text control will appear for in-place editing. If the user changed the label (i.e. s/he does not press ESC or leave the text control without changes, a EVT_LIST_END_LABEL_EDIT event will be sent which can be vetoed as well.

wxListCtrl::EnsureVisible
bool EnsureVisible(long item) Ensures this item is visible.

wxListCtrl::FindItem
long FindItem(long start, const wxString& str, const bool partial = false) Find an item whose label matches this string, starting from start or the beginning if start is -1. long FindItem(long start, long data) Find an item whose data matches this data, starting from start or the beginning if 'start' is -1. long FindItem(long start, const wxPoint& pt, int direction) Find an item nearest this position in the specified direction, starting from start or the beginning if start is -1. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: FindItem(start, str, partial=false) FindItemData(start, data) FindItemAtPos(start, point, direction) wxPerl note: In wxPerl there are three methods instead of a single overloaded method: FindItem( start, str, partial = false ) FindItemData( start, data ) FindItemAtPos( start, point, direction )

804


CHAPTER 7

wxListCtrl::GetColumn
bool GetColumn(int col, wxListItem& item) const Gets information about this column. See wxListCtrl::SetItem (p. 814) for more information. wxPerl note: In wxPerl this method takes only the col parameter and returns a Wx::ListItem ( or undef ).

wxListCtrl::GetColumnCount
int GetColumnCount() const Returns the number of columns.

wxListCtrl::GetColumnWidth
int GetColumnWidth(int col) const Gets the column width (report view only).

wxListCtrl::GetCountPerPage
int GetCountPerPage() const Gets the number of items that can fit vertically in the visible area of the list control (list or report view) or the total number of items in the list control (icon or small icon view).

wxListCtrl::GetEditControl
wxTextCtrl * GetEditControl() const Returns the edit control being currently used to edit a label. Returns NULLif no label is being edited. NB: It is currently only implemented for wxMSW.

wxListCtrl::GetImageList
wxImageList* GetImageList(int which) const Returns the specified image list. which may be one of: wxIMAGE_LIST_NORMAL The normal (large icon) image list.

805


CHAPTER 7
wxIMAGE_LIST_SMALL wxIMAGE_LIST_STATE The small icon image list. The user-defined state image list (unimplemented).

wxListCtrl::GetItem
bool GetItem(wxListItem& info) const Gets information about the item. See wxListCtrl::SetItem (p. 814) for more information. You must call info.SetId() to the ID of item you're interested in before calling this method. wxPython note: The wxPython version of this method takes an integer parameter for the item ID, an optional integer for the column number, and returns the wxListItem object. wxPerl note: In wxPerl this method takes as parameter the ID of the item and ( optionally ) the column, and returns a Wx::ListItem object.

wxListCtrl::GetItemBackgroundColour
wxColour GetItemBackgroundColour(long item) const Returns the colour for this item. If the item has no specific colour, returns an invalid colour (and not the default background control of the control itself). See also GetItemTextColour (p. 807)

wxListCtrl::GetItemCount
int GetItemCount() const Returns the number of items in the list control.

wxListCtrl::GetItemData
long GetItemData(long item) const Gets the application-defined data associated with this item.

wxListCtrl::GetItemPosition
bool GetItemPosition(long item, wxPoint& pos) const Returns the position of the item, in icon or small icon view.

806


CHAPTER 7
wxPython note: The wxPython version of this method accepts only the item ID and returns the wxPoint. wxPerl note: In wxPerl this method takes only the item parameter and returns a Wx::Point ( or undef ).

wxListCtrl::GetItemRect
bool GetItemRect(long item, wxRect& rect, int code = wxLIST_RECT_BOUNDS) const Returns the rectangle representing the item's size and position, in client coordinates. code is one of wxLIST_RECT_BOUNDS, wxLIST_RECT_ICON, wxLIST_RECT_LABEL. wxPython note: The wxPython version of this method accepts only the item ID and code and returns the wxRect. wxPerl note: In wxPerl this method takes only the item parameter and returns a Wx::Rect ( or undef ).

wxListCtrl::GetItemSpacing
wxSize GetItemSpacing() const Retrieves the spacing between icons in pixels: horizontal spacing is returned as x component of the wxSize (p. 1106) object and the vertical spacing as its y component.

wxListCtrl::GetItemState
int GetItemState(long item, long stateMask) const Gets the item state. For a list of state flags, see wxListCtrl::SetItem (p. 814). The stateMask indicates which state flags are of interest.

wxListCtrl::GetItemText
wxString GetItemText(long item) const Gets the item text for this item.

wxListCtrl::GetItemTextColour
wxColour GetItemTextColour(long item) const Returns the colour for this item. If the item has no specific colour, returns an invalid

807


CHAPTER 7
colour (and not the default foreground control of the control itself as this wouldn't allow distinguishing between items having the same colour as the current control foreground and items with default colour which, hence, have always the same colour as the control).

wxListCtrl::GetNextItem
long GetNextItem(long item, int geometry = wxLIST_NEXT_ALL, int state = wxLIST_STATE_DONTCARE) const Searches for an item with the given geometry or state, starting fromitem but excluding the item itself. If item is -1, the first item that matches the specified flags will be returned. Returns the first item with given state following item or -1 if no such item found. This function may be used to find all selected items in the control like this:
long item = -1; for ( ;; ) { item = listctrl->GetNextItem(item, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED); if ( item == -1 ) break; // this item is selected - do whatever is needed with it wxLogMessage("Item %ld is selected."), item); }

geometry can be one of: wxLIST_NEXT_ABOVE wxLIST_NEXT_ALL wxLIST_NEXT_BELOW wxLIST_NEXT_LEFT wxLIST_NEXT_RIGHT Searches for an item above the specified item. Searches for subsequent item by index. Searches for an item below the specified item. Searches for an item to the left of the specified item. Searches for an item to the right of the specified item.

NB: this parameters is only supported by wxMSW currently and ignored on other platforms. state can be a bitlist of the following: wxLIST_STATE_DONTCARE wxLIST_STATE_DROPHILITED Don't care what the state is. The item indicates it is a drop target.

wxLIST_STATE_FOCUSED The item has the focus. wxLIST_STATE_SELECTED The item is selected. wxLIST_STATE_CUT The item is selected as part of a cut and paste operation.

808


CHAPTER 7 wxListCtrl::GetSelectedItemCount
int GetSelectedItemCount() const Returns the number of selected items in the list control.

wxListCtrl::GetTextColour
wxColour GetTextColour() const Gets the text colour of the list control.

wxListCtrl::GetTopItem
long GetTopItem() const Gets the index of the topmost visible item when in list or report view.

wxRect
wxListCtrl::GetViewRect wxRect GetViewRect() const Returns the rectangle taken by all items in the control. In other words, if the controls client size were equal to the size of this rectangle, no scrollbars would be needed and no free space would be left. Note that this function only works in the icon and small icon views, not in list or report views (this is a limitation of the native Win32 control).

wxListCtrl::HitTest
long HitTest(const wxPoint& point, int& flags) Determines which item (if any) is at the specified point, giving details in flags. flags will be a combination of the following flags: wxLIST_HITTEST_ABOVE Above the client area. wxLIST_HITTEST_BELOW Below the client area. wxLIST_HITTEST_NOWHERE wxLIST_HITTEST_ONITEMICON In the client area but below the last item. On the bitmap associated with an item.

wxLIST_HITTEST_ONITEMLABEL On the label (string) associated with an item. wxLIST_HITTEST_ONITEMRIGHT In the area to the right of an item.

809


CHAPTER 7
wxLIST_HITTEST_ONITEMSTATEICON On the state icon for a tree view item that is in a user-defined state. wxLIST_HITTEST_TOLEFT To the right of the client area. wxLIST_HITTEST_TORIGHT To the left of the client area.

wxLIST_HITTEST_ONITEM Combination of wxLIST_HITTEST_ONITEMICON, wxLIST_HITTEST_ONITEMLABEL, wxLIST_HITTEST_ONITEMSTATEICON. wxPython note: A tuple of values is returned in the wxPython version of this method. The first value is the item id and the second is the flags value mentioned above. wxPerl note: In wxPerl this method only takes the point parameter and returns a 2element list ( item, flags ).

wxListCtrl::InsertColumn
long InsertColumn(long col, wxListItem& info) long InsertColumn(long col, const wxString& heading, int format = wxLIST_FORMAT_LEFT, int width = -1) For report view mode (only), inserts a column. For more details, see wxListCtrl::SetItem (p. 814). wxPython note: In place of a single overloaded method name, wxPython implements the following methods: InsertColumn(col, heading, format=wxLIST_FORMAT_LEFT, width=-1) Creates a column using a header string only. InsertColumnInfo(col, item) Creates a column using a wxListInfo.

wxListCtrl::InsertItem
long InsertItem(wxListItem& info) Inserts an item, returning the index of the new item if successful, -1 otherwise. long InsertItem(long index, const wxString& label) Inserts a string item. long InsertItem(long index, int imageIndex) Inserts an image item. long InsertItem(long index, const wxString& label, int imageIndex)

810


CHAPTER 7
Insert an image/string item. Parameters info wxListItem object index Index of the new item, supplied by the application label String label imageIndex index into the image list associated with this control and view style wxPython note: In place of a single overloaded method name, wxPython implements the following methods: InsertItem(item) Inserts an item using a wxListItem.

InsertStringItem(index, label) Inserts a string item. InsertImageItem(index, imageIndex) Inserts an image item. InsertImageStringItem(index, label, imageIndex) item. Insert an image/string

wxPerl note: In wxPerl there are four methods instead of a single overloaded method: InsertItem( item ) Inserts a Wx::ListItem

InsertStringItem( index, label ) Inserts a string item InsertImageItem( index, imageIndex ) Inserts an image item InsertImageStringItem( index, label, imageIndex ) Inserts an item with a string and an image

wxListCtrl::OnGetItemAttr
virtual wxListItemAttr * OnGetItemAttr(long item) This function may be overloaded in the derived class for a control with wxLC_VIRTUAL style. It should return the attribute for the for the specified item or NULL to use the default appearance parameters. The base class version always returns NULL.

811


CHAPTER 7
See also OnGetItemImage (p. 812), OnGetItemText (p. 812)

wxListCtrl::OnGetItemImage
virtual int OnGetItemImage(long item) This function must be overloaded in the derived class for a control with wxLC_VIRTUAL style having an image list (p. 813) (if the control doesn't have an image list, it is not necessary to overload it). It should return the index of the items image in the controls image list or -1 for no image. The base class version always returns -1. See also OnGetItemText (p. 812), OnGetItemAttr (p. 811)

wxListCtrl::OnGetItemText
virtual wxString OnGetItemText(long item, long column) This function must be overloaded in the derived class for a control with wxLC_VIRTUAL style. It should return the string containing the text of the given column for the specified item. See also SetItemCount (p. 815), OnGetItemImage (p. 812), OnGetItemAttr (p. 811)

wxListCtrl::RefreshItem
void RefreshItem(long item) Redraws the given item. This is only useful for the virtual list controls as without calling this function the displayed value of the item doesn't change even when the underlying data does change. See also RefreshItems (p. 812)

wxListCtrl::RefreshItems

812


CHAPTER 7
void RefreshItems(long itemFrom, long itemTo) Redraws the items between itemFrom and itemTo. The starting item must be less than or equal to the ending one. Just as RefreshItem (p. 812) this is only useful for virtual list controls.

wxListCtrl::ScrollList
bool ScrollList(int dx, int dy) Scrolls the list control. If in icon, small icon or report view mode, dx specifies the number of pixels to scroll. If in list view mode, dx specifies the number of columns to scroll. dy always specifies the number of pixels to scroll vertically. NB: This method is currently only implemented in the Windows version.

wxListCtrl::SetBackgroundColour
void SetBackgroundColour(const wxColour& col) Sets the background colour (GetBackgroundColour already implicit in wxWindow class).

wxListCtrl::SetColumn
bool SetColumn(int col, wxListItem& item) Sets information about this column. See wxListCtrl::SetItem (p. 814) for more information.

wxListCtrl::SetColumnWidth
bool SetColumnWidth(int col, int width) Sets the column width. width can be a width in pixels or wxLIST_AUTOSIZE (-1) or wxLIST_AUTOSIZE_USEHEADER (-2). wxLIST_AUTOSIZE will resize the column to the length of its longest item. wxLIST_AUTOSIZE_USEHEADER will resize the column to the length of the header (Win32) or 80 pixels (other platforms). In small or normal icon view, col must be -1, and the column width is set for all columns.

wxListCtrl::SetImageList
void SetImageList(wxImageList* imageList, int which) Sets the image list associated with the control. which is one of

813


CHAPTER 7
wxIMAGE_LIST_NORMAL, wxIMAGE_LIST_SMALL, wxIMAGE_LIST_STATE (the last is unimplemented). This method does not take ownership of the image list, you have to delete it yourself. See also wxListCtrl::AssignImageList (p. 802)

wxListCtrl::SetItem
bool SetItem(wxListItem& info) long SetItem(long index, int col, const wxString& label, int imageId = -1) Sets information about the item. wxListItem is a class with the following members: long m_mask long m_itemId int m_col long m_state long m_stateMask wxString m_text int m_image long m_data int m_format Indicates which fields are valid. See the list of valid mask flags below. The zero-based item position. Zero-based column, if in report mode. The state of the item. See the list of valid state flags below. A mask indicating which state flags are valid. See the list of valid state flags below. The label/header text. The zero-based index into an image list. Application-defined data. For columns only: the format. Can be wxLIST_FORMAT_LEFT, wxLIST_FORMAT_RIGHT or wxLIST_FORMAT_CENTRE. For columns only: the column width.

int m_width

The m_mask member contains a bitlist specifying which of the other fields are valid. The flags are: wxLIST_MASK_STATE wxLIST_MASK_TEXT wxLIST_MASK_IMAGE wxLIST_MASK_DATA The m_state field is valid. The m_text field is valid. The m_image field is valid. The m_data field is valid.

814


CHAPTER 7
wxLIST_MASK_WIDTH wxLIST_MASK_FORMAT The m_width field is valid. The m_format field is valid.

The m_stateMask and m_state members take flags from the following: The wxListItem object can also contain item-specific colour and font information: for this you need to call one of SetTextColour(), SetBackgroundColour() or SetFont() functions on it passing it the colour/font to use. If the colour/font is not specified, the default list control colour/font is used. wxLIST_STATE_DONTCARE Don't care what the state is. Win32 only.

wxLIST_STATE_DROPHILITED The item is highlighted to receive a drop event. Win32 only. wxLIST_STATE_FOCUSED The item has the focus. wxLIST_STATE_SELECTED The item is selected. wxLIST_STATE_CUT The item is in the cut state. Win32 only.

long SetItem(long index, int col, const wxString& label, int imageId = -1) Sets a string field at a particular column. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: SetItem(item) Sets information about the given wxListItem. Sets a string or image at a

SetStringItem(index, col, label, imageId) given location.

wxListCtrl::SetItemBackgroundColour
void SetItemBackgroundColour(long item, const wxColour& col) Sets the background colour for this item. This function only works in report view. The colour can be retrieved using GetItemBackgroundColour (p. 806).

wxListCtrl::SetItemCount
void SetItemCount(long count) This method can only be used with virtual list controls. It is used to indicate to the control the number of items it contains. After calling it, the main program should be ready to handle calls to various item callbacks (such asOnGetItemText (p. 812)) for all items in the range from 0 to count.

815


CHAPTER 7 wxListCtrl::SetItemData
bool SetItemData(long item, long data) Associates application-defined data with this item.

wxListCtrl::SetItemImage
bool SetItemImage(long item, int image, int selImage) Sets the unselected and selected images associated with the item. The images are indices into the image list associated with the list control.

wxListCtrl::SetItemPosition
bool SetItemPosition(long item, const wxPoint& pos) Sets the position of the item, in icon or small icon view.

wxListCtrl::SetItemState
bool SetItemState(long item, long state, long stateMask) Sets the item state. For a list of state flags, see wxListCtrl::SetItem (p. 814). The stateMask indicates which state flags are valid.

wxListCtrl::SetItemText
void SetItemText(long item, const wxString& text) Sets the item text for this item.

wxListCtrl::SetItemTextColour
void SetItemTextColour(long item, const wxColour& col) Sets the colour for this item. This function only works in report view. The colour can be retrieved using GetItemTextColour (p. 807).

wxListCtrl::SetSingleStyle
void SetSingleStyle(long style, const bool add = true) Adds or removes a single window style.

816


CHAPTER 7 wxListCtrl::SetTextColour
void SetTextColour(const wxColour& col) Sets the text colour of the list control.

wxListCtrl::SetWindowStyleFlag
void SetWindowStyleFlag(long style) Sets the whole window style, deleting all items.

wxListCtrl::SortItems
bool SortItems(wxListCtrlCompare fnSortCallBack, long data) Call this function to sort the items in the list control. Sorting is done using the specified fnSortCallBack function. This function must have the following prototype:
int wxCALLBACK wxListCompareFunction(long item1, long item2, long sortData)

It is called each time when the two items must be compared and should return 0 if the items are equal, negative value if the first item is less than the second one and positive value if the first one is greater than the second one (the same convention as used by qsort(3)). Parameters item1 client data associated with the first item (NOT the index). item2 client data associated with the second item (NOT the index). data the value passed to SortItems() itself. Notice that the control may only be sorted on client data associated with the items, so you must use SetItemData (p. 816) if you want to be able to sort the items in the control. Please see the listctrl sample (p. 1566) for an example of using this function. wxPython note: wxPython uses the sortData parameter to pass the Python function to call, so it is not available for programmer use. Call SortItems with a reference to a callable object that expects two parameters. wxPerl note: In wxPerl the comparison function must take just two parameters; however, you may use a closure to achieve an effect similar to the SortItems third

817


CHAPTER 7
parameter.

wxListEvent
A list event holds information about events associated with wxListCtrl objects. Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/listctrl.h> Event table macros To process input from a list control, use these event handler macros to direct input to member functions that take a wxListEvent argument. EVT_LIST_BEGIN_DRAG(id, func) EVT_LIST_BEGIN_RDRAG(id, func) Begin dragging with the left mouse button. Begin dragging with the right mouse button.

EVT_LIST_BEGIN_LABEL_EDIT(id, func) Begin editing a label. This can be prevented by calling Veto() (p. 954). EVT_LIST_END_LABEL_EDIT(id, func) Finish editing a label. This can be prevented by calling Veto() (p. 954). EVT_LIST_DELETE_ITEM(id, func) Delete an item.

EVT_LIST_DELETE_ALL_ITEMS(id, func) Delete all items. EVT_LIST_ITEM_SELECTED(id, func) The item has been selected. EVT_LIST_ITEM_DESELECTED(id, func) The item has been deselected. EVT_LIST_ITEM_ACTIVATED(id, func) The item has been activated (ENTER or double click). EVT_LIST_ITEM_FOCUSED(id, func) The currently focused item has changed. EVT_LIST_ITEM_MIDDLE_CLICK(id, func) The middle mouse button has been clicked on an item. EVT_LIST_ITEM_RIGHT_CLICK(id, func) The right mouse button has been clicked on an item. EVT_LIST_KEY_DOWN(id, func) A key has been pressed.

818


CHAPTER 7
EVT_LIST_INSERT_ITEM(id, func) EVT_LIST_COL_CLICK(id, func) An item has been inserted. A column (m_col) has been left-clicked.

EVT_LIST_COL_RIGHT_CLICK(id, func) A column (m_col) (which can be -1 if the click occured outside any column) has been right-clicked. EVT_LIST_COL_BEGIN_DRAG(id, func) The user started resizing a column - can be vetoed. EVT_LIST_COL_DRAGGING(id, func) The divider between columns is being dragged. EVT_LIST_COL_END_DRAG(id, func) A column has been resized by the user. EVT_LIST_CACHE_HINT(id, func) See also wxListCtrl (p. 799) Prepare cache for a virtual list control

wxListEvent::wxListEvent
wxListEvent(WXTYPE commandType = 0, int id = 0) Constructor.

wxListEvent::GetCacheFrom
long GetCacheFrom() const For EVT_LIST_CACHE_HINT event only: return the first item which the list control advises us to cache.

wxListEvent::GetCacheTo
long GetCacheTo() const For EVT_LIST_CACHE_HINT event only: return the last item (inclusive) which the list control advises us to cache.

wxListEvent::GetKeyCode
int GetKeyCode() const Key code if the event is a keypress event.

819


CHAPTER 7 wxListEvent::GetIndex
long GetIndex() const The item index.

wxListEvent::GetColumn
int GetColumn() const The column position: it is only used with COL events. For the column dragging events, it is the column to the left of the divider being dragged, for the column click events it may be -1 if the user clicked in the list control header outside any column.

wxListEvent::GetPoint
wxPoint GetPoint() const The position of the mouse pointer if the event is a drag event.

wxListEvent::GetLabel
const wxString& GetLabel() const The (new) item label for EVT_LIST_END_LABEL_EDIT event.

wxListEvent::GetText
const wxString& GetText() const The text.

wxListEvent::GetImage
int GetImage() const The image.

wxListEvent::GetData
long GetData() const The data.

wxListEvent::GetMask 820


CHAPTER 7
long GetMask() const The mask.

wxListEvent::GetItem
const wxListItem& GetItem() const An item object, used by some events. See also wxListCtrl::SetItem (p. 814).

wxListEvent::IsEditCancelled
bool IsEditCancelled() const This method only makes sense for EVT_LIST_END_LABEL_EDIT message and returns true if it the label editing has been cancelled by the user (GetLabel (p. 820) returns an empty string in this case but it doesn't allow to distinguish between really cancelling the edit and, admittedly rare, case when the user wants to rename it to an empty string0.

wxListItem
This class stores information about a wxListCtrl item or column. Derived from wxObject (p. 954) Include files <wx/listctrl.h>

wxListItem::wxListItem
wxListItem() Constructor.

wxListItem::Clear
void Clear() Resets the item state to the default.

wxListItem::GetAlign 821


CHAPTER 7
wxListColumnFormat GetAlign() const Returns the alignment for this item. Can be one of wxLIST_FORMAT_LEFT, wxLIST_FORMAT_RIGHT or wxLIST_FORMAT_CENTRE.

wxListItem::GetBackgroundColour
wxColour GetBackgroundColour() const Returns the background colour for this item.

wxListItem::GetColumn
int GetColumn() const Returns the zero-based column; meaningful only in report mode.

wxListItem::GetData
long GetData() const Returns client data associated with the control.

wxListItem::GetFont
wxFont GetFont() const Returns the font used to display the item.

wxListItem::GetId
long GetId() const Returns the zero-based item position.

wxListItem::GetImage
int GetImage() const Returns the zero-based index of the image associated with the item into the image list.

wxListItem::GetMask
long GetMask() const

822


CHAPTER 7
Returns a bit mask indicating which fields of the structure are valid; can be any combination of the following values: wxLIST_MASK_STATE wxLIST_MASK_TEXT wxLIST_MASK_IMAGE wxLIST_MASK_DATA wxLIST_MASK_WIDTH wxLIST_MASK_FORMAT The GetState is valid. The GetText is valid. The GetImage is valid. The GetData is valid. The GetWidth is valid. The GetAlign is valid.

wxListItem::GetState
long GetState() const Returns a bit field representing the state of the item. Can be any combination of: wxLIST_STATE_DONTCARE Don't care what the state is. Win32 only.

wxLIST_STATE_DROPHILITED The item is highlighted to receive a drop event. Win32 only. wxLIST_STATE_FOCUSED The item has the focus. wxLIST_STATE_SELECTED The item is selected. wxLIST_STATE_CUT The item is in the cut state. Win32 only.

wxListItem::GetText
const wxString& GetText() const Returns the label/header text.

wxListItem::GetTextColour
wxColour GetTextColour() const Returns the text colour.

wxListItem::GetWidth
int GetWidth() const Meaningful only for column headers in report mode. Returns the column width.

823


CHAPTER 7 wxListItem::SetAlign
void SetAlign(wxListColumnFormat align) Sets the alignment for the item. See alsowxListItem::SetAlign (p. 824)

wxListItem::SetBackgroundColour
void SetBackgroundColour(const wxColour& colBack) Sets the background colour for the item.

wxListItem::SetColumn
void SetColumn(int col) Sets the zero-based column. Meaningful only in report mode.

wxListItem::SetData
void SetData(long data) void SetData(void* data) Sets client data for the item.

wxListItem::SetFont
void SetFont(const wxFont& font) Sets the font for the item.

wxListItem::SetId
void SetId(long id) Sets the zero-based item position.

wxListItem::SetImage
void SetImage(int image) Returns the zero-based index of the image associated with the item into the image list.

wxListItem::SetMask 824


CHAPTER 7
void SetMask(long mask) Sets the mask of valid fields. See wxListItem::GetMask (p. 822).

wxListItem::SetState
void SetState(long state) Sets the item state flags (note that the valid state flags are influenced by the value of the state mask, seewxListItem::SetStateMask (p. 825)). See wxListItem::GetState (p. 825) for valid flag values.

wxListItem::SetStateMask
void SetStateMask(long stateMask) Sets the bitmask that is used to determine which of the state flags are to be set. See also wxListItem::SetState (p. 825).

wxListItem::SetText
void SetText(const wxString& text) Sets the text label for the item.

wxListItem::SetTextColour
void SetTextColour(const wxColour& colText) Sets the text colour for the item.

wxListItem::SetWidth
void SetWidth(int width) Meaningful only for column headers in report mode. Sets the column width.

wxListView
This class currently simply presents a simpler to use interface for the wxListCtrl (p. 799) -- it can be thought of as a faadefor that complicated class. Using it is preferable to using wxListCtrl (p. 799) directly whenever possible because in the future some ports might implement wxListView but not the full set of wxListCtrl features. Other than different interface, this class is identical to wxListCtrl. In particular, it uses the

825


CHAPTER 7
same events, same windows styles and so on. Derived from wxListCtrl (p. 799) wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/listctrl.h>

wxListView::ClearColumnImage
void ClearColumnImage(int col) Resets the column image -- after calling this function, no image will be shown. Parameters col the column to clear image for See also SetColumnImage (p. 828)

wxListView::Focus
void Focus(long index) Sets focus to the item with the given index.

wxListView::GetFirstSelected
long GetFirstSelected() const Returns the first selected item in a (presumably) multiple selection control. Tigether with GetNextSelected (p. 827) it can be used to iterate over all selected items in the control. Return value The fisrt selected item, if any, -1 otherwise.

826


CHAPTER 7 wxListView::GetFocusedItem
long GetFocusedItem() const Returns the currently focused item or -1 if none. See also IsSelected (p. 827), Focus (p. 826)

wxListView::GetNextSelected
long GetNextSelected(long item) const Used together with GetFirstSelected (p. 826) to iterate oevr all selected items in the control. Return value Returns the next selected item or -1 if there are no more of them.

wxListView::IsSelected
bool IsSelected(long index) Returns true if the item with the given index is selected, false otherwise. See also GetFirstSelected (p. 826), GetNextSelected (p. 827)

wxListView::Select
void Select(long n, bool on = true) Selects or unselects the given item. Parameters n the item to select or unselect on if true (default), selects the item, otherwise unselects it See also

827


CHAPTER 7
SetItemState (p. 816)

wxListView::SetColumnImage
void SetColumnImage(int col, int image) Sets the column image for the specified column. To use the column images, the control must have a valid image list with at least one image. Parameters col the column to set image for image the index of the column image in the controls image list See also ClearColumnImage (p. 826), SetImageList (p. 813)

wxLocale
wxLocale class encapsulates all language-dependent settings and is a generalization of the C locale concept. In wxWindows this class manages message catalogs which contain the translations of the strings used to the current language. wxPerl note: In wxPerl you can't use the '_' function name, so the Wx::Locale module can export the gettext and gettext_noop under any given name.
# this imports gettext ( equivalent to Wx::GetTranslation # and gettext_noop ( a noop ) # into your module use Wx::Locale qw(:default); # .... # use the functions print gettext( ``Panic!'' ); button = Wx::Button->new( window, -1, gettext( ``Label'' ) );

If you need to translate a lot of strings, then adding gettext( ) around each one is a long task ( that is why _( ) was introduced ), so just choose a shorter name for gettext:
# use Wx::Locale 'gettext' => 't', 'gettext_noop' => 'gettext_noop';

828


CHAPTER 7
# ... # use the functions print t( ``Panic!!'' ); # ...

Derived from No base class See also Internationalization overview (p. 1589), Internat sample (p. 1566) Include files <wx/intl.h>

Supported languages
The following wxLanguage constants may be used to specify the language in Init (p. 842) and are returned by GetSystemLanguage (p. 841):             wxLANGUAGE_DEFAULT -- user's default language as obtained from the operating system wxLANGUAGE_UNKNOWN -- returned by GetSystemLanguage (p. 841)if it fails to detect the default language wxLANGUAGE_USER_DEFINED -- user defined languages' integer identifiers should start from this wxLANGUAGE_ABKHAZIAN wxLANGUAGE_AFAR wxLANGUAGE_AFRIKAANS wxLANGUAGE_ALBANIAN wxLANGUAGE_AMHARIC wxLANGUAGE_ARABIC wxLANGUAGE_ARABIC_ALGERIA wxLANGUAGE_ARABIC_BAHRAIN wxLANGUAGE_ARABIC_EGYPT

829


CHAPTER 7
                            wxLANGUAGE_ARABIC_IRAQ wxLANGUAGE_ARABIC_JORDAN wxLANGUAGE_ARABIC_KUWAIT wxLANGUAGE_ARABIC_LEBANON wxLANGUAGE_ARABIC_LIBYA wxLANGUAGE_ARABIC_MOROCCO wxLANGUAGE_ARABIC_OMAN wxLANGUAGE_ARABIC_QATAR wxLANGUAGE_ARABIC_SAUDI_ARABIA wxLANGUAGE_ARABIC_SUDAN wxLANGUAGE_ARABIC_SYRIA wxLANGUAGE_ARABIC_TUNISIA wxLANGUAGE_ARABIC_UAE wxLANGUAGE_ARABIC_YEMEN wxLANGUAGE_ARMENIAN wxLANGUAGE_ASSAMESE wxLANGUAGE_AYMARA wxLANGUAGE_AZERI wxLANGUAGE_AZERI_CYRILLIC wxLANGUAGE_AZERI_LATIN wxLANGUAGE_BASHKIR wxLANGUAGE_BASQUE wxLANGUAGE_BELARUSIAN wxLANGUAGE_BENGALI wxLANGUAGE_BHUTANI wxLANGUAGE_BIHARI wxLANGUAGE_BISLAMA wxLANGUAGE_BRETON

830


CHAPTER 7
                            wxLANGUAGE_BULGARIAN wxLANGUAGE_BURMESE wxLANGUAGE_CAMBODIAN wxLANGUAGE_CATALAN wxLANGUAGE_CHINESE wxLANGUAGE_CHINESE_SIMPLIFIED wxLANGUAGE_CHINESE_TRADITIONAL wxLANGUAGE_CHINESE_HONGKONG wxLANGUAGE_CHINESE_MACAU wxLANGUAGE_CHINESE_SINGAPORE wxLANGUAGE_CHINESE_TAIWAN wxLANGUAGE_CORSICAN wxLANGUAGE_CROATIAN wxLANGUAGE_CZECH wxLANGUAGE_DANISH wxLANGUAGE_DUTCH wxLANGUAGE_DUTCH_BELGIAN wxLANGUAGE_ENGLISH wxLANGUAGE_ENGLISH_UK wxLANGUAGE_ENGLISH_US wxLANGUAGE_ENGLISH_AUSTRALIA wxLANGUAGE_ENGLISH_BELIZE wxLANGUAGE_ENGLISH_BOTSWANA wxLANGUAGE_ENGLISH_CANADA wxLANGUAGE_ENGLISH_CARIBBEAN wxLANGUAGE_ENGLISH_DENMARK wxLANGUAGE_ENGLISH_EIRE wxLANGUAGE_ENGLISH_JAMAICA

831


CHAPTER 7
                            wxLANGUAGE_ENGLISH_NEW_ZEALAND wxLANGUAGE_ENGLISH_PHILIPPINES wxLANGUAGE_ENGLISH_SOUTH_AFRICA wxLANGUAGE_ENGLISH_TRINIDAD wxLANGUAGE_ENGLISH_ZIMBABWE wxLANGUAGE_ESPERANTO wxLANGUAGE_ESTONIAN wxLANGUAGE_FAEROESE wxLANGUAGE_FARSI wxLANGUAGE_FIJI wxLANGUAGE_FINNISH wxLANGUAGE_FRENCH wxLANGUAGE_FRENCH_BELGIAN wxLANGUAGE_FRENCH_CANADIAN wxLANGUAGE_FRENCH_LUXEMBOURG wxLANGUAGE_FRENCH_MONACO wxLANGUAGE_FRENCH_SWISS wxLANGUAGE_FRISIAN wxLANGUAGE_GALICIAN wxLANGUAGE_GEORGIAN wxLANGUAGE_GERMAN wxLANGUAGE_GERMAN_AUSTRIAN wxLANGUAGE_GERMAN_BELGIUM wxLANGUAGE_GERMAN_LIECHTENSTEIN wxLANGUAGE_GERMAN_LUXEMBOURG wxLANGUAGE_GERMAN_SWISS wxLANGUAGE_GREEK wxLANGUAGE_GREENLANDIC

832


CHAPTER 7
                            wxLANGUAGE_GUARANI wxLANGUAGE_GUJARATI wxLANGUAGE_HAUSA wxLANGUAGE_HEBREW wxLANGUAGE_HINDI wxLANGUAGE_HUNGARIAN wxLANGUAGE_ICELANDIC wxLANGUAGE_INDONESIAN wxLANGUAGE_INTERLINGUA wxLANGUAGE_INTERLINGUE wxLANGUAGE_INUKTITUT wxLANGUAGE_INUPIAK wxLANGUAGE_IRISH wxLANGUAGE_ITALIAN wxLANGUAGE_ITALIAN_SWISS wxLANGUAGE_JAPANESE wxLANGUAGE_JAVANESE wxLANGUAGE_KANNADA wxLANGUAGE_KASHMIRI wxLANGUAGE_KASHMIRI_INDIA wxLANGUAGE_KAZAKH wxLANGUAGE_KERNEWEK wxLANGUAGE_KINYARWANDA wxLANGUAGE_KIRGHIZ wxLANGUAGE_KIRUNDI wxLANGUAGE_KONKANI wxLANGUAGE_KOREAN wxLANGUAGE_KURDISH

833


CHAPTER 7
                            wxLANGUAGE_LAOTHIAN wxLANGUAGE_LATIN wxLANGUAGE_LATVIAN wxLANGUAGE_LINGALA wxLANGUAGE_LITHUANIAN wxLANGUAGE_MACEDONIAN wxLANGUAGE_MALAGASY wxLANGUAGE_MALAY wxLANGUAGE_MALAYALAM wxLANGUAGE_MALAY_BRUNEI_DARUSSALAM wxLANGUAGE_MALAY_MALAYSIA wxLANGUAGE_MALTESE wxLANGUAGE_MANIPURI wxLANGUAGE_MAORI wxLANGUAGE_MARATHI wxLANGUAGE_MOLDAVIAN wxLANGUAGE_MONGOLIAN wxLANGUAGE_NAURU wxLANGUAGE_NEPALI wxLANGUAGE_NEPALI_INDIA wxLANGUAGE_NORWEGIAN_BOKMAL wxLANGUAGE_NORWEGIAN_NYNORSK wxLANGUAGE_OCCITAN wxLANGUAGE_ORIYA wxLANGUAGE_OROMO wxLANGUAGE_PASHTO wxLANGUAGE_POLISH wxLANGUAGE_PORTUGUESE

834


CHAPTER 7
                            wxLANGUAGE_PORTUGUESE_BRAZILIAN wxLANGUAGE_PUNJABI wxLANGUAGE_QUECHUA wxLANGUAGE_RHAETO_ROMANCE wxLANGUAGE_ROMANIAN wxLANGUAGE_RUSSIAN wxLANGUAGE_RUSSIAN_UKRAINE wxLANGUAGE_SAMOAN wxLANGUAGE_SANGHO wxLANGUAGE_SANSKRIT wxLANGUAGE_SCOTS_GAELIC wxLANGUAGE_SERBIAN wxLANGUAGE_SERBIAN_CYRILLIC wxLANGUAGE_SERBIAN_LATIN wxLANGUAGE_SERBO_CROATIAN wxLANGUAGE_SESOTHO wxLANGUAGE_SETSWANA wxLANGUAGE_SHONA wxLANGUAGE_SINDHI wxLANGUAGE_SINHALESE wxLANGUAGE_SISWATI wxLANGUAGE_SLOVAK wxLANGUAGE_SLOVENIAN wxLANGUAGE_SOMALI wxLANGUAGE_SPANISH wxLANGUAGE_SPANISH_ARGENTINA wxLANGUAGE_SPANISH_BOLIVIA wxLANGUAGE_SPANISH_CHILE

835


CHAPTER 7
                            wxLANGUAGE_SPANISH_COLOMBIA wxLANGUAGE_SPANISH_COSTA_RICA wxLANGUAGE_SPANISH_DOMINICAN_REPUBLIC wxLANGUAGE_SPANISH_ECUADOR wxLANGUAGE_SPANISH_EL_SALVADOR wxLANGUAGE_SPANISH_GUATEMALA wxLANGUAGE_SPANISH_HONDURAS wxLANGUAGE_SPANISH_MEXICAN wxLANGUAGE_SPANISH_MODERN wxLANGUAGE_SPANISH_NICARAGUA wxLANGUAGE_SPANISH_PANAMA wxLANGUAGE_SPANISH_PARAGUAY wxLANGUAGE_SPANISH_PERU wxLANGUAGE_SPANISH_PUERTO_RICO wxLANGUAGE_SPANISH_URUGUAY wxLANGUAGE_SPANISH_US wxLANGUAGE_SPANISH_VENEZUELA wxLANGUAGE_SUNDANESE wxLANGUAGE_SWAHILI wxLANGUAGE_SWEDISH wxLANGUAGE_SWEDISH_FINLAND wxLANGUAGE_TAGALOG wxLANGUAGE_TAJIK wxLANGUAGE_TAMIL wxLANGUAGE_TATAR wxLANGUAGE_TELUGU wxLANGUAGE_THAI wxLANGUAGE_TIBETAN

836


CHAPTER 7
                       wxLANGUAGE_TIGRINYA wxLANGUAGE_TONGA wxLANGUAGE_TSONGA wxLANGUAGE_TURKISH wxLANGUAGE_TURKMEN wxLANGUAGE_TWI wxLANGUAGE_UIGHUR wxLANGUAGE_UKRAINIAN wxLANGUAGE_URDU wxLANGUAGE_URDU_INDIA wxLANGUAGE_URDU_PAKISTAN wxLANGUAGE_UZBEK wxLANGUAGE_UZBEK_CYRILLIC wxLANGUAGE_UZBEK_LATIN wxLANGUAGE_VIETNAMESE wxLANGUAGE_VOLAPUK wxLANGUAGE_WELSH wxLANGUAGE_WOLOF wxLANGUAGE_XHOSA wxLANGUAGE_YIDDISH wxLANGUAGE_YORUBA wxLANGUAGE_ZHUANG wxLANGUAGE_ZULU

wxLocale::wxLocale
wxLocale() This is the default constructor and it does nothing to initialize the object: Init() (p. 842) must be used to do that.

837


CHAPTER 7
wxLocale(int language, int flags = wxLOCALE_CONV_ENCODING) See Init() (p. 842) for parameters description. wxLocale(const char *szName, const char *szShort = NULL, const char *szLocale = NULL, bool bLoadDefault = true, bool bConvertEncoding = false) See Init() (p. 842) for parameters description. The call of this function has several global side effects which you should understand: first of all, the application locale is changed - note that this will affect many of standard C library functions such as printf() or strftime(). Second, this wxLocale object becomes the new current global locale for the application and so all subsequent calls to wxGetTranslation() will try to translate the messages using the message catalogs for this locale. wxLOCALE_LOAD_DEFAULT |

wxLocale::~wxLocale
~wxLocale() The destructor, like the constructor, also has global side effects: the previously set locale is restored and so the changes described in Init (p. 842) documentation are rolled back.

wxLocale::AddCatalog
bool AddCatalog(const char *szDomain) Add a catalog for use with the current locale: it is searched for in standard places (current directory first, then the system one), but you may also prepend additional directories to the search path with AddCatalogLookupPathPrefix() (p. 838). All loaded catalogs will be used for message lookup by GetString() for the current locale. Returns true if catalog was successfully loaded, false otherwise (which might mean that the catalog is not found or that it isn't in the correct format).

wxLocale::AddCatalogLookupPathPrefix
void AddCatalogLookupPathPrefix(const wxString& prefix) Add a prefix to the catalog lookup path: the message catalog files will be looked up under prefix/<lang>/LC_MESSAGES, prefix/LC_MESSAGES and prefix (in this order). This only applies to subsequent invocations of AddCatalog()!

wxLocale::AddLanguage
static void AddLanguage(const wxLanguageInfo& info)

838


CHAPTER 7
Adds custom, user-defined language to the database of known languages. This database is used in conjunction with the first form of Init (p. 842). wxLanguageInfo is defined as follows:
struct WXDLLEXPORT wxLanguageInfo { int Language; wxString CanonicalName; #ifdef __WIN32__ wxUint32 WinLang, WinSublang; #endif wxString Description; };

// wxLanguage id // Canonical name, e.g. fr_FR // Win32 language identifiers // (LANG_xxxx, SUBLANG_xxxx) // human-readable name of the language

Language should be greater than wxLANGUAGE_USER_DEFINED. wxPerl note: In wxPerl Wx::LanguageInfo has only one method: Wx::LanguageInfo->new( language, canonicalName, WinLang, WinSubLang, Description )

wxLocale::FindLanguageInfo
wxlocalefindlanguageinfo static wxLanguageInfo * FindLanguageInfo(const wxString& locale) const This function may be used to find the language description structure for the given locale, specified either as a two letter ISO language code (for example, "pt"), a language code followed by the country code ("pt_BR") or a full, human readable, language description ("Portuguese-Brazil"). Returns the information for the given language or NULL if this language is unknown. Note that even if the returned pointer is valid, the caller shouldnot delete it. See also GetLanguageInfo (p. 840)

wxLocale::GetCanonicalName
wxString GetSysName() const Returns the canonical form of current locale name. Canonical form is the one that is used on UNIX systems: it is a two- or five-letter string in xx or xx_YY format, where xx is ISO 639 code of language and YY is ISO 3166 code of the country. Examples are "en", "en_GB", "en_US" or "fr_FR". This form is internally used when looking up message catalogs. Compare GetSysName (p. 841).

839


CHAPTER 7 wxLocale::GetLanguage
int GetLanguage() const Returns wxLanguage (p. 829) constant of current language. Note that you can call this function only if you used the form ofInit (p. 842) that takes wxLanguage argument.

wxLocale::GetLanguageInfo
static wxLanguageInfo * GetLanguageInfo(int lang) const Returns a pointer to wxLanguageInfo structure containing information about the given language or NULL if this language is unknown. Note that even if the returned pointer is valid, the caller should not delete it. See AddLanguage (p. 838) for the wxLanguageInfo description.

wxLocale::GetLanguageName
static wxString GetLanguageName(int lang) const Returns English name of the given language or empty string if this language is unknown.

wxLocale::GetLocale
const char* GetLocale() const Returns the locale name as passed to the constructor or Init() (p. 842). This is full, human-readable name, e.g. "English" or "French".

wxLocale::GetName
const wxString& GetName() const Returns the current short name for the locale (as given to the constructor or the Init() function).

wxLocale::GetString
const char* GetString(const char *szOrigString, const char *szDomain = NULL) const const char* GetString(const char *szOrigString, const char *szOrigString2, size_t n, const char *szDomain = NULL) const Retrieves the translation for a string in all loaded domains unless the szDomain parameter is specified (and then only this catalog/domain is searched).

840


CHAPTER 7
Returns original string if translation is not available (in this case an error message is generated the first time a string is not found; use wxLogNull (p. 1595) to suppress it). The second form is used when retrieving translation of string that has different singular and plural form in English or different plural forms in some other language. It takes two extra arguments: szOrigStringparameter must contain the singular form of the string to be converted. It is also used as the key for the search in the catalog. The szOrigString2 parameter is the plural form (in English). The parameter n is used to determine the plural form. If no message catalog is found szOrigString is returned if 'n == 1', otherwise szOrigString2. See GNU gettext manual (http://www.gnu.org/manual/gettext/html_chapter/gettext_10.html#S EC150) for additional information on plural forms handling. Remarks Domains are searched in the last to first order, i.e. catalogs added later override those added before.

wxLocale::GetSysName
wxString GetSysName() const Returns current platform-specific locale name as passed to setlocale(). Compare GetCanonicalName (p. 839).

wxLocale::GetSystemEncoding
static wxFontEncoding GetSystemEncoding() const Tries to detect the user's default font encoding. Returns wxFontEncoding (p. 510) value or wxFONTENCODING_SYSTEM if it couldn't be determined.

wxLocale::GetSystemEncodingName
static wxString GetSystemEncodingName() const Tries to detect the name of the user's default font encoding. This string isn't particularly useful for the application as its form is platform-dependent and so you should probably use GetSystemEncoding (p. 841) instead. Returns a user-readable string value or an empty string if it couldn't be determined.

wxLocale::GetSystemLanguage
static int GetSystemLanguage() const Tries to detect the user's default language setting. Returns wxLanguage (p. 829) value

841


CHAPTER 7
or wxLANGUAGE_UNKNOWN if the language-guessing algorithm failed.

wxLocale::Init
bool Init(int language = wxLANGUAGE_DEFAULT, int flags = wxLOCALE_LOAD_DEFAULT | wxLOCALE_CONV_ENCODING) bool Init(const char *szName, const char *szShort = NULL, const char *szLocale = NULL, bool bLoadDefault = true, bool bConvertEncoding = false) The second form is deprecated, use the first one unless you know what you are doing. Parameters language wxLanguage (p. 829) identifier of the locale. wxLANGUAGE_DEFAULT has special meaning -- wxLocale will use system's default language (see GetSystemLanguage (p. 841)). flags Combination of the following: wxLOCALE_LOAD_DEFAULT Load the message catalog for the given locale containing the translations of standard wxWindows messages automatically. wxLOCALE_CONV_ENCODING Automatically convert message catalogs to platform's default encoding. Note that it will do only basic conversion between well-known pair like iso8859-1 and windows-1252 or iso8859-2 and windows-1250. See Writing non-English applications (p. 1590) for detailed description of this behaviour. Note that this flag is meaningless in Unicode build. szName The name of the locale. Only used in diagnostic messages. szShort The standard 2 letter locale abbreviation and is used as the directory prefix when looking for the message catalog files. szLocale The parameter for the call to setlocale(). Note that it is platform-specific. bLoadDefault May be set to false to prevent loading of the message catalog for the given locale

842


CHAPTER 7
containing the translations of standard wxWindows messages. This parameter would be rarely used in normal circumstances. bConvertEncoding May be set to true to do automatic conversion of message catalogs to platform's native encoding. Note that it will do only basic conversion between well-known pair like iso8859-1 and windows-1252 or iso8859-2 and windows-1250. See Writing non-English applications (p. 1590) for detailed description of this behaviour. The call of this function has several global side effects which you should understand: first of all, the application locale is changed - note that this will affect many of standard C library functions such as printf() or strftime(). Second, this wxLocale object becomes the new current global locale for the application and so all subsequent calls to wxGetTranslation() will try to translate the messages using the message catalogs for this locale. Returns true on success or false if the given locale couldn't be set.

wxLocale::IsLoaded
bool IsLoaded(const char* domain) const Check if the given catalog is loaded, and returns true if it is. According to GNU gettext tradition, each catalog normally corresponds to 'domain' which is more or less the application name. See also: AddCatalog (p. 838)

wxLocale::IsOk
bool IsOk() const Returns true if the locale could be set successfully.

wxLog
wxLog class defines the interface for the log targets used by wxWindows logging functions as explained in the wxLog overview (p. 1595). The only situations when you need to directly use this class is when you want to derive your own log target because the existing ones don't satisfy your needs. Another case is if you wish to customize the behaviour of the standard logging classes (all of which respect the wxLog settings): for example, set which trace messages are logged and which are not or change (or even remove completely) the timestamp on the messages. Otherwise, it is completely hidden behind the wxLogXXX() functions and you may not even know about its existence.

843


CHAPTER 7
See log overview (p. 1595) for the descriptions of wxWindows logging facilities. Derived from No base class Include files <wx/log.h>

Static functions
The functions in this section work with and manipulate the active log target. The OnLog() (p. 846) is called by the wxLogXXX() functions and invokes the DoLog() (p. 847) of the active log target if any. Get/Set methods are used to install/query the current active target and, finally, DontCreateOnDemand() (p. 848) disables the automatic creation of a standard log target if none actually exists. It is only useful when the application is terminating and shouldn't be used in other situations because it may easily lead to a loss of messages. OnLog (p. 846) GetActiveTarget (p. 847) SetActiveTarget (p. 847) DontCreateOnDemand (p. 848) Suspend (p. 847) Resume (p. 847)

Logging functions
There are two functions which must be implemented by any derived class to actually process the log messages: DoLog (p. 847) andDoLogString (p. 848). The second function receives a string which just has to be output in some way and the easiest way to write a new log target is to override just this function in the derived class. If more control over the output format is needed, then the first function must be overridden which allows to construct custom messages depending on the log level or even do completely different things depending on the message severity (for example, throw away all messages except warnings and errors, show warnings on the screen and forward the error messages to the user's (or programmer's) cell phone - maybe depending on whether the timestamp tells us if it is day or night in the current time zone). There also functions to support message buffering. Why are they needed? Some of wxLog implementations, most notably the standard wxLogGui class, buffer the messages (for example, to avoid showing the user a zillion of modal message boxes one after another -- which would be really annoying).Flush() (p. 848) shows them all and clears the buffer contents. This function doesn't do anything if the buffer is already empty. Flush (p. 848)

844


CHAPTER 7
FlushActive (p. 848)

Customization
The functions below allow some limited customization of wxLog behaviour without writing a new log target class (which, aside of being a matter of several minutes, allows you to do anything you want). The verbose messages are the trace messages which are not disabled in the release mode and are generated by wxLogVerbose (p. 1522). They are not normally shown to the user because they present little interest, but may be activated, for example, in order to help the user find some program problem. As for the (real) trace messages, their handling depends on the settings of the (application global) trace mask. There are two ways to specify it: either by using SetTraceMask (p. 849) andGetTraceMask (p. 849) and usingwxLogTrace (p. 1523) which takes an integer mask or by usingAddTraceMask (p. 846) for string trace masks. The difference between bit-wise and string trace masks is that a message using integer trace mask will only be logged if all bits of the mask are set in the current mask while a message using string mask will be logged simply if the mask had been added before to the list of allowed ones. For example,
// wxTraceOleCalls is one of standard bit masks wxLogTrace(wxTraceRefCount | wxTraceOleCalls, "Active object ref count: %d", nRef);

will do something only if the current trace mask contains bothwxTraceRefCount and wxTraceOle, but
// wxTRACE_OleCalls is one of standard string masks wxLogTrace(wxTRACE_OleCalls, "IFoo::Bar() called");

will log the message if it was preceded by
wxLog::AddTraceMask(wxTRACE_OleCalls);

Using string masks is simpler and allows to easily add custom ones, so this is the preferred way of working with trace messages. The integer trace mask is kept for compatibility and for additional (but very rarely needed) flexibility only. The standard trace masks are given in wxLogTrace (p. 1523)documentation. Finally, the wxLog::DoLog() function automatically prepends a time stamp to all the messages. The format of the time stamp may be changed: it can be any string with % specifications fully described in the documentation of the standard strftime() function. For example, the default format is "[%d/%b/%y %H:%M:%S] " which gives something like "[17/Sep/98 22:10:16] " (without quotes) for the current date. Setting an empty string as the time format disables timestamping of the messages completely. NB: Timestamping is disabled for Visual C++ users in debug builds by default because

845


CHAPTER 7
otherwise it would be impossible to directly go to the line from which the log message was generated by simply clicking in the debugger window on the corresponding error message. If you wish to enable it, please useSetTimestamp (p. 849) explicitly. AddTraceMask (p. 846) RemoveTraceMask (p. 850) ClearTraceMasks (p. 846) GetTraceMasks (p. 846) IsAllowedTraceMask (p. 850) SetVerbose (p. 848) GetVerbose (p. 849) SetTimestamp (p. 849) GetTimestamp (p. 849) SetTraceMask (p. 849) GetTraceMask (p. 849)

wxLog::AddTraceMask
static void AddTraceMask(const wxString& mask) Add the mask to the list of allowed masks forwxLogTrace (p. 1523). See also RemoveTraceMask (p. 850)GetTraceMasks (p. 846)

wxLog::ClearTraceMasks
static void ClearTraceMasks() Removes all trace masks previously set withAddTraceMask (p. 846). See also RemoveTraceMask (p. 850)

wxLog::GetTraceMasks
static const wxArrayString & GetTraceMasks() Returns the currently allowed list of string trace masks. See also AddTraceMask (p. 846).

wxLog::OnLog 846


CHAPTER 7
static void OnLog(wxLogLevel level, const char * message) Forwards the message at specified level to the DoLog() function of the active log target if there is any, does nothing otherwise.

wxLog::GetActiveTarget
static wxLog * GetActiveTarget() Returns the pointer to the active log target (may be NULL).

wxLog::SetActiveTarget
static wxLog * SetActiveTarget(wxLog * logtarget) Sets the specified log target as the active one. Returns the pointer to the previous active log target (may be NULL).

wxLog::Suspend
static void Suspend() Suspends the logging until Resume (p. 847) is called. Note that the latter must be called the same number of times as the former to undo it, i.e. if you call Suspend() twice you must call Resume() twice as well. Note that suspending the logging means that the log sink won't be be flushed periodically, it doesn't have any effect if the current log target does the logging immediately without waiting for Flush (p. 848) to be called (the standard GUI log target only shows the log dialog when it is flushed, so Suspend() works as expected with it). See also Resume (p. 847), wxLogNull (p. 1595)

wxLog::Resume
static void Resume() Resumes logging previously suspended by a call toSuspend (p. 847). All messages logged in the meanwhile will be flushed soon.

wxLog::DoLog
virtual void DoLog(wxLogLevel level, const wxChar *msg, time_t timestamp)

847


CHAPTER 7
Called to process the message of the specified severity. msg is the text of the message as specified in the call of wxLogXXX() function which generated it and timestamp is the moment when the message was generated. The base class version prepends the timestamp to the message, adds a prefix corresponding to the log level and then callsDoLogString (p. 848) with the resulting string.

wxLog::DoLogString
virtual void DoLogString(const wxChar *msg, time_t timestamp) Called to log the specified string. The timestamp is already included into the string but still passed to this function. A simple implementation may just send the string to stdout or, better,stderr.

wxLog::DontCreateOnDemand
static void DontCreateOnDemand() Instructs wxLog to not create new log targets on the fly if there is none currently. (Almost) for internal use only: it is supposed to be called by the application shutdown code. Note that this function also callsClearTraceMasks (p. 846).

wxLog::Flush
virtual void Flush() Shows all the messages currently in buffer and clears it. If the buffer is already empty, nothing happens.

wxLog::FlushActive
static void FlushActive() Flushes the current log target if any, does nothing if there is none. See also: Flush (p. 848)

wxLog::SetVerbose
static void SetVerbose(bool verbose = true)

848


CHAPTER 7
Activates or deactivates verbose mode in which the verbose messages are logged as the normal ones instead of being silently dropped.

wxLog::GetVerbose
static bool GetVerbose() Returns whether the verbose mode is currently active.

wxLog::SetLogLevel
static void SetLogLevel(wxLogLevel logLevel) Specifies that log messages with level > logLevel should be ignored and not sent to the active log target.

wxLog::GetLogLevel
static wxLogLevel GetLogLevel() Returns the current log level limit.

wxLog::SetTimestamp
void SetTimestamp(const char * format) Sets the timestamp format prepended by the default log targets to all messages. The string may contain any normal characters as well as %prefixed format specificators, see strftime() manual for details. Passing a NULL value (not empty string) to this function disables message timestamping.

wxLog::GetTimestamp
const char * GetTimestamp() const Returns the current timestamp format string.

wxLog::SetTraceMask
static void SetTraceMask(wxTraceMask mask) Sets the trace mask, see Customization (p. 845)section for details.

wxLog::GetTraceMask

849


CHAPTER 7
Returns the current trace mask, see Customization (p. 845) section for details.

wxLog::IsAllowedTraceMask
static bool IsAllowedTraceMask(const wxChar *mask) Returns true if the mask is one of allowed masks forwxLogTrace (p. 1523). See also: AddTraceMask (p. 846),RemoveTraceMask (p. 850)

wxLog::RemoveTraceMask
static void RemoveTraceMask(const wxString& mask) Remove the mask from the list of allowed masks forwxLogTrace (p. 1523). See also: AddTraceMask (p. 846)

wxLogChain
This simple class allows to chain log sinks, that is to install a new sink but keep passing log messages to the old one instead of replacing it completely asSetActiveTarget (p. 847) does. It is especially useful when you want to divert the logs somewhere (for example to a file or a log window) but also keep showing the error messages using the standard dialogs as wxLogGui (p. 1595) does by default. Example of usage:
wxLogChain *logChain = new wxLogChain(new wxLogStderr); // all the log messages are sent to stderr and also processed as usually ... // don't delete logChain directly as this would leave a dangling // pointer as active log target, use SetActiveTarget() instead delete wxLog::SetActiveTarget(...something else or NULL...);

Derived from wxLog (p. 843) Include files <wx/log.h>

wxLogChain::wxLogChain 850


CHAPTER 7
wxLogChain(wxLog *logger) Sets the specified logger (which may be NULL) as the default log target but the log messages are also passed to the previous log target if any.

wxLogChain::~wxLogChain
~wxLogChain() Destroys the previous log target.

wxLogChain::GetOldLog
wxLog * GetOldLog() const Returns the pointer to the previously active log target (which may be NULL).

wxLogChain::IsPassingMessages
bool IsPassingMessages() const Returns true if the messages are passed to the previously active log target (default) or false if PassMessages (p. 851)had been called.

wxLogChain::PassMessages
void PassMessages(bool passMessages) By default, the log messages are passed to the previously active log target. Calling this function with false parameter disables this behaviour (presumably temporarily, as you shouldn't use wxLogChain at all otherwise) and it can be reenabled by calling it again with passMessages set to true.

wxLogChain::SetLog
void SetLog(wxLog *logger) Sets another log target to use (may be NULL). The log target specified in the constructor (p. 850) or in a previous call to this function is deleted. This doesn't change the old log target value (the one the messages are forwarded to) which still remains the same as was active when wxLogChain object was created.

wxLogGui

851


CHAPTER 7
This is the default log target for the GUI wxWindows applications. It is passed to wxLog::SetActiveTarget (p. 847) at the program startup and is deleted by wxWindows during the program shut down. Derived from wxLog (p. 843) Include files <wx/log.h>

wxLogGui::wxLogGui
wxLogGui() Default constructor.

wxLogNull
This class allows to temporarily suspend logging. All calls to the log functions during the life time of an object of this class are just ignored. In particular, it can be used to suppress the log messages given by wxWindows itself but it should be noted that it is rarely the best way to cope with this problem as all log messages are suppressed, even if they indicate a completely different error than the one the programmer wanted to suppress. For instance, the example of the overview:
wxFile file; // wxFile.Open() normally complains if file can't be opened, we don't want it { wxLogNull logNo; if ( !file.Open("bar") ) ... process error ourselves ... } // ~wxLogNull called, old log sink restored wxLogMessage("..."); // ok

would be better written as:
wxFile file; // don't try to open file if it doesn't exist, we are prepared to deal with // this ourselves - but all other errors are not expected if ( wxFile::Exists("bar") ) { // gives an error message if the file couldn't be opened file.Open("bar"); }

852


CHAPTER 7
else { ... }

Derived from wxLog (p. 843) Include files <wx/log.h>

wxLogNull::wxLogNull
wxLogNull() Suspends logging.

wxLogNull::~wxLogNull
Resumes logging.

wxLogPassThrough
A special version of wxLogChain (p. 850) which uses itself as the new log target. Maybe more clearly, it means that this is a log target which forwards the log messages to the previously installed one in addition to processing them itself. Unlike wxLogChain (p. 850) which is usually used directly as is, this class must be derived from to implement DoLog (p. 847)and/or DoLogString (p. 848) methods. Derived from wxLogChain (p. 850) Include files <wx/log.h>

wxLogPassThrough::wxLogPassThrough
Default ctor installs this object as the current active log target.

853


CHAPTER 7

wxLogStderr
This class can be used to redirect the log messages to a C file stream (not to be confused with C++ streams). It is the default log target for the non-GUI wxWindows applications which send all the output to stderr. Derived from wxLog (p. 843) Include files <wx/log.h> See also wxLogStream (p. 854)

wxLogStderr::wxLogStderr
wxLogStderr(FILE *fp = NULL) Constructs a log target which sends all the log messages to the givenFILE. If it is NULL, the messages are sent to stderr.

wxLogStream
This class can be used to redirect the log messages to a C++ stream. Please note that this class is only available if wxWindows was compiled with the standard iostream library support (wxUSE_STD_IOSTREAM must be on). Derived from wxLog (p. 843) Include files <wx/log.h> See also wxLogStderr (p. 854), wxStreamToTextRedirector (p. 1198)

wxLogStream::wxLogStream 854


CHAPTER 7
wxLogStream(std::ostream *ostr = NULL) Constructs a log target which sends all the log messages to the given output stream. If it is NULL, the messages are sent to cerr.

wxLogTextCtrl
Using these target all the log messages can be redirected to a text control. The text control must have been created with wxTE_MULTILINE style by the caller previously. Derived from wxLog (p. 843) Include files <wx/log.h> See also wxLogTextCtrl (p. 855), wxStreamToTextRedirector (p. 1198)

wxLogTextCtrl::wxLogTextCtrl
wxLogTextCtrl(wxTextCtrl *textctrl) Constructs a log target which sends all the log messages to the given text control. The textctrl parameter cannot be NULL.

wxLogWindow
This class represents a background log window: to be precise, it collects all log messages in the log frame which it manages but also passes them on to the log target which was active at the moment of its creation. This allows, for example, to show all the log messages in a frame but still continue to process them normally by showing the standard log dialog. Derived from wxLogPassThrough (p. 853) Include files <wx/log.h> See also

855


CHAPTER 7
wxLogTextCtrl (p. 855)

wxLogWindow::wxLogWindow
wxLogWindow(wxFrame *parent, const wxChar *title, bool show = true, bool passToOld = true) Creates the log frame window and starts collecting the messages in it. Parameters parent The parent window for the log frame, may be NULL ti tl e The title for the log frame show true to show the frame initially (default), otherwisewxLogWindow::Show (p. 856) must be called later. passToOld true to process the log messages normally in addition to logging them in the log frame (default), false to only log them in the log frame.

wxLogWindow::Show
void Show(bool show = true) Shows or hides the frame.

wxLogWindow::GetFrame
wxFrame * GetFrame() const Returns the associated log frame window. This may be used to position or resize it but use wxLogWindow::Show (p. 856) to show or hide it.

wxLogWindow::OnFrameCreate
virtual void OnFrameCreate(wxFrame *frame) Called immediately after the log frame creation allowing for any extra initializations.

856


CHAPTER 7 wxLogWindow::OnFrameClose
virtual void OnFrameClose(wxFrame *frame) Called if the user closes the window interactively, will not be called if it is destroyed for another reason (such as when program exits). Return true from here to allow the frame to close, false to prevent this from happening. See also wxLogWindow::OnFrameDelete (p. 857)

wxLogWindow::OnFrameDelete
virtual void OnFrameDelete(wxFrame *frame) Called right before the log frame is going to be deleted: will always be called unlike OnFrameClose() (p. 857).

wxLongLong
This class represents a signed 64 bit long number. It is implemented using the native 64 bit type where available (machines with 64 bit longs or compilers which have (an analog of) long long type) and uses the emulation code in the other cases which ensures that it is the most efficient solution for working with 64 bit integers independently of the architecture. wxLongLong defines all usual arithmetic operations such as addition, subtraction, bitwise shifts and logical operations as well as multiplication and division (not yet for the machines without native long long). It also has operators for implicit construction from and conversion to the native long long type if it exists and long. You would usually use this type in exactly the same manner as any other (built-in) arithmetic type. Note that wxLongLong is a signed type, if you want unsigned values use wxULongLong which has exactly the same API as wxLongLong except when explicitly mentioned otherwise. If a native (i.e. supported directly by the compiler) 64 bit integer type was found to exist, wxLongLong_t macro will be defined to correspond to it. Also, in this case only, two additional macros will be defined: wxLongLongFmtSpec (p. 1507) for printing 64 bit integers using the standard printf() function (but see also ToString() (p. 859) for a more portable solution) andwxLL (p. 1506) for defining 64 bit integer compile-time constants. Derived from No base class Include files

857


CHAPTER 7
<wx/longlong.h>

wxLongLong::wxLongLong
wxLongLong() Default constructor initializes the object to 0.

wxLongLong::wxLongLong
wxLongLong(wxLongLong_t ll) Constructor from native long long (only for compilers supporting it).

wxLongLong::wxLongLong
wxLongLong(long hi, unsigned long lo) Constructor from 2 longs: the high and low part are combined into one wxLongLong.

wxLongLong::operator=
wxLongLong& operator operator=(wxLongLong_t ll) Assignment operator from native long long (only for compilers supporting it).

wxLongLong::Abs
wxLongLong Abs() const wxLongLong& Abs() Returns an absolute value of wxLongLong - either making a copy (const version) or modifying it in place (the second one). Not in wxULongLong.

wxLongLong::Assign
wxLongLong& Assign(double d) This allows to convert a double value to wxLongLong type. Such conversion is not always possible in which case the result will be silently truncated in a platformdependent way. Not in wxULongLong.

858


CHAPTER 7 wxLongLong::GetHi
long GetHi() const Returns the high 32 bits of 64 bit integer.

wxLongLong::GetLo
unsigned long GetLo() const Returns the low 32 bits of 64 bit integer.

wxLongLong::GetValue
wxLongLong_t GetValue() const Convert to native long long (only for compilers supporting it)

wxLongLong::ToLong
long ToLong() const Truncate wxLongLong to long. If the conversion loses data (i.e. the wxLongLong value is outside the range of built-in long type), an assert will be triggered in debug mode.

wxLongLong::ToString
wxString ToString() const Returns the string representation of a wxLongLong.

wxLongLong::operator+
wxLongLong operator+(const wxLongLong& ll) const Adds 2 wxLongLongs together and returns the result.

wxLongLong::operator+=
wxLongLong& operator+(const wxLongLong& ll) Add another wxLongLong to this one.

wxLongLong::operator++

859


CHAPTER 7
wxLongLong& operator++() wxLongLong& operator++(int) Pre/post increment operator.

wxLongLong::operatorwxLongLong operator-() const Returns the value of this wxLongLong with opposite sign. Not in wxULongLong.

wxLongLong::operatorwxLongLong operator-(const wxLongLong& ll) const Substracts 2 wxLongLongs and returns the result.

wxLongLong::operator-=
wxLongLong& operator-(const wxLongLong& ll) Substracts another wxLongLong from this one.

wxLongLong::operator-wxLongLong& operator--() wxLongLong& operator--(int) Pre/post decrement operator.

wxMask
This class encapsulates a monochrome mask bitmap, where the masked area is black and the unmasked area is white. When associated with a bitmap and drawn in a device context, the unmasked area of the bitmap will be drawn, and the masked area will not be drawn. Derived from wxObject (p. 954) Include files <wx/bitmap.h> Remarks

860


CHAPTER 7
A mask may be associated with a wxBitmap (p. 67). It is used in wxDC::Blit (p. 348) when the source device context is a wxMemoryDC (p. 881) with wxBitmap selected into it that contains a mask. See also wxBitmap (p. 67), wxDC::Blit (p. 348), wxMemoryDC (p. 881)

wxMask::wxMask
wxMask() Default constructor. wxMask(const wxBitmap (p. 67)& bitmap) Constructs a mask from a monochrome bitmap. wxPython note: This is the default constructor for wxMask in wxPython. wxMask(const wxBitmap (p. 67)& bitmap, const wxColour (p. 150)& colour) Constructs a mask from a bitmap and a colour that indicates the background. wxPython note: wxPython has an alternate wxMask constructor matching this form called wxMaskColour. wxMask(const wxBitmap& bitmap, int index) Constructs a mask from a bitmap and a palette index that indicates the background. Not yet implemented for GTK. Parameters bitmap A valid bitmap. colour A colour specifying the transparency RGB values. index Index into a palette, specifying the transparency colour.

wxMask::~wxMask
~wxMask() Destroys the wxMask object and the underlying bitmap data.

861


CHAPTER 7 wxMask::Create
bool Create(const wxBitmap& bitmap) Constructs a mask from a monochrome bitmap. bool Create(const wxBitmap& bitmap, const wxColour& colour) Constructs a mask from a bitmap and a colour that indicates the background. bool Create(const wxBitmap& bitmap, int index) Constructs a mask from a bitmap and a palette index that indicates the background. Not yet implemented for GTK. Parameters bitmap A valid bitmap. colour A colour specifying the transparency RGB values. index Index into a palette, specifying the transparency colour.

wxMaximizeEvent
An event being sent when the frame is maximized (minimized) or restored. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a maximize event, use this event handler macro to direct input to a member function that takes a wxMaximizeEvent argument. EVT_MAXIMIZE(func) Process a wxEVT_MAXIMIZE event.

See also Event handling overview (p. 1602), wxFrame::Maximize (p. 537), wxFrame::IsMaximized (p. 537)

862


CHAPTER 7 wxMaximizeEvent::wxMaximizeEvent
wxMaximizeEvent(int id = 0) Constructor.

wxMBConv
This class is the base class of a hierarchy of classes capable of converting text strings between multibyte (SBCS or DBCS) encodings and Unicode. It is itself a wrapper around the standard libc mbstowcs() and wcstombs() routines, and has one predefined instance, wxConvLibc. Derived from No base class Include files <wx/strconv.h> See also wxCSConv (p. 208), wxEncodingConverter (p. 435), wxMBConv classes overview (p. 1586)

wxMBConv::wxMBConv
wxMBConv() Constructor.

wxMBConv::MB2WC
virtual size_t MB2WC(wchar_t* buf, const char* psz, size_t n) const Converts from a string psz in multibyte encoding to Unicode putting the output into the buffer buf of the size n (in wide characters, not bytes). If buf is NULL, nothing is written to it but the length of the string which would result from the conversion is calculated and returned. Note that this is the length and not size, i.e. the returned value does not include the trailing NUL. But when the function is called with a non-NULL buffer, the n parameter should be the size of the buffer and so it should take into account the trailing NUL. Parameters buf

863


CHAPTER 7
the output buffer, may be NULL if the caller is only interested in the length of the resulting string psz the NUL-terminated input string, cannot be NULL n the size of the output buffer, ignored if buf is NULL Return value The length of the converted string.

wxMBConv::WC2MB
virtual size_t WC2MB(char* buf, const wchar_t* psz, size_t n) const Converts from Unicode to multibyte encoding. The semantics of this function (including the return value meaning) is the same as for MB2WC (p. 863). Notice that when the function is called with a non-NULL buffer, the n parameter should be the size of the buffer and so it should take into account the trailing NUL, which might take two or four bytes for some encodings (UTF-16 and UTF-32).

wxMBConv::cMB2WC
const wxWCharBuffer cMB2WC(const char* psz) const Converts from multibyte encoding to Unicode by calling MB2WC, allocating a temporary wxWCharBuffer to hold the result.

wxMBConv::cWC2MB
const wxCharBuffer cWC2MB(const wchar_t* psz) const Converts from Unicode to multibyte encoding by calling WC2MB, allocating a temporary wxCharBuffer to hold the result.

wxMBConv::cMB2WX
const char* cMB2WX(const char* psz) const const wxWCharBuffer cMB2WX(const char* psz) const Converts from multibyte encoding to the current wxChar type (which depends on whether wxUSE_UNICODE is set to 1). If wxChar is char, it returns the parameter unaltered. If wxChar is wchar_t, it returns the result in a wxWCharBuffer. The macro

864


CHAPTER 7
wxMB2WXbuf is defined as the correct return type (without const).

wxMBConv::cWX2MB
const char* cWX2MB(const wxChar* psz) const const wxCharBuffer cWX2MB(const wxChar* psz) const Converts from the current wxChar type to multibyte encoding. If wxChar is char, it returns the parameter unaltered. If wxChar is wchar_t, it returns the result in a wxCharBuffer. The macro wxWX2MBbuf is defined as the correct return type (without const).

wxMBConv::cWC2WX
const wchar_t* cWC2WX(const wchar_t* psz) const const wxCharBuffer cWC2WX(const wchar_t* psz) const Converts from Unicode to the current wxChar type. If wxChar is wchar_t, it returns the parameter unaltered. If wxChar is char, it returns the result in a wxCharBuffer. The macro wxWC2WXbuf is defined as the correct return type (without const).

wxMBConv::cWX2WC
const wchar_t* cWX2WC(const wxChar* psz) const const wxWCharBuffer cWX2WC(const wxChar* psz) const Converts from the current wxChar type to Unicode. If wxChar is wchar_t, it returns the parameter unaltered. If wxChar is char, it returns the result in a wxWCharBuffer. The macro wxWX2WCbuf is defined as the correct return type (without const).

wxMBConvFile
This class converts file names between filesystem multibyte encoding and Unicode. It has one predefined instance, wxConvFile. Since some platforms (e.g. Win32) use Unicode in the filenames, and others (e.g. Unix) use multibyte encodings, this class should only be used directly if wxMBFILES is defined to 1. A convenience macro, wxFNCONV, is defined to wxConvFile.cWX2MB in this case. You could use it like this:
wxChar *name = wxT("rawfile.doc"); FILE *fil = fopen(wxFNCONV(name), "r");

(although it would be better to use wxFopen(name, wxT("r")) in this case.) Derived from wxMBConv (p. 863)

865


CHAPTER 7
Include files <wx/strconv.h> See also wxMBConv classes overview (p. 1586)

wxMBConvFile::MB2WC
size_t MB2WC(wchar_t* buf, const char* psz, size_t n) const Converts from multibyte filename encoding to Unicode. Returns the size of the destination buffer.

wxMBConvFile::WC2MB
size_t WC2MB(char* buf, const wchar_t* psz, size_t n) const Converts from Unicode to multibyte filename encoding. Returns the size of the destination buffer.

wxMBConvUTF7
This class converts between the UTF-7 encoding and Unicode. It has one predefined instance, wxConvUTF7. WARNING: this class is not implemented yet. Derived from wxMBConv (p. 863) Include files <wx/strconv.h> See also wxMBConvUTF8 (p. 867), wxMBConv classes overview (p. 1586)

wxMBConvUTF7::MB2WC
size_t MB2WC(wchar_t* buf, const char* psz, size_t n) const

866


CHAPTER 7
Converts from UTF-7 encoding to Unicode. Returns the size of the destination buffer.

wxMBConvUTF7::WC2MB
size_t WC2MB(char* buf, const wchar_t* psz, size_t n) const Converts from Unicode to UTF-7 encoding. Returns the size of the destination buffer.

wxMBConvUTF8
This class converts between the UTF-8 encoding and Unicode. It has one predefined instance, wxConvUTF8. Derived from wxMBConv (p. 863) Include files <wx/strconv.h> See also wxMBConvUTF7 (p. 866), wxMBConv classes overview (p. 1586) Remarks UTF-8 is a compatibility encoding used to encode Unicode text into anything that was originally written for 8-bit strings, including (but not limited to) filenames, transfer protocols, and database fields. Notable properties include:      Variable-length encoding able to encode up to 31 bits per character ASCII characters (character values under 128) are encoded as plain ASCII (1 byte per character) Null bytes do not occur in the encoding, except when there's an actual Unicode null character Preserves sort ordering for plain 8-bit comparison routines like strcmp() High bit patterns disambiguates character boundaries, and makes it easy to detect whether a string is encoded with UTF-8 or not

All of these properties make UTF-8 a very favorable solution in any situation where full Unicode character support is desired while remaining compatible with code written with only 8-bit extended-ASCII characters in mind.

867


CHAPTER 7 wxMBConvUTF8::MB2WC
size_t MB2WC(wchar_t* buf, const char* psz, size_t n) const Converts from UTF-8 encoding to Unicode. Returns the size of the destination buffer.

wxMBConvUTF8::WC2MB
size_t WC2MB(char* buf, const wchar_t* psz, size_t n) const Converts from Unicode to UTF-8 encoding. Returns the size of the destination buffer.

wxMBConvUTF16
This class is used to convert between multibyte encodings and UTF-16 Unicode encoding (also known as UCS-2). Unlike UTF-8 (p. 867) encoding, UTF-16 uses words and not bytes and hence depends on the byte ordering: big or little endian. Hence this class is provided in two versions: wxMBConvUTF16LE and wxMBConvUTF16BE and wxMBConvUTF16 itself is just a typedef for one of them (native for the given platform, e.g. LE under Windows and BE under Mac). Derived from wxMBConv (p. 863) Include files <wx/strconv.h> See also wxMBConvUTF8 (p. 867), wxMBConvUTF32 (p. 869), wxMBConv classes overview (p. 1586)

wxMBConvUTF16::MB2WC
size_t MB2WC(wchar_t* buf, const char* psz, size_t n) const Converts from UTF-16 encoding to Unicode. Returns the size of the destination buffer.

wxMBConvUTF16::WC2MB
size_t WC2MB(char* buf, const wchar_t* psz, size_t n) const Converts from Unicode to UTF-16 encoding. Returns the size of the destination buffer.

868


CHAPTER 7

wxMBConvUTF32
This class is used to convert between multibyte encodings and UTF-32 Unicode encoding (also known as UCS-4). Unlike UTF-8 (p. 867) encoding, UTF-32 uses (double) words and not bytes and hence depends on the byte ordering: big or little endian. Hence this class is provided in two versions: wxMBConvUTF32LE and wxMBConvUTF32BE and wxMBConvUTF32 itself is just a typedef for one of them (native for the given platform, e.g. LE under Windows and BE under Mac). Derived from wxMBConv (p. 863) Include files <wx/strconv.h> See also wxMBConvUTF8 (p. 867), wxMBConvUTF16 (p. 868), wxMBConv classes overview (p. 1586)

wxMBConvUTF32::MB2WC
size_t MB2WC(wchar_t* buf, const char* psz, size_t n) const Converts from UTF-32 encoding to Unicode. Returns the size of the destination buffer.

wxMBConvUTF32::WC2MB
size_t WC2MB(char* buf, const wchar_t* psz, size_t n) const Converts from Unicode to UTF-32 encoding. Returns the size of the destination buffer.

wxMDIChildFrame
An MDI child frame is a frame that can only exist on a wxMDIClientWindow (p. 872), which is itself a child of wxMDIParentFrame (p. 874). Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files

869


CHAPTER 7
<wx/mdi.h> Window styles wxCAPTION Puts a caption on the frame.

wxDEFAULT_FRAME_STYLE Defined as wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxTHICK_FRAME | wxSYSTEM_MENU | wxCAPTION. wxICONIZE wxMAXIMIZE wxMAXIMIZE_BOX wxMINIMIZE wxMINIMIZE_BOX wxRESIZE_BORDER wxSTAY_ON_TOP wxSYSTEM_MENU wxTHICK_FRAME Display the frame iconized (minimized) (Windows only). Displays the frame maximized (Windows only). Displays a maximize box on the frame (Windows and Motif only). Identical to wxICONIZE. Displays a minimize box on the frame (Windows and Motif only). Displays a resizeable border around the window (Motif only; for Windows, it is implicit in wxTHICK_FRAME). Stay on top of other windows (Windows only). Displays a system menu (Windows and Motif only). Displays a thick frame around the window (Windows and Motif only).

See also window styles overview (p. 1611). Remarks Although internally an MDI child frame is a child of the MDI client window, in wxWindows you create it as a child of wxMDIParentFrame (p. 874). You can usually forget that the client window exists. MDI child frames are clipped to the area of the MDI client window, and may be iconized on the client window. You can associate a menubar with a child frame as usual, although an MDI child doesn't display its menubar under its own title bar. The MDI parent frame's menubar will be changed to reflect the currently active child frame. If there are currently no children, the parent frame's own menubar will be displayed. See also wxMDIClientWindow (p. 872), wxMDIParentFrame (p. 874), wxFrame (p. 530)

870


CHAPTER 7 wxMDIChildFrame::wxMDIChildFrame
wxMDIChildFrame() Default constructor. wxMDIChildFrame(wxMDIParentFrame* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor, creating the window. Parameters parent The window parent. This should not be NULL. id The window identifier. It may take a value of -1 to indicate a default value. title The caption to be displayed on the frame's title bar. pos The window position. A value of (-1, -1) indicates a default position, chosen by either the windowing system or wxWindows, depending on platform. size The window size. A value of (-1, -1) indicates a default size, chosen by either the windowing system or wxWindows, depending on platform. style The window style. See wxMDIChildFrame (p. 869). name The name of the window. This parameter is used to associate a name with the item, allowing the application user to set Motif resource values for individual windows. Remarks None. See also wxMDIChildFrame::Create (p. 872)

871


CHAPTER 7 wxMDIChildFrame::~wxMDIChildFrame
~wxMDIChildFrame() Destructor. Destroys all child windows and menu bar if present.

wxMDIChildFrame::Activate
void Activate() Activates this MDI child frame. See also wxMDIChildFrame::Maximize (p. 872), wxMDIChildFrame::Restore (p. 872)

wxMDIChildFrame::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Used in two-step frame construction. See wxMDIChildFrame::wxMDIChildFrame (p. 871) for further details.

wxMDIChildFrame::Maximize
void Maximize() Maximizes this MDI child frame. See also wxMDIChildFrame::Activate (p. 872), wxMDIChildFrame::Restore (p. 872)

wxMDIChildFrame::Restore
void Restore() Restores this MDI child frame (unmaximizes). See also wxMDIChildFrame::Activate (p. 872), wxMDIChildFrame::Maximize (p. 872)

wxMDIClientWindow

872


CHAPTER 7
An MDI client window is a child of wxMDIParentFrame (p. 874), and manages zero or more wxMDIChildFrame (p. 869) objects. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/mdi.h> Remarks The client window is the area where MDI child windows exist. It doesn't have to cover the whole parent frame; other windows such as toolbars and a help window might coexist with it. There can be scrollbars on a client window, which are controlled by the parent window style. The wxMDIClientWindow class is usually adequate without further derivation, and it is created automatically when the MDI parent frame is created. If the application needs to derive a new class, the function wxMDIParentFrame::OnCreateClient (p. 879) must be overridden in order to give an opportunity to use a different class of client window. Under Windows 95, the client window will automatically have a sunken border style when the active child is not maximized, and no border style when a child is maximized. See also wxMDIChildFrame (p. 869), wxMDIParentFrame (p. 874), wxFrame (p. 530)

wxMDIClientWindow::wxMDIClientWindow
wxMDIClientWindow() Default constructor. wxMDIClientWindow(wxMDIParentFrame* parent, long style = 0) Constructor, creating the window. Parameters parent The window parent. style The window style. Currently unused.

873


CHAPTER 7
Remarks The second style of constructor is called within wxMDIParentFrame::OnCreateClient (p. 879). See also wxMDIParentFrame::wxMDIParentFrame (p. 876), wxMDIParentFrame::OnCreateClient (p. 879)

wxMDIClientWindow::~wxMDIClientWindow
~wxMDIClientWindow() Destructor.

wxMDIClientWindow::CreateClient
bool CreateClient(wxMDIParentFrame* parent, long style = 0) Used in two-step frame construction. See wxMDIClientWindow::wxMDIClientWindow (p. 873) for further details.

wxMDIParentFrame
An MDI (Multiple Document Interface) parent frame is a window which can contain MDI child frames in its own 'desktop'. It is a convenient way to avoid window clutter, and is used in many popular Windows applications, such as Microsoft Word(TM). Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/mdi.h> Remarks There may be multiple MDI parent frames in a single application, but this probably only makes sense within programming development environments. Child frames may be of class wxMDIChildFrame (p. 869) (contained within the parent frame) or wxFrame (p. 530) (shown as a top-level frame). An MDI parent frame always has a wxMDIClientWindow (p. 872) associated with it, which is the parent for MDI client frames. This client window may be resized to

874


CHAPTER 7
accommodate non-MDI windows, as seen in Microsoft Visual C++ (TM) and Microsoft Publisher (TM), where a documentation window is placed to one side of the workspace. MDI remains popular despite dire warnings from Microsoft itself that MDI is an obsolete user interface style. The implementation is native in Windows, and simulated under Motif. Under Motif, the child window frames will often have a different appearance from other frames because the window decorations are simulated. Window styles wxCAPTION Puts a caption on the frame.

wxDEFAULT_FRAME_STYLE Defined as wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxTHICK_FRAME | wxSYSTEM_MENU | wxCAPTION. wxHSCROLL Displays a horizontal scrollbar in the client window, allowing the user to view child frames that are off the current view. Display the frame iconized (minimized) (Windows only). Displays the frame maximized (Windows only). Displays a maximize box on the frame (Windows and Motif only). Identical to wxICONIZE. Displays a minimize box on the frame (Windows and Motif only). Displays a resizeable border around the window (Motif only; for Windows, it is implicit in wxTHICK_FRAME). Stay on top of other windows (Windows only). Displays a system menu (Windows and Motif only). Displays a thick frame around the window (Windows and Motif only). Displays a vertical scrollbar in the client window, allowing the user to view child frames that are off the current view.

wxICONIZE wxMAXIMIZE wxMAXIMIZE_BOX wxMINIMIZE wxMINIMIZE_BOX wxRESIZE_BORDER wxSTAY_ON_TOP wxSYSTEM_MENU wxTHICK_FRAME wxVSCROLL

wxFRAME_NO_WINDOW_MENU Under Windows, removes the Window menu that is normally added automatically. See also window styles overview (p. 1611). See also wxMDIChildFrame (p. 869), wxMDIClientWindow (p. 872), wxFrame (p. 530), wxDialog

875


CHAPTER 7
(p. 367)

wxMDIParentFrame::wxMDIParentFrame
wxMDIParentFrame() Default constructor. wxMDIParentFrame(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE | wxVSCROLL | wxHSCROLL, const wxString& name = "frame") Constructor, creating the window. Parameters parent The window parent. This should be NULL. id The window identifier. It may take a value of -1 to indicate a default value. title The caption to be displayed on the frame's title bar. pos The window position. A value of (-1, -1) indicates a default position, chosen by either the windowing system or wxWindows, depending on platform. size The window size. A value of (-1, -1) indicates a default size, chosen by either the windowing system or wxWindows, depending on platform. style The window style. See wxMDIParentFrame (p. 874). name The name of the window. This parameter is used to associate a name with the item, allowing the application user to set Motif resource values for individual windows. Remarks During the construction of the frame, the client window will be created. To use a different

876


CHAPTER 7
class from wxMDIClientWindow (p. 872), override wxMDIParentFrame::OnCreateClient (p. 879). Under Windows 95, the client window will automatically have a sunken border style when the active child is not maximized, and no border style when a child is maximized. See also wxMDIParentFrame::Create (p. 878), wxMDIParentFrame::OnCreateClient (p. 879)

wxMDIParentFrame::~wxMDIParentFrame
~wxMDIParentFrame() Destructor. Destroys all child windows and menu bar if present.

wxMDIParentFrame::ActivateNext
void ActivateNext() Activates the MDI child following the currently active one. See also wxMDIParentFrame::ActivatePrevious (p. 877)

wxMDIParentFrame::ActivatePrevious
void ActivatePrevious() Activates the MDI child preceding the currently active one. See also wxMDIParentFrame::ActivateNext (p. 877)

wxMDIParentFrame::ArrangeIcons
void ArrangeIcons() Arranges any iconized (minimized) MDI child windows. See also wxMDIParentFrame::Cascade (p. 877), wxMDIParentFrame::Tile (p. 881)

wxMDIParentFrame::Cascade

877


CHAPTER 7
void Cascade() Arranges the MDI child windows in a cascade. See also wxMDIParentFrame::Tile (p. 881), wxMDIParentFrame::ArrangeIcons (p. 877)

wxMDIParentFrame::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE | wxVSCROLL | wxHSCROLL, const wxString& name = "frame") Used in two-step frame construction. See wxMDIParentFrame::wxMDIParentFrame (p. 876) for further details.

wxMDIParentFrame::GetClientSize
virtual void GetClientSize(int* width, int* height) const This gets the size of the frame 'client area' in pixels. Parameters width Receives the client width in pixels. height Receives the client height in pixels. Remarks The client area is the area which may be drawn on by the programmer, excluding title bar, border, status bar, and toolbar if present. If you wish to manage your own toolbar (or perhaps you have more than one), provide an OnSize event handler. Call GetClientSize to find how much space there is for your windows and don't forget to set the size and position of the MDI client window as well as your toolbar and other windows (but not the status bar). If you have set a toolbar with wxMDIParentFrame::SetToolbar (p. 880), the client size returned will have subtracted the toolbar height. However, the available positions for the client window and other windows of the frame do not start at zero - you must add the toolbar height. The position and size of the status bar and toolbar (if known to the frame) are always managed by wxMDIParentFrame, regardless of what behaviour is defined in your OnSize event handler. However, the client window position and size are always set in

878


CHAPTER 7
OnSize, so if you override this event handler, make sure you deal with the client window. You do not have to manage the size and position of MDI child windows, since they are managed automatically by the client window. See also wxMDIParentFrame::GetToolBar (p. 879), wxMDIParentFrame::SetToolBar (p. 880), wxMDIClientWindow (p. 872) wxPython note: The wxPython version of this method takes no arguments and returns a tuple containing width and height.

wxMDIParentFrame::GetActiveChild
wxMDIChildFrame* GetActiveChild() const Returns a pointer to the active MDI child, if there is one.

wxMDIParentFrame::GetClientWindow
wxMDIClientWindow* GetClientWindow() const Returns a pointer to the client window. See also wxMDIParentFrame::OnCreateClient (p. 879)

wxMDIParentFrame::GetToolBar
virtual wxWindow* GetToolBar() const Returns the window being used as the toolbar for this frame. See also wxMDIParentFrame::SetToolBar (p. 880)

wxMDIParentFrame::GetWindowMenu
wxMenu* GetWindowMenu() const Returns the current Window menu (added by wxWindows to the menubar). This function is available under Windows only.

wxMDIParentFrame::OnCreateClient

879


CHAPTER 7
virtual wxMDIClientWindow* OnCreateClient() Override this to return a different kind of client window. If you override this function, you must create your parent frame in two stages, or your function will never be called, due to the way C++ treats virtual functions called from constructors. For example:
frame = new MyParentFrame; frame->Create(parent, myParentFrameId, wxT("My Parent Frame"));

Remarks You might wish to derive from wxMDIClientWindow (p. 872) in order to implement different erase behaviour, for example, such as painting a bitmap on the background. Note that it is probably impossible to have a client window that scrolls as well as painting a bitmap or pattern, since in OnScroll, the scrollbar positions always return zero. (Solutions to: julian.smart@btopenworld.com). See also wxMDIParentFrame::GetClientWindow (p. 879), wxMDIClientWindow (p. 872)

wxMDIParentFrame::SetToolBar
virtual void SetToolBar(wxWindow* toolbar) Sets the window to be used as a toolbar for this MDI parent window. It saves the application having to manage the positioning of the toolbar MDI client window. Parameters toolbar Toolbar to manage. Remarks When the frame is resized, the toolbar is resized to be the width of the frame client area, and the toolbar height is kept the same. The parent of the toolbar must be this frame. If you wish to manage your own toolbar (or perhaps you have more than one), don't call this function, and instead manage your subwindows and the MDI client window by providing an OnSize event handler. Call wxMDIParentFrame::GetClientSize (p. 878) to find how much space there is for your windows. Note that SDI (normal) frames and MDI child windows must always have their toolbars managed by the application. See also wxMDIParentFrame::GetToolBar (p. 879), wxMDIParentFrame::GetClientSize (p. 878)

880


CHAPTER 7 wxMDIParentFrame::SetWindowMenu
void SetWindowMenu(wxMenu* menu) Call this to change the current Window menu. Ownership of the menu object passes to the frame when you call this function. This call is available under Windows only. To remove the window completely, use the wxFRAME_NO_WINDOW_MENU window style.

wxMDIParentFrame::Tile
void Tile() Tiles the MDI child windows. See also wxMDIParentFrame::Cascade (p. 877), wxMDIParentFrame::ArrangeIcons (p. 877)

wxMemoryDC
A memory device context provides a means to draw graphics onto a bitmap. When drawing in to a mono-bitmap, using wxWHITE, wxWHITE_PEN andwxWHITE_BRUSHwill draw the background colour (i.e. 0) whereas all other colours will draw the foreground colour (i.e. 1). Derived from wxDC (p. 347) wxObject (p. 954) Include files <wx/dcmemory.h> Remarks A bitmap must be selected into the new memory DC before it may be used for anything. Typical usage is as follows:
// Create a memory DC wxMemoryDC temp_dc; temp_dc.SelectObject(test_bitmap); // We can now draw into the memory DC... // Copy from this DC to another DC. old_dc.Blit(250, 50, BITMAP_WIDTH, BITMAP_HEIGHT, temp_dc, 0, 0);

Note that the memory DC must be deleted (or the bitmap selected out of it) before a bitmap can be reselected into another memory DC.

881


CHAPTER 7
See also wxBitmap (p. 67), wxDC (p. 347)

wxMemoryDC::wxMemoryDC
wxMemoryDC() Constructs a new memory device context. Use the Ok member to test whether the constructor was successful in creating a usable device context. Don't forget to select a bitmap into the DC before drawing on it.

wxMemoryDC::SelectObject
SelectObject(const wxBitmap& bitmap) Selects the given bitmap into the device context, to use as the memory bitmap. Selecting the bitmap into a memory DC allows you to draw into the DC (and therefore the bitmap) and also to use Blit to copy the bitmap to a window. For this purpose, you may find wxDC::DrawIcon (p. 353) easier to use instead. If the argument is wxNullBitmap (or some other uninitialised wxBitmap) the current bitmap is selected out of the device context, and the original bitmap restored, allowing the current bitmap to be destroyed safely.

wxMemoryFSHandler
This wxFileSystem (p. 492) handler can store arbitrary data in memory stream and make them accessible via URL. It is particularly suitable for storing bitmaps from resources or included XPM files so that they can be used with wxHTML. Filenames are prefixed with "memory:", e.g. "memory:myfile.html". Example:
#ifndef __WXMSW__ #include "logo.xpm" #endif void MyFrame::OnAbout(wxCommandEvent&) { wxBusyCursor bcur; wxFileSystem::AddHandler(new wxMemoryFSHandler); wxMemoryFSHandler::AddFile("logo.pcx", wxBITMAP(logo), wxBITMAP_TYPE_PCX); wxMemoryFSHandler::AddFile("about.htm", "<html><body>About: " "<img src=\"memory:logo.pcx\"></body></html>"); wxDialog dlg(this, -1, wxString(_("About")));

882


CHAPTER 7
wxBoxSizer *topsizer; wxHtmlWindow *html; topsizer = new wxBoxSizer(wxVERTICAL); html = new wxHtmlWindow(&dlg, -1, wxDefaultPosition, wxSize(380, 160), wxHW_SCROLLBAR_NEVER); html->SetBorders(0); html->LoadPage("memory:about.htm"); html->SetSize(html->GetInternalRepresentation()->GetWidth(), html->GetInternalRepresentation()->GetHeight()); topsizer->Add(html, 1, wxALL, 10); topsizer->Add(new wxStaticLine(&dlg, -1), 0, wxEXPAND | wxLEFT | wxRIGHT, 10); topsizer->Add(new wxButton(&dlg, wxID_OK, "Ok"), 0, wxALL | wxALIGN_RIGHT, 15); dlg.SetAutoLayout(true); dlg.SetSizer(topsizer); topsizer->Fit(&dlg); dlg.Centre(); dlg.ShowModal(); wxMemoryFSHandler::RemoveFile("logo.pcx"); wxMemoryFSHandler::RemoveFile("about.htm"); }

Derived from wxFileSystemHandler (p. 494) Include files <wx/fs_mem.h>

wxMemoryFSHandler::wxMemoryFSHandler
wxMemoryFSHandler() Constructor.

wxMemoryFSHandler::AddFile
static void AddFile(const wxString& filename, wxImage& image, long type) static void AddFile(const wxString& filename, const wxBitmap& bitmap, long type) static void AddFile(const wxString& filename, const wxString& textdata) static void AddFile(const wxString& filename, const void* binarydata, size_t size) Add file to list of files stored in memory. Stored data (bitmap, text or raw data) will be copied into private memory stream and available under name "memory:" + filename. Note that when storing image/bitmap, you must use image format that wxWindows can write (e.g. JPG, PNG, see wxImage documentation (p. 728))!

883


CHAPTER 7 wxMemoryFSHandler::RemoveFile
static void RemoveFile(const wxString& filename) Remove file from memory FS and free occupied memory.

wxMemoryInputStream
Derived from wxInputStream (p. 762) Include files <wx/mstream.h> See also wxStreamBuffer (p. 1193), wxMemoryOutputStream (p. 884)

wxMemoryInputStream::wxMemoryInputStream
wxMemoryInputStream(const char * data, size_t len) Initializes a new read-only memory stream which will use the specified bufferdata of length len. The stream does not take ownership of the buffer, i.e. that it will not delete in its destructor.

wxMemoryInputStream::~wxMemoryInputStream
~wxMemoryInputStream() Destructor.

wxMemoryOutputStream
Derived from wxOutputStream (p. 958) Include files <wx/mstream.h> See also wxStreamBuffer (p. 1193)

884


CHAPTER 7

wxMemoryOutputStream::wxMemoryOutputStream
wxMemoryOutputStream(char * data = NULL, size_t length = 0) If data is NULL, then it will initialize a new empty buffer which will grow if required. Warning If the buffer is created, it will be destroyed at the destruction of the stream.

wxMemoryOutputStream::~wxMemoryOutputStream
~wxMemoryOutputStream() Destructor.

wxMemoryOutputStream::CopyTo
size_t CopyTo(char *buffer, size_t len) const CopyTo allowed you to transfer data from the internal buffer of wxMemoryOutputStream to an external buffer. len specifies the size of the buffer. Returned value CopyTo returns the number of bytes copied to the buffer. Generally it is either len or the size of the stream buffer.

wxMenu
A menu is a popup (or pull down) list of items, one of which may be selected before the menu goes away (clicking elsewhere dismisses the menu). Menus may be used to construct either menu bars or popup menus. A menu item has an integer ID associated with it which can be used to identify the selection, or to change the menu item in some way. A menu item with a special identifier -1 is a separator item and doesn't have an associated command but just makes a separator line appear in the menu. Menu items may be either normal items, check items or radio items. Normal items don't have any special properties while the check items have a boolean flag associated to them and they show a checkmark in the menu when the flag is set. wxWindows automatically toggles the flag value when the item is clicked and its value may be retrieved using either IsChecked (p. 895) method of wxMenu or wxMenuBar itself or by using wxEvent::IsChecked (p. 169) when you get the menu notification for the item in question.

885


CHAPTER 7
The radio items are similar to the check items except that all the other items in the same radio group are unchecked when a radio item is checked. The radio group is formed by a contiguous range of radio items, i.e. it starts at the first item of this kind and ends with the first item of a different kind (or the end of the menu). Notice that because the radio groups are defined in terms of the item positions inserting or removing the items in the menu containing the radio items risks to not work correctly. Finally note that the radio items are only supported under Windows and GTK+ currently. Allocation strategy All menus except the popup ones must be created on the heap. All menus attached to a menubar or to another menu will be deleted by their parent when it is deleted. As the frame menubar is deleted by the frame itself, it means that normally all menus used are deleted automatically. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/menu.h> Event handling If the menu is part of a menubar, then wxMenuBar (p. 898) event processing is used. With a popup menu, there is a variety of ways to handle a menu selection event (wxEVT_COMMAND_MENU_SELECTED). 1. 2. 3. 4. Derive a new class from wxMenu and define event table entries using the EVT_MENU macro. Set a new event handler for wxMenu, using an object whose class has EVT_MENU entries. Provide EVT_MENU handlers in the window which pops up the menu, or in an ancestor of this window. Define a callback of type wxFunction, which you pass to the wxMenu constructor. The callback takes a reference to the menu, and a reference to awxCommandEvent (p. 164). This method is deprecated and should not be used in the new code, it is provided for backwards compatibility only.

See also wxMenuBar (p. 898), wxWindow::PopupMenu (p. 1413), Event handling overview (p. 1602)

wxMenu::wxMenu 886


CHAPTER 7
wxMenu(const wxString& title = "", long style = 0) Constructs a wxMenu object. Parameters title A title for the popup menu: the empty string denotes no title. style If set to wxMENU_TEAROFF, the menu will be detachable (wxGTK only). wxMenu(long style) Constructs a wxMenu object. Parameters style If set to wxMENU_TEAROFF, the menu will be detachable (wxGTK only).

wxMenu::~wxMenu
~wxMenu() Destructor, destroying the menu. Note: under Motif, a popup menu must have a valid parent (the window it was last popped up on) when being destroyed. Therefore, make sure you delete or re-use the popup menu before destroying the parent window. Re-use in this context means popping up the menu on a different window from last time, which causes an implicit destruction and recreation of internal data structures.

wxMenu::Append
wxMenuItem* Append(int id, const wxString& item, const wxString& helpString = "", wxItemKind kind = wxITEM_NORMAL) Adds a string item to the end of the menu. wxMenuItem* Append(int id, const wxString& item, wxMenu *subMenu, const wxString& helpString = "") Adds a pull-right submenu to the end of the menu. Append the submenu to the parent menu after you have added your menu items, or accelerators may not be registered properly. wxMenuItem* Append(wxMenuItem* menuItem)

887


CHAPTER 7
Adds a menu item object. This is the most generic variant of Append() method because it may be used for both items (including separators) and submenus and because you can also specify various extra properties of a menu item this way, such as bitmaps and fonts. Parameters id The menu command identifier. item The string to appear on the menu item. menu Pull-right submenu. kind May be wxITEM_SEPARATOR, wxITEM_NORMAL, wxITEM_CHECK or wxITEM_RADIO helpString An optional help string associated with the item. By default, the handler for the wxEVT_MENU_HIGHLIGHT event displays this string in the status line. menuItem A menuitem object. It will be owned by the wxMenu object after this function is called, so do not delete it yourself. Remarks This command can be used after the menu has been shown, as well as on initial creation of a menu or menubar. The item string for the normal menu items (not submenus or separators) may include the accelerator which can be used to activate the menu item from keyboard. The accelerator string follows the item label and is separated from it by a TAB character ('\t'). Its general syntax is any combination of "CTRL", "ALT" and "SHIFT" strings (case doesn't matter) separated by either '-' or '+' characters and followed by the accelerator itself. The accelerator may be any alphanumeric character, any function key (from F1 to F12) or one of the special characters listed in the table below (again, case doesn't matter): DEL or DELETE INS or INSERT ENTER or RETURN PGUP Delete key Insert key Enter key PageUp key

888


CHAPTER 7
PGDN LEFT RIGHT UP DOWN HOME END SPACE TAB ESC or ESCAPE See also wxMenu::AppendSeparator (p. 890), wxMenu::AppendCheckItem (p. 889), wxMenu::AppendRadioItem (p. 889), wxMenu::Insert (p. 894), wxMenu::SetLabel (p. 897), wxMenu::GetHelpString (p. 893), wxMenu::SetHelpString (p. 897), wxMenuItem (p. 909) wxPython note: In place of a single overloaded method name, wxPython implements the following methods: Append(id, string, helpStr="", checkable=false) AppendMenu(id, string, aMenu, helpStr="") AppendItem(aMenuItem) PageDown key Left cursor arrow key Right cursor arrow key Up cursor arrow key Down cursor arrow key Home key End key Space Tab key Escape key (Windows only)

wxMenu::AppendCheckItem
wxMenuItem* AppendCheckItem(int id, const wxString& item, const wxString& helpString = "") Adds a checkable item to the end of the menu. See also wxMenu::Append (p. 887), wxMenu::InsertCheckItem (p. 894)

wxMenu::AppendRadioItem
wxMenuItem* AppendRadioItem(int id, const wxString& item, const wxString& helpString = "")

889


CHAPTER 7
Adds a radio item to the end of the menu. All consequent radio items form a group and when an item in the group is checked, all the others are automatically unchecked. NB: Currently only implemented under Windows and GTK, use#if wxHAS_RADIO_MENU_ITEMS to test for availability of this feature. See also wxMenu::Append (p. 887), wxMenu::InsertRadioItem (p. 894)

wxMenu::AppendSeparator
wxMenuItem* AppendSeparator() Adds a separator to the end of the menu. See also wxMenu::Append (p. 887), wxMenu::InsertSeparator (p. 895)

wxMenu::Break
void Break() Inserts a break in a menu, causing the next appended item to appear in a new column.

wxMenu::Check
void Check(int id, const bool check) Checks or unchecks the menu item. Parameters id The menu item identifier. check If true, the item will be checked, otherwise it will be unchecked. See also wxMenu::IsChecked (p. 895)

wxMenu::Delete
void Delete(int id)

890


CHAPTER 7
void Delete(wxMenuItem *item) Deletes the menu item from the menu. If the item is a submenu, it willnot be deleted. Use Destroy (p. 891) if you want to delete a submenu. Parameters id Id of the menu item to be deleted. item Menu item to be deleted. See also wxMenu::FindItem (p. 892), wxMenu::Destroy (p. 891), wxMenu::Remove (p. 897)

wxMenu::Destroy
void Destroy(int id) void Destroy(wxMenuItem *item) Deletes the menu item from the menu. If the item is a submenu, it will be deleted. Use Remove (p. 897) if you want to keep the submenu (for example, to reuse it later). Parameters id Id of the menu item to be deleted. item Menu item to be deleted. See also wxMenu::FindItem (p. 892), wxMenu::Deletes (p. 890), wxMenu::Remove (p. 897)

wxMenu::Enable
void Enable(int id, const bool enable) Enables or disables (greys out) a menu item. Parameters id The menu item identifier.

891


CHAPTER 7
enable true to enable the menu item, false to disable it. See also wxMenu::IsEnabled (p. 895)

wxMenu::FindItem
int FindItem(const wxString& itemString) const Finds the menu item id for a menu item string. wxMenuItem * FindItem(int id, wxMenu **menu = NULL) const Finds the menu item object associated with the given menu item identifier and, optionally, the (sub)menu it belongs to. wxPerl note: In wxPerl this method takes just the id parameter; in scalar context it returns the associated Wx::MenuItem, in list context it returns a 2-element list ( item, submenu ) Parameters itemString Menu item string to find. id Menu item identifier. menu If the pointer is not NULL, it will be filled with the items parent menu (if the item was found) Return value First form: menu item identifier, or wxNOT_FOUND if none is found. Second form: returns the menu item object, or NULL if it is not found. Remarks Any special menu codes are stripped out of source and target strings before matching. wxPython note: The name of this method in wxPython is FindItemById and it does not support the second parameter.

wxMenu::FindItemByPosition

892


CHAPTER 7
wxMenuItem* FindItemByPosition(size_t position) const Returns the wxMenuItem given a position in the menu.

wxMenu::GetHelpString
wxString GetHelpString(int id) const Returns the help string associated with a menu item. Parameters id The menu item identifier. Return value The help string, or the empty string if there is no help string or the item was not found. See also wxMenu::SetHelpString (p. 897), wxMenu::Append (p. 887)

wxMenu::GetLabel
wxString GetLabel(int id) const Returns a menu item label. Parameters id The menu item identifier. Return value The item label, or the empty string if the item was not found. See also wxMenu::SetLabel (p. 897)

wxMenu::GetMenuItemCount
size_t GetMenuItemCount() const Returns the number of items in the menu.

893


CHAPTER 7 wxMenu::GetMenuItems
wxMenuItemList& GetMenuItems() const Returns the list of items in the menu. wxMenuItemList is a pseudo-template list class containing wxMenuItem pointers.

wxMenu::GetTitle
wxString GetTitle() const Returns the title of the menu. Remarks This is relevant only to popup menus, use wxMenuBar::GetLabelTop (p. 903) for the menus in the menubar. See also wxMenu::SetTitle (p. 898)

wxMenu::Insert
wxMenuItem* Insert(size_t pos, wxMenuItem *item) wxMenuItem* Insert(size_t pos, int id, const wxString& item, const wxString& helpString = "", wxItemKind kind = wxITEM_NORMAL) Inserts the given item before the position pos. Inserting the item at the position GetMenuItemCount (p. 893) is the same as appending it. See also wxMenu::Append (p. 887), wxMenu::Prepend (p. 896)

wxMenu::InsertCheckItem
wxMenuItem* InsertCheckItem(size_t pos, int id, const wxString& item, const wxString& helpString = "") Inserts a checkable item at the given position. See also wxMenu::Insert (p. 894), wxMenu::AppendCheckItem (p. 889)

wxMenu::InsertRadioItem

894


CHAPTER 7
wxMenuItem* InsertRadioItem(size_t pos, int id, const wxString& item, const wxString& helpString = "") Inserts a radio item at the given position. See also wxMenu::Insert (p. 894), wxMenu::AppendRadioItem (p. 889)

wxMenu::InsertSeparator
wxMenuItem* InsertSeparator(size_t pos) Inserts a separator at the given position. See also wxMenu::Insert (p. 894), wxMenu::AppendSeparator (p. 890)

wxMenu::IsChecked
bool IsChecked(int id) const Determines whether a menu item is checked. Parameters id The menu item identifier. Return value true if the menu item is checked, false otherwise. See also wxMenu::Check (p. 890)

wxMenu::IsEnabled
bool IsEnabled(int id) const Determines whether a menu item is enabled. Parameters id The menu item identifier. Return value

895


CHAPTER 7
true if the menu item is enabled, false otherwise. See also wxMenu::Enable (p. 891)

wxMenu::Prepend
wxMenuItem* Prepend(wxMenuItem *item) wxMenuItem* Prepend(int id, const wxString& item, const wxString& helpString = "", wxItemKind kind = wxITEM_NORMAL) Inserts the given item at the position 0, i.e. before all the other existing items. See also wxMenu::Append (p. 887), wxMenu::Inserts (p. 894)

wxMenu::PrependCheckItem
wxMenuItem* PrependCheckItem(int id, const wxString& item, const wxString& helpString = "") Inserts a checkable item at the position 0. See also wxMenu::Prepend (p. 896), wxMenu::AppendCheckItem (p. 889)

wxMenu::PrependRadioItem
wxMenuItem* PrependRadioItem(int id, const wxString& item, const wxString& helpString = "") Inserts a radio item at the position 0. See also wxMenu::Prepend (p. 896), wxMenu::AppendRadioItem (p. 889)

wxMenu::PrependSeparator
wxMenuItem* PrependSeparator(size_t pos) Inserts a separator at the position 0. See also wxMenu::Prepend (p. 896), wxMenu::AppendSeparator (p. 890)

896


CHAPTER 7 wxMenu::Remove
wxMenuItem * Remove(int id) wxMenuItem * Remove(wxMenuItem *item) Removes the menu item from the menu but doesn't delete the associated C++ object. This allows to reuse the same item later by adding it back to the menu (especially useful with submenus). Parameters id The identifier of the menu item to remove. item The menu item to remove. Return value The item which was detached from the menu.

wxMenu::SetHelpString
void SetHelpString(int id, const wxString& helpString) Sets an item's help string. Parameters id The menu item identifier. helpString The help string to set. See also wxMenu::GetHelpString (p. 893)

wxMenu::SetLabel
void SetLabel(int id, const wxString& label) Sets the label of a menu item. Parameters id

897


CHAPTER 7
The menu item identifier. label The menu item label to set. See also wxMenu::Append (p. 887), wxMenu::GetLabel (p. 893)

wxMenu::SetTitle
void SetTitle(const wxString& title) Sets the title of the menu. Parameters title The title to set. Remarks This is relevant only to popup menus, use wxMenuBar::SetLabelTop (p. 907) for the menus in the menubar. See also wxMenu::GetTitle (p. 894)

wxMenu::UpdateUI
void UpdateUI(wxEvtHandler* source = NULL) const Sends events to source (or owning window if NULL) to update the menu UI. This is called just before the menu is popped up with wxWindow::PopupMenu (p. 1413), but the application may call it at other times if required. See also wxUpdateUIEvent (p. 1350)

wxMenuBar
A menu bar is a series of menus accessible from the top of a frame. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443)

898


CHAPTER 7
wxObject (p. 954) Include files <wx/menu.h> Event handling To respond to a menu selection, provide a handler for EVT_MENU, in the frame that contains the menu bar. If you have a toolbar which uses the same identifiers as your EVT_MENU entries, events from the toolbar will also be processed by your EVT_MENU event handlers. Tip: under Windows, if you discover that menu shortcuts (for example, Alt-F to show the file menu) are not working, check any EVT_CHAR events you are handling in child windows. If you are not calling event.Skip() for events that you don't process in these event handlers, menu shortcuts may cease to work. See also wxMenu (p. 885), Event handling overview (p. 1602)

wxMenuBar::wxMenuBar
void wxMenuBar(long style = 0) Default constructor. void wxMenuBar(int n, wxMenu* menus[], const wxString titles[]) Construct a menu bar from arrays of menus and titles. Parameters n The number of menus. menus An array of menus. Do not use this array again - it now belongs to the menu bar. titles An array of title strings. Deallocate this array after creating the menu bar. style If wxMB_DOCKABLE the menu bar can be detached (wxGTK only). wxPython note: Only the default constructor is supported in wxPython. Use wxMenuBar.Append instead.

899


CHAPTER 7
wxPerl note: wxPerl only supports the first constructor: use Append instead.

wxMenuBar::~wxMenuBar
void ~wxMenuBar() Destructor, destroying the menu bar and removing it from the parent frame (if any).

wxMenuBar::Append
bool Append(wxMenu *menu, const wxString& title) Adds the item to the end of the menu bar. Parameters menu The menu to add. Do not deallocate this menu after calling Append. ti tl e The title of the menu. Return value true on success, false if an error occurred. See also wxMenuBar::Insert (p. 904)

wxMenuBar::Check
void Check(int id, const bool check) Checks or unchecks a menu item. Parameters id The menu item identifier. check If true, checks the menu item, otherwise the item is unchecked. Remarks Only use this when the menu bar has been associated with a frame; otherwise, use the wxMenu equivalent call.

900


CHAPTER 7 wxMenuBar::Enable
void Enable(int id, const bool enable) Enables or disables (greys out) a menu item. Parameters id The menu item identifier. enable true to enable the item, false to disable it. Remarks Only use this when the menu bar has been associated with a frame; otherwise, use the wxMenu equivalent call.

wxMenuBar::EnableTop
void EnableTop(int pos, const bool enable) Enables or disables a whole menu. Parameters pos The position of the menu, starting from zero. enable true to enable the menu, false to disable it. Remarks Only use this when the menu bar has been associated with a frame.

wxMenuBar::FindMenu
int FindMenu(const wxString& title) const Returns the index of the menu with the given title or wxNOT_FOUND if no such menu exists in this menubar. The title parameter may specify either the menu title (with accelerator characters, i.e. "&File") or just the menu label ("File") indifferently.

wxMenuBar::FindMenuItem

901


CHAPTER 7
int FindMenuItem(const wxString& menuString, const wxString& itemString) const Finds the menu item id for a menu name/menu item string pair. Parameters menuString Menu title to find. itemString Item to find. Return value The menu item identifier, or wxNOT_FOUND if none was found. Remarks Any special menu codes are stripped out of source and target strings before matching.

wxMenuBar::FindItem
wxMenuItem * FindItem(int id, wxMenu **menu = NULL) const Finds the menu item object associated with the given menu item identifier. Parameters id Menu item identifier. menu If not NULL, menu will get set to the associated menu. Return value The found menu item object, or NULL if one was not found.

wxMenuBar::GetHelpString
wxString GetHelpString(int id) const Gets the help string associated with the menu item identifier. Parameters id The menu item identifier.

902


CHAPTER 7
Return value The help string, or the empty string if there was no help string or the menu item was not found. See also wxMenuBar::SetHelpString (p. 906)

wxMenuBar::GetLabel
wxString GetLabel(int id) const Gets the label associated with a menu item. Parameters id The menu item identifier. Return value The menu item label, or the empty string if the item was not found. Remarks Use only after the menubar has been associated with a frame.

wxMenuBar::GetLabelTop
wxString GetLabelTop(int pos) const Returns the label of a top-level menu. Note that the returned string does not include the accelerator characters which could have been specified in the menu title string during its construction. Parameters pos Position of the menu on the menu bar, starting from zero. Return value The menu label, or the empty string if the menu was not found. Remarks Use only after the menubar has been associated with a frame. See also

903


CHAPTER 7
wxMenuBar::SetLabelTop (p. 907)

wxMenuBar::GetMenu
wxMenu* GetMenu(int menuIndex) const Returns the menu at menuIndex (zero-based).

wxMenuBar::GetMenuCount
int GetMenuCount() const Returns the number of menus in this menubar.

wxMenuBar::Insert
bool Insert(size_t pos, wxMenu *menu, const wxString& title) Inserts the menu at the given position into the menu bar. Inserting menu at position 0 will insert it in the very beginning of it, inserting at position GetMenuCount() (p. 904) is the same as calling Append() (p. 900). Parameters pos The position of the new menu in the menu bar menu The menu to add. wxMenuBar owns the menu and will free it. title The title of the menu. Return value true on success, false if an error occurred. See also wxMenuBar::Append (p. 900)

wxMenuBar::IsChecked
bool IsChecked(int id) const Determines whether an item is checked.

904


CHAPTER 7
Parameters id The menu item identifier. Return value true if the item was found and is checked, false otherwise.

wxMenuBar::IsEnabled
bool IsEnabled(int id) const Determines whether an item is enabled. Parameters id The menu item identifier. Return value true if the item was found and is enabled, false otherwise.

wxMenuBar::Refresh
void Refresh() Redraw the menu bar

wxMenuBar::Remove
wxMenu * Remove(size_t pos) Removes the menu from the menu bar and returns the menu object - the caller is responsible for deleting it. This function may be used together with wxMenuBar::Insert (p. 904) to change the menubar dynamically. See also wxMenuBar::Replace (p. 905)

wxMenuBar::Replace
wxMenu * Replace(size_t pos, wxMenu *menu, const wxString& title) Replaces the menu at the given position with another one.

905


CHAPTER 7
Parameters pos The position of the new menu in the menu bar menu The menu to add. title The title of the menu. Return value The menu which was previously at the position pos. The caller is responsible for deleting it. See also wxMenuBar::Insert (p. 904), wxMenuBar::Remove (p. 905)

wxMenuBar::SetHelpString
void SetHelpString(int id, const wxString& helpString) Sets the help string associated with a menu item. Parameters id Menu item identifier. helpString Help string to associate with the menu item. See also wxMenuBar::GetHelpString (p. 902)

wxMenuBar::SetLabel
void SetLabel(int id, const wxString& label) Sets the label of a menu item. Parameters id

906


CHAPTER 7
Menu item identifier. label Menu item label. Remarks Use only after the menubar has been associated with a frame. See also wxMenuBar::GetLabel (p. 903)

wxMenuBar::SetLabelTop
void SetLabelTop(int pos, const wxString& label) Sets the label of a top-level menu. Parameters pos The position of a menu on the menu bar, starting from zero. label The menu label. Remarks Use only after the menubar has been associated with a frame. See also wxMenuBar::GetLabelTop (p. 903)

wxMenuEvent
This class is used for a variety of menu-related events. Note that these do not include menu command events, which are handled using wxCommandEvent (p. 164) objects. The default handler for wxEVT_MENU_HIGHLIGHT displays help text in the first field of the status bar. Derived from wxEvent (p. 439) wxObject (p. 954) Include files

907


CHAPTER 7
<wx/event.h> Event table macros To process a menu event, use these event handler macros to direct input to member functions that take a wxMenuEvent argument. EVT_MENU_OPEN(func) A menu is about to be opened. On Windows, this is only sent once for each navigation of the menubar (up until all menus have closed). A menu has been just closed. The menu item with the specified id has been highlighted: used to show help prompts in the status bar by wxFrame (p. 530) A menu item has been highlighted, i.e. the currently selected menu item has changed.

EVT_MENU_CLOSE(func) EVT_MENU_HIGHLIGHT(id, func)

EVT_MENU_HIGHLIGHT_ALL(func) See also Command events (p. 164), Event handling overview (p. 1602)

wxMenuEvent::wxMenuEvent
wxMenuEvent(WXTYPE id = 0, int id = 0, wxDC* dc = NULL) Constructor.

wxMenuEvent::m_menuId
int m_menuId The relevant menu identifier.

wxMenuEvent::GetMenuId
int GetMenuId() const Returns the menu identifier associated with the event. This method should be only used with the HIGHLIGHT events.

wxMenuEvent::IsPopup

908


CHAPTER 7
bool IsPopup() const Returns true if the menu which is being opened or closed is a popup menu, false if it is a normal one. This method should be only used with the OPEN and CLOSE events.

wxMenuItem
A menu item represents an item in a menu. Note that you usually don't have to deal with it directly as wxMenu (p. 885) methods usually construct an object of this class for you. Also please note that the methods related to fonts and bitmaps are currently only implemented for Windows. Derived from wxOwnerDrawn (Windows only) wxObject (p. 954) Include files <wx/menuitem.h> See also wxMenuBar (p. 898), wxMenu (p. 885)

wxMenuItem::wxMenuItem
wxMenuItem(wxMenu* parentMenu = NULL, int id = wxID_SEPARATOR, const wxString& text = "", const wxString& helpString = "", wxItemKind kind = wxITEM_NORMAL, wxMenu* subMenu = NULL, ) Constructs a wxMenuItem object. Parameters parentMenu Menu that the menu item belongs to. id Identifier for this menu item, or wxID_SEPARATOR to indicate a separator. text Text for the menu item, as shown on the menu. An accelerator key can be specified using the ampersand '&' character. In order to embed an ampersand

909


CHAPTER 7
character in the menu item text, the ampersand must be doubled. helpString Optional help string that will be shown on the status bar. kind May be wxITEM_SEPARATOR, wxITEM_NORMAL, wxITEM_CHECK or wxITEM_RADIO subMenu If non-NULL, indicates that the menu item is a submenu.

wxMenuItem::~wxMenuItem
~wxMenuItem() Destructor.

wxMenuItem::Check
void Check(bool check) Checks or unchecks the menu item.

wxMenuItem::DeleteSubMenu
void DeleteSubMenu() Deletes the submenu, if any.

wxMenuItem::Enable
void Enable(bool enable) Enables or disables the menu item.

wxMenuItem::GetBackgroundColour
wxColour& GetBackgroundColour() const Returns the background colour associated with the menu item (Windows only).

wxMenuItem::GetBitmap

910


CHAPTER 7
wxBitmap& GetBitmap(bool checked = true) const Returns the checked or unchecked bitmap (Windows only).

wxMenuItem::GetFont
wxFont& GetFont() const Returns the font associated with the menu item (Windows only).

wxMenuItem::GetHelp
wxString GetHelp() const Returns the help string associated with the menu item.

wxMenuItem::GetId
int GetId() const Returns the menu item identifier.

wxMenuItem::GetKind
wxItemKind GetKind() const Returns the item kind, one of wxITEM_SEPARATOR, wxITEM_NORMAL, wxITEM_CHECK or wxITEM_RADIO.

wxMenuItem::GetLabel
wxString GetLabel() const Returns the text associated with the menu item without any accelerator characters it might contain. See also GetText (p. 912), GetLabelFromText (p. 911)

wxMenuItem::GetLabelFromText
static wxString GetLabelFromText(const wxString& text) Strips all accelerator characters and mnemonics from the given text. For example,
wxMenuItem::GetLabelFromText("&Hello\tCtrl-H");

911


CHAPTER 7

will return just "Hello". See also GetText (p. 912), GetLabel (p. 911)

wxMenuItem::GetMarginWidth
int GetMarginWidth() const Gets the width of the menu item checkmark bitmap (Windows only).

wxMenuItem::GetName
wxString GetName() const Returns the text associated with the menu item. NB: this function is deprecated, please use GetText (p. 912) or GetLabel (p. 911) instead.

wxMenuItem::GetText
wxString GetText() const Returns the text associated with the menu item, such as it was passed to the wxMenuItem constructor, i.e. with any accelerator characters it may contain. See also GetLabel (p. 911), GetLabelFromText (p. 911)

wxMenuItem::GetSubMenu
wxMenu* GetSubMenu() const Returns the submenu associated with the menu item, or NULL if there isn't one.

wxMenuItem::GetTextColour
wxColour& GetTextColour() const Returns the text colour associated with the menu item (Windows only).

wxMenuItem::IsCheckable

912


CHAPTER 7
bool IsCheckable() const Returns true if the item is checkable.

wxMenuItem::IsChecked
bool IsChecked() const Returns true if the item is checked.

wxMenuItem::IsEnabled
bool IsEnabled() const Returns true if the item is enabled.

wxMenuItem::IsSeparator
bool IsSeparator() const Returns true if the item is a separator.

wxMenuItem::SetBackgroundColour
void SetBackgroundColour(const wxColour& colour) const Sets the background colour associated with the menu item (Windows only).

wxMenuItem::SetBitmap
void SetBitmap(const wxBitmap& bmp) const Sets the bitmap for the menu item (Windows and GTK+ only). It is equivalent to SetBitmaps (p. 913)(bmp, wxNullBitmap).

wxMenuItem::SetBitmaps
void SetBitmaps(const wxBitmap& checked, const wxBitmap& unchecked = wxNullBitmap) const Sets the checked/unchecked bitmaps for the menu item (Windows only). The first bitmap is also used as the single bitmap for uncheckable menu items.

wxMenuItem::SetFont

913


CHAPTER 7
void SetFont(const wxFont& font) const Sets the font associated with the menu item (Windows only).

wxMenuItem::SetHelp
void SetHelp(const wxString& helpString) const Sets the help string.

wxMenuItem::SetMarginWidth
void SetMarginWidth(int width) const Sets the width of the menu item checkmark bitmap (Windows only).

wxMenuItem::SetText
void SetText(const wxString& text) const Sets the text associated with the menu item.

wxMenuItem::SetTextColour
void SetTextColour(const wxColour& colour) const Sets the text colour associated with the menu item (Windows only).

wxMessageDialog
This class represents a dialog that shows a single or multi-line message, with a choice of OK, Yes, No and Cancel buttons. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/msgdlg.h> See also wxMessageDialog overview (p. 1651)

914


CHAPTER 7

wxMessageDialog::wxMessageDialog
wxMessageDialog(wxWindow* parent, const wxString& message, const wxString& caption = "Message box", long style = wxOK | wxCANCEL, const wxPoint& pos = wxDefaultPosition) Constructor. Use wxMessageDialog::ShowModal (p. 916) to show the dialog. Parameters parent Parent window. message Message to show on the dialog. caption The dialog caption. style A dialog style (bitlist) containing flags chosen from the following: wxOK wxCANCEL wxYES_NO wxYES_DEFAULT wxNO_DEFAULT wxICON_EXCLAMATION wxICON_HAND wxICON_ERROR wxICON_QUESTION wxICON_INFORMATION wxSTAY_ON_TOP Show an OK button. Show a Cancel button. Show Yes and No buttons. Used with wxYES_NO, makes Yes button the default - which is the default behaviour. Used with wxYES_NO, makes No button the default. Shows an exclamation mark icon. Shows an error icon. Shows an error icon - the same as wxICON_HAND. Shows a question mark icon. Shows an information (i) icon. The message box stays on top of all other window, even those of the other applications (Windows only).

pos

915


CHAPTER 7
Dialog position. Not Windows.

wxMessageDialog::~wxMessageDialog
~wxMessageDialog() Destructor.

wxMessageDialog::ShowModal
int ShowModal() Shows the dialog, returning one of wxID_OK, wxID_CANCEL, wxID_YES, wxID_NO.

wxMetafile
A wxMetafile represents the MS Windows metafile object, so metafile operations have no effect in X. In wxWindows, only sufficient functionality has been provided for copying a graphic to the clipboard; this may be extended in a future version. Presently, the only way of creating a metafile is to use a wxMetafileDC. Derived from wxObject (p. 954) Include files <wx/metafile.h> See also wxMetafileDC (p. 917)

wxMetafile::wxMetafile
wxMetafile(const wxString& filename = "") Constructor. If a filename is given, the Windows disk metafile is read in. Check whether this was performed successfully by using the wxMetafile::Ok (p. 917) member.

wxMetafile::~wxMetafile
~wxMetafile() Destructor.

916


CHAPTER 7 wxMetafile::Ok
bool Ok() Returns true if the metafile is valid.

wxMetafile::Play
bool Play(wxDC *dc) Plays the metafile into the given device context, returning true if successful.

wxMetafile::SetClipboard
bool SetClipboard(int width = 0, int height = 0) Passes the metafile data to the clipboard. The metafile can no longer be used for anything, but the wxMetafile object must still be destroyed by the application. Below is a example of metafile, metafile device context and clipboard use from the hello.cpp example. Note the way the metafile dimensions are passed to the clipboard, making use of the device context's ability to keep track of the maximum extent of drawing commands.
wxMetafileDC dc; if (dc.Ok()) { Draw(dc, false); wxMetafile *mf = dc.Close(); if (mf) { bool success = mf->SetClipboard((int)(dc.MaxX() + 10), (int)(dc.MaxY() + 10)); delete mf; } }

wxMetafileDC
This is a type of device context that allows a metafile object to be created (Windows only), and has most of the characteristics of a normal wxDC. The wxMetafileDC::Close (p. 918) member must be called after drawing into the device context, to return a metafile. The only purpose for this at present is to allow the metafile to be copied to the clipboard (see wxMetafile (p. 916)). Adding metafile capability to an application should be easy if you already write to a wxDC; simply pass the wxMetafileDC to your drawing function instead. You may wish to conditionally compile this code so it is not compiled under X (although no harm will result if you leave it in). Note that a metafile saved to disk is in standard Windows metafile format, and cannot be imported into most applications. To make it importable, call the function

917


CHAPTER 7
::wxMakeMetafilePlaceable (p. 1500) after closing your disk-based metafile device context. Derived from wxDC (p. 347) wxObject (p. 954) Include files <wx/metafile.h> See also wxMetafile (p. 916), wxDC (p. 347)

wxMetafileDC::wxMetafileDC
wxMetafileDC(const wxString& filename = "") Constructor. If no filename is passed, the metafile is created in memory.

wxMetafileDC::~wxMetafileDC
~wxMetafileDC() Destructor.

wxMetafileDC::Close
wxMetafile * Close() This must be called after the device context is finished with. A metafile is returned, and ownership of it passes to the calling application (so it should be destroyed explicitly).

wxMimeTypesManager
This class allows the application to retrieve the information about all known MIME types from a system-specific location and the filename extensions to the MIME types and vice versa. After initialization the functionswxMimeTypesManager::GetFileTypeFromMimeType (p. 921) and wxMimeTypesManager::GetFileTypeFromExtension (p. 921) may be called: they will return a wxFileType (p. 497) object which may be further queried for file description, icon and other attributes. Windows: MIME type information is stored in the registry and no additional initialization

918


CHAPTER 7
is needed. Unix: MIME type information is stored in the files mailcap and mime.types (system-wide) and .mailcap and .mime.types in the current user's home directory: all of these files are searched for and loaded if found by default. However, additional functions wxMimeTypesManager::ReadMailcap (p. 921) and wxMimeTypesManager::ReadMimeTypes (p. 921) are provided to load additional files. If GNOME or KDE desktop environment is installed, then wxMimeTypesManager gathers MIME information from respective files (e.g. .kdelnk files under KDE). NB: Currently, wxMimeTypesManager is limited to reading MIME type information but it will support modifying it as well in the future versions. Global objects Global instance of wxMimeTypesManager is always available. It is defined as follows:
wxMimeTypesManager *wxTheMimeTypesManager;

It is recommended to use this instance instead of creating your own because gathering MIME information may take quite a long on Unix systems. Derived from No base class. Include files <wx/mimetype.h> See also wxFileType (p. 497)

Helper functions
All of these functions are static (i.e. don't need a wxMimeTypesManager object to call them) and provide some useful operations for string representations of MIME types. Their usage is recommended instead of directly working with MIME types using wxString functions. IsOfType (p. 921)

Constructor and destructor
NB: You won't normally need to use more than one wxMimeTypesManager object in a program. wxMimeTypesManager (p. 920)

919


CHAPTER 7
~wxMimeTypesManager (p. 920)

Query database
These functions are the heart of this class: they allow to find a file type (p. 497) object from either file extension or MIME type. If the function is successful, it returns a pointer to the wxFileType object which must be deleted by the caller, otherwise NULL will be returned. GetFileTypeFromMimeType (p. 921) GetFileTypeFromExtension (p. 921)

Initialization functions
Unix: These functions may be used to load additional files (except for the default ones which are loaded automatically) containing MIME information in either mailcap(5) or mime.types(5) format. ReadMailcap (p. 921) ReadMimeTypes (p. 921) AddFallbacks (p. 920)

wxMimeTypesManager::wxMimeTypesManager
wxMimeTypesManager() Constructor puts the object in the "working" state, no additional initialization are needed but ReadXXX (p. 920) may be used to load additional mailcap/mime.types files.

wxMimeTypesManager::~wxMimeTypesManager
~wxMimeTypesManager() Destructor is not virtual, so this class should not be derived from.

wxMimeTypesManager::AddFallbacks
void AddFallbacks(const wxFileTypeInfo *fallbacks) This function may be used to provide hard-wired fallbacks for the MIME types and extensions that might not be present in the system MIME database. Please see the typetest sample for an example of using it.

920


CHAPTER 7 wxMimeTypesManager::GetFileTypeFromExtension
wxFileType* GetFileTypeFromExtension(const wxString& extension) Gather information about the files with given extension and return the corresponding wxFileType (p. 497) object or NULL if the extension is unknown.

wxMimeTypesManager::GetFileTypeFromMimeType
wxFileType* GetFileTypeFromMimeType(const wxString& mimeType) Gather information about the files with given MIME type and return the corresponding wxFileType (p. 497) object or NULL if the MIME type is unknown.

wxMimeTypesManager::IsOfType
bool IsOfType(const wxString& mimeType, const wxString& wildcard) This function returns true if either the given mimeType is exactly the same as wildcard or if it has the same category and the subtype ofwildcard is '*'. Note that the '*' wildcard is not allowed inmimeType itself. The comparison don by this function is case insensitive so it is not necessary to convert the strings to the same case before calling it.

wxMimeTypesManager::ReadMailcap
bool ReadMailcap(const wxString& filename, bool fallback = false) Load additional file containing information about MIME types and associated information in mailcap format. See metamail(1) and mailcap(5) for more information. fallback parameter may be used to load additional mailcap files without overriding the settings found in the standard files: normally, entries from files loaded with ReadMailcap will override the entries from files loaded previously (and the standard ones are loaded in the very beginning), but this will not happen if this parameter is set to true (default is false). The return value is true if there were no errors in the file or false otherwise.

wxMimeTypesManager::ReadMimeTypes
bool ReadMimeTypes(const wxString& filename) Load additional file containing information about MIME types and associated information in mime.types file format. See metamail(1) and mailcap(5) for more information. The return value is true if there were no errors in the file or false otherwise.

921


CHAPTER 7

wxMiniFrame
A miniframe is a frame with a small title bar. It is suitable for floating toolbars that must not take up too much screen area. Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/minifram.h> Window styles wxICONIZE wxCAPTION Display the frame iconized (minimized) (Windows only). Puts a caption on the frame.

wxDEFAULT_FRAME_STYLE Defined as wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxTHICK_FRAME | wxSYSTEM_MENU | wxCAPTION | wxCLOSE_BOX. wxMINIMIZE wxMINIMIZE_BOX wxMAXIMIZE wxMAXIMIZE_BOX wxCLOSE_BOX wxSTAY_ON_TOP wxSYSTEM_MENU wxTHICK_FRAME Identical to wxICONIZE. Displays a minimize box on the frame (Windows and Motif only). Displays the frame maximized (Windows only). Displays a maximize box on the frame (Windows and Motif only). Displays a close box on the frame. Stay on top of other windows (Windows only). Displays a system menu (Windows and Motif only). Displays a thick frame around the window (Windows and Motif only).

wxTINY_CAPTION_HORIZ This style is obsolete and not used any longer. wxTINY_CAPTION_VERT wxRESIZE_BORDER This style is obsolete and not used any longer. Displays a resizeable border around the window (Motif only; for Windows, it is implicit in wxTHICK_FRAME).

See also window styles overview (p. 1611). Note that all the window styles above are ignored under GTK and the mini frame cannot be resized by the user.

922


CHAPTER 7
Remarks This class has miniframe functionality under Windows and GTK, i.e. the presence of mini frame will not be noted in the task bar and focus behaviour is different. On other platforms, it behaves like a normal frame. See also wxMDIParentFrame (p. 874), wxMDIChildFrame (p. 869), wxFrame (p. 530), wxDialog (p. 367)

wxMiniFrame::wxMiniFrame
wxMiniFrame() Default constructor. wxMiniFrame(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor, creating the window. Parameters parent The window parent. This may be NULL. If it is non-NULL, the frame will always be displayed on top of the parent window on Windows. id The window identifier. It may take a value of -1 to indicate a default value. title The caption to be displayed on the frame's title bar. pos The window position. A value of (-1, -1) indicates a default position, chosen by either the windowing system or wxWindows, depending on platform. size The window size. A value of (-1, -1) indicates a default size, chosen by either the windowing system or wxWindows, depending on platform. style The window style. See wxMiniFrame (p. 922).

923


CHAPTER 7
name The name of the window. This parameter is used to associate a name with the item, allowing the application user to set Motif resource values for individual windows. Remarks The frame behaves like a normal frame on non-Windows platforms. See also wxMiniFrame::Create (p. 924)

wxMiniFrame::~wxMiniFrame
void ~wxMiniFrame() Destructor. Destroys all child windows and menu bar if present.

wxMiniFrame::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Used in two-step frame construction. See wxMiniFrame::wxMiniFrame (p. 923) for further details.

wxMirrorDC
wxMirrorDC is a simple wrapper class which is always associated with a real wxDC (p. 347) object and either forwards all of its operations to it without changes (no mirroring takes place) or exchanges x and y coordinates which makes it possible to reuse the same code to draw a figure and its mirror -- i.e. reflection related to the diagonal line x == y. wxMirrorDC has been added in wxWindows version 2.5.0. Derived from wxDC (p. 347) Include files <wx/dcmirror.h>

924


CHAPTER 7 wxMirrorDC::wxMirrorDC
wxMirrorDC(wxDC& dc, bool mirror) Creates a (maybe) mirrored DC associated with the real dc. Everything drawn on wxMirrorDC will appear (and maybe mirrored) on dc. mirror specifies if we do mirror (if it is true) or not (if it is false).

wxModule
The module system is a very simple mechanism to allow applications (and parts of wxWindows itself) to define initialization and cleanup functions that are automatically called on wxWindows startup and exit. To define a new kind of module, derive a class from wxModule, override the OnInit and OnExit functions, and add the DECLARE_DYNAMIC_CLASS and IMPLEMENT_DYNAMIC_CLASS to header and implementation files (which can be the same file). On initialization, wxWindows will find all classes derived from wxModule, create an instance of each, and call each OnInit function. On exit, wxWindows will call the OnExit function for each module instance. Note that your module class does not have to be in a header file. For example:
// A module to allow DDE initialization/cleanup // without calling these functions from app.cpp or from // the user's application. class wxDDEModule: public wxModule { DECLARE_DYNAMIC_CLASS(wxDDEModule) public: wxDDEModule() {} bool OnInit() { wxDDEInitialize(); return true; }; void OnExit() { wxDDECleanUp(); }; }; IMPLEMENT_DYNAMIC_CLASS(wxDDEModule, wxModule)

Derived from wxObject (p. 954) Include files <wx/module.h>

wxModule::wxModule
wxModule()

925


CHAPTER 7
Constructs a wxModule object.

wxModule::~wxModule
~wxModule() Destructor.

wxModule::CleanupModules
static void CleanupModules() Calls Exit for each module instance. Called by wxWindows on exit, so there is no need for an application to call it.

wxModule::Exit
void Exit() Calls OnExit. This function is called by wxWindows and should not need to be called by an application.

wxModule::Init
bool Init() Calls OnInit. This function is called by wxWindows and should not need to be called by an application.

wxModule::InitializeModules
static bool InitializeModules() Calls Init for each module instance. Called by wxWindows on startup, so there is no need for an application to call it.

wxModule::OnExit
virtual void OnExit() Provide this function with appropriate cleanup for your module.

wxModule::OnInit
virtual bool OnInit()

926


CHAPTER 7
Provide this function with appropriate initialization for your module. If the function returns false, wxWindows will exit immediately.

wxModule::RegisterModule
static void RegisterModule(wxModule* module) Registers this module with wxWindows. Called by wxWindows on startup, so there is no need for an application to call it.

wxModule::RegisterModules
static bool RegisterModules() Creates instances of and registers all modules. Called by wxWindows on startup, so there is no need for an application to call it.

wxMouseCaptureChangedEvent
An mouse capture changed event is sent to a window that loses its mouse capture. This is called even if wxWindow::ReleaseCapture was called by the application code. Handling this event allows an application to cater for unexpected capture releases which might otherwise confuse mouse handling code. This event is implemented under Windows only. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process this event, use the following event handler macro to direct input to a member function that takes a wxMouseCaptureChangedEvent argument. EVT_MOUSE_CAPTURE_CHANGED(func) Process a wxEVT_MOUSE_CAPTURE_CHANGED event. See also Event handling overview (p. 1602), wxWindow::CaptureMouse (p. 1390), wxWindow::ReleaseMouse (p. 1416), wxWindow::GetCapture (p. 1400)

927


CHAPTER 7 wxMouseCaptureChangedEvent::wxMouseCaptureChangedEvent
wxMouseCaptureChangedEvent(wxWindowID windowId = 0, wxWindow* gainedCapture = NULL) Constructor.

wxActivateEvent::GetCapturedWindow
wxWindow* GetCapturedWindow() const Returns the window that gained the capture, or NULL if it was a non-wxWindows window.

wxMouseEvent
This event class contains information about the events generated by the mouse: they include mouse buttons press and release events and mouse move events. All mouse events involving the buttons use wxMOUSE_BTN_LEFT for the left mouse button, wxMOUSE_BTN_MIDDLE for the middle one andwxMOUSE_BTN_RIGHT for the right one. Note that not all mice have a middle button so a portable application should avoid relying on the events from it. NB: Note that under Windows mouse enter and leave events are not natively supported by the system but are generated by wxWindows itself. This has several drawbacks: the LEAVE_WINDOW event might be received some time after the mouse left the window and the state variables for it may have changed during this time. NB: Note the difference between methods likeLeftDown (p. 935) andLeftIsDown (p. 935): the former returns truewhen the event corresponds to the left mouse button click while the latter returns true if the left mouse button is currently being pressed. For example, when the user is dragging the mouse you can useLeftIsDown (p. 935) to test whether the left mouse button is (still) depressed. Also, by convention, ifLeftDown (p. 935) returns true,LeftIsDown (p. 935) will also return true in wxWindows whatever the underlying GUI behaviour is (which is platform-dependent). The same applies, of course, to other mouse buttons as well. Derived from wxEvent (p. 439) Include files <wx/event.h> Event table macros To process a mouse event, use these event handler macros to direct input to member functions that take a wxMouseEvent argument.

928


CHAPTER 7
EVT_LEFT_DOWN(func) EVT_LEFT_UP(func) EVT_LEFT_DCLICK(func) EVT_MIDDLE_DOWN(func) EVT_MIDDLE_UP(func) EVT_MIDDLE_DCLICK(func) EVT_RIGHT_DOWN(func) EVT_RIGHT_UP(func) EVT_RIGHT_DCLICK(func) EVT_MOTION(func) EVT_ENTER_WINDOW(func) EVT_LEAVE_WINDOW(func) EVT_MOUSEWHEEL(func) EVT_MOUSE_EVENTS(func) Process a wxEVT_LEFT_DOWN event. Process a wxEVT_LEFT_UP event. Process a wxEVT_LEFT_DCLICK event. Process a wxEVT_MIDDLE_DOWN event. Process a wxEVT_MIDDLE_UP event. Process a wxEVT_MIDDLE_DCLICK event. Process a wxEVT_RIGHT_DOWN event. Process a wxEVT_RIGHT_UP event. Process a wxEVT_RIGHT_DCLICK event. Process a wxEVT_MOTION event. Process a wxEVT_ENTER_WINDOW event. Process a wxEVT_LEAVE_WINDOW event. Process a wxEVT_MOUSEWHEEL event. Process all mouse events.

wxMouseEvent::m_altDown
bool m_altDown true if the Alt key is pressed down.

wxMouseEvent::m_controlDown
bool m_controlDown true if control key is pressed down.

wxMouseEvent::m_leftDown
bool m_leftDown true if the left mouse button is currently pressed down.

wxMouseEvent::m_middleDown
bool m_middleDown

929


CHAPTER 7
true if the middle mouse button is currently pressed down.

wxMouseEvent::m_rightDown
bool m_rightDown true if the right mouse button is currently pressed down.

wxMouseEvent::m_metaDown
bool m_metaDown true if the Meta key is pressed down.

wxMouseEvent::m_shiftDown
bool m_shiftDown true if shift is pressed down.

wxMouseEvent::m_x
long m_x X-coordinate of the event.

wxMouseEvent::m_y
long m_y Y-coordinate of the event.

wxMouseEvent::m_wheelRotation
int m_wheelRotation The distance the mouse wheel is rotated.

wxMouseEvent::m_wheelDelta
int m_wheelDelta The wheel delta, normally 120.

930


CHAPTER 7 wxMouseEvent::m_linesPerAction
int m_linesPerAction The configured number of lines (or whatever) to be scrolled per wheel action.

wxMouseEvent::wxMouseEvent
wxMouseEvent(WXTYPE mouseEventType = 0, int id = 0) Constructor. Valid event types are:              wxEVT_ENTER_WINDOW wxEVT_LEAVE_WINDOW wxEVT_LEFT_DOWN wxEVT_LEFT_UP wxEVT_LEFT_DCLICK wxEVT_MIDDLE_DOWN wxEVT_MIDDLE_UP wxEVT_MIDDLE_DCLICK wxEVT_RIGHT_DOWN wxEVT_RIGHT_UP wxEVT_RIGHT_DCLICK wxEVT_MOTION wxEVT_MOUSEWHEEL

wxMouseEvent::AltDown
bool AltDown() Returns true if the Alt key was down at the time of the event.

wxMouseEvent::Button
bool Button(int button) Returns true if the identified mouse button is changing state. Valid values of button are:

931


CHAPTER 7
wxMOUSE_BTN_LEFT wxMOUSE_BTN_MIDDLE wxMOUSE_BTN_RIGHT wxMOUSE_BTN_ANY check if left button was pressed check if left button was pressed check if left button was pressed check if any button was pressed

wxMouseEvent::ButtonDClick
bool ButtonDClick(int but = wxMOUSE_BTN_ANY) If the argument is omitted, this returns true if the event was a mouse double click event. Otherwise the argument specifies which double click event was generated (see Button (p. 931) for the possible values).

wxMouseEvent::ButtonDown
bool ButtonDown(int but = -1) If the argument is omitted, this returns true if the event was a mouse button down event. Otherwise the argument specifies which button-down event was generated (see Button (p. 931) for the possible values).

wxMouseEvent::ButtonUp
bool ButtonUp(int but = -1) If the argument is omitted, this returns true if the event was a mouse button up event. Otherwise the argument specifies which button-up event was generated (see Button (p. 931) for the possible values).

wxMouseEvent::ControlDown
bool ControlDown() Returns true if the control key was down at the time of the event.

wxMouseEvent::Dragging
bool Dragging() Returns true if this was a dragging event (motion while a button is depressed). See also Moving (p. 936)

932


CHAPTER 7 wxMouseEvent::Entering
bool Entering() Returns true if the mouse was entering the window. See also wxMouseEvent::Leaving (p. 934).

wxMouseEvent::GetButton
int GetButton() const Returns the mouse button which generated this event or wxMOUSE_BTN_NONE if no button is involved (for mouse move, enter or leave event, for example). Otherwise wxMOUSE_BTN_LEFT is returned for the left button down, up and double click events, wxMOUSE_BTN_MIDDLE and wxMOUSE_BTN_RIGHT for the same events for the middle and the right buttons respectively.

wxMouseEvent::GetPosition
wxPoint GetPosition() const void GetPosition(wxCoord* x, wxCoord* y) const void GetPosition(long* x, long* y) const Sets *x and *y to the position at which the event occurred. Returns the physical mouse position in pixels.

wxMouseEvent::GetLogicalPosition
wxPoint GetLogicalPosition(const wxDC& dc) const Returns the logical mouse position in pixels (i.e. translated according to the translation set for the DC, which usually indicates that the window has been scrolled).

wxMouseEvent::GetLinesPerAction
int GetLinesPerAction() const Returns the configured number of lines (or whatever) to be scrolled per wheel action. Defaults to three.

wxMouseEvent::GetWheelRotation
int GetWheelRotation() const

933


CHAPTER 7
Get wheel rotation, positive or negative indicates direction of rotation. Current devices all send an event when rotation is equal to +/-WheelDelta, but this allows for finer resolution devices to be created in the future. Because of this you shouldn't assume that one event is equal to 1 line or whatever, but you should be able to either do partial line scrolling or wait until +/-WheelDelta rotation values have been accumulated before scrolling.

wxMouseEvent::GetWheelDelta
int GetWheelDelta() const Get wheel delta, normally 120. This is the threshold for action to be taken, and one such action (for example, scrolling one increment) should occur for each delta.

wxMouseEvent::GetX
long GetX() const Returns X coordinate of the physical mouse event position.

wxMouseEvent::GetY
long GetY() Returns Y coordinate of the physical mouse event position.

wxMouseEvent::IsButton
bool IsButton() const Returns true if the event was a mouse button event (not necessarily a button down event - that may be tested using ButtonDown).

wxMouseEvent::IsPageScroll
bool IsPageScroll() const Returns true if the system has been setup to do page scrolling with the mouse wheel instead of line scrolling.

wxMouseEvent::Leaving
bool Leaving() const Returns true if the mouse was leaving the window.

934


CHAPTER 7
See also wxMouseEvent::Entering (p. 933).

wxMouseEvent::LeftDClick
bool LeftDClick() const Returns true if the event was a left double click.

wxMouseEvent::LeftDown
bool LeftDown() const Returns true if the left mouse button changed to down.

wxMouseEvent::LeftIsDown
bool LeftIsDown() const Returns true if the left mouse button is currently down, independent of the current event type. Please notice that it is not the same asLeftDown (p. 935) which returns true if the left mouse button was just pressed. Rather, it describes the state of the mouse button before the event happened. This event is usually used in the mouse event handlers which process "move mouse" messages to determine whether the user is (still) dragging the mouse.

wxMouseEvent::LeftUp
bool LeftUp() const Returns true if the left mouse button changed to up.

wxMouseEvent::MetaDown
bool MetaDown() const Returns true if the Meta key was down at the time of the event.

wxMouseEvent::MiddleDClick
bool MiddleDClick() const Returns true if the event was a middle double click.

935


CHAPTER 7 wxMouseEvent::MiddleDown
bool MiddleDown() const Returns true if the middle mouse button changed to down.

wxMouseEvent::MiddleIsDown
bool MiddleIsDown() const Returns true if the middle mouse button is currently down, independent of the current event type.

wxMouseEvent::MiddleUp
bool MiddleUp() const Returns true if the middle mouse button changed to up.

wxMouseEvent::Moving
bool Moving() const Returns true if this was a motion event and no mouse buttons were pressed. If any mouse button is held pressed, then this method returns false and Dragging (p. 932) returns true.

wxMouseEvent::RightDClick
bool RightDClick() const Returns true if the event was a right double click.

wxMouseEvent::RightDown
bool RightDown() const Returns true if the right mouse button changed to down.

wxMouseEvent::RightIsDown
bool RightIsDown() const Returns true if the right mouse button is currently down, independent of the current event type.

936


CHAPTER 7 wxMouseEvent::RightUp
bool RightUp() const Returns true if the right mouse button changed to up.

wxMouseEvent::ShiftDown
bool ShiftDown() const Returns true if the shift key was down at the time of the event.

wxMoveEvent
A move event holds information about move change events. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a move event, use this event handler macro to direct input to a member function that takes a wxMoveEvent argument. EVT_MOVE(func) See also wxPoint (p. 991), Event handling overview (p. 1602) Process a wxEVT_MOVE event, which is generated when a window is moved.

wxMoveEvent::wxMoveEvent
wxMoveEvent(const wxPoint& pt, int id = 0) Constructor.

wxMoveEvent::GetPosition
wxPoint GetPosition() const

937


CHAPTER 7
Returns the position of the window generating the move change event.

wxMultipleChoiceDialog
This class represents a dialog that shows a list of strings, and allows the user to select one or more. NOTE: this class is not yet implemented. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/choicdlg.h> See also wxMultipleChoiceDialog overview (p. 1651)

wxMutex
A mutex object is a synchronization object whose state is set to signaled when it is not owned by any thread, and nonsignaled when it is owned. Its name comes from its usefulness in coordinating mutually-exclusive access to a shared resource as only one thread at a time can own a mutex object. Mutexes may be recursive in the sense that a thread can lock a mutex which it had already locked before (instead of dead locking the entire process in this situation by starting to wait on a mutex which will never be released while the thread is waiting) but using them is not recommended and they are notrecursive by default. The reason for this is that recursive mutexes are not supported by all Unix flavours and, worse, they cannot be used with wxCondition (p. 173). For example, when several thread use the data stored in the linked list, modifications to the list should be only allowed to one thread at a time because during a new node addition the list integrity is temporarily broken (this is also called program invariant). Example
// this variable has an "s_" prefix because it is static: seeing an "s_" in // a multithreaded program is in general a good sign that you should use a // mutex (or a critical section) static wxMutex *s_mutexProtectingTheGlobalData;

938


CHAPTER 7

// we store some numbers in this global array which is presumably used by // several threads simultaneously wxArrayInt s_data; void MyThread::AddNewNode(int num) { // ensure that no other thread accesses the list s_mutexProtectingTheGlobalList->Lock(); s_data.Add(num); s_mutexProtectingTheGlobalList->Unlock(); } // return true the given number is greater than all array elements bool MyThread::IsGreater(int num) { // before using the list we must acquire the mutex wxMutexLocker lock(s_mutexProtectingTheGlobalData); size_t count = s_data.Count(); for ( size_t n = 0; n < count; n++ ) { if ( s_data[n] > num ) return false; } return true; }

Notice how wxMutexLocker was used in the second function to ensure that the mutex is unlocked in any case: whether the function returns true or false (because the destructor of the local object lock is always called). Using this class instead of directly using wxMutex is, in general safer and is even more so if your program uses C++ exceptions. Constants
enum wxMutexType { // normal mutex: try to always use this one wxMUTEX_DEFAULT, // recursive mutex: don't use these ones with wxCondition wxMUTEX_RECURSIVE };

Derived from None. Include files <wx/thread.h> See also wxThread (p. 1284), wxCondition (p. 173), wxMutexLocker (p. 941), wxCriticalSection (p. 206)

939


CHAPTER 7 wxMutex::wxMutex
wxMutex(wxMutexType type = wxMUTEX_DEFAULT) Default constructor.

wxMutex::~wxMutex
~wxMutex() Destroys the wxMutex object.

wxMutex::Lock
wxMutexError Lock() Locks the mutex object. Return value One of: wxMUTEX_NO_ERROR wxMUTEX_DEAD_LOCK wxMUTEX_BUSY There was no error. A deadlock situation was detected. The mutex is already locked by another thread.

wxMutex::TryLock
wxMutexError TryLock() Tries to lock the mutex object. If it can't, returns immediately with an error. Return value One of: wxMUTEX_NO_ERROR wxMUTEX_DEAD_LOCK wxMUTEX_BUSY There was no error. A deadlock situation was detected. The mutex is already locked by another thread.

wxMutex::Unlock
wxMutexError Unlock() Unlocks the mutex object.

940


CHAPTER 7
Return value One of: wxMUTEX_NO_ERROR wxMUTEX_DEAD_LOCK wxMUTEX_BUSY wxMUTEX_UNLOCKED There was no error. A deadlock situation was detected. The mutex is already locked by another thread. The calling thread tries to unlock an unlocked mutex.

wxMutexLocker
This is a small helper class to be used with wxMutex (p. 938) objects. A wxMutexLocker acquires a mutex lock in the constructor and releases (or unlocks) the mutex in the destructor making it much more difficult to forget to release a mutex (which, in general, will promptly lead to the serious problems). See wxMutex (p. 938) for an example of wxMutexLocker usage. Derived from None. Include files <wx/thread.h> See also wxMutex (p. 938), wxCriticalSectionLocker (p. 207)

wxMutexLocker::wxMutexLocker
wxMutexLocker(wxMutex& mutex) Constructs a wxMutexLocker object associated with mutex and locks it. Call IsLocked (p. 941) to check if the mutex was successfully locked.

wxMutexLocker::~wxMutexLocker
~wxMutexLocker() Destructor releases the mutex if it was successfully acquired in the ctor.

wxMutexLocker::IsOk 941


CHAPTER 7
bool IsOk() const Returns true if mutex was acquired in the constructor, false otherwise.

wxNode
wxNodeBase is the node structure used in linked lists (see wxList (p. 786)) and derived classes. You should never use wxNodeBase class directly, however, because it works with untyped (void *) data and this is unsafe. Use wxNodeBase-derived classes which are automatically defined by WX_DECLARE_LIST and WX_DEFINE_LIST macros instead as described inwxList (p. 786) documentation (see example there). Also note that although there is a class called wxNode, it is defined for backwards compatibility only and usage of this class is strongly deprecated. In the documentation below, the type T should be thought of as a "template'' parameter: this is the type of data stored in the linked list or, in other words, the first argument of WX_DECLARE_LIST macro. Also, wxNode is written as wxNode<T> even though it isn't really a template class -- but it helps to think of it as if it were. Derived from None. Include files <wx/list.h> See also wxList (p. 786), wxHashTable (p. 642)

wxNode<T>::GetData
T * GetData() const Retrieves the client data pointer associated with the node.

wxNode<T>::GetNext
wxNode<T> * GetNext() const Retrieves the next node or NULL if this node is the last one.

wxNode<T>::GetPrevious
wxNode<T> * GetPrevious()

942


CHAPTER 7
Retrieves the previous node or NULL if this node is the first one in the list.

wxNode<T>::SetData
void SetData(T *data) Sets the data associated with the node (usually the pointer will have been set when the node was created).

wxNode<T>::IndexOf
int IndexOf() Returns the zero-based index of this node within the list. The return value will be NOT_FOUND if the node has not been added to a list yet.

wxNotebook
This class represents a notebook control, which manages multiple windows with associated tabs. To use the class, create a wxNotebook object and call AddPage (p. 945) or InsertPage (p. 948), passing a window to be used as the page. Do not explicitly delete the window for a page that is currently managed by wxNotebook. wxNotebookPage is a typedef for wxWindow. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/notebook.h> Window styles wxNB_LEFT wxNB_RIGHT wxNB_BOTTOM wxNB_FIXEDWIDTH Place tabs on the left side. Not supported under Windows XP. Place tabs on the right side. Not supported under Windows XP. Place tabs under instead of above the notebook pages. Not supported under Windows XP. (Windows only) All tabs will have same width.

943


CHAPTER 7
wxNB_MULTILINE (Windows only) There can be several rows of tabs.

See also window styles overview (p. 1611). Event handling To process input from a notebook control, use the following event handler macros to direct input to member functions that take a wxNotebookEvent (p. 950) argument. EVT_NOTEBOOK_PAGE_CHANGED(id, func) The page selection was changed. Processes a wxEVT_COMMAND_NOTEBOOK_PAGE_CH ANGED event. EVT_NOTEBOOK_PAGE_CHANGING(id, func) The page selection is about to be changed. Processes a wxEVT_COMMAND_NOTEBOOK_PAGE_CH ANGING event. This event can be vetoed (p. 954). See also wxNotebookEvent (p. 950), wxImageList (p. 754), wxTabCtrl (p. 1234)

wxNotebook::wxNotebook
wxNotebook() Default constructor. wxNotebook(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "notebook") Constructs a notebook control. Note that sometimes you can reduce flicker by passing the wxCLIP_CHILDREN window style. Parameters parent The parent window. Must be non-NULL. id The window identifier. pos

944


CHAPTER 7
The window position. size The window size. style The window style. See wxNotebook (p. 943). name The name of the control (used only under Motif).

wxNotebook::~wxNotebook
~wxNotebook() Destroys the wxNotebook object.

wxNotebook::AddPage
bool AddPage(wxNotebookPage* page, const wxString& text, bool select = false, int imageId = -1) Adds a new page. The call to this function may generate the page changing events. Parameters page Specifies the new page. text Specifies the text for the new page. select Specifies whether the page should be selected. imageId Specifies the optional image index for the new page. Return value true if successful, false otherwise. Remarks

945


CHAPTER 7
Do not delete the page, it will be deleted by the notebook. See also wxNotebook::InsertPage (p. 948)

wxNotebook::AdvanceSelection
void AdvanceSelection(bool forward = true) Cycles through the tabs. The call to this function generates the page changing events.

wxNotebook::AssignImageList
void AssignImageList(wxImageList* imageList) Sets the image list for the page control and takes ownership of the list. See also wxImageList (p. 754),SetImageList (p. 949)

wxNotebook::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size, long style = 0, const wxString& name = "notebook") Creates a notebook control. See wxNotebook::wxNotebook (p. 944) for a description of the parameters.

wxNotebook::DeleteAllPages
bool DeleteAllPages() Deletes all pages.

wxNotebook::DeletePage
bool DeletePage(size_t page) Deletes the specified page, and the associated window. The call to this function generates the page changing events.

946


CHAPTER 7 wxNotebook::GetImageList
wxImageList* GetImageList() const Returns the associated image list. See also wxImageList (p. 754), wxNotebook::SetImageList (p. 949)

wxNotebook::GetPage
wxNotebookPage* GetPage(size_t page) Returns the window at the given page position.

wxNotebook::GetPageCount
size_t GetPageCount() const Returns the number of pages in the notebook control.

wxNotebook::GetPageImage
int GetPageImage(size_t nPage) const Returns the image index for the given page.

wxNotebook::GetPageText
wxString GetPageText(size_t nPage) const Returns the string for the given page.

wxNotebook::GetRowCount
int GetRowCount() const Returns the number of rows in the notebook control.

wxNotebook::GetSelection
int GetSelection() const Returns the currently selected page, or -1 if none was selected.

947


CHAPTER 7
Note that this method may return either the previously or newly selected page when called from the EVT_NOTEBOOK_PAGE_CHANGED handler depending on the platform and so wxNotebookEvent::GetSelection (p. 952) should be used instead in this case.

wxNotebook::HitTest
int HitTest(const wxPoint& pt, long *flags = NULL) Returns the index of the tab at the specified position or wxNOT_FOUND if none. If flags parameter is non NULL, the position of the point inside the tab is returned as well. NB: This method is currently only implemented under wxMSW and wxUniv. Parameters pt Specifies the point for the hit test. flags Return value for detailed information. One of the following values:wxNB_HITTEST_NOWHERE There was no tab under this point. wxNB_HITTEST_ONICON wxNB_HITTEST_ONLABEL wxNB_HITTEST_ONITEM The point was over an icon (currently wxMSW only). The point was over a label (currently wxMSW only). The point was over an item, but not on the label or icon.

Return value Returns the zero-based tab index or wxNOT_FOUND if there is no tab is at the specified position.

wxNotebook::InsertPage
bool InsertPage(size_t index, wxNotebookPage* page, const wxString& text, bool select = false, int imageId = -1) Inserts a new page at the specified position. Parameters index Specifies the position for the new page.

948


CHAPTER 7
page Specifies the new page. text Specifies the text for the new page. select Specifies whether the page should be selected. imageId Specifies the optional image index for the new page. Return value true if successful, false otherwise. Remarks Do not delete the page, it will be deleted by the notebook. See also wxNotebook::AddPage (p. 945)

wxNotebook::OnSelChange
void OnSelChange(wxNotebookEvent& event) An event handler function, called when the page selection is changed. See also wxNotebookEvent (p. 950)

wxNotebook::RemovePage
bool RemovePage(size_t page) Deletes the specified page, without deleting the associated window.

wxNotebook::SetImageList
void SetImageList(wxImageList* imageList) Sets the image list for the page control. It does not take ownership of the image list, you must delete it yourself. See also

949


CHAPTER 7
wxImageList (p. 754),AssignImageList (p. 946)

wxNotebook::SetPadding
void SetPadding(const wxSize& padding) Sets the amount of space around each page's icon and label, in pixels. NB: The vertical padding cannot be changed in wxGTK.

wxNotebook::SetPageSize
void SetPageSize(const wxSize& size) Sets the width and height of the pages. NB: This method is currently not implemented for wxGTK.

wxNotebook::SetPageImage
bool SetPageImage(size_t page, int image) Sets the image index for the given page. image is an index into the image list which was set with wxNotebook::SetImageList (p. 949).

wxNotebook::SetPageText
bool SetPageText(size_t page, const wxString& text) Sets the text for the given page.

wxNotebook::SetSelection
int SetSelection(size_t page) Sets the selection for the given page, returning the previous selection. The call to this function generates the page changing events. See also wxNotebook::GetSelection (p. 947)

wxNotebookEvent
This class represents the events generated by a notebook control: currently, there are

950


CHAPTER 7
two of them. The PAGE_CHANGING event is sent before the current page is changed. It allows to the program to examine the current page (which can be retrieved with GetOldSelection() (p. 952)) and to veto the page change by calling Veto() (p. 954) if, for example, the current values in the controls of the old page are invalid. The second event - PAGE_CHANGED - is sent after the page has been changed and the program cannot veto it any more, it just informs it about the page change. To summarize, if the program is interested in validating the page values before allowing the user to change it, it should process the PAGE_CHANGING event, otherwise PAGE_CHANGED is probably enough. In any case, it is probably unnecessary to process both events at once. Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/notebook.h> Event handling To process input from a notebook control, use the following event handler macros to direct input to member functions that take a wxNotebookEvent (p. 950) argument. EVT_NOTEBOOK_PAGE_CHANGED(id, func) The page selection was changed. Processes a wxEVT_COMMAND_NOTEBOOK_PAGE_CH ANGED event. EVT_NOTEBOOK_PAGE_CHANGING(id, func) The page selection is about to be changed. Processes a wxEVT_COMMAND_NOTEBOOK_PAGE_CH ANGING event. This event can be vetoed (p. 954). See also wxNotebook (p. 943), wxTabCtrl (p. 1234), wxTabEvent (p. 1239)

wxNotebookEvent::wxNotebookEvent
wxNotebookEvent(wxEventType eventType = wxEVT_NULL, int id = 0, int sel = -1, int oldSel = -1) Constructor (used internally by wxWindows only).

951


CHAPTER 7 wxNotebookEvent::GetOldSelection
int GetOldSelection() const Returns the page that was selected before the change, -1 if none was selected.

wxNotebookEvent::GetSelection
int GetSelection() const Returns the currently selected page, or -1 if none was selected. NB: under Windows, GetSelection() will return the same value as GetOldSelection() (p. 952) when called fromEVT_NOTEBOOK_PAGE_CHANGING handler and not the page which is going to be selected.

wxNotebookEvent::SetOldSelection
void SetOldSelection(int page) Sets the id of the page selected before the change.

wxNotebookEvent::SetSelection
void SetSelection(int page) Sets the selection member variable. See also wxNotebookEvent::GetSelection (p. 952)

wxNotebookSizer
wxNotebookSizer is a specialized sizer to make sizers work in connection with using notebooks. This sizer is different from any other sizer as you must not add any children to it - instead, it queries the notebook class itself. The only thing this sizer does is to determine the size of the biggest page of the notebook and report an adjusted minimal size to a more toplevel sizer. For more information, please see Programming with wxNotebookSizer (p. 1626). Derived from wxSizer (p. 1109) wxObject (p. 954) See also

952


CHAPTER 7
wxSizer (p. 1109), wxNotebook (p. 943), Sizer overview (p. 1620)

wxNotebookSizer::wxNotebookSizer
wxNotebookSizer(wxNotebook* notebook) Constructor. It takes an associated notebook as its only parameter.

wxNotebookSizer::GetNotebook
wxNotebook* GetNotebook() Returns the notebook associated with the sizer.

wxNotifyEvent
This class is not used by the event handlers by itself, but is a base class for other event classes (such as wxNotebookEvent (p. 950)). It (or an object of a derived class) is sent when the controls state is being changed and allows the program to Veto() (p. 954) this change if it wants to prevent it from happening. Derived from wxCommandEvent (p. 164) wxEvent (p. 439) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/event.h> Event table macros None See also wxNotebookEvent (p. 950)

wxNotifyEvent::wxNotifyEvent
wxNotifyEvent(wxEventType eventType = wxEVT_NULL, int id = 0)

953


CHAPTER 7
Constructor (used internally by wxWindows only).

wxNotifyEvent::Allow
void Allow() This is the opposite of Veto() (p. 954): it explicitly allows the event to be processed. For most events it is not necessary to call this method as the events are allowed anyhow but some are forbidden by default (this will be mentioned in the corresponding event description).

wxNotifyEvent::IsAllowed
bool IsAllowed() const Returns true if the change is allowed (Veto() (p. 954) hasn't been called) or false otherwise (if it was).

wxNotifyEvent::Veto
void Veto() Prevents the change announced by this event from happening. It is in general a good idea to notify the user about the reasons for vetoing the change because otherwise the applications behaviour (which just refuses to do what the user wants) might be quite surprising.

wxObject
This is the root class of all wxWindows classes. It declares a virtual destructor which ensures that destructors get called for all derived class objects where necessary. wxObject is the hub of a dynamic object creation scheme, enabling a program to create instances of a class only knowing its string class name, and to query the class hierarchy. The class contains optional debugging versions of new and delete, which can help trace memory allocation and deallocation problems. wxObject can be used to implement reference counted objects, such as wxPen, wxBitmap and others. See also wxClassInfo (p. 130), Debugging overview (p. 1598), wxObjectRefData (p. 958)

954


CHAPTER 7 wxObject::wxObject
wxObject() wxObject(const wxObject& other) Default and copy constructors.

wxObject::~wxObject
wxObject() Destructor. Performs dereferencing, for those objects that use reference counting.

wxObject::m_refData
wxObjectRefData* m_refData Pointer to an object which is the object's reference-counted data. See also wxObject::Ref (p. 956), wxObject::UnRef (p. 957), wxObject::SetRefData (p. 957), wxObject::GetRefData (p. 956), wxObjectRefData (p. 958)

wxObject::Dump
void Dump(ostream& stream) A virtual function that may be redefined by derived classes to allow dumping of memory states. This function is only defined in debug build and doesn't exist at all if__WXDEBUG__ is not defined. Parameters stream Stream on which to output dump information. Remarks Currently wxWindows does not define Dump for derived classes, but programmers may wish to use it for their own applications. Be sure to call the Dump member of the class's base class to allow all information to be dumped. The implementation of this function in wxObject just writes the class name of the object.

955


CHAPTER 7 wxObject::GetClassInfo
wxClassInfo * GetClassInfo() This virtual function is redefined for every class that requires run-time type information, when using DECLARE_CLASS macros.

wxObject::GetRefData
wxObjectRefData* GetRefData() const Returns the m_refData pointer. See also wxObject::Ref (p. 956), wxObject::UnRef (p. 957), wxObject::m_refData (p. 955), wxObject::SetRefData (p. 957), wxObjectRefData (p. 958)

wxObject::IsKindOf
bool IsKindOf(wxClassInfo *info) Determines whether this class is a subclass of (or the same class as) the given class. Parameters info A pointer to a class information object, which may be obtained by using the CLASSINFO macro. Return value true if the class represented by info is the same class as this one or is derived from it. Example
bool tmp = obj->IsKindOf(CLASSINFO(wxFrame));

wxObject::Ref
void Ref(const wxObject& clone) Makes this object refer to the data in clone. Parameters clone The object to 'clone'.

956


CHAPTER 7
Remarks First this function calls wxObject::UnRef (p. 957) on itself to decrement (and perhaps free) the data it is currently referring to. It then sets its own m_refData to point to that of clone, and increments the reference count inside the data. See also wxObject::UnRef (p. 957), wxObject::m_refData (p. 955), wxObject::SetRefData (p. 957), wxObject::GetRefData (p. 956), wxObjectRefData (p. 958)

wxObject::SetRefData
void SetRefData(wxObjectRefData* data) Sets the m_refData pointer. See also wxObject::Ref (p. 956), wxObject::UnRef (p. 957), wxObject::m_refData (p. 955), wxObject::GetRefData (p. 956), wxObjectRefData (p. 958)

wxObject::UnRef
void UnRef() Decrements the reference count in the associated data, and if it is zero, deletes the data. The m_refData member is set to NULL. See also wxObject::Ref (p. 956), wxObject::m_refData (p. 955), wxObject::SetRefData (p. 957), wxObject::GetRefData (p. 956), wxObjectRefData (p. 958)

wxObject::operator new
void * new(size_t size, const wxString& filename = NULL, int lineNum = 0) The new operator is defined for debugging versions of the library only, when the identifier __WXDEBUG__ is defined. It takes over memory allocation, allowing wxDebugContext operations.

wxObject::operator delete
void delete(void buf) The delete operator is defined for debugging versions of the library only, when the

957


CHAPTER 7
identifier __WXDEBUG__ is defined. It takes over memory deallocation, allowing wxDebugContext operations.

wxObjectRefData
This class is used to store reference-counted data. Derive classes from this to store your own data. When retrieving information from a wxObject's reference data, you will need to cast to your own derived class. Friends wxObject (p. 954) See also wxObject (p. 954)

wxObjectRefData::m_count
int m_count Reference count. When this goes to zero during a wxObject::UnRef (p. 957), an object can delete the wxObjectRefData object.

wxObjectRefData::wxObjectRefData
wxObjectRefData() Default constructor. Initialises the m_count member to 1.

wxObjectRefData::~wxObjectRefData
wxObjectRefData() Destructor.

wxOutputStream
wxOutputStream is an abstract base class which may not be used directly. Derived from wxStreamBase (p. 1191) Include files

958


CHAPTER 7
<wx/stream.h>

wxOutputStream::wxOutputStream
wxOutputStream() Creates a dummy wxOutputStream object.

wxOutputStream::~wxOutputStream
~wxOutputStream() Destructor.

wxOutputStream::LastWrite
size_t LastWrite() const Returns the number of bytes written during the last Write().

wxOutputStream::PutC
void PutC(char c) Puts the specified character in the output queue and increments the stream position.

wxOutputStream::SeekO
off_t SeekO(off_t pos, wxSeekMode mode) Changes the stream current position.

wxOutputStream::TellO
off_t TellO() const Returns the current stream position.

wxOutputStream::Write
wxOutputStream& Write(const void *buffer, size_t size) Writes the specified amount of bytes using the data of buffer. WARNING! The buffer

959


CHAPTER 7
absolutely needs to have at least the specified size. This function returns a reference on the current object, so the user can test any states of the stream right away. wxOutputStream& Write(wxInputStream& stream_in) Reads data from the specified input stream and stores them in the current stream. The data is read until an error is raised by one of the two streams.

wxPageSetupDialog
This class represents the page setup common dialog. The page setup dialog is standard from Windows 95 on, replacing the print setup dialog (which is retained in Windows and wxWindows for backward compatibility). On Windows 95 and NT 4.0 and above, the page setup dialog is native to the windowing system, otherwise it is emulated. The page setup dialog contains controls for paper size (A4, A5 etc.), orientation (landscape or portrait), and controls for setting left, top, right and bottom margin sizes in millimetres. When the dialog has been closed, you need to query the wxPageSetupDialogData (p. 961) object associated with the dialog. Note that the OK and Cancel buttons do not destroy the dialog; this must be done by the application. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/printdlg.h> See also wxPrintDialog (p. 1002), wxPageSetupDialogData (p. 961)

wxPageSetupDialog::wxPageSetupDialog
wxPageSetupDialog(wxWindow* parent, wxPageSetupDialogData* data = NULL) Constructor. Pass a parent window, and optionally a pointer to a block of page setup data, which will be copied to the print dialog's internal data.

960


CHAPTER 7 wxPageSetupDialog::~wxPageSetupDialog
~wxPageSetupDialog() Destructor.

wxPageSetupDialog::GetPageSetupData
wxPageSetupDialogData& GetPageSetupData() Returns the page setup data (p. 961) associated with the dialog.

wxPageSetupDialog::ShowModal
int ShowModal() Shows the dialog, returning wxID_OK if the user pressed OK, and wxID_CANCEL otherwise.

wxPageSetupDialogData
This class holds a variety of information related to wxPageSetupDialog (p. 960). It contains a wxPrintData (p. 996) member which is used to hold basic printer configuration data (as opposed to the user-interface configuration settings stored by wxPageSetupDialogData). Derived from wxObject (p. 954) Include files <wx/cmndata.h> See also wxPageSetupDialog (p. 960)

wxPageSetupDialogData::wxPageSetupDialogData
wxPageSetupDialogData() Default constructor. wxPageSetupDialogData(wxPageSetupDialogData& data)

961


CHAPTER 7
Copy constructor. wxPageSetupDialogData(wxPrintData& printData) Construct an object from a print data object.

wxPageSetupDialogData::~wxPageSetupDialogData
~wxPageSetupDialogData() Destructor.

wxPageSetupDialogData::EnableHelp
void EnableHelp(bool flag) Enables or disables the 'Help' button (Windows only).

wxPageSetupDialogData::EnableMargins
void EnableMargins(bool flag) Enables or disables the margin controls (Windows only).

wxPageSetupDialogData::EnableOrientation
void EnableOrientation(bool flag) Enables or disables the orientation control (Windows only).

wxPageSetupDialogData::EnablePaper
void EnablePaper(bool flag) Enables or disables the paper size control (Windows only).

wxPageSetupDialogData::EnablePrinter
void EnablePrinter(bool flag) Enables or disables the Printer button, which invokes a printer setup dialog.

wxPageSetupDialogData::GetDefaultMinMargins
bool GetDefaultMinMargins() const

962


CHAPTER 7
Returns true if the page setup dialog will take its minimum margin values from the currently selected printer properties. Windows only.

wxPageSetupDialogData::GetEnableMargins
bool GetEnableMargins() const Returns true if the margin controls are enabled (Windows only).

wxPageSetupDialogData::GetEnableOrientation
bool GetEnableOrientation() const Returns true if the orientation control is enabled (Windows only).

wxPageSetupDialogData::GetEnablePaper
bool GetEnablePaper() const Returns true if the paper size control is enabled (Windows only).

wxPageSetupDialogData::GetEnablePrinter
bool GetEnablePrinter() const Returns true if the printer setup button is enabled.

wxPageSetupDialogData::GetEnableHelp
bool GetEnableHelp() const Returns true if the printer setup button is enabled.

wxPageSetupDialogData::GetDefaultInfo
bool GetDefaultInfo() const Returns true if the dialog will simply return default printer information (such as orientation) instead of showing a dialog. Windows only.

wxPageSetupDialogData::GetMarginTopLeft
wxPoint GetMarginTopLeft() const Returns the left (x) and top (y) margins in millimetres.

963


CHAPTER 7 wxPageSetupDialogData::GetMarginBottomRight
wxPoint GetMarginBottomRight() const Returns the right (x) and bottom (y) margins in millimetres.

wxPageSetupDialogData::GetMinMarginTopLeft
wxPoint GetMinMarginTopLeft() const Returns the left (x) and top (y) minimum margins the user can enter (Windows only). Units are in millimetres

wxPageSetupDialogData::GetMinMarginBottomRight
wxPoint GetMinMarginBottomRight() const Returns the right (x) and bottom (y) minimum margins the user can enter (Windows only). Units are in millimetres

wxPageSetupDialogData::GetPaperId
wxPaperSize GetPaperId() const Returns the paper id (stored in the internal wxPrintData object). For further information, see wxPrintData::SetPaperId (p. 1000).

wxPageSetupDialogData::GetPaperSize
wxSize GetPaperSize() const Returns the paper size in millimetres.

wxPageSetupDialogData::GetPrintData
wxPrintData& GetPrintData() Returns a reference to the print data (p. 996) associated with this object.

wxPageSetupDialogData::Ok
bool Ok() const Returns true if the print data associated with the dialog data is valid. This can return false on Windows if the current printer is not set, for example. On all other platforms, it

964


CHAPTER 7
returns true.

wxPageSetupDialogData::SetDefaultInfo
void SetDefaultInfo(bool flag) Pass true if the dialog will simply return default printer information (such as orientation) instead of showing a dialog. Windows only.

wxPageSetupDialogData::SetDefaultMinMargins
void SetDefaultMinMargins(bool flag) Pass true if the page setup dialog will take its minimum margin values from the currently selected printer properties. Windows only. Units are in millimetres

wxPageSetupDialogData::SetMarginTopLeft
void SetMarginTopLeft(const wxPoint& pt) Sets the left (x) and top (y) margins in millimetres.

wxPageSetupDialogData::SetMarginBottomRight
void SetMarginBottomRight(const wxPoint& pt) Sets the right (x) and bottom (y) margins in millimetres.

wxPageSetupDialogData::SetMinMarginTopLeft
void SetMinMarginTopLeft(const wxPoint& pt) Sets the left (x) and top (y) minimum margins the user can enter (Windows only). Units are in millimetres.

wxPageSetupDialogData::SetMinMarginBottomRight
void SetMinMarginBottomRight(const wxPoint& pt) Sets the right (x) and bottom (y) minimum margins the user can enter (Windows only). Units are in millimetres.

wxPageSetupDialogData::SetPaperId
void SetPaperId(wxPaperSize& id)

965


CHAPTER 7
Sets the paper size id. For further information, see wxPrintData::SetPaperId (p. 1000). Calling this function overrides the explicit paper dimensions passed in wxPageSetupDialogData::SetPaperSize (p. 966).

wxPageSetupDialogData::SetPaperSize
void SetPaperSize(const wxSize& size) Sets the paper size in millimetres. If a corresponding paper id is found, it will be set in the internal wxPrintData object, otherwise the paper size overrides the paper id.

wxPageSetupDialogData::SetPrintData
void SetPrintData(const wxPrintData& printData) Sets the print data (p. 996) associated with this object.

wxPageSetupDialogData::operator =
void operator =(const wxPrintData& data) Assigns print data to this object. void operator =(const wxPageSetupDialogData& data) Assigns page setup data to this object.

wxPaintDC
A wxPaintDC must be constructed if an application wishes to paint on the client area of a window from within an OnPaint event. This should normally be constructed as a temporary stack object; don't store a wxPaintDC object. If you have an OnPaint handler, you must create a wxPaintDC object within it even if you don't actually use it. Using wxPaintDC within OnPaint is important because it automatically sets the clipping area to the damaged area of the window. Attempts to draw outside this area do not appear. To draw on a window from outside OnPaint, construct a wxClientDC (p. 133) object. To draw on the whole window including decorations, construct a wxWindowDC (p. 1436) object (Windows only). Derived from wxWindowDC (p. 1436) wxDC (p. 347)

966


CHAPTER 7
Include files <wx/dcclient.h> See also wxDC (p. 347), wxMemoryDC (p. 881), wxPaintDC (p. 966), wxWindowDC (p. 1436), wxScreenDC (p. 1072)

wxPaintDC::wxPaintDC
wxPaintDC(wxWindow* window) Constructor. Pass a pointer to the window on which you wish to paint.

wxPaintEvent
A paint event is sent when a window's contents needs to be repainted. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a paint event, use this event handler macro to direct input to a member function that takes a wxPaintEvent argument. EVT_PAINT(func) See also Event handling overview (p. 1602) Remarks Note that In a paint event handler, the application must always create a wxPaintDC (p. 966) object, even if you do not use it. Otherwise, under MS Windows, refreshing for this and other windows will go wrong. For example:
void MyWindow::OnPaint(wxPaintEvent& event) { wxPaintDC dc(this); DrawMyDocument(dc); }

Process a wxEVT_PAINT event.

967


CHAPTER 7

You can optimize painting by retrieving the rectangles that have been damaged and only repainting these. The rectangles are in terms of the client area, and are unscrolled, so you will need to do some calculations using the current view position to obtain logical, scrolled units. Here is an example of using the wxRegionIterator (p. 1057) class:
// Called when window needs to be repainted. void MyWindow::OnPaint(wxPaintEvent& event) { wxPaintDC dc(this); // Find Out where the window is scrolled to int vbX,vbY; // Top left corner of client GetViewStart(&vbX,&vbY); int vX,vY,vW,vH; // Dimensions of client area in pixels wxRegionIterator upd(GetUpdateRegion()); // get the update rect list while (upd) { vX = upd.GetX(); vY = upd.GetY(); vW = upd.GetW(); vH = upd.GetH(); // Alternatively we can do this: // wxRect rect(upd.GetRect()); // Repaint this rectangle ...some code... upd ++ ; } }

wxPaintEvent::wxPaintEvent
wxPaintEvent(int id = 0) Constructor.

wxPalette
A palette is a table that maps pixel values to RGB colours. It allows the colours of a lowdepth bitmap, for example, to be mapped to the available colours in a display. Derived from wxGDIObject (p. 560) wxObject (p. 954) Include files <wx/palette.h>

968


CHAPTER 7
Predefined objects Objects: wxNullPalette See also wxDC::SetPalette (p. 363), wxBitmap (p. 67)

wxPalette::wxPalette
wxPalette() Default constructor. wxPalette(const wxPalette& palette) Copy constructor. This uses reference counting so is a cheap operation. wxPalette(int n, const unsigned char* red, const unsigned char* green, const unsigned char* blue) Creates a palette from arrays of size n, one for each red, blue or green component. Parameters palette A pointer or reference to the palette to copy. n The number of indices in the palette. red An array of red values. green An array of green values. blue An array of blue values. See also wxPalette::Create (p. 970) wxPerl note: In wxPerl the third constructor form takes as parameters 3 array references ( they must be of the same length ).

969


CHAPTER 7 wxPalette::~wxPalette
~wxPalette() Destructor.

wxPalette::Create
bool Create(int n, const unsigned char* red, const unsigned char* green, const unsigned char* blue) Creates a palette from arrays of size n, one for each red, blue or green component. Parameters n The number of indices in the palette. red An array of red values. green An array of green values. blue An array of blue values. Return value true if the creation was successful, false otherwise. See also wxPalette::wxPalette (p. 969)

wxPalette::GetPixel
int GetPixel(const unsigned char red, const unsigned char green, const unsigned char blue) const Returns a pixel value (index into the palette) for the given RGB values. Parameters red Red value. green

970


CHAPTER 7
Green value. blue Blue value. Return value The nearest palette index. See also wxPalette::GetRGB (p. 971)

wxPalette::GetRGB
bool GetPixel(int pixel, const unsigned char* red, const unsigned char* green, const unsigned char* blue) const Returns RGB values for a given palette index. Parameters pixel The palette index. red Receives the red value. green Receives the green value. blue Receives the blue value. Return value true if the operation was successful. See also wxPalette::GetPixel (p. 970) wxPerl note: In wxPerl this method takes only the pixel parameter and returns a 3element list ( or the empty list upon failure ).

wxPalette::Ok
bool Ok() const

971


CHAPTER 7
Returns true if palette data is present.

wxPalette::operator =
wxPalette& operator =(const wxPalette& palette) Assignment operator, using reference counting. Returns a reference to 'this'.

wxPalette::operator ==
bool operator ==(const wxPalette& palette) Equality operator. Two palettes are equal if they contain pointers to the same underlying palette data. It does not compare each attribute, so two independently-created palettes using the same parameters will fail the test.

wxPalette::operator !=
bool operator !=(const wxPalette& palette) Inequality operator. Two palettes are not equal if they contain pointers to different underlying palette data. It does not compare each attribute.

wxPanel
A panel is a window on which controls are placed. It is usually placed within a frame. It contains minimal extra functionality over and above its parent class wxWindow; its main purpose is to be similar in appearance and functionality to a dialog, but with the flexibility of having any window as a parent. Note: if not all characters are being intercepted by your OnKeyDown or OnChar handler, it may be because you are using the wxTAB_TRAVERSAL style, which grabs some keypresses for use by child controls. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/panel.h> Window styles There are no specific styles for this window.

972


CHAPTER 7
See also window styles overview (p. 1611). Remarks By default, a panel has the same colouring as a dialog. See also wxDialog (p. 367)

wxPanel::wxPanel
wxPanel() Default constructor. wxPanel(wxWindow* parent, wxWindowID id = -1, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxTAB_TRAVERSAL, const wxString& name = "panel") Constructor. Parameters parent The parent window. id An identifier for the panel. A value of -1 is taken to mean a default. pos The panel position. A value of (-1, -1) indicates a default position, chosen by either the windowing system or wxWindows, depending on platform. size The panel size. A value of (-1, -1) indicates a default size, chosen by either the windowing system or wxWindows, depending on platform. style The window style. See wxPanel (p. 972). name Used to associate a name with the window, allowing the application user to set Motif resource values for individual dialog boxes. See also

973


CHAPTER 7
wxPanel::Create (p. 974)

wxPanel::~wxPanel
~wxPanel() Destructor. Deletes any child windows before deleting the physical window.

wxPanel::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxTAB_TRAVERSAL, const wxString& name = "panel") Used for two-step panel construction. See wxPanel::wxPanel (p. 973) for details.

wxPanel::GetDefaultItem
wxButton* GetDefaultItem() const Returns a pointer to the button which is the default for this window, or NULL. The default button is the one activated by pressing the Enter key.

wxPanel::InitDialog
void InitDialog() Sends a wxInitDialogEvent (p. 761), which in turn transfers data to the dialog via validators. See also wxInitDialogEvent (p. 761)

wxPanel::OnSysColourChanged
void OnSysColourChanged(wxSysColourChangedEvent& event) The default handler for wxEVT_SYS_COLOUR_CHANGED. Parameters event The colour change event. Remarks

974


CHAPTER 7
Changes the panel's colour to conform to the current settings (Windows only). Add an event table entry for your panel class if you wish the behaviour to be different (such as keeping a user-defined background colour). If you do override this function, call wxEvent::Skip to propagate the notification to child windows and controls. See also wxSysColourChangedEvent (p. 1227)

wxPanel::SetDefaultItem
void SetDefaultItem(wxButton *btn) Changes the default button for the panel. See also GetDefaultItem (p. 974)

wxPathList
The path list is a convenient way of storing a number of directories, and when presented with a filename without a directory, searching for an existing file in those directories. Storing the filename only in an application's files and using a locally-defined list of directories makes the application and its files more portable. Use the wxFileNameFromPath global function to extract the filename from the path. Derived from wxList (p. 786) wxObject (p. 954) Include files <wx/filefn.h> See also wxList (p. 786)

wxPathList::wxPathList
wxPathList() Constructor.

975


CHAPTER 7 wxPathList::AddEnvList
void AddEnvList(const wxString& env_variable) Finds the value of the given environment variable, and adds all paths to the path list. Useful for finding files in the PATH variable, for example.

wxPathList::Add
void Add(const wxString& path) Adds the given directory to the path list, but does not check if the path was already on the list (use wxPathList::Member) for this).

wxPathList::EnsureFileAccessible
void EnsureFileAccessible(const wxString& filename) Given a full filename (with path), ensures that files in the same path can be accessed using the pathlist. It does this by stripping the filename and adding the path to the list if not already there.

wxPathList::FindAbsoluteValidPath
wxString FindAbsoluteValidPath(const wxString& file) Searches for a full path for an existing file by appending file to successive members of the path list. If the file exists, a temporary pointer to the absolute path is returned.

wxPathList::FindValidPath
wxString FindValidPath(const wxString& file) Searches for a full path for an existing file by appending file to successive members of the path list. If the file exists, a temporary pointer to the full path is returned. This path may be relative to the current working directory.

wxPathList::Member
bool Member(const wxString& file) true if the path is in the path list (ignoring case).

wxPen

976


CHAPTER 7
A pen is a drawing tool for drawing outlines. It is used for drawing lines and painting the outline of rectangles, ellipses, etc. It has a colour, a width and a style. Derived from wxGDIObject (p. 560) wxObject (p. 954) Include files <wx/pen.h> Predefined objects Objects: wxNullPen Pointers: wxRED_PEN wxCYAN_PEN wxGREEN_PEN wxBLACK_PEN wxWHITE_PEN wxTRANSPARENT_PEN wxBLACK_DASHED_PEN wxGREY_PEN wxMEDIUM_GREY_PEN wxLIGHT_GREY_PEN Remarks On a monochrome display, wxWindows shows all non-white pens as black. Do not initialize objects on the stack before the program commences, since other required structures may not have been set up yet. Instead, define global pointers to objects and create them in OnInit or when required. An application may wish to dynamically create pens with different characteristics, and there is the consequent danger that a large number of duplicate pens will be created. Therefore an application may wish to get a pointer to a pen by using the global list of pens wxThePenList, and calling the member function FindOrCreatePen. See the entry for wxPenList (p. 983). wxPen uses a reference counting system, so assignments between brushes are very cheap. You can therefore use actual wxPen objects instead of pointers without efficiency problems. Once one wxPen object changes its data it will create its own pen data internally so that other pens, which previously shared the data using the reference counting, are not affected. See also wxPenList (p. 983), wxDC (p. 347), wxDC::SetPen (p. 366)

977


CHAPTER 7

wxPen::wxPen
wxPen() Default constructor. The pen will be uninitialised, and wxPen::Ok (p. 981) will return false. wxPen(const wxColour& colour, int width = 1, int style = wxSOLID) Constructs a pen from a colour object, pen width and style. wxPen(const wxString& colourName, int width, int style) Constructs a pen from a colour name, pen width and style. wxPen(const wxBitmap& stipple, int width) Constructs a stippled pen from a stipple bitmap and a width. wxPen(const wxPen& pen) Copy constructor. This uses reference counting so is a cheap operation. Parameters colour A colour object. colourName A colour name. width Pen width. Under Windows, the pen width cannot be greater than 1 if the style is wxDOT, wxLONG_DASH, wxSHORT_DASH, wxDOT_DASH, or wxUSER_DASH. stipple A stipple bitmap. pen A pointer or reference to a pen to copy. style The style may be one of the following: wxSOLID wxTRANSPARENT Solid style. No pen is used.

978


CHAPTER 7
wxDOT wxLONG_DASH wxSHORT_DASH wxDOT_DASH wxSTIPPLE wxUSER_DASH wxBDIAGONAL_HATCH wxCROSSDIAG_HATCH wxFDIAGONAL_HATCH wxCROSS_HATCH wxHORIZONTAL_HATCH wxVERTICAL_HATCH Remarks Different versions of Windows and different versions of other platforms support very different subsets of the styles above - there is no similarity even between Windows95 and Windows98 - so handle with care. If the named colour form is used, an appropriate wxColour structure is found in the colour database. See also wxPen::SetStyle (p. 983), wxPen::SetColour (p. 982), wxPen::SetWidth (p. 983), wxPen::SetStipple (p. 982) wxPerl note: Constructors supported by wxPerl are: ::Pen->new( colour, width, style ) ::Pen->new( colourName, width, style ) ::Pen->new( stipple, width ) Dotted style. Long dashed style. Short dashed style. Dot and dash style. Use the stipple bitmap. Use the user dashes: see wxPen::SetDashes (p. 982). Backward diagonal hatch. Cross-diagonal hatch. Forward diagonal hatch. Cross hatch. Horizontal hatch. Vertical hatch.

wxPen::~wxPen
~wxPen() Destructor.

979


CHAPTER 7
Remarks The destructor may not delete the underlying pen object of the native windowing system, since wxBrush uses a reference counting system for efficiency. Although all remaining pens are deleted when the application exits, the application should try to clean up all pens itself. This is because wxWindows cannot know if a pointer to the pen object is stored in an application data structure, and there is a risk of double deletion.

wxPen::GetCap
int GetCap() const Returns the pen cap style, which may be one of wxCAP_ROUND, wxCAP_PROJECTING and wxCAP_BUTT. The default is wxCAP_ROUND. See also wxPen::SetCap (p. 981)

wxPen::GetColour
wxColour& GetColour() const Returns a reference to the pen colour. See also wxPen::SetColour (p. 982)

wxPen::GetDashes
int GetDashes(wxDash** dashes) const Gets an array of dashes (defined as char in X, DWORD under Windows).dashes is a pointer to the internal array. Do not deallocate or store this pointer. The function returns the number of dashes associated with this pen. See also wxPen::SetDashes (p. 982)

wxPen::GetJoin
int GetJoin() const Returns the pen join style, which may be one of wxJOIN_BEVEL, wxJOIN_ROUND and wxJOIN_MITER. The default is wxJOIN_ROUND.

980


CHAPTER 7
See also wxPen::SetJoin (p. 982)

wxPen::GetStipple
wxBitmap* GetStipple() const Gets a pointer to the stipple bitmap. See also wxPen::SetStipple (p. 982)

wxPen::GetStyle
int GetStyle() const Returns the pen style. See also wxPen::wxPen (p. 978), wxPen::SetStyle (p. 983)

wxPen::GetWidth
int GetWidth() const Returns the pen width. See also wxPen::SetWidth (p. 983)

wxPen::Ok
bool Ok() const Returns true if the pen is initialised.

wxPen::SetCap
void SetCap(int capStyle) Sets the pen cap style, which may be one of wxCAP_ROUND, wxCAP_PROJECTING and wxCAP_BUTT. The default is wxCAP_ROUND. See also

981


CHAPTER 7
wxPen::GetCap (p. 980)

wxPen::SetColour
void SetColour(wxColour& colour) void SetColour(const wxString& colourName) void SetColour(int red, int green, int blue) The pen's colour is changed to the given colour. See also wxPen::GetColour (p. 980)

wxPen::SetDashes
void SetDashes(int n, wxDash* dashes) Associates an array of pointers to dashes (defined as char in X, DWORD under Windows) with the pen. The array is not deallocated by wxPen, but neither must it be deallocated by the calling application until the pen is deleted or this function is called with a NULL array. See also wxPen::GetDashes (p. 980)

wxPen::SetJoin
void SetJoin(intjoin_style) Sets the pen join style, which may be one of wxJOIN_BEVEL, wxJOIN_ROUND and wxJOIN_MITER. The default is wxJOIN_ROUND. See also wxPen::GetJoin (p. 980)

wxPen::SetStipple
void SetStipple(wxBitmap* stipple) Sets the bitmap for stippling. See also wxPen::GetStipple (p. 981)

982


CHAPTER 7 wxPen::SetStyle
void SetStyle(int style) Set the pen style. See also wxPen::wxPen (p. 978)

wxPen::SetWidth
void SetWidth(int width) Sets the pen width. See also wxPen::GetWidth (p. 981)

wxPen::operator =
wxPen& operator =(const wxPen& pen) Assignment operator, using reference counting. Returns a reference to 'this'.

wxPen::operator ==
bool operator ==(const wxPen& pen) Equality operator. Two pens are equal if they contain pointers to the same underlying pen data. It does not compare each attribute, so two independently-created pens using the same parameters will fail the test.

wxPen::operator !=
bool operator !=(const wxPen& pen) Inequality operator. Two pens are not equal if they contain pointers to different underlying pen data. It does not compare each attribute.

wxPenList
There is only one instance of this class: wxThePenList. Use this object to search for a previously created pen of the desired type and create it if not already found. In some windowing systems, the pen may be a scarce resource, so it can pay to reuse old resources if possible. When an application finishes, all pens will be deleted and their

983


CHAPTER 7
resources freed, eliminating the possibility of 'memory leaks'. However, it is best not to rely on this automatic cleanup because it can lead to double deletion in some circumstances. There are two mechanisms in recent versions of wxWindows which make the pen list less useful than it once was. Under Windows, scarce resources are cleaned up internally if they are not being used. Also, a referencing counting mechanism applied to all GDI objects means that some sharing of underlying resources is possible. You don't have to keep track of pointers, working out when it is safe delete a pen, because the referencing counting does it for you. For example, you can set a pen in a device context, and then immediately delete the pen you passed, because the pen is 'copied'. So you may find it easier to ignore the pen list, and instead create and copy pens as you see fit. If your Windows resource meter suggests your application is using too many resources, you can resort to using GDI lists to share objects explicitly. The only compelling use for the pen list is for wxWindows to keep track of pens in order to clean them up on exit. It is also kept for backward compatibility with earlier versions of wxWindows. See also wxPen (p. 976)

wxPenList::wxPenList
void wxPenList() Constructor. The application should not construct its own pen list: use the object pointer wxThePenList.

wxPenList::AddPen
void AddPen(wxPen* pen) Used internally by wxWindows to add a pen to the list.

wxPenList::FindOrCreatePen
wxPen* FindOrCreatePen(const wxColour& colour, int width, int style) Finds a pen with the specified attributes and returns it, else creates a new pen, adds it to the pen list, and returns it. wxPen* FindOrCreatePen(const wxString& colourName, int width, int style) Finds a pen with the specified attributes and returns it, else creates a new pen, adds it to the pen list, and returns it.

984


CHAPTER 7
Parameters colour Colour object. colourName Colour name, which should be in the colour database (p. 155). width Width of pen. style Pen style. See wxPen::wxPen (p. 978) for a list of styles.

wxPenList::RemovePen
void RemovePen(wxPen* pen) Used by wxWindows to remove a pen from the list.

wxPlotCurve
The wxPlotCurve class represents a curve displayed in a wxPlotWindow (p. 987). It is a virtual curve, i.e. is acts only as an interface, leaving it to the programmer to care for how the values pairs are matched. wxPlotWindow and wxPlotCurve are designed to display large amounts of data, i.e. most typically data measured by some sort of machine. This class is abstract, i.e. you have to derive your own class and implement the pure virtual functions (GetStartX() (p. 986), GetEndX() (p. 985)and GetY() (p. 986)). Derived from wxObject (p. 954)

wxPlotCurve::wxPlotCurve
wxPlotCurve(int offsetY, double startY, double endY) Constructor assigning start values. See below for interpretation.

wxPlotCurve::GetEndX
wxInt32 GetEndX()

985


CHAPTER 7
Must be overridden. This function should return the index of the last value of this curve, typically 99 if 100 values have been measured.

wxPlotCurve::GetEndY
double GetEndY() See SetStartY (p. 986).

wxPlotCurve::GetOffsetY
int GetOffsetY()

Returns the vertical offset.wxPlotCurve::GetY
double GetY(wxInt32 x) Must be overridden. This function will return the actual Y value corresponding to the given X value. The x value is of an integer type because it is considered to be an index in row of measured values.

wxPlotCurve::GetStartX
wxInt32 GetStartX() Must be overridden. This function should return the index of the first value of this curve, typically zero.

wxPlotCurve::GetStartY
double GetStartY() See SetStartY (p. 987).

wxPlotCurve::SetEndY
void SetEndY(double endY) The value returned by this function tells the plot window what the highest values in the curve will be so that a suitable scale can be found for the display. If the Y values in this curve are in the range of -1.5 to 0.5, this function should return 0.5 or maybe 1.0 for nicer aesthetics.

wxPlotCurve::SetOffsetY

986


CHAPTER 7
void SetOffsetY(int offsetY) When displaying several curves in one window, it is often useful to assign different offsets to the curves. You should call wxPlotWindow::Move (p. 989) to set this value after you have added the curve to the window.

wxPlotCurve::SetStartY
void SetStartY(double startY) The value returned by this function tells the plot window what the lowest values in the curve will be so that a suitable scale can be found for the display. If the Y values in this curve are in the range of -1.5 to 0.5, this function should return -1.5 or maybe -2.0 for nicer aesthetics.

wxPlotWindow
wxPlotWindow is a specialized window designed to display data that typically has been measured by machines, i.e. that may have thousands of values. One example of such data would be the well known ECG measuring the electrical activity of your heart: the measuring device will produce thousands of values per minute, several measurements are done simultaneously and you might want to have a look at parts of the curves, enlarging them or scrolling from one position to another. Note that this window is not useful for real-time measuring or for displaying charts with error bars etc. A single curve in the plot window is represented by the wxPlotCurve (p. 985) class. The wxPlotWindow interacts with program using events, for example when clicking or double clicking on a curve or when selecting one by clicking on it (which can be vetoed). Future versions will hopefully feature selecting values or sections of the displayed curves etc. Derived from wxScrolledWindow (p. 1085) wxPanel (p. 972) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Window styles wxPLOT_BUTTON_MOVE wxPLOT_BUTTON_ENLARGE wxPLOT_BUTTON_ZOOM Display buttons to allow moving individual curves up or down. Display buttons to allow enlarging individual curves vertically. Display buttons to allow zooming all curves horizontally.

987


CHAPTER 7
wxPLOT_BUTTON_ALL wxPLOT_Y_AXIS wxPLOT_X_AXIS wxPLOT_DEFAULT Display all buttons. Display an Y axis to the left of the drawing area. Display a X axis at the bottom of the drawing area. All of the above options.

wxPlotWindow::wxPlotWindow
wxPlotWindow() wxPlotWindow(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, int flags = wxPLOT_DEFAULT) Constructor.

wxPlotWindow::~wxPlotWindow
~wxPlotWindow() The destructor will not delete the curves associated to the window.

wxPlotWindow::Add
void Add(wxPlotCurve* curve) Add a curve to the window.

wxPlotWindow::GetCount
size_t GetCount() Returns number of curves.

wxPlotWindow::GetAt
wxPlotCurve* GetAt(size_t n) Get the nth curve.

wxPlotWindow::SetCurrent

988


CHAPTER 7
void SetCurrent(wxPlotCurve* current) Make one curve the current curve. This will emit a wxPlotEvent.

wxPlotWindow::GetCurrent
wxPlotCurve* GetCurrent() Returns a pointer to the current curve, or NULL.

wxPlotWindow::Delete
void Delete(wxPlotCurve* curve) Removes a curve from the window and delete is on screen. This does not delete the actual curve. If the curve removed was the current curve, the current curve will be set to NULL.

wxPlotWindow::Move
void Move(wxPlotCurve* curve, int pixels_up) Move the curve curve up by pixels_up pixels. Down if the value is negative.

wxPlotWindow::Enlarge
void Enlarge(wxPlotCurve* curve, double factor) Changes the representation of the given curve. A factor of more than one will stretch the curve vertically. The Y axis will change accordingly.

wxPlotWindow::SetUnitsPerValue
void SetUnitsPerValue(double upv) This sets the virtual units per value. Normally, you will not be interested in what measured value you see, but what it stands for. If you want to display seconds on the X axis and the measuring device produced 50 values per second, set this value to 50. This will affect all curves being displayed.

wxPlotWindow::GetUnitsPerValue
double GetUnitsPerValue() See SetUnitsPerValue (p. 989).

989


CHAPTER 7 wxPlotWindow::SetZoom
void SetZoom(double zoom) This functions zooms all curves in their horizontal dimension. The X axis will be changed accordingly.

wxPlotWindow::GetZoom
double GetZoom() See SetZoom (p. 990).

wxPlotWindow::RedrawEverything
void RedrawEverything() Helper function which redraws both axes and the central area.

wxPlotWindow::RedrawXAxis
void RedrawXAxis() Helper function which redraws the X axis.

wxPlotWindow::RedrawYAxis
void RedrawYAxis() Helper function which redraws the Y axis.

wxPlotWindow::SetScrollOnThumbRelease
void SetScrollOnThumbRelease(bool onrelease = true) This function controls if the plot area will get scrolled only if the scrollbar thumb has been release or also if the thumb is being dragged. When displaying large amounts of data, it might become impossible to display the data fast enough to produce smooth scrolling and then this function should be called.

wxPlotWindow::SetEnlargeAroundWindowCentre
void SetEnlargeAroundWindowCentre(bool aroundwindow = true) Depending on the kind of data you display, enlarging the individual curves might have different desired effects. Sometimes, the data will be supposed to get enlarged with the

990


CHAPTER 7
fixed point being the origin, sometimes the fixed point should be the centre of the current drawing area. This function controls this behaviour.

wxPoint
A wxPoint is a useful data structure for graphics operations. It simply contains integer x and y members. See also wxRealPoint (p. 1041) for a floating point version. Derived from None Include files <wx/gdicmn.h> See also wxRealPoint (p. 1041)

wxPoint::wxPoint
wxPoint() wxPoint(int x, int y) Create a point.

wxPoint::x
int x x member.

wxPoint::y
int y y member.

wxPostScriptDC
This defines the wxWindows Encapsulated PostScript device context, which can write

991


CHAPTER 7
PostScript files on any platform. See wxDC (p. 347) for descriptions of the member functions. Derived from wxDC (p. 347) wxObject (p. 954) Include files <wx/dcps.h>

wxPostScriptDC::wxPostScriptDC
wxPostScriptDC(const wxPrintData& printData) Constructs a PostScript printer device context from a wxPrintData (p. 996) object. wxPostScriptDC(const wxString& output, bool interactive = true, wxWindow *parent) Constructor. output is an optional file for printing to, and if interactive is true a dialog box will be displayed for adjusting various parameters. parent is the parent of the printer dialog box. Use the Ok member to test whether the constructor was successful in creating a usable device context. See Printer settings (p. 1501) for functions to set and get PostScript printing settings. This constructor and the global printer settings are now deprecated; use the wxPrintData constructor instead.

wxPostScriptDC::SetResolution
static void SetResolution(int ppi) Set resolution (in pixels per inch) that will be used in PostScript output. Default is 720ppi.

wxPostScriptDC::GetResolution
static int GetResolution() Return resolution used in PostScript output. See SetResolution (p. 992).

wxPreviewCanvas
A preview canvas is the default canvas used by the print preview system to display the preview.

992


CHAPTER 7
Derived from wxScrolledWindow (p. 1085) wxWindow (p. 1386) wxevthandler (p. 443) wxObject (p. 954) Include files <wx/print.h> See also wxPreviewFrame (p. 995), wxPreviewControlBar (p. 993), wxPrintPreview (p. 1014)

wxPreviewCanvas::wxPreviewCanvas
wxPreviewCanvas(wxPrintPreview* preview, wxWindow* parent, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "canvas") Constructor.

wxPreviewCanvas::~wxPreviewCanvas
~wxPreviewCanvas() Destructor.

wxPreviewCanvas::OnPaint
void OnPaint(wxPaintEvent& event) Calls wxPrintPreview::PaintPage (p. 1017) to refresh the canvas.

wxPreviewControlBar
This is the default implementation of the preview control bar, a panel with buttons and a zoom control. You can derive a new class from this and override some or all member functions to change the behaviour and appearance; or you can leave it as it is. Derived from wxPanel (p. 972) wxWindow (p. 1386) wxEvtHandler (p. 443)

993


CHAPTER 7
wxObject (p. 954) Include files <wx/print.h> See also wxPreviewFrame (p. 995), wxPreviewCanvas (p. 992), wxPrintPreview (p. 1014)

wxPreviewControlBar::wxPreviewControlbar
wxPreviewControlBar(wxPrintPreview* preview, long buttons, wxWindow* parent, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "panel") Constructor. The buttons parameter may be a combination of the following, using the bitwise 'or' operator. wxPREVIEW_PRINT wxPREVIEW_NEXT wxPREVIEW_PREVIOUS wxPREVIEW_ZOOM wxPREVIEW_DEFAULT Create a print button. Create a next page button. Create a previous page button. Create a zoom control. Equivalent to a combination of wxPREVIEW_PREVIOUS, wxPREVIEW_NEXT and wxPREVIEW_ZOOM.

wxPreviewControlBar::~wxPreviewControlBar
~wxPreviewControlBar() Destructor.

wxPreviewControlBar::CreateButtons
void CreateButtons() Creates buttons, according to value of the button style flags.

wxPreviewControlBar::GetPrintPreview

994


CHAPTER 7
wxPrintPreview * GetPrintPreview() Gets the print preview object associated with the control bar.

wxPreviewControlBar::GetZoomControl
int GetZoomControl() Gets the current zoom setting in percent.

wxPreviewControlBar::SetZoomControl
void SetZoomControl(int percent) Sets the zoom control.

wxPreviewFrame
This class provides the default method of managing the print preview interface. Member functions may be overridden to replace functionality, or the class may be used without derivation. Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/print.h> See also wxPreviewCanvas (p. 992), wxPreviewControlBar (p. 993), wxPrintPreview (p. 1014)

wxPreviewFrame::wxPreviewFrame
wxPreviewFrame(wxPrintPreview* preview, wxWindow* parent, const wxString& title, const wxPoint& pos = wxDefaultPosition, const wxSize& size size = wxDefaultSize, long style = wxDEFAULT_FRAME_STYLE, const wxString& name = "frame") Constructor. Pass a print preview object plus other normal frame arguments. The print preview object will be destroyed by the frame when it closes.

995


CHAPTER 7 wxPreviewFrame::~wxPreviewFrame
~wxPreviewFrame() Destructor.

wxPreviewFrame::CreateControlBar
void CreateControlBar() Creates a wxPreviewControlBar. Override this function to allow a user-defined preview control bar object to be created.

wxPreviewFrame::CreateCanvas
void CreateCanvas() Creates a wxPreviewCanvas. Override this function to allow a user-defined preview canvas object to be created.

wxPreviewFrame::Initialize
void Initialize() Creates the preview canvas and control bar, and calls wxWindow::MakeModal(true) to disable other top-level windows in the application. This function should be called by the application prior to showing the frame.

wxPreviewFrame::OnCloseWindow
void OnCloseWindow(wxCloseEvent& event) Enables the other frames in the application, and deletes the print preview object, implicitly deleting any printout objects associated with the print preview object.

wxPrintData
This class holds a variety of information related to printers and printer device contexts. This class is used to create a wxPrinterDC and a wxPostScriptDC. It is also used as a data member of wxPrintDialogData and wxPageSetupDialogData, as part of the mechanism for transferring data between the print dialogs and the application. Derived from wxObject (p. 954)

996


CHAPTER 7
Include files <wx/cmndata.h> See also wxPrintDialog (p. 1002), wxPageSetupDialog (p. 960), wxPrintDialogData (p. 1003), wxPageSetupDialogData (p. 961), wxPrintDialog Overview (p. 1650), wxPrinterDC (p. 1010), wxPostScriptDC (p. 991) Remarks The following functions are specific to PostScript printing and have not yet been documented:
const wxString& GetPrinterCommand() const ; const wxString& GetPrinterOptions() const ; const wxString& GetPreviewCommand() const ; const wxString& GetFilename() const ; const wxString& GetFontMetricPath() const ; double GetPrinterScaleX() const ; double GetPrinterScaleY() const ; long GetPrinterTranslateX() const ; long GetPrinterTranslateY() const ; // wxPRINT_MODE_PREVIEW, wxPRINT_MODE_FILE, wxPRINT_MODE_PRINTER wxPrintMode GetPrintMode() const ; void void void void void void void void void void void void SetPrinterCommand(const wxString& command) ; SetPrinterOptions(const wxString& options) ; SetPreviewCommand(const wxString& command) ; SetFilename(const wxString& filename) ; SetFontMetricPath(const wxString& path) ; SetPrinterScaleX(double x) ; SetPrinterScaleY(double y) ; SetPrinterScaling(double x, double y) ; SetPrinterTranslateX(long x) ; SetPrinterTranslateY(long y) ; SetPrinterTranslation(long x, long y) ; SetPrintMode(wxPrintMode printMode) ;

wxPrintData::wxPrintData
wxPrintData() Default constructor. wxPrintData(const wxPrintData& data) Copy constructor.

wxPrintData::~wxPrintData
~wxPrintData() Destructor.

997


CHAPTER 7 wxPrintData::GetCollate
bool GetCollate() const Returns true if collation is on.

wxPrintData::GetColour
bool GetColour() const Returns true if colour printing is on.

wxPrintData::GetDuplex
wxDuplexMode GetDuplex() const Returns the duplex mode. One of wxDUPLEX_SIMPLEX, wxDUPLEX_HORIZONTAL, wxDUPLEX_VERTICAL.

wxPrintData::GetNoCopies
int GetNoCopies() const Returns the number of copies requested by the user.

wxPrintData::GetOrientation
int GetOrientation() const Gets the orientation. This can be wxLANDSCAPE or wxPORTRAIT.

wxPrintData::GetPaperId
wxPaperSize GetPaperId() const Returns the paper size id. For more information, see wxPrintData::SetPaperId (p. 1000).

wxPrintData::GetPrinterName
const wxString& GetPrinterName() const Returns the printer name. If the printer name is the empty string, it indicates that the default printer should be used.

wxPrintData::GetQuality 998


CHAPTER 7
wxPrintQuality GetQuality() const Returns the current print quality. This can be a positive integer, denoting the number of dots per inch, or one of the following identifiers:
wxPRINT_QUALITY_HIGH wxPRINT_QUALITY_MEDIUM wxPRINT_QUALITY_LOW wxPRINT_QUALITY_DRAFT

On input you should pass one of these identifiers, but on return you may get back a positive integer indicating the current resolution setting.

wxPrintData::Ok
bool Ok() const Returns true if the print data is valid for using in print dialogs. This can return false on Windows if the current printer is not set, for example. On all other platforms, it returns true.

wxPrintData::SetCollate
void SetCollate(bool flag) Sets collation to on or off.

wxPrintData::SetColour
void SetColour(bool flag) Sets colour printing on or off.

wxPrintData::SetDuplex
void SetDuplex(wxDuplexMode mode) Returns the duplex mode. One of wxDUPLEX_SIMPLEX, wxDUPLEX_HORIZONTAL, wxDUPLEX_VERTICAL.

wxPrintData::SetNoCopies
void SetNoCopies(int n) Sets the default number of copies to be printed out.

wxPrintData::SetOrientation 999


CHAPTER 7
void SetOrientation(int orientation) Sets the orientation. This can be wxLANDSCAPE or wxPORTRAIT.

wxPrintData::SetPaperId
void SetPaperId(wxPaperSize paperId) Sets the paper id. This indicates the type of paper to be used. For a mapping between paper id, paper size and string name, see wxPrintPaperDatabase in paper.h (not yet documented). paperId can be one of:
wxPAPER_NONE, wxPAPER_LETTER, wxPAPER_LEGAL, wxPAPER_A4, wxPAPER_CSHEET, wxPAPER_DSHEET, wxPAPER_ESHEET, wxPAPER_LETTERSMALL, wxPAPER_TABLOID, wxPAPER_LEDGER, wxPAPER_STATEMENT, wxPAPER_EXECUTIVE, wxPAPER_A3, wxPAPER_A4SMALL, wxPAPER_A5, wxPAPER_B4, wxPAPER_B5, wxPAPER_FOLIO, wxPAPER_QUARTO, wxPAPER_10X14, wxPAPER_11X17, wxPAPER_NOTE, wxPAPER_ENV_9, wxPAPER_ENV_10, wxPAPER_ENV_11, wxPAPER_ENV_12, wxPAPER_ENV_14, wxPAPER_ENV_DL, wxPAPER_ENV_C5, wxPAPER_ENV_C3, wxPAPER_ENV_C4, wxPAPER_ENV_C6, wxPAPER_ENV_C65, wxPAPER_ENV_B4, wxPAPER_ENV_B5, wxPAPER_ENV_B6, wxPAPER_ENV_ITALY, wxPAPER_ENV_MONARCH, wxPAPER_ENV_PERSONAL, wxPAPER_FANFOLD_US, wxPAPER_FANFOLD_STD_GERMAN, wxPAPER_FANFOLD_LGL_GERMAN, inches // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // // Use specific dimensions Letter, 8 1/2 by 11 inches Legal, 8 1/2 by 14 inches A4 Sheet, 210 by 297 millimeters C Sheet, 17 by 22 inches D Sheet, 22 by 34 inches E Sheet, 34 by 44 inches Letter Small, 8 1/2 by 11 inches Tabloid, 11 by 17 inches Ledger, 17 by 11 inches Statement, 5 1/2 by 8 1/2 inches Executive, 7 1/4 by 10 1/2 inches A3 sheet, 297 by 420 millimeters A4 small sheet, 210 by 297 millimeters A5 sheet, 148 by 210 millimeters B4 sheet, 250 by 354 millimeters B5 sheet, 182-by-257-millimeter paper Folio, 8-1/2-by-13-inch paper Quarto, 215-by-275-millimeter paper 10-by-14-inch sheet 11-by-17-inch sheet Note, 8 1/2 by 11 inches #9 Envelope, 3 7/8 by 8 7/8 inches #10 Envelope, 4 1/8 by 9 1/2 inches #11 Envelope, 4 1/2 by 10 3/8 inches #12 Envelope, 4 3/4 by 11 inches #14 Envelope, 5 by 11 1/2 inches DL Envelope, 110 by 220 millimeters C5 Envelope, 162 by 229 millimeters C3 Envelope, 324 by 458 millimeters C4 Envelope, 229 by 324 millimeters C6 Envelope, 114 by 162 millimeters C65 Envelope, 114 by 229 millimeters B4 Envelope, 250 by 353 millimeters B5 Envelope, 176 by 250 millimeters B6 Envelope, 176 by 125 millimeters Italy Envelope, 110 by 230 millimeters Monarch Envelope, 3 7/8 by 7 1/2 inches 6 3/4 Envelope, 3 5/8 by 6 1/2 inches US Std Fanfold, 14 7/8 by 11 inches German Std Fanfold, 8 1/2 by 12 inches German Legal Fanfold, 8 1/2 by 13

Windows 95 only: wxPAPER_ISO_B4, // B4 (ISO) 250 x 353 mm wxPAPER_JAPANESE_POSTCARD, // Japanese Postcard 100 x 148 mm wxPAPER_9X11, // 9 x 11 in wxPAPE_10X11, R // 10 x 11 in wxPAPER_15X11, // 15 x 11 in wxPAPER_ENV_INVITE, // Envelope Invite 220 x 220 mm wxPAPER_LETTER_EXTRA, // Letter Extra 9 \275 x 12 in

1000


CHAPTER 7
wxPAPER_LEGAL_EXTRA, // Legal Extra 9 \275 x 15 in wxPAPER_TABLOID_EXTRA, // Tabloid Extra 11.69 x 18 in wxPAPER_A4_EXTRA, // A4 Extra 9.27 x 12.69 in wxPAPER_LETTER_TRANSVERSE, // Letter Transverse 8 \275 x 11 in wxPAPER_A4_TRANSVERSE, // A4 Transverse 210 x 297 mm wxPAPER_LETTER_EXTRA_TRANSVERSE, // Letter Extra Transverse 9\275 x 12 in wxPAPER_A_PLUS, // SuperA/SuperA/A4 227 x 356 mm wxPAPER_B_PLUS, // SuperB/SuperB/A3 305 x 487 mm wxPAPER_LETTER_PLUS, // Letter Plus 8.5 x 12.69 in wxPAPER_A4_PLUS, // A4 Plus 210 x 330 mm wxPAPER_A5_TRANSVERSE, // A5 Transverse 148 x 210 mm wxPAPER_B5_TRANSVERSE, // B5 (JIS) Transverse 182 x 257 mm wxPAPER_A3_EXTRA, // A3 Extra 322 x 445 mm wxPAPER_A5_EXTRA, // A5 Extra 174 x 235 mm wxPAPER_B5_EXTRA, // B5 (ISO) Extra 201 x 276 mm wxPAPER_A2, // A2 420 x 594 mm wxPAPER_A3_TRANSVERSE, // A3 Transverse 297 x 420 mm wxPAPE_A3_EXTRA_TRANSVERSE // A3 Extra Transverse 322 x 445 mm R

wxPrintData::SetPrinterName
void SetPrinterName(const wxString& printerName) Sets the printer name. This can be the empty string to indicate that the default printer should be used.

wxPrintData::SetQuality
void SetQuality(wxPrintQuality quality) Sets the desired print quality. This can be a positive integer, denoting the number of dots per inch, or one of the following identifiers:
wxPRINT_QUALITY_HIGH wxPRINT_QUALITY_MEDIUM wxPRINT_QUALITY_LOW wxPRINT_QUALITY_DRAFT

On input you should pass one of these identifiers, but on return you may get back a positive integer indicating the current resolution setting.

wxPrintData::operator =
void operator =(const wxPrintData& data) Assigns print data to this object. void operator =(const wxPrintSetupData& data) Assigns print setup data to this object. wxPrintSetupData is deprecated, but retained for backward compatibility.

1001


CHAPTER 7

wxPrintDialog
This class represents the print and print setup common dialogs. You may obtain a wxPrinterDC (p. 1010) device context from a successfully dismissed print dialog. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/printdlg.h> See also wxPrintDialog Overview (p. 1650)

wxPrintDialog::wxPrintDialog
wxPrintDialog(wxWindow* parent, wxPrintDialogData* data = NULL) Constructor. Pass a parent window, and optionally a pointer to a block of print data, which will be copied to the print dialog's print data. See also wxPrintDialogData (p. 1003)

wxPrintDialog::~wxPrintDialog
~wxPrintDialog() Destructor. If wxPrintDialog::GetPrintDC has not been called, the device context obtained by the dialog (if any) will be deleted.

wxPrintDialog::GetPrintDialogData
wxPrintDialogData& GetPrintDialogData() Returns the print dialog data (p. 1003) associated with the print dialog.

wxPrintDialog::GetPrintDC
wxDC* GetPrintDC()

1002


CHAPTER 7
Returns the device context created by the print dialog, if any. When this function has been called, the ownership of the device context is transferred to the application, so it must then be deleted explicitly.

wxPrintDialog::Ok
bool Ok() const Returns true if the print data associated with the dialog is valid. This can return false on Windows if the current printer is not set, for example. On all other platforms, it returns true.

wxPrintDialog::ShowModal
int ShowModal() Shows the dialog, returning wxID_OK if the user pressed OK, and wxID_CANCEL otherwise. After this function is called, a device context may be retrievable using wxPrintDialog::GetPrintDC (p. 1002).

wxPrintDialogData
This class holds information related to the visual characteristics of wxPrintDialog. It contains a wxPrintData object with underlying printing settings. Derived from wxObject (p. 954) Include files <wx/cmndata.h> See also wxPrintDialog (p. 1002), wxPrintDialog Overview (p. 1650)

wxPrintDialogData::wxPrintDialogData
wxPrintDialogData() Default constructor. wxPrintDialogData(wxPrintDialogData& dialogData) Copy constructor.

1003


CHAPTER 7
wxPrintDialogData(wxPrintData& printData) Construct an object from a print dialog data object.

wxPrintDialogData::~wxprintdialogdata
~wxPrintDialogData() Destructor.

wxPrintDialogData::EnableHelp
void EnableHelp(bool flag) Enables or disables the 'Help' button.

wxPrintDialogData::EnablePageNumbers
void EnablePageNumbers(bool flag) Enables or disables the 'Page numbers' controls.

wxPrintDialogData::EnablePrintToFile
void EnablePrintToFile(bool flag) Enables or disables the 'Print to file' checkbox.

wxPrintDialogData::EnableSelection
void EnableSelection(bool flag) Enables or disables the 'Selection' radio button.

wxPrintDialogData::GetAllPages
bool GetAllPages() const Returns true if the user requested that all pages be printed.

wxPrintDialogData::GetCollate
bool GetCollate() const Returns true if the user requested that the document(s) be collated.

1004


CHAPTER 7 wxPrintDialogData::GetFromPage
int GetFromPage() const Returns the from page number, as entered by the user.

wxPrintDialogData::GetMaxPage
int GetMaxPage() const Returns the maximum page number.

wxPrintDialogData::GetMinPage
int GetMinPage() const Returns the minimum page number.

wxPrintDialogData::GetNoCopies
int GetNoCopies() const Returns the number of copies requested by the user.

wxPrintDialogData::GetPrintData
wxPrintData& GetPrintData() Returns a reference to the internal wxPrintData object.

wxPrintDialogData::GetPrintToFile
bool GetPrintToFile() const Returns true if the user has selected printing to a file.

wxPrintDialogData::GetSelection
bool GetSelection() const Returns true if the user requested that the selection be printed (where 'selection' is a concept specific to the application).

wxPrintDialogData::GetToPage

1005


CHAPTER 7
int GetToPage() const Returns the to page number, as entered by the user.

wxPrintDialogData::Ok
bool Ok() const Returns true if the print data is valid for using in print dialogs. This can return false on Windows if the current printer is not set, for example. On all other platforms, it returns true.

wxPrintDialogData::SetCollate
void SetCollate(bool flag) Sets the 'Collate' checkbox to true or false.

wxPrintDialogData::SetFromPage
void SetFromPage(int page) Sets the from page number.

wxPrintDialogData::SetMaxPage
void SetMaxPage(int page) Sets the maximum page number.

wxPrintDialogData::SetMinPage
void SetMinPage(int page) Sets the minimum page number.

wxPrintDialogData::SetNoCopies
void SetNoCopies(int n) Sets the default number of copies the user has requested to be printed out.

wxPrintDialogData::SetPrintData
void SetPrintData(const wxPrintData& printData)

1006


CHAPTER 7
Sets the internal wxPrintData.

wxPrintDialogData::SetPrintToFile
void SetPrintToFile(bool flag) Sets the 'Print to file' checkbox to true or false.

wxPrintDialogData::SetSelection
void SetSelection(bool flag) Selects the 'Selection' radio button. The effect of printing the selection depends on how the application implements this command, if at all.

wxPrintDialogData::SetSetupDialog
void SetSetupDialog(bool flag) Determines whether the dialog to be shown will be the Print dialog (pass false) or Print Setup dialog (pass true). Note that the setup dialog is (according to Microsoft) obsolete from Windows 95, though retained for backward compatibility.

wxPrintDialogData::SetToPage
void SetToPage(int page) Sets the to page number.

wxPrintDialogData::operator =
void operator =(const wxPrintData& data) Assigns print data to this object. void operator =(const wxPrintDialogData& data) Assigns another print dialog data object to this object.

wxPrinter
This class represents the Windows or PostScript printer, and is the vehicle through which printing may be launched by an application. Printing can also be achieved through using of lower functions and classes, but this and associated classes provide a more

1007


CHAPTER 7
convenient and general method of printing. Derived from wxObject (p. 954) Include files <wx/print.h> See also Printing framework overview (p. 1664), wxPrinterDC (p. 1010), wxPrintDialog (p. 1002), wxPrintout (p. 1010), wxPrintPreview (p. 1014).

wxPrinter::wxPrinter
wxPrinter(wxPrintDialogData* data = NULL) Constructor. Pass an optional pointer to a block of print dialog data, which will be copied to the printer object's local data. See also wxPrintDialogData (p. 1003),wxPrintData (p. 996)

wxPrinter::~wxPrinter
~wxPrinter() Destructor.

wxPrinter::Abort
bool Abort() Returns true if the user has aborted the print job.

wxPrinter::CreateAbortWindow
void CreateAbortWindow(wxWindow* parent, wxPrintout* printout) Creates the default printing abort window, with a cancel button.

wxPrinter::GetLastError

1008


CHAPTER 7
static wxPrinterError GetLastError() Return last error. Valid after calling Print (p. 1009),PrintDialog (p. 1009) or wxPrintPreview::Print (p. 1017). These functions set last error to wxPRINTER_NO_ERROR if no error happened. Returned value is one of the following: wxPRINTER_NO_ERROR wxPRINTER_CANCELLED wxPRINTER_ERROR No error happened. The user cancelled printing. There was an error during printing.

wxPrinter::GetPrintDialogData
wxPrintDialogData& GetPrintDialogData() Returns the print data (p. 996) associated with the printer object.

wxPrinter::Print
bool Print(wxWindow *parent, wxPrintout *printout, bool prompt=true) Starts the printing process. Provide a parent window, a user-defined wxPrintout object which controls the printing of a document, and whether the print dialog should be invoked first. Print could return false if there was a problem initializing the printer device context (current printer not set, for example) or the user cancelled printing. CallwxPrinter::GetLastError (p. 1008) to get detailed information about the kind of the error.

wxPrinter::PrintDialog
wxDC* PrintDialog(wxWindow *parent) Invokes the print dialog. If successful (the user did not press Cancel and no error occurred), a suitable device context will be returned (otherwise NULL is returned -callwxPrinter::GetLastError (p. 1008) to get detailed information about the kind of the error). The application must delete this device context to avoid a memory leak.

wxPrinter::ReportError
void ReportError(wxWindow *parent, wxPrintout *printout, const wxString& message)

1009


CHAPTER 7
Default error-reporting function.

wxPrinter::Setup
bool Setup(wxWindow *parent) Invokes the print setup dialog. Note that the setup dialog is obsolete from Windows 95, though retained for backward compatibility.

wxPrinterDC
A printer device context is specific to Windows, and allows access to any printer with a Windows driver. See wxDC (p. 347) for further information on device contexts, and wxDC::GetSize (p. 359) for advice on achieving the correct scaling for the page. Derived from wxDC (p. 347) wxObject (p. 347) Include files <wx/dcprint.h> See also wxDC (p. 347), Printing framework overview (p. 1664)

wxPrinterDC::wxPrinterDC
wxPrinterDC(const wxPrintData& printData) Pass a wxPrintData (p. 996) object with information necessary for setting up a suitable printer device context. This is the recommended way to construct a wxPrinterDC. wxPrinterDC(const wxString& driver, const wxString& device, const wxString& output, const bool interactive = true, int orientation = wxPORTRAIT) Constructor. With empty strings for the first three arguments, the default printer dialog is displayed. device indicates the type of printer and outputis an optional file for printing to. The driver parameter is currently unused. Use the Ok member to test whether the constructor was successful in creating a usable device context. This constructor is deprecated and retained only for backward compatibility.

wxPrintout
1010


CHAPTER 7
This class encapsulates the functionality of printing out an application document. A new class must be derived and members overridden to respond to calls such as OnPrintPage and HasPage. Instances of this class are passed to wxPrinter::Print or a wxPrintPreview object to initiate printing or previewing. Derived from wxObject (p. 954) Include files <wx/print.h> See also Printing framework overview (p. 1664), wxPrinterDC (p. 1010), wxPrintDialog (p. 1002), wxPrinter (p. 1007), wxPrintPreview (p. 1014)

wxPrintout::wxPrintout
wxPrintout(const wxString& title = "Printout") Constructor. Pass an optional title argument - the current filename would be a good idea. This will appear in the printing list (at least in MSW)

wxPrintout::~wxPrintout
~wxPrintout() Destructor.

wxPrintout::GetDC
wxDC * GetDC() Returns the device context associated with the printout (given to the printout at start of printing or previewing). This will be a wxPrinterDC if printing under Windows, a wxPostScriptDC if printing on other platforms, and a wxMemoryDC if previewing.

wxPrintout::GetPageInfo
void GetPageInfo(int *minPage, int *maxPage, int *pageFrom, int *pageTo) Called by the framework to obtain information from the application about minimum and maximum page values that the user can select, and the required page range to be printed. By default this returns 1, 32000 for the page minimum and maximum values, and 1, 1 for the required page range.

1011


CHAPTER 7
If minPage is zero, the page number controls in the print dialog will be disabled. wxPython note: When this method is implemented in a derived Python class, it should be designed to take no parameters (other than the self reference) and to return a tuple of four integers. wxPerl note: When this method is overridden in a derived class, it must not take any parameters, and returns a 4-element list.

wxPrintout::GetPageSizeMM
void GetPageSizeMM(int *w, int *h) Returns the size of the printer page in millimetres. wxPython note: This method returns the output-only parameters as a tuple. wxPerl note: In wxPerl this method takes no arguments and returns a 2-element list ( w, h )

wxPrintout::GetPageSizePixels
void GetPageSizePixels(int *w, int *h) Returns the size of the printer page in pixels. These may not be the same as the values returned from wxDC::GetSize (p. 359) if the printout is being used for previewing, since in this case, a memory device context is used, using a bitmap size reflecting the current preview zoom. The application must take this discrepancy into account if previewing is to be supported. wxPython note: This method returns the output-only parameters as a tuple. wxPerl note: In wxPerl this method takes no arguments and returns a 2-element list ( w, h )

wxPrintout::GetPPIPrinter
void GetPPIPrinter(int *w, int *h) Returns the number of pixels per logical inch of the printer device context. Dividing the printer PPI by the screen PPI can give a suitable scaling factor for drawing text onto the printer. Remember to multiply this by a scaling factor to take the preview DC size into account. wxPython note: This method returns the output-only parameters as a tuple. wxPerl note: In wxPerl this method takes no arguments and returns a 2-element list ( w, h )

1012


CHAPTER 7 wxPrintout::GetPPIScreen
void GetPPIScreen(int *w, int *h) Returns the number of pixels per logical inch of the screen device context. Dividing the printer PPI by the screen PPI can give a suitable scaling factor for drawing text onto the printer. Remember to multiply this by a scaling factor to take the preview DC size into account.

wxPrintout::GetTitle
wxString GetTitle() Returns the title of the printout wxPython note: This method returns the output-only parameters as a tuple. wxPerl note: In wxPerl this method takes no arguments and returns a 2-element list ( w, h )

wxPrintout::HasPage
bool HasPage(int pageNum) Should be overridden to return true if the document has this page, or false if not. Returning false signifies the end of the document. By default, HasPage behaves as if the document has only one page.

wxPrintout::IsPreview
bool IsPreview() Returns true if the printout is currently being used for previewing.

wxPrintout::OnBeginDocument
bool OnBeginDocument(int startPage, int endPage) Called by the framework at the start of document printing. Return false from this function cancels the print job. OnBeginDocument is called once for every copy printed. The base wxPrintout::OnBeginDocument must be called (and the return value checked) from within the overridden function, since it calls wxDC::StartDoc. wxPython note: If this method is overridden in a Python class then the base class version can be called by using the methodbase_OnBeginDocument(startPage, endPage).

1013


CHAPTER 7 wxPrintout::OnEndDocument
void OnEndDocument() Called by the framework at the end of document printing. OnEndDocument is called once for every copy printed. The base wxPrintout::OnEndDocument must be called from within the overridden function, since it calls wxDC::EndDoc.

wxPrintout::OnBeginPrinting
void OnBeginPrinting() Called by the framework at the start of printing. OnBeginPrinting is called once for every print job (regardless of how many copies are being printed).

wxPrintout::OnEndPrinting
void OnEndPrinting() Called by the framework at the end of printing. OnEndPrinting is called once for every print job (regardless of how many copies are being printed).

wxPrintout::OnPreparePrinting
void OnPreparePrinting() Called once by the framework before any other demands are made of the wxPrintout object. This gives the object an opportunity to calculate the number of pages in the document, for example.

wxPrintout::OnPrintPage
bool OnPrintPage(int pageNum) Called by the framework when a page should be printed. Returning false cancels the print job. The application can use wxPrintout::GetDC to obtain a device context to draw on.

wxPrintPreview
Objects of this class manage the print preview process. The object is passed a wxPrintout object, and the wxPrintPreview object itself is passed to a wxPreviewFrame object. Previewing is started by initializing and showing the preview frame. Unlike wxPrinter::Print, flow of control returns to the application immediately after the frame is

1014


CHAPTER 7
shown. Derived from wxObject (p. 954) Include files <wx/print.h> See also Printing framework overview (p. 1664), wxPrinterDC (p. 1010), wxPrintDialog (p. 1002), wxPrintout (p. 1010), wxPrinter (p. 1007), wxPreviewCanvas (p. 992), wxPreviewControlBar (p. 993), wxPreviewFrame (p. 995).

wxPrintPreview::wxPrintPreview
wxPrintPreview(wxPrintout* printout, wxPrintout* printoutForPrinting,wxPrintData* data=NULL) Constructor. Pass a printout object, an optional printout object to be used for actual printing, and the address of an optional block of printer data, which will be copied to the print preview object's print data. If printoutForPrinting is non-NULL, a Print... button will be placed on the preview frame so that the user can print directly from the preview interface. Do not explicitly delete the printout objects once this destructor has been called, since they will be deleted in the wxPrintPreview constructor. The same does not apply to the data argument. Test the Ok member to check whether the wxPrintPreview object was created correctly. Ok could return false if there was a problem initializing the printer device context (current printer not set, for example).

wxPrintPreview::~wxPrintPreview
~wxPrinter() Destructor. Deletes both print preview objects, so do not destroy these objects in your application.

wxPrintPreview::DrawBlankPage
bool DrawBlankPage(wxWindow* window) Draws a representation of the blank page into the preview window. Used internally.

1015


CHAPTER 7 wxPrintPreview::GetCanvas
wxPreviewCanvas* GetCanvas() Gets the preview window used for displaying the print preview image.

wxPrintPreview::GetCurrentPage
int GetCurrentPage() Gets the page currently being previewed.

wxPrintPreview::GetFrame
wxFrame * GetFrame() Gets the frame used for displaying the print preview canvas and control bar.

wxPrintPreview::GetMaxPage
int GetMaxPage() Returns the maximum page number.

wxPrintPreview::GetMinPage
int GetMinPage() Returns the minimum page number.

wxPrintPreview::GetPrintData
wxPrintData& GetPrintData() Returns a reference to the internal print data.

wxPrintPreview::GetPrintout
wxPrintout * GetPrintout() Gets the preview printout object associated with the wxPrintPreview object.

wxPrintPreview::GetPrintoutForPrinting
wxPrintout * GetPrintoutForPrinting()

1016


CHAPTER 7
Gets the printout object to be used for printing from within the preview interface, or NULL if none exists.

wxPrintPreview::Ok
bool Ok() Returns true if the wxPrintPreview is valid, false otherwise. It could return false if there was a problem initializing the printer device context (current printer not set, for example).

wxPrintPreview::PaintPage
bool PaintPage(wxWindow* window) This refreshes the preview window with the preview image. It must be called from the preview window's OnPaint member. The implementation simply blits the preview bitmap onto the canvas, creating a new preview bitmap if none exists.

wxPrintPreview::Print
bool Print(bool prompt) Invokes the print process using the second wxPrintout object supplied in the wxPrintPreview constructor. Will normally be called by the Print... panel item on the preview frame's control bar. Returns false in case of error -- callwxPrinter::GetLastError (p. 1008) to get detailed information about the kind of the error.

wxPrintPreview::RenderPage
bool RenderPage(int pageNum) Renders a page into a wxMemoryDC. Used internally by wxPrintPreview.

wxPrintPreview::SetCanvas
void SetCanvas(wxPreviewCanvas** window) Sets the window to be used for displaying the print preview image.

wxPrintPreview::SetCurrentPage
void SetCurrentPage(int pageNum)

1017


CHAPTER 7
Sets the current page to be previewed.

wxPrintPreview::SetFrame
void SetFrame(wxFrame *frame) Sets the frame to be used for displaying the print preview canvas and control bar.

wxPrintPreview::SetPrintout
void SetPrintout(wxPrintout *printout) Associates a printout object with the wxPrintPreview object.

wxPrintPreview::SetZoom
void SetZoom(int percent) Sets the percentage preview zoom, and refreshes the preview canvas accordingly.

wxPrivateDropTarget
wxPrivateDropTarget is for... Derived from wxDropTarget (p. 429) Include files <wx/dnd.h> See also wxDropTarget (p. 429)

wxPrivateDropTarget::wxPrivateDropTarget
wxPrivateDropTarget()

wxPrivateDropTarget::SetId
void SetId(const wxString& id)

1018


CHAPTER 7
You have to override OnDrop to get at the data. The string ID identifies the format of clipboard or DnD data. A word processor would e.g. add a wxTextDataObject and a wxPrivateDataObject to the clipboard - the latter with the Id "WXWORD_FORMAT".

wxPrivateDropTarget::GetId
virtual wxString GetId() const

wxProcess
The objects of this class are used in conjunction with thewxExecute (p. 1469) function. When a wxProcess object is passed to wxExecute(), its OnTerminate() (p. 1023) virtual method is called when the process terminates. This allows the program to be (asynchronously) notified about the process termination and also retrieve its exit status which is unavailable from wxExecute() in the case of asynchronous execution. Please note that if the process termination notification is processed by the parent, it is responsible for deleting the wxProcess object which sent it. However, if it is not processed, the object will delete itself and so the library users should only delete those objects whose notifications have been processed (and call Detach() (p. 1020) for others). wxProcess also supports IO redirection of the child process. For this, you have to call its Redirect (p. 1024) method before passing it towxExecute (p. 1469). If the child process was launched successfully,GetInputStream (p. 1021),GetOutputStream (p. 1021) andGetErrorStream (p. 1021) can then be used to retrieve the streams corresponding to the child process standard output, input and error output respectively. wxPerl note: In wxPerl this class has an additional Destroy method, for explicit destruction. Derived from wxEvtHandler (p. 443) Include files <wx/process.h> See also wxExecute (p. 1469) exec sample (p. 1565)

wxProcess::wxProcess
wxProcess(wxEvtHandler * parent = NULL, int id = -1)

1019


CHAPTER 7
wxProcess(int flags) Constructs a process object. id is only used in the case you want to use wxWindows events. It identifies this object, or another window that will receive the event. If the parent parameter is different from NULL, it will receive a wxEVT_END_PROCESS notification event (you should insert EVT_END_PROCESS macro in the event table of the parent to handle it) with the given id. The second constructor creates an object without any associated parent (and hence no id neither) but allows to specify the flags which can have the value of wxPROCESS_DEFAULT or wxPROCESS_REDIRECT. Specifying the former value has no particular effect while using the latter one is equivalent to calling Redirect (p. 1024). Parameters parent The event handler parent. id id of an event. flags either wxPROCESS_DEFAULT or wxPROCESS_REDIRECT

wxProcess::~wxProcess
~wxProcess() Destroys the wxProcess object.

wxProcess::CloseOutput
void CloseOutput() Closes the output stream (the one connected to the stdin of the child process). This function can be used to indicate to the child process that there is no more data to be read - usually, a filter program will only terminate when the input stream is closed.

wxProcess::Detach
void Detach() Normally, a wxProcess object is deleted by its parent when it receives the notification about the process termination. However, it might happen that the parent object is destroyed before the external process is terminated (e.g. a window from which this external process was launched is closed by the user) and in this case it should not

1020


CHAPTER 7
delete the wxProcess object, butshould call Detach() instead. After the wxProcess object is detached from its parent, no notification events will be sent to the parent and the object will delete itself upon reception of the process termination notification.

wxProcess::GetErrorStream
wxInputStream* GetErrorStream() const Returns an input stream which corresponds to the standard error output (stderr) of the child process.

wxProcess::GetInputStream
wxInputStream* GetInputStream() const It returns an input stream corresponding to the standard output stream of the subprocess. If it is NULL, you have not turned on the redirection. See wxProcess::Redirect (p. 1024).

wxProcess::GetOutputStream
wxOutputStream* GetOutputStream() const It returns an output stream correspoding to the input stream of the subprocess. If it is NULL, you have not turned on the redirection. See wxProcess::Redirect (p. 1024).

wxProcess::IsErrorAvailable
bool IsErrorAvailable() const Returns true if there is data to be read on the child process standard error stream. See also IsInputAvailable (p. 1021)

wxProcess::IsInputAvailable
bool IsInputAvailable() const Returns true if there is data to be read on the child process standard output stream. This allows to write simple (and extremely inefficient) polling-based code waiting for a better mechanism in future wxWindows versions. See the exec sample (p. 1565) for an example of using this function. See also

1021


CHAPTER 7
IsInputOpened (p. 1022)

wxProcess::IsInputOpened
bool IsInputOpened() const Returns true if the child process standard output stream is opened.

wxProcess::Kill
static wxKillError Kill(int pid, wxSignal signal = wxSIGNONE) Send the specified signal to the given process. Possible signal values are:
enum wxSignal { wxSIGNONE = 0, wxSIGHUP, wxSIGINT, wxSIGQUIT, wxSIGILL, wxSIGTRAP, wxSIGABRT, wxSIGEMT, wxSIGFPE, wxSIGKILL, wxSIGBUS, wxSIGSEGV, wxSIGSYS, wxSIGPIPE, wxSIGALRM, wxSIGTERM };

// verify if the process exists under Unix

// forcefully kill, dangerous!

// terminate the process gently

wxSIGNONE, wxSIGKILL and wxSIGTERM have the same meaning under both Unix and Windows but all the other signals are equivalent towxSIGTERM under Windows. Returns the element of wxKillError enum:
enum wxKillError { wxKILL_OK, wxKILL_BAD_SIGNAL, wxKILL_ACCESS_DENIED, wxKILL_NO_PROCESS, wxKILL_ERROR };

// // // // //

no error no such signal permission denied no such process another, unspecified error

See also wxProcess::Exists (p. 1022), wxKill (p. 1471), Exec sample (p. 1565)

wxProcess::Exists
static bool Exists(int pid) Returns true if the given process exists in the system.

1022


CHAPTER 7
See also wxProcess::Kill (p. 1022), Exec sample (p. 1565)

wxProcess::OnTerminate
void OnTerminate(int pid, int status) const It is called when the process with the pid pid finishes. It raises a wxWindows event when it isn't overridden. pid The pid of the process which has just terminated. status The exit code of the process.

wxProcess::Open
static wxProcess * Open(const wxString& cmd int flags = wxEXEC_ASYNC) This static method replaces the standard popen() function: it launches the process specified by the cmd parameter and returns the wxProcess object which can be used to retrieve the streams connected to the standard input, output and error output of the child process. If the process couldn't be launched, NULL is returned. Note that in any case the returned pointer should not be deleted, rather the process object will be destroyed automatically when the child process terminates. This does mean that the child process should be told to quit before the main program exits to avoid memory leaks. Parameters cmd The command to execute, including optional arguments. flags The flags to pass to wxExecute (p. 1469). NOTE: wxEXEC_SYNC should not be used. Return value A pointer to new wxProcess object or NULL on error. See also wxExecute (p. 1469)

1023


CHAPTER 7 wxProcess::Redirect
void Redirect() Turns on redirection. wxExecute will try to open a couple of pipes to catch the subprocess stdio. The caught input stream is returned by GetOutputStream() as a nonseekable stream. The caught output stream is returned by GetInputStream() as a nonseekable stream.

wxProcessEvent
A process event is sent when a process is terminated. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/process.h> Event table macros To process a wxProcessEvent, use these event handler macros to direct input to a member function that takes a wxProcessEvent argument. EVT_END_PROCESS(id, func) Process a wxEVT_END_PROCESS event.id is the identifier of the process object (the id passed to the wxProcess constructor) or a window to receive the event.

See also wxProcess (p. 1019), Event handling overview (p. 1602)

wxProcessEvent::wxProcessEvent
wxProcessEvent(int id = 0, int pid = 0, int exitcode = 0) Constructor. Takes a wxProcessObject or window id, a process id and an exit status.

wxProcessEvent::GetPid
int GetPid() const Returns the process id.

1024


CHAPTER 7 wxProcessEvent::GetExitCode
int GetExitCode() Returns the exist status.

wxProgressDialog
This class represents a dialog that shows a short message and a progress bar. Optionally, it can display an ABORT button. Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/progdlg.h>

wxProgressDialog::wxProgressDialog
wxProgressDialog(const wxString& title, const wxString& message, int maximum = 100, wxWindow * parent = NULL, int style = wxPD_AUTO_HIDE | wxPD_APP_MODAL) Constructor. Creates the dialog, displays it and disables user input for other windows, or, if wxPD_APP_MODAL flag is not given, for its parent window only. Parameters title Dialog title to show in titlebar. message Message displayed above the progress bar. maximum Maximum value for the progress bar. parent Parent window. style

1025


CHAPTER 7
The dialog style. This is the combination of the following bitmask constants defined in wx/defs.h: wxPD_APP_MODAL Make the progress dialog modal. If this flag is not given, it is only "locally" modal that is the input to the parent window is disabled, but not to the other ones. Causes the progress dialog to disappear from screen as soon as the maximum value of the progress meter has been reached. This flag tells the dialog that it should have a "Cancel" button which the user may press. If this happens, the next call to Update() (p. 1026) will return false. This flag tells the dialog that it should show elapsed time (since creating the dialog). This flag tells the dialog that it should show estimated time. This flag tells the dialog that it should show remaining time.

wxPD_AUTO_HIDE

wxPD_CAN_ABORT

wxPD_ELAPSED_TIME

wxPD_ESTIMATED_TIME wxPD_REMAINING_TIME

wxProgressDialog::~wxProgressDialog
~wxMessageDialog() Destructor. Deletes the dialog and enables all top level windows.

wxProgressDialog::Resume
void Resume() Can be used to continue with the dialog, after the user had chosen ABORT.

wxProgressDialog::Update
bool Update( int value, const wxString& newmsg = "") Updates the dialog, setting the progress bar to the new value and, if given changes the message above it. Returns true unless the Cancel button has been pressed. If false is returned, the application can either immediately destroy the dialog or ask the user for the confirmation and if the abort is not confirmed the dialog may be resumed

1026


CHAPTER 7
with Resume (p. 1026) function. Parameters value The new value of the progress meter. It must be strictly less than the maximum value given to the constructor (i.e., as usual in C, the index runs from 0 to maximum-1). newmsg The new messages for the progress dialog text, if it is empty (which is the default) the message is not changed.

wxProtocol
Derived from wxSocketClient (p. 1148) Include files <wx/protocol/protocol.h> See also wxSocketBase (p. 1131), wxURL (p. 1355)

wxProtocol::Reconnect
bool Reconnect() Tries to reestablish a previous opened connection (close and renegotiate connection). Return value true, if the connection is established, else false.

wxProtocol::GetInputStream
wxInputStream * GetInputStream(const wxString& path) Creates a new input stream on the the specified path. You can use all but seek functionality of wxStream. Seek isn't available on all stream. For example, http or ftp streams doesn't deal with it. Other functions like StreamSize and Tell aren't available for the moment for this sort of stream. You will be notified when the EOF is reached by an error.

1027


CHAPTER 7
Return value Returns the initialized stream. You will have to delete it yourself once you don't use it anymore. The destructor closes the network connection. See also wxInputStream (p. 762)

wxProtocol::Abort
bool Abort() Abort the current stream. Warning It is advised to destroy the input stream instead of aborting the stream this way. Return value Returns true, if successful, else false.

wxProtocol::GetError
wxProtocolError GetError() Returns the last occurred error. wxPROTO_NOERR wxPROTO_NETERR wxPROTO_PROTERR wxPROTO_CONNERR wxPROTO_INVVAL wxPROTO_NOHNDLR wxPROTO_NOFILE wxPROTO_ABRT wxPROTO_RCNCT wxPROTO_STREAM No error. A generic network error occurred. An error occurred during negotiation. The client failed to connect the server. Invalid value. . The remote file doesn't exist. Last action aborted. An error occurred during reconnection. Someone tried to send a command during a transfer.

wxProtocol::GetContentType

1028


CHAPTER 7
wxString GetContentType() Returns the type of the content of the last opened stream. It is a mime-type.

wxProtocol::SetUser
void SetUser(const wxString& user) Sets the authentication user. It is mainly useful when FTP is used.

wxProtocol::SetPassword
void SetPassword(const wxString& user) Sets the authentication password. It is mainly useful when FTP is used.

wxQuantize
Performs quantization, or colour reduction, on a wxImage. Functions in this class are static and so a wxQuantize object need not be created. Derived from wxObject (p. 954) Include files <wx/quantize.h>

wxQuantize::wxQuantize
wxQuantize() Constructor. You do not need to construct a wxQuantize object since its functions are static.

wxQuantize::Quantize
bool Quantize(const wxImage& src, wxImage& dest, wxPalette** pPalette, int desiredNoColours = 236, unsigned char** eightBitData = 0, int flags = wxQUANTIZE_INCLUDE_WINDOWS_COLOURS|wxQUANTIZE_FILL_DESTINATION_ IMAGE|wxQUANTIZE_RETURN_8BIT_DATA) Reduce the colours in the source image and put the result into the destination image.

1029


CHAPTER 7
Both images may be the same, to overwrite the source image. Specify an optional palette pointer to receive the resulting palette. This palette may be passed to ConvertImageToBitmap, for example. If you pass a palette pointer, you must free the palette yourself. bool Quantize(const wxImage& src, wxImage& dest, int desiredNoColours = 236, unsigned char** eightBitData = 0, int flags = wxQUANTIZE_INCLUDE_WINDOWS_COLOURS|wxQUANTIZE_FILL_DESTINATION_ IMAGE|wxQUANTIZE_RETURN_8BIT_DATA) This version sets a palette in the destination image so you don't have to manage it yourself.

wxQuantize::DoQuantize
void DoQuantize(unsigned w, unsigned h, unsigned char** in_rows, unsigned char** out_rows, unsigned char* palette, int desiredNoColours) Converts input bitmap(s) into 8bit representation with custom palette. in_rows and out_rows are arrays [0..h-1] of pointer to rows (in_rows contains w * 3 bytes per row, out_rows w bytes per row). Fills out_rows with indexes into palette (which is also stored into palette variable).

wxQueryLayoutInfoEvent
This event is sent when wxLayoutAlgorithm (p. 781) wishes to get the size, orientation and alignment of a window. More precisely, the event is sent by the OnCalculateLayout handler which is itself invoked by wxLayoutAlgorithm. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/laywin.h> Event table macros EVT_QUERY_LAYOUT_INFO(func) Process a wxEVT_QUERY_LAYOUT_INFO event, to get size, orientation and alignment from a window.

Data structures
enum wxLayoutOrientation { wxLAYOUT_HORIZONTAL, wxLAYOUT_VERTICAL

1030


CHAPTER 7
}; enum wxLayoutAlignment { wxLAYOUT_NONE, wxLAYOUT_TOP, wxLAYOUT_LEFT, wxLAYOUT_RIGHT, wxLAYOUT_BOTTOM, };

See also wxCalculateLayoutEvent (p. 107), wxSashLayoutWindow (p. 1065), wxLayoutAlgorithm (p. 781).

wxQueryLayoutInfoEvent::wxQueryLayoutInfoEvent
wxQueryLayoutInfoEvent(wxWindowID id = 0) Constructor.

wxQueryLayoutInfoEvent::GetAlignment
void GetAlignment() const Specifies the alignment of the window (which side of the remaining parent client area the window sticks to). One of wxLAYOUT_TOP, wxLAYOUT_LEFT, wxLAYOUT_RIGHT, wxLAYOUT_BOTTOM.

wxQueryLayoutInfoEvent::GetFlags
int GetFlags() const Returns the flags associated with this event. Not currently used.

wxQueryLayoutInfoEvent::GetOrientation
wxLayoutOrientation GetOrientation() const Returns the orientation that the event handler specified to the event object. May be one of wxLAYOUT_HORIZONTAL, wxLAYOUT_VERTICAL.

wxQueryLayoutInfoEvent::GetRequestedLength
int GetRequestedLength() const

1031


CHAPTER 7
Returns the requested length of the window in the direction of the window orientation. This information is not yet used.

wxQueryLayoutInfoEvent::GetSize
wxSize GetSize() const Returns the size that the event handler specified to the event object as being the requested size of the window.

wxQueryLayoutInfoEvent::SetAlignment
void SetAlignment(wxLayoutAlignment alignment) Call this to specify the alignment of the window (which side of the remaining parent client area the window sticks to). May be one of wxLAYOUT_TOP, wxLAYOUT_LEFT, wxLAYOUT_RIGHT, wxLAYOUT_BOTTOM.

wxQueryLayoutInfoEvent::SetFlags
void SetFlags(int flags) Sets the flags associated with this event. Not currently used.

wxQueryLayoutInfoEvent::SetOrientation
void SetOrientation(wxLayoutOrientation orientation) Call this to specify the orientation of the window. May be one of wxLAYOUT_HORIZONTAL, wxLAYOUT_VERTICAL.

wxQueryLayoutInfoEvent::SetRequestedLength
void SetRequestedLength(int length) Sets the requested length of the window in the direction of the window orientation. This information is not yet used.

wxQueryLayoutInfoEvent::SetSize
void SetSize(const wxSize& size) Call this to let the calling code know what the size of the window is.

1032


CHAPTER 7

wxRadioBox
A radio box item is used to select one of number of mutually exclusive choices. It is displayed as a vertical column or horizontal row of labelled buttons. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/radiobox.h> Window styles wxRA_SPECIFY_ROWS wxRA_SPECIFY_COLS The major dimension parameter refers to the maximum number of rows. The major dimension parameter refers to the maximum number of columns.

See also window styles overview (p. 1611). Event handling EVT_RADIOBOX(id, func) Process a wxEVT_COMMAND_RADIOBOX_SELECTED event, when a radiobutton is clicked.

See also Event handling overview (p. 1602), wxRadioButton (p. 1039), wxCheckBox (p. 120)

wxRadioBox::wxRadioBox
wxRadioBox() Default constructor. wxRadioBox(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& point = wxDefaultPosition, const wxSize& size = wxDefaultSize, int n = 0, const wxString choices[] = NULL, int majorDimension = 0, long style = wxRA_SPECIFY_COLS, const wxValidator& validator = wxDefaultValidator, const wxString& name = "radioBox") wxRadioBox(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& point, const wxSize& size, const wxArrayString& choices, int majorDimension = 0, long style = wxRA_SPECIFY_COLS, const wxValidator&

1033


CHAPTER 7
validator = wxDefaultValidator, const wxString& name = "radioBox") Constructor, creating and showing a radiobox. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. label Label for the static box surrounding the radio buttons. pos Window position. If the position (-1, -1) is specified then a default position is chosen. size Window size. If the default size (-1, -1) is specified then a default size is chosen. n Number of choices with which to initialize the radiobox. choices An array of choices with which to initialize the radiobox. majorDimension Specifies the maximum number of rows (if style contains wxRA_SPECIFY_ROWS) or columns (if style contains wxRA_SPECIFY_COLS) for a two-dimensional radiobox. style Window style. See wxRadioBox (p. 1033). validator Window validator. name Window name. See also wxRadioBox::Create (p. 1035), wxValidator (p. 1358)

1034


CHAPTER 7
wxPython note: The wxRadioBox constructor in wxPython reduces the nand choices arguments are to a single argument, which is a list of strings. wxPerl note: In wxPerl there is just an array reference in place of nand choices.

wxRadioBox::~wxRadioBox
~wxRadioBox() Destructor, destroying the radiobox item.

wxRadioBox::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& point = wxDefaultPosition, const wxSize& size = wxDefaultSize, int n = 0, const wxString choices[] = NULL, int majorDimension = 0, long style = wxRA_SPECIFY_COLS, const wxValidator& validator = wxDefaultValidator, const wxString& name = "radioBox") bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& point, const wxSize& size, const wxArrayString& choices, int majorDimension = 0, long style = wxRA_SPECIFY_COLS, const wxValidator& validator = wxDefaultValidator, const wxString& name = "radioBox") Creates the radiobox for two-step construction. See wxRadioBox::wxRadioBox (p. 1033) for further details.

wxRadioBox::Enable
void Enable(bool enable = true) Enables or disables the entire radiobox. void Enable(int n, bool enable = true) Enables or disables an individual button in the radiobox. Parameters enable true to enable, false to disable. n The zero-based button to enable or disable. wxPython note: In place of a single overloaded method name, wxPython implements the following methods:

1035


CHAPTER 7
Enable(flag) EnableItem(n, flag) Enables or disables the entire radiobox. Enables or disables an individual button in the radiobox.

wxRadioBox::FindString
int FindString(const wxString& string) const Finds a button matching the given string, returning the position if found, or -1 if not found. Parameters string The string to find.

wxRadioBox::GetCount
int GetCount() const Returns the number of items in the radiobox.

wxRadioBox::GetLabel
wxString GetLabel() const Returns the radiobox label. wxString GetLabel(int n) const Returns the label for the given button. Parameters n The zero-based button index. See also wxRadioBox::SetLabel (p. 1037) wxPython note: In place of a single overloaded method name, wxPython implements the following methods: GetLabel() Returns the radiobox label.

1036


CHAPTER 7
GetItemLabel(n) Returns the label for the given button.

wxRadioBox::GetSelection
int GetSelection() const Returns the zero-based position of the selected button.

wxRadioBox::GetStringSelection
wxString GetStringSelection() const Returns the selected string.

wxRadioBox::GetString
wxString GetString(int n) const Returns the label for the button at the given position. Parameters n The zero-based button position.

wxRadioBox::Number
int Number() const Obsolescence note: This method is obsolete and was replaced with GetCount (p. 1036), please use the new method in the new code. This method is only available if wxWindows was compiled with WXWIN_COMPATIBILITY_2_2 defined and will disappear completely in future versions. Returns the number of buttons in the radiobox.

wxRadioBox::SetLabel
void SetLabel(const wxString& label) Sets the radiobox label. void SetLabel(int n, const wxString& label) Sets a label for a radio button.

1037


CHAPTER 7
Parameters label The label to set. n The zero-based button index. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: SetLabel(string) SetItemLabel(n, string) Sets the radiobox label. Sets a label for a radio button.

wxRadioBox::SetSelection
void SetSelection(int n) Sets a button by passing the desired string position. This does not cause a wxEVT_COMMAND_RADIOBOX_SELECTED event to get emitted. Parameters n The zero-based button position.

wxRadioBox::SetStringSelection
void SetStringSelection(const wxString& string) Sets the selection to a button by passing the desired string. This does not cause a wxEVT_COMMAND_RADIOBOX_SELECTED event to get emitted. Parameters string The label of the button to select.

wxRadioBox::Show
void Show(const bool show) Shows or hides the entire radiobox. void Show(int item, const bool show)

1038


CHAPTER 7
Shows or hides individual buttons. Parameters show true to show, false to hide. item The zero-based position of the button to show or hide. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: Show(flag) ShowItem(n, flag) Shows or hides the entire radiobox. Shows or hides individual buttons.

wxRadioButton
A radio button item is a button which usually denotes one of several mutually exclusive options. It has a text label next to a (usually) round button. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/radiobut.h> Window styles wxRB_GROUP wxRB_SINGLE Marks the beginning of a new group of radio buttons. If your radio buttons are not consecutive siblings, they cannot form a group under Windows and you should use this style to indicate that each of them is handled individually.

See also window styles overview (p. 1611). Event handling EVT_RADIOBUTTON(id, func) Process a wxEVT_COMMAND_RADIOBUTTON_SELEC TED event, when the radiobutton is clicked.

1039


CHAPTER 7
See also Event handling overview (p. 1602), wxRadioBox (p. 1033), wxCheckBox (p. 120)

wxRadioButton::wxRadioButton
wxRadioButton() Default constructor. wxRadioButton(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "radioButton") Constructor, creating and showing a radio button. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. label Label for the radio button. pos Window position. If the position (-1, -1) is specified then a default position is chosen. size Window size. If the default size (-1, -1) is specified then a default size is chosen. style Window style. See wxRadioButton (p. 1039). validator Window validator. name Window name.

1040


CHAPTER 7
See also wxRadioButton::Create (p. 1041), wxValidator (p. 1358)

wxRadioButton::~wxRadioButton
void ~wxRadioButton() Destructor, destroying the radio button item.

wxRadioButton::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = "radioButton") Creates the choice for two-step construction. See wxRadioButton::wxRadioButton (p. 1040) for further details.

wxRadioButton::GetValue
bool GetValue() const Returns true if the radio button is depressed, false otherwise.

wxRadioButton::SetValue
void SetValue(const bool value) Sets the radio button to selected or deselected status. This does not cause a wxEVT_COMMAND_RADIOBUTTON_SELECTED event to get emitted. Parameters value true to select, false to deselect.

wxRealPoint
A wxRealPoint is a useful data structure for graphics operations. It contains floating point point x and y members. See also wxPoint (p. 991) for an integer version. Derived from None

1041


CHAPTER 7
Include files <wx/gdicmn.h> See also wxPoint (p. 991)

wxRealPoint::wxRealPoint
wxRealPoint() wxRealPoint(double x, double y) Create a point. double x double y Members of the wxRealPoint object.

wxRect
A class for manipulating rectangles. Derived from None Include files <wx/gdicmn.h> See also wxPoint (p. 991), wxSize (p. 1106)

wxRect::wxRect
wxRect() Default constructor. wxRect(int x, int y, int width, int height) Creates a wxRect object from x, y, width and height values.

1042


CHAPTER 7
wxRect(const wxPoint& topLeft, const wxPoint& bottomRight) Creates a wxRect object from top-left and bottom-right points. wxRect(const wxPoint& pos, const wxSize& size) Creates a wxRect object from position and size values.

wxRect::x
int x x coordinate of the top-level corner of the rectangle.

wxRect::y
int y y coordinate of the top-level corner of the rectangle.

wxRect::width
int width Width member.

wxRect::height
int height Height member.

wxRect::Deflate
void Deflate(wxCoord dx, wxCoord dy) void Deflate(wxCoord diff) wxRect Deflate(wxCoord dx, wxCoord dy) const Decrease the rectangle size by dx in x direction and dy in y direction. Both (or one of) parameters may be negative to increase the rectngle size. This method is the opposite of Inflate (p. 1045). The second form uses the same diff for both dx and dy. The first two versions modify the rectangle in place, the last one returns a new rectangle leaving this one unchanged.

1043


CHAPTER 7
See also Inflate (p. 1045)

wxRect::GetBottom
int GetBottom() const Gets the bottom point of the rectangle.

wxRect::GetHeight
int GetHeight() const Gets the height member.

wxRect::GetLeft
int GetLeft() const Gets the left point of the rectangle (the same as wxRect::GetX (p. 1045)).

wxRect::GetPosition
wxPoint GetPosition() const Gets the position.

wxRect::GetTopLeft
wxPoint GetTopLeft() const Gets the topleft position of the rectangle. (Same as GetPosition).

wxRect::GetBottomRight
wxPoint GetBottomRight() const Gets the the bottom right position. Returns the bottom right point inside the rectangle.

wxRect::GetRight
int GetRight() const Gets the right point of the rectangle.

1044


CHAPTER 7 wxRect::GetSize
wxSize GetSize() const Gets the size.

wxRect::GetTop
int GetTop() const Gets the top point of the rectangle (the same as wxRect::GetY (p. 1045)).

wxRect::GetWidth
int GetWidth() const Gets the width member.

wxRect::GetX
int GetX() const Gets the x member.

wxRect::GetY
int GetY() const Gets the y member.

wxRect::Inflate
void Inflate(wxCoord dx, wxCoord dy) void Inflate(wxCoord diff) wxRect Inflate(wxCoord dx, wxCoord dy) const Increase the rectangle size by dx in x direction and dy in y direction. Both (or one of) parameters may be negative to decrease the rectangle size. The second form uses the same diff for both dx and dy. The first two versions modify the rectangle in place, the last one returns a new rectangle leaving this one unchanged. See also

1045


CHAPTER 7
Deflate (p. 1043)

wxRect:Inside
bool Inside(int x, int y) const bool Inside(const wxPoint& pt) const Returns true if the given point is inside the rectangle (or on its boundary) and false otherwise.

wxRect:Intersects
bool Intersects(const wxRect& rect) const Returns true if this rectangle has a non empty intersection with the rectangle rect and false otherwise.

wxRect::Offset
void Offset(wxCoord dx, wxCoord dy) void Offset(const wxPoint& pt) Moves the rectangle by the specified offset. If dx is positive, the rectangle is moved to the right, if dy is positive, it is moved to the bottom, otherwise it is moved to the left or top respectively.

wxRect::SetHeight
void SetHeight(int height) Sets the height.

wxRect::SetWidth
void SetWidth(int width) Sets the width.

wxRect::SetX
void SetX(int x) Sets the x position.

1046


CHAPTER 7 wxRect::SetY
void SetY(int y) Sets the y position.

wxRect::operator =
void operator =(const wxRect& rect) Assignment operator.

wxRect::operator ==
bool operator ==(const wxRect& rect) Equality operator.

wxRect::operator !=
bool operator !=(const wxRect& rect) Inequality operator.

wxRecursionGuard
wxRecursionGuard is a very simple class which can be used to prevent reentrancy problems in a function. It is not thread-safe and so should be used only in the singlethreaded programs or in combination with some thread synchronization mechanisms.
wxRecursionGuard is always used together with the wxRecursionGuardFlag (p. 1048) like in this example: void Foo() { static wxRecursionGuardFlag s_flag; wxRecursionGuard guard(s_flag); if ( guard.IsInside() ) { // don't allow reentrancy return; } ... }

As you can see, wxRecursionGuard simply tests the flag value and sets it to true if it hadn't been already set. IsInside() (p. 1048) allows testing the old flag value. The advantage of using this class compared to directly manipulating the flag is that the flag is always reset in the wxRecursionGuard destructor and so you don't risk to forget to do it even if the function returns in an unexpected way (for example because an exception has been thrown).

1047


CHAPTER 7
Derived from No base class Include files <wx/recguard.h>

wxRecursionGuard::wxRecursionGuard
wxRecursionGuard(wxRecursionGuardFlag& flag) A wxRecursionGuard object must always be initialized with a (static) wxRecursionGuardFlag (p. 1048). The constructor saves the value of the flag to be able to return the correct value from IsInside (p. 1048).

wxRecursionGuard::~wxRecursionGuard
~wxRecursionGuard() The destructor resets the flag value so that the function can be entered again the next time. Note that it is not virtual and so this class is not meant to be derived from (besides, there is absolutely no reason to do it anyhow).

wxRecursionGuard::IsInside
bool IsInside() const Returns true if we're already inside the code block "protected'' by this wxRecursionGuard (i.e. between this line and the end of current scope). Usually the function using wxRecursionGuard takes some specific actions in such case (may be simply returning) to prevent reentrant calls to itself. If this method returns false, it is safe to continue.

wxRecursionGuardFlag
This is a completely opaque class which exists only to be used with wxRecursionGuard (p. 1047), please see the example in that class documentation. Please notice that wxRecursionGuardFlag object must be declared static or the recursion would never be detected. Derived from

1048


CHAPTER 7
No base class Include files <wx/recguard.h>

wxRegEx
wxRegEx represents a regular expression. This class provides support for regular expressions matching and also replacement. It is built on top of either the system library (if it has support for POSIX regular expressions - which is the case of the most modern Unices) or uses the built in Henry Spencer's library. Henry Spencer would appreciate being given credit in the documentation of software which uses his library, but that is not a requirement. Regular expressions, as defined by POSIX, come in two flavours: extendedand basic. The builtin library also adds a third flavour of expression advanced (p. 1712), which is not available when using the system library. Unicode is fully supported only when using the builtin library. When using the system library in Unicode mode, the expressions and data are translated to the default 8-bit encoding before being passed to the library. On platforms where a system library is available, the default is to use the builtin library for Unicode builds, and the system library otherwise. It is possible to use the other if preferred by selecting it when building the wxWindows. Derived from No base class Data structures Flags for regex compilation to be used with Compile() (p. 1051):
enum { // use extended regex syntax wxRE_EXTENDED = 0, // use advanced RE syntax (built-in regex only) #ifdef wxHAS_REGEX_ADVANCED wxRE_ADVANCED = 1, #endif // use basic RE syntax wxRE_BASIC = 2, // ignore case in match wxRE_ICASE = 4, // only check match, don't set back references wxRE_NOSUB = 8, // if not set, treat '\n' as an ordinary character, otherwise it is // special: it is not matched by '.' and '^' and '$' always match // after/before it regardless of the setting of wxRE_NOT[BE]OL

1049


CHAPTER 7
wxRE_NEWLINE = 16,

// default flags wxRE_DEFAULT = wxRE_EXTENDED }

Flags for regex matching to be used with Matches() (p. 1051). These flags are mainly useful when doing several matches in a long string to prevent erroneous matches for '' and '$':
enum { // '^' doesn't match at the start of line wxRE_NOTBOL = 32, // '$' doesn't match at the end of line wxRE_NOTEOL = 64 }

Examples A bad example of processing some text containing email addresses (the example is bad because the real email addresses can have more complicated form thanuser@host.net):
wxString text; ... wxRegEx reEmail = "([^@]+)@([[:alnum:].-_].)+([[:alnum:]]+)"; if ( reEmail.Matches(text) ) { wxString text = reEmail.GetMatch(email); wxString username = reEmail.GetMatch(email, 1); if ( reEmail.GetMatch(email, 3) == "com" ) // .com TLD? { ... } } // or we could do this to hide the email address size_t count = reEmail.ReplaceAll(text, "HIDDEN@\\2\\3"); printf("text now contains %u hidden addresses", count);

wxRegEx::wxRegEx
wxRegEx() Default ctor: use Compile() (p. 1051) later. wxRegEx(const wxString& expr, int flags = wxRE_DEFAULT) Create and compile the regular expression, use IsValid (p. 1051) to test for compilation errors.

wxRegEx::~wxRegEx

1050


CHAPTER 7
~wxRegEx() dtor not virtual, don't derive from this class

wxRegEx::Compile
bool Compile(const wxString& pattern, int flags = wxRE_DEFAULT) Compile the string into regular expression, return true if ok or false if string has a syntax error.

wxRegEx::IsValid
bool IsValid() const Return true if this is a valid compiled regular expression, false otherwise.

wxRegEx::GetMatch
bool GetMatch(size_t* start, size_t* len, size_t index = 0) const Get the start index and the length of the match of the expression (if index is 0) or a bracketed subexpression (index different from 0). May only be called after successful call to Matches() (p. 1051) and only if wxRE_NOSUB was not used in Compile() (p. 1051). Returns false if no match or if an error occured. wxString GetMatch(const wxString& text, size_t index = 0) const Returns the part of string corresponding to the match where index is interpreted as above. Empty string is returned if match failed May only be called after successful call to Matches() (p. 1051) and only if wxRE_NOSUB was not used in Compile() (p. 1051).

wxRegEx::Matches
bool Matches(const wxChar* text, int flags = 0) const Matches the precompiled regular expression against the string text, returns true if matches and false otherwise. Flags may be combination of wxRE_NOTBOL and wxRE_NOTEOL. May only be called after successful call to Compile() (p. 1051).

1051


CHAPTER 7 wxRegEx::Replace
int Replace(wxString* text, const wxString& replacement, size_t maxMatches = 0) const Replaces the current regular expression in the string pointed to bytext, with the text in replacement and return number of matches replaced (maybe 0 if none found) or -1 on error. The replacement text may contain back references \number which will be replaced with the value of the corresponding subexpression in the pattern match. \0 corresponds to the entire match and & is a synonym for it. Backslash may be used to quote itself or & character. maxMatches may be used to limit the number of replacements made, setting it to 1, for example, will only replace first occurrence (if any) of the pattern in the text while default value of 0 means replace all.

wxRegEx::ReplaceAll
int ReplaceAll(wxString* text, const wxString& replacement) const Replace all occurrences: this is actually a synonym for Replace() (p. 1052). See also ReplaceFirst (p. 1052)

wxRegEx::ReplaceFirst
int ReplaceFirst(wxString* text, const wxString& replacement) const Replace the first occurrence. See also Replace (p. 1052)

wxRegion
A wxRegion represents a simple or complex region on a device context or window. It uses reference counting, so copying and assignment operations are fast. Derived from wxGDIObject (p. 560) wxObject (p. 954) Include files

1052


CHAPTER 7
<wx/region.h> See also wxRegionIterator (p. 1057)

wxRegion::wxRegion
wxRegion() Default constructor. wxRegion(wxCoord x, wxCoord y, wxCoord width, wxCoord height) Constructs a rectangular region with the given position and size. wxRegion(const wxPoint& topLeft, const wxPoint& bottomRight) Constructs a rectangular region from the top left point and the bottom right point. wxRegion(const wxRect& rect) Constructs a rectangular region a wxRect object. wxRegion(const wxRegion& region) Constructs a region by copying another region. wxRegion(size_t n, const wxPoint *points, int fillStyle = wxWINDING_RULE) Constructs a region corresponding to the polygon made of n points in the provided array. fillStyle parameter may have valueswxWINDING_RULE or wxODDEVEN_RULE. NB: This constructor is only implemented for Win32 and GTK+ wxWindows ports. wxRegion(const wxBitmap& bmp, wxNullColour, int tolerance = 0) const wxColour& transColour =

Constructs a region using the non-transparent pixels of a bitmap. SeeUnion (p. 1056) for more details.

wxRegion::~wxRegion
~wxRegion() Destructor.

wxRegion::Clear

1053


CHAPTER 7
void Clear() Clears the current region.

wxRegion::Contains
wxRegionContain Contains(long& x, long& y) const Returns a value indicating whether the given point is contained within the region. wxRegionContain Contains(const wxPoint& pt) const Returns a value indicating whether the given point is contained within the region. wxRegionContain Contains(long& x, long& y, long& width, long& height) const Returns a value indicating whether the given rectangle is contained within the region. wxRegionContain Contains(const wxRect& rect) const Returns a value indicating whether the given rectangle is contained within the region. Return value The return value is one of wxOutRegion, wxPartRegion and wxInRegion. On Windows, only wxOutRegion and wxInRegion are returned; a value wxInRegion then indicates that all or some part of the region is contained in this region.

wxRegion::ConvertToBitmap
wxBitmap ConvertToBitmap() const Convert the region to a black and white bitmap with the white pixels being inside the region.

wxRegion::GetBox
void GetBox(long& x, long& y, long& width, long& height) const Returns the outer bounds of the region. wxRect GetBox() const Returns the outer bounds of the region.

wxRegion::Intersect
bool Intersect(wxCoord x, wxCoord y, wxCoord width, wxCoord height)

1054


CHAPTER 7
Finds the intersection of this region and another, rectangular region, specified using position and size. bool Intersect(const wxRect& rect) Finds the intersection of this region and another, rectangular region. bool Intersect(const wxRegion& region) Finds the intersection of this region and another region. Return value true if successful, false otherwise. Remarks Creates the intersection of the two regions, that is, the parts which are in both regions. The result is stored in this region.

wxRegion::IsEmpty
bool IsEmpty() const Returns true if the region is empty, false otherwise.

wxRegion::Subtract
bool Subtract(const wxRect& rect) Subtracts a rectangular region from this region. bool Subtract(const wxRegion& region) Subtracts a region from this region. Return value true if successful, false otherwise. Remarks This operation combines the parts of 'this' region that are not part of the second region. The result is stored in this region.

wxRegion::Offset
bool Offset(wxCoord x, wxCoord y) Moves the region by the specified offsets in horizontal and vertical directions.

1055


CHAPTER 7
Return value true if successful, false otherwise (the region is unchanged then).

wxRegion::Union
bool Union(wxCoord x, wxCoord y, wxCoord width, wxCoord height) Finds the union of this region and another, rectangular region, specified using position and size. bool Union(const wxRect& rect) Finds the union of this region and another, rectangular region. bool Union(const wxRegion& region) Finds the union of this region and another region. bool Union(const wxBitmap& bmp, wxNullColour, int tolerance = 0) const wxColour& transColour =

Finds the union of this region and the the non-transparent pixels of a bitmap. If the bitmap has a mask then it will be used, otherwise the colour to be treated as transparent may be specified, along with an optional colour tolerance value. Return value true if successful, false otherwise. Remarks This operation creates a region that combines all of this region and the second region. The result is stored in this region.

wxRegion::Xor
bool Xor(wxCoord x, wxCoord y, wxCoord width, wxCoord height) Finds the Xor of this region and another, rectangular region, specified using position and size. bool Xor(const wxRect& rect) Finds the Xor of this region and another, rectangular region. bool Xor(const wxRegion& region) Finds the Xor of this region and another region. Return value true if successful, false otherwise.

1056


CHAPTER 7
Remarks This operation creates a region that combines all of this region and the second region, except for any overlapping areas. The result is stored in this region.

wxRegion::operator =
void operator =(const wxRegion& region) Copies region by reference counting.

wxRegionIterator
This class is used to iterate through the rectangles in a region, typically when examining the damaged regions of a window within an OnPaint call. To use it, construct an iterator object on the stack and loop through the regions, testing the object and incrementing the iterator at the end of the loop. See wxPaintEvent (p. 967) for an example of use. Derived from wxObject (p. 954) Include files <wx/region.h> See also wxPaintEvent (p. 967)

wxRegionIterator::wxRegionIterator
wxRegionIterator() Default constructor. wxRegionIterator(const wxRegion& region) Creates an iterator object given a region.

wxRegionIterator::GetX
wxCoord GetX() const

1057


CHAPTER 7
Returns the x value for the current region.

wxRegionIterator::GetY
wxCoord GetY() const Returns the y value for the current region.

wxRegionIterator::GetW
wxCoord GetW() const An alias for GetWidth.

wxRegionIterator::GetWidth
wxCoord GetWidth() const Returns the width value for the current region.

wxRegionIterator::GetH
wxCoord GetH() const An alias for GetHeight.

wxRegionIterator::GetHeight
wxCoord GetWidth() const Returns the width value for the current region.

wxRegionIterator::GetRect
wxRect GetRect() const Returns the current rectangle.

wxRegionIterator::HaveRects
bool HaveRects() const Returns true if there are still some rectangles; otherwise returns false.

1058


CHAPTER 7 wxRegionIterator::Reset
void Reset() Resets the iterator to the beginning of the rectangles. void Reset(const wxRegion& region) Resets the iterator to the given region.

wxRegionIterator::operator ++
void operator ++() Increment operator. Increments the iterator to the next region. wxPython note: A wxPython alias for this operator is called Next.

wxRegionIterator::operator bool
operator bool() const Returns true if there are still some rectangles; otherwise returns false. You can use this to test the iterator object as if it were of type bool.

wxRendererNative
First, a brief introduction to wxRenderer and why it is needed. Usually wxWindows uses the underlying low level GUI system to draw all the controls -this is what we mean when we say that it is a "native'' framework. However not all controls exist under all (or even any) platforms and in this case wxWindows provides a default, generic, implementation of them written in wxWindows itself. These controls don't have the native appearance if only the standard line drawing and other graphics primitives are used, because the native appearance is different under different platforms while the lines are always drawn in the same way. This is why we have renderers: wxRenderer is a class which virtualizes the drawing, i.e. it abstracts the drawing operations and allows you to draw say, a button, without caring about exactly how this is done. Of course, as we can draw the button differently in different renderers, this also allows us to emulate the native look and feel. So the renderers work by exposing a large set of high-level drawing functions which are used by the generic controls. There is always a default global renderer but it may be changed or extended by the user, see Render sample (p. 1567). All drawing functions take some standard parameters:

1059


CHAPTER 7
 win is the window being drawn. It is normally not used and when it is it should only be used as a generic wxWindow (p. 1386) (in order to get its low level handle, for example), but you should not assume that it is of some given type as the same renderer function may be reused for drawing different kinds of control. dc is the wxDC (p. 347) to draw on. Only this device context should be used for drawing. It is not necessary to restore pens and brushes for it on function exit but, on the other hand, you shouldn't assume that it is in any specific state on function entry: the rendering functions should always prepare it. rect the bounding rectangle for the element to be drawn. flags the optional flags (none by default) which can be a combination of the wxCONTROL_XXX constants below.



 

Constants The following rendering flags are defined:
enum { wxCONTROL_DISABLED wxCONTROL_FOCUSED wxCONTROL_PRESSED wxCONTROL_ISDEFAULT wxCONTROL_ISSUBMENU wxCONTROL_EXPANDED wxCONTROL_CURRENT control wxCONTROL_SELECTED wxCONTROL_CHECKED wxCONTROL_CHECKABLE }; = = = = = = = 0x00000001, // control is disabled 0x00000002, // currently has keyboard focus 0x00000004, // (button) is pressed 0x00000008, // only applies to the buttons wxCONTROL_ISDEFAULT, // only for menu items wxCONTROL_ISDEFAULT, // only for the tree items 0x00000010, // mouse is currently over the // selected item in e.g. listbox // (check/radio button) is checked // (menu) item can be checked

= 0x00000020, = 0x00000040, = 0x00000080

Derived from No base class Include files <wx/renderer.h>

wxRendererNative::~wxRendererNative
~wxRendererNative() Virtual destructor as for any base class.

wxRendererNative::DrawHeaderButton
void DrawHeaderButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags = 0)

1060


CHAPTER 7
Draw the header control button (used by wxListCtrl (p. 799)).

wxRendererNative::DrawSplitterBorder
void DrawSplitterBorder(wxWindow* win, wxDC& dc, const wxRect& rect, int flags = 0) Draw the border for sash window: this border must be such that the sash drawn by DrawSash (p. 1061) blends into it well.

wxRendererNative::DrawSplitterSash
void DrawSplitterSash(wxWindow* win, wxDC& dc, const wxSize& size, wxCoord position, wxOrientation orient, int flags = 0) Draw a sash. The orient parameter defines whether the sash should be vertical or horizontal and how should the position be interpreted.

wxRendererNative::DrawTreeItemButton
void DrawTreeItemButton(wxWindow* win, wxDC& dc, const wxRect& rect, int flags = 0) Draw the expanded/collapsed icon for a tree control item. To draw an expanded button the flags parameter must contain wxCONTROL_EXPANDED bit.

wxRendererNative::Get
wxRendererNative& Get() Return the currently used renderer.

wxRendererNative::GetDefault
wxRendererNative& GetDefault() Return the default (native) implementation for this platform -- this is also the one used by default but this may be changed by calling Set (p. 1062) in which case the return value of this method may be different from the return value of Get (p. 1061).

wxRendererNative::GetGeneric
wxRendererNative& GetGeneric() Return the generic implementation of the renderer. Under some platforms, this is the default renderer implementation, others have platform-specific default renderer which

1061


CHAPTER 7
can be retrieved by calling GetDefault (p. 1061).

wxRendererNative::GetSplitterParams
wxSplitterRenderParams GetSplitterParams(const wxWindow* win) Get the splitter parameters, see wxSplitterRenderParams (p. 1176).

wxRendererNative::GetVersion
wxRendererVersion GetVersion() const This function is used for version checking: Load (p. 1062) refuses to load any shared libraries implementing an older or incompatible version. The implementation of this method is always the same in all renderers (simply construct wxRendererVersion (p. 1062) using the wxRendererVersion::Current_XXX values), but it has to be in the derived, not base, class, to detect mismatches between the renderers versions and so you have to implement it anew in all renderers.

wxRendererNative::Load
wxRendererNative* Load(const wxString& name) Load the renderer from the specified DLL, the returned pointer must be deleted by caller if not NULL when it is not used any more. The name should be just the base name of the renderer and not the full name of the DLL file which is constructed differently (using wxDynamicLibrary::CanonicalizePluginName (p. 433)) on different systems.

wxRendererNative::Set
wxRendererNative* Set(wxRendererNative* renderer) Set the renderer to use, passing NULL reverts to using the default renderer (the global renderer must always exist). Return the previous renderer used with Set() or NULL if none.

wxRendererVersion
This simple struct represents the wxRendererNative (p. 1059) interface version and is only used as the return value of wxRendererNative::GetVersion (p. 1062). The version has two components: the version itself and the age. If the main program and the renderer have different versions they are never compatible with each other because

1062


CHAPTER 7
the version is only changed when an existing virtual function is modified or removed. The age, on the other hand, is incremented each time a new virtual method is added and so, at least for the compilers using a common C++ object model, the calling program is compatible with any renderer which has the age greater or equal to its age. This verification is done by IsCompatible (p. 1063) method. Derived from No base class Include files <wx/renderer.h>

wxRendererVersion::IsCompatible
static bool IsCompatible(const wxRendererVersion& ver) Checks if the main program is compatible with the renderer having the version ver, returns true if it is and false otherwise. This method is used by wxRendererNative::Load (p. 1062) to determine whether a renderer can be used.

wxRendererVersion::version
const int version The version component.

wxRendererVersion::age
const int age The age component.

wxSashEvent
A sash event is sent when the sash of a wxSashWindow (p. 1068) has been dragged by the user. Derived from wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954)

1063


CHAPTER 7
Include files <wx/sashwin.h> Event table macros To process an activate event, use these event handler macros to direct input to a member function that takes a wxSashEvent argument. EVT_SASH_DRAGGED(id, func) Process a wxEVT_SASH_DRAGGED event, when the user has finished dragging a sash.

EVT_SASH_DRAGGED_RANGE(id1, id2, func) Process a wxEVT_SASH_DRAGGED_RANGE event, when the user has finished dragging a sash. The event handler is called when windows with ids in the given range have their sashes dragged. Data structures
enum wxSashDragStatus { wxSASH_STATUS_OK, wxSASH_STATUS_OUT_OF_RANGE };

Remarks When a sash belonging to a sash window is dragged by the user, and then released, this event is sent to the window, where it may be processed by an event table entry in a derived class, a plug-in event handler or an ancestor class. Note that the wxSashWindow doesn't change the window's size itself. It relies on the application's event handler to do that. This is because the application may have to handle other consequences of the resize, or it may wish to veto it altogether. The event handler should look at the drag rectangle: see wxSashEvent::GetDragRect (p. 1065) to see what the new size of the window would be if the resize were to be applied. It should also call wxSashEvent::GetDragStatus (p. 1065) to see whether the drag was OK or out of the current allowed range. See also wxSashWindow (p. 1068), Event handling overview (p. 1602)

wxSashEvent::wxSashEvent
wxSashEvent(int id = 0, wxSashEdgePosition edge = wxSASH_NONE) Constructor.

1064


CHAPTER 7 wxSashEvent::GetEdge
wxSashEdgePosition GetEdge() const Returns the dragged edge. The return value is one of wxSASH_TOP, wxSASH_RIGHT, wxSASH_BOTTOM, wxSASH_LEFT.

wxSashEvent::GetDragRect
wxRect GetDragRect() const Returns the rectangle representing the new size the window would be if the resize was applied. It is up to the application to set the window size if required.

wxSashEvent::GetDragStatus
wxSashDragStatus GetDragStatus() const Returns the status of the sash: one of wxSASH_STATUS_OK, wxSASH_STATUS_OUT_OF_RANGE. If the drag caused the notional bounding box of the window to flip over, for example, the drag will be out of rage.

wxSashLayoutWindow
wxSashLayoutWindow responds to OnCalculateLayout events generated by wxLayoutAlgorithm (p. 781). It allows the application to use simple accessors to specify how the window should be laid out, rather than having to respond to events. The fact that the class derives from wxSashWindow allows sashes to be used if required, to allow the windows to be user-resizable. The documentation for wxLayoutAlgorithm (p. 781) explains the purpose of this class in more detail. Derived from wxSashWindow (p. 1068) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/laywin.h> Window styles See wxSashWindow (p. 1068). Event handling

1065


CHAPTER 7
This class handles the EVT_QUERY_LAYOUT_INFO and EVT_CALCULATE_LAYOUT events for you. However, if you use sashes, see wxSashWindow (p. 1068) for relevant event information. See also wxLayoutAlgorithm (p. 781) for information about the layout events. See also wxLayoutAlgorithm (p. 781), wxSashWindow (p. 1068), Event handling overview (p. 1602)

wxSashLayoutWindow::wxSashLayoutWindow
wxSashLayoutWindow() Default constructor. wxSashLayoutWindow(wxSashLayoutWindow* parent, wxSashLayoutWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxCLIP_CHILDREN | wxSW_3D, const wxString& name = "layoutWindow") Constructs a sash layout window, which can be a child of a frame, dialog or any other non-control window. Parameters parent Pointer to a parent window. id Window identifier. If -1, will automatically create an identifier. pos Window position. wxDefaultPosition is (-1, -1) which indicates that wxSashLayoutWindows should generate a default position for the window. If using the wxSashLayoutWindow class directly, supply an actual position. size Window size. wxDefaultSize is (-1, -1) which indicates that wxSashLayoutWindows should generate a default size for the window. style Window style. For window styles, please see wxSashLayoutWindow (p. 1065). name

1066


CHAPTER 7
Window name.

wxSashLayoutWindow::~wxSashLayoutWindow
~wxSashLayoutWindow() Destructor.

wxSashLayoutWindow::GetAlignment
wxLayoutAlignment GetAlignment() const Returns the alignment of the window: one of wxLAYOUT_TOP, wxLAYOUT_LEFT, wxLAYOUT_RIGHT, wxLAYOUT_BOTTOM.

wxSashLayoutWindow::GetOrientation
wxLayoutOrientation GetOrientation() const Returns the orientation of the window: one of wxLAYOUT_HORIZONTAL, wxLAYOUT_VERTICAL.

wxSashLayoutWindow::OnCalculateLayout
void OnCalculateLayout(wxCalculateLayoutEvent& event) The default handler for the event that is generated by wxLayoutAlgorithm. The implementation of this function calls wxCalculateLayoutEvent::SetRect to shrink the provided size according to how much space this window takes up. For further details, see wxLayoutAlgorithm (p. 781) and wxCalculateLayoutEvent (p. 107).

wxSashLayoutWindow::OnQueryLayoutInfo
void OnQueryLayoutInfo(wxQueryLayoutInfoEvent& event) The default handler for the event that is generated by OnCalculateLayout to get size, alignment and orientation information for the window. The implementation of this function uses member variables as set by accessors called by the application. For further details, see wxLayoutAlgorithm (p. 781) and wxQueryLayoutInfoEvent (p. 1030).

wxSashLayoutWindow::SetAlignment
void SetAlignment(wxLayoutAlignment alignment) Sets the alignment of the window (which edge of the available parent client area the window is attached to). alignment is one of wxLAYOUT_TOP, wxLAYOUT_LEFT,

1067


CHAPTER 7
wxLAYOUT_RIGHT, wxLAYOUT_BOTTOM.

wxSashLayoutWindow::SetDefaultSize
void SetDefaultSize(const wxSize& size) Sets the default dimensions of the window. The dimension other than the orientation will be fixed to this value, and the orientation dimension will be ignored and the window stretched to fit the available space.

wxSashLayoutWindow::SetOrientation
void SetOrientation(wxLayoutOrientation orientation) Sets the orientation of the window (the direction the window will stretch in, to fill the available parent client area). orientation is one of wxLAYOUT_HORIZONTAL, wxLAYOUT_VERTICAL.

wxSashWindow
wxSashWindow allows any of its edges to have a sash which can be dragged to resize the window. The actual content window will be created by the application as a child of wxSashWindow. The window (or an ancestor) will be notified of a drag via a wxSashEvent (p. 1063) notification. Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/sashwin.h> Window styles The following styles apply in addition to the normal wxWindow styles. wxSW_3D wxSW_3DSASH wxSW_3DBORDER wxSW_BORDER Draws a 3D effect sash and border. Draws a 3D effect sash. Draws a 3D effect border. Draws a thin black border.

See also window styles overview (p. 1611). Event handling

1068


CHAPTER 7
EVT_SASH_DRAGGED(id, func) Process a wxEVT_SASH_DRAGGED event, when the user has finished dragging a sash.

EVT_SASH_DRAGGED_RANGE(id1, id2, func) Process a wxEVT_SASH_DRAGGED_RANGE event, when the user has finished dragging a sash. The event handler is called when windows with ids in the given range have their sashes dragged. Data types
enum wxSashEdgePosition { wxSASH_TOP = 0, wxSASH_RIGHT, wxSASH_BOTTOM, wxSASH_LEFT, wxSASH_NONE = 100 };

See also wxSashEvent (p. 1063), wxSashLayoutWindow (p. 1065), Event handling overview (p. 1602)

wxSashWindow::wxSashWindow
wxSashWindow() Default constructor. wxSashWindow(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxCLIP_CHILDREN | wxSW_3D, const wxString& name = "sashWindow") Constructs a sash window, which can be a child of a frame, dialog or any other noncontrol window. Parameters parent Pointer to a parent window. id Window identifier. If -1, will automatically create an identifier. pos Window position. wxDefaultPosition is (-1, -1) which indicates that

1069


CHAPTER 7
wxSashWindows should generate a default position for the window. If using the wxSashWindow class directly, supply an actual position. size Window size. wxDefaultSize is (-1, -1) which indicates that wxSashWindows should generate a default size for the window. style Window style. For window styles, please see wxSashWindow (p. 1068). name Window name.

wxSashWindow::~wxSashWindow
~wxSashWindow() Destructor.

wxSashWindow::GetSashVisible
bool GetSashVisible(wxSashEdgePosition edge) const Returns true if a sash is visible on the given edge, false otherwise. Parameters edge Edge. One of wxSASH_TOP, wxSASH_RIGHT, wxSASH_BOTTOM, wxSASH_LEFT. See also wxSashWindow::SetSashVisible (p. 1072)

wxSashWindow::GetMaximumSizeX
int GetMaximumSizeX() const Gets the maximum window size in the x direction.

wxSashWindow::GetMaximumSizeY
int GetMaximumSizeY() const Gets the maximum window size in the y direction.

1070


CHAPTER 7 wxSashWindow::GetMinimumSizeX
int GetMinimumSizeX() Gets the minimum window size in the x direction.

wxSashWindow::GetMinimumSizeY
int GetMinimumSizeY(int min) const Gets the minimum window size in the y direction.

wxSashWindow::HasBorder
bool HasBorder(wxSashEdgePosition edge) const Returns true if the sash has a border, false otherwise. Parameters edge Edge. One of wxSASH_TOP, wxSASH_RIGHT, wxSASH_BOTTOM, wxSASH_LEFT. See also wxSashWindow::SetSashBorder (p. 1072)

wxSashWindow::SetMaximumSizeX
void SetMaximumSizeX(int min) Sets the maximum window size in the x direction.

wxSashWindow::SetMaximumSizeY
void SetMaximumSizeY(int min) Sets the maximum window size in the y direction.

wxSashWindow::SetMinimumSizeX
void SetMinimumSizeX(int min) Sets the minimum window size in the x direction.

1071


CHAPTER 7 wxSashWindow::SetMinimumSizeY
void SetMinimumSizeY(int min) Sets the minimum window size in the y direction.

wxSashWindow::SetSashVisible
void SetSashVisible(wxSashEdgePosition edge, bool visible) Call this function to make a sash visible or invisible on a particular edge. Parameters edge Edge to change. One of wxSASH_TOP, wxSASH_RIGHT, wxSASH_BOTTOM, wxSASH_LEFT. visible true to make the sash visible, false to make it invisible. See also wxSashWindow::GetSashVisible (p. 1070)

wxSashWindow::SetSashBorder
void SetSashBorder(wxSashEdgePosition edge, bool hasBorder) Call this function to give the sash a border, or remove the border. Parameters edge Edge to change. One of wxSASH_TOP, wxSASH_RIGHT, wxSASH_BOTTOM, wxSASH_LEFT. hasBorder true to give the sash a border visible, false to remove it. See also wxSashWindow::HasBorder (p. 1071)

wxScreenDC
A wxScreenDC can be used to paint on the screen. This should normally be constructed

1072


CHAPTER 7
as a temporary stack object; don't store a wxScreenDC object. Derived from wxDC (p. 347) Include files <wx/dcscreen.h> See also wxDC (p. 347), wxMemoryDC (p. 881), wxPaintDC (p. 966), wxClientDC (p. 133), wxWindowDC (p. 1436)

wxScreenDC::wxScreenDC
wxScreenDC() Constructor.

wxScreenDC::StartDrawingOnTop
bool StartDrawingOnTop(wxWindow* window) bool StartDrawingOnTop(wxRect* rect = NULL) Use this in conjunction with EndDrawingOnTop (p. 1074) to ensure that drawing to the screen occurs on top of existing windows. Without this, some window systems (such as X) only allow drawing to take place underneath other windows. By using the first form of this function, an application is specifying that the area that will be drawn on coincides with the given window. By using the second form, an application can specify an area of the screen which is to be drawn on. If NULL is passed, the whole screen is available. It is recommended that an area of the screen is specified because with large regions, flickering effects are noticeable when destroying the temporary transparent window used to implement this feature. You might use this pair of functions when implementing a drag feature, for example as in the wxSplitterWindow (p. 1166) implementation. Remarks This function is probably obsolete since the X implementations allow drawing directly on the screen now. However, the fact that this function allows the screen to be refreshed afterwards, may be useful to some applications.

1073


CHAPTER 7 wxScreenDC::EndDrawingOnTop
bool EndDrawingOnTop() Use this in conjunction with StartDrawingOnTop (p. 1073). This function destroys the temporary window created to implement on-top drawing (X only).

wxScopedArray
This is a simple scoped smart pointer array implementation that is similar to the Boost (http://www.boost.org) smart pointers but rewritten to use macros instead. Example Below is an example of using a wxWindows scoped smart pointer and pointer array.
class MyClass { /* ... */ }; // declare a smart pointer to a MyClass called wxMyClassPtr wxDECLARE_SCOPED_PTR(MyClass, wxMyClassPtr) // declare a smart pointer to an array of chars wxDECLARE_SCOPED_ARRAY(char, wxCharArray) ... // define the first pointer class, must be complete wxDEFINE_SCOPED_PTR(MyClass, wxMyClassPtr) // define the second pointer class wxDEFINE_SCOPED_ARRAY(char, wxCharArray) // create an object with a new pointer to MyClass wxMyClassPtr theObj(new MyClass()); // reset the pointer (deletes the previous one) theObj.reset(new MyClass()); // access the pointer theObj->MyFunc(); // create an object with a new array of chars wxCharArray theCharObj(new char[100]); // access the array theCharObj[0] = "!";

Declaring new smart pointer types
wxDECLAR_SCOPED_ARRAY( TYPE, // type of the values CLASSNAME ); // name of the class

A smart pointer holds a pointer to an object (which must be complete when wxDEFINE_SCOPED_ARRAY() is called). The memory used by the object is deleted when the smart pointer goes out of scope. The first argument of the macro is the pointer type, the second is the name of the new smart pointer class being created. Below we will use wxScopedArray to represent the scoped pointer array class, but the user may create the class with any legal name. Include files

1074


CHAPTER 7
<wx/ptr_scpd.h> See also wxScopedPtr (p. 1075)

wxScopedArray::wxScopedArray
wxScopedArray(type * T = NULL) Creates the smart pointer with the given pointer or none if NULL. On compilers that support it, this uses the explicit keyword.

wxScopedArray::reset
reset(T p * = NULL) Deletes the currently held pointer and sets it to 'p' or to NULL if no arguments are specified. This function does check to make sure that the pointer you are assigning is not the same pointer that is already stored.

wxScopedArray::operator []
const T & operator [](long inti) This operator acts like the standard [] indexing operator for C++ arrays. The function does not do bounds checking.

wxScopedArray::get
const T* get() This operator gets the pointer stored in the smart pointer or returns NULL if there is none.

wxScopedArray::swap
swap(wxScopedPtr & ot) Swap the pointer inside the smart pointer with 'ot'. The pointer being swapped must be of the same type (hence the same class name).

wxScopedPtr

1075


CHAPTER 7
This is a simple scoped smart pointer implementation that is similar to the Boost (http://www.boost.org/) smart pointers but rewritten to use macros instead. A smart pointer holds a pointer to an object. The memory used by the object is deleted when the smart pointer goes out of scope. This class is different from the std::auto_ptr<> in so far as it doesn't provide copy constructor nor assignment operator. This limits what you can do with it but is much less surprizing than the "destructive copy'' behaviour of the standard class. Example Below is an example of using a wxWindows scoped smart pointer and pointer array.
class MyClass { /* ... */ }; // declare a smart pointer to a MyClass called wxMyClassPtr wxDECLARE_SCOPED_PTR(MyClass, wxMyClassPtr) // declare a smart pointer to an array of chars wxDECLARE_SCOPED_ARRAY(char, wxCharArray) ... // define the first pointer class, must be complete wxDEFINE_SCOPED_PTR(MyClass, wxMyClassPtr) // define the second pointer class wxDEFINE_SCOPED_ARRAY(char, wxCharArray) // create an object with a new pointer to MyClass wxMyClassPtr theObj(new MyClass()); // reset the pointer (deletes the previous one) theObj.reset(new MyClass()); // access the pointer theObj->MyFunc(); // create an object with a new array of chars wxCharArray theCharObj(new char[100]); // access the array theCharObj[0] = "!";

Declaring new smart pointer types To declare the smart pointer class CLASSNAME containing pointes to a (possibly incomplete) type TYPE you should use
wxDECLARE_SCOPED_PTR( TYPE, // type of the values CLASSNAME ); // name of the class

And later, when TYPE is fully defined, you must also use
wxDEFINE_SCOPED_PTR( TYPE, CLASSNAME );

to implement the scoped pointer class. The first argument of these macro is the pointer type, the second is the name of the new smart pointer class being created. Below we will use wxScopedPtr to represent the scoped pointer class, but the user may create the class with any legal name. Alternatively, if you don't have to separate the point of declaration and definition of this class and if you accept the standard naming convention, that is that the scoped pointer

1076


CHAPTER 7
for the class Foo is called FooPtr, you can use a single macro which replaces two macros above:
wxDEFINE_SCOPED_PTR_TYPE( TYPE );

Once again, in this cass CLASSNAME will be TYPEPtr. Include files <wx/ptr_scpd.h> See also wxScopedArray (p. 1074)

wxScopedPtr::wxScopedPtr
explicit wxScopedPtr(type * T = NULL) Creates the smart pointer with the given pointer or none if NULL. On compilers that support it, this uses the explicit keyword.

wxScopedPtr::~wxScopedPtr
~wxScopedPtr() Destructor frees the pointer help by this object if it is not NULL.

wxScopedPtr::release
T * release() Returns the currently hold pointer and resets the smart pointer object to NULL. After a call to this function the caller is responsible for deleting the pointer.

wxScopedPtr::reset
reset(T p * = NULL) Deletes the currently held pointer and sets it to p or to NULL if no arguments are specified. This function does check to make sure that the pointer you are assigning is not the same pointer that is already stored.

wxScopedPtr::operator *
const T& operator *()

1077


CHAPTER 7
This operator works like the standard C++ pointer operator to return the object being pointed to by the pointer. If the pointer is NULL or invalid this will crash.

wxScopedPtr::operator ->
const T* operator ->() This operator works like the standard C++ pointer operator to return the pointer in the smart pointer or NULL if it is empty.

wxScopedPtr::get
const T* get() This operator gets the pointer stored in the smart pointer or returns NULL if there is none.

wxScopedPtr::swap
swap(wxScopedPtr & other) Swap the pointer inside the smart pointer with other. The pointer being swapped must be of the same type (hence the same class name).

wxScopedTiedPtr
This is a variation on the topic of wxScopedPtr (p. 1075). This class is also a smart pointer but in addition it "ties'' the pointer value to another variable. In other words, during the life time of this class the value of that variable is set to be the same as the value of the pointer itself and it is reset to its old value when the object is destroyed. This class is especially useful when converting the existing code (which may already store the pointers value in some variable) to the smart pointers. Example Derives from wxScopedPtr (p. 1075) Include files <wx/ptr_scpd.h>

wxScopedTiedPtr::wxScopedTiedPtr
wxScopedTiedPtr(T **ppTie, T *ptr)

1078


CHAPTER 7
Constructor creates a smart pointer initialized with ptr and stores ptr in the location specified by ppTie which must not be NULL.

wxScopedTiedPtr::~wxScopedTiedPtr
~wxScopedTiedPtr() Destructor frees the pointer help by this object and restores the value stored at the tied location (as specified in the constructor (p. 1078)) to the old value. Warning: this location may now contain an uninitialized value if it hadn't been initialized previously, in particular don't count on it magically being NULL!

wxScrollBar
A wxScrollBar is a control that represents a horizontal or vertical scrollbar. It is distinct from the two scrollbars that some windows provide automatically, but the two types of scrollbar share the way events are received. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/scrolbar.h> Remarks A scrollbar has the following main attributes: range, thumb size, page size, and position. The range is the total number of units associated with the view represented by the scrollbar. For a table with 15 columns, the range would be 15. The thumb size is the number of units that are currently visible. For the table example, the window might be sized so that only 5 columns are currently visible, in which case the application would set the thumb size to 5. When the thumb size becomes the same as or greater than the range, the scrollbar will be automatically hidden on most platforms. The page size is the number of units that the scrollbar should scroll by, when 'paging' through the data. This value is normally the same as the thumb size length, because it is natural to assume that the visible window size defines a page. The scrollbar position is the current thumb position. Most applications will find it convenient to provide a function called AdjustScrollbars which can be called initially, from an OnSize event handler, and whenever the application data changes in size. It will adjust the view, object and page size according

1079


CHAPTER 7
to the size of the window and the size of the data. Window styles wxSB_HORIZONTAL wxSB_VERTICAL Specifies a horizontal scrollbar. Specifies a vertical scrollbar.

See also window styles overview (p. 1611). Event table macros To process a scroll event, use these event handler macros to direct input to member functions that take a wxScrollEvent argument. You can useEVT_COMMAND_SCROLL... macros with window IDs for when intercepting scroll events from controls, or EVT_SCROLL... macros without window IDs for intercepting scroll events from the receiving window - except for this, the macros behave exactly the same. EVT_SCROLL(func) EVT_SCROLL_TOP(func) Process all scroll events. Process wxEVT_SCROLL_TOP scroll-to-top events (minium position). Process wxEVT_SCROLL_TOP scroll-to-bottom events (maximum position). Process wxEVT_SCROLL_LINEUP line up events. Process wxEVT_SCROLL_LINEDOWN line down events. Process wxEVT_SCROLL_PAGEUP page up events. Process wxEVT_SCROLL_PAGEDOWN page down events. Process wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent as the user drags the thumbtrack). Process wxEVT_SCROLL_THUMBRELEAS E thumb release events. Process

EVT_SCROLL_BOTTOM(func)

EVT_SCROLL_LINEUP(func) EVT_SCROLL_LINEDOWN(func)

EVT_SCROLL_PAGEUP(func)

EVT_SCROLL_PAGEDOWN(func)

EVT_SCROLL_THUMBTRACK(func)

EVT_SCROLL_THUMBRELEASE(func)

EVT_SCROLL_ENDSCROLL(func)

1080


CHAPTER 7
wxEVT_SCROLL_ENDSCROLL end of scrolling events (MSW only). EVT_COMMAND_SCROLL(id, func) EVT_COMMAND_SCROLL_TOP(id, func) Process all scroll events. Process wxEVT_SCROLL_TOP scroll-to-top events (minimum position). Process wxEVT_SCROLL_TOP scroll-to-bottom events (maximum position). Process wxEVT_SCROLL_LINEUP line up events.

EVT_COMMAND_SCROLL_BOTTOM(id, func)

EVT_COMMAND_SCROLL_LINEUP(id, func)

EVT_COMMAND_SCROLL_LINEDOWN(id, func) Process wxEVT_SCROLL_LINEDOWN line down events. EVT_COMMAND_SCROLL_PAGEUP(id, func) Process wxEVT_SCROLL_PAGEUP page up events.

EVT_COMMAND_SCROLL_PAGEDOWN(id, func) Process wxEVT_SCROLL_PAGEDOWN page down events. EVT_COMMAND_SCROLL_THUMBTRACK(id, func) Process wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent as the user drags the thumbtrack). Process EVT_COMMAND_SCROLL_THUMBRELEASE(func) wxEVT_SCROLL_THUMBRELEAS E thumb release events. EVT_COMMAND_SCROLL_ENDSCROLL(func) Process wxEVT_SCROLL_ENDSCROLL end of scrolling events (MSW only).

The difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_ENDSCROLL The EVT_SCROLL_THUMBRELEASE event is only emitted when actually dragging the thumb using the mouse and releasing it (This EVT_SCROLL_THUMBRELEASEevent is also followed by an EVT_SCROLL_ENDSCROLL event). The EVT_SCROLL_ENDSCROLL event also occurs when using the keyboard to change the thumb position, and when clicking next to the thumb (In all these cases the EVT_SCROLL_THUMBRELEASE event does not happen). In short, the EVT_SCROLL_ENDSCROLL event is triggered when scrolling/ moving has

1081


CHAPTER 7
finished. The only exception (unfortunately) is that changing the thumb position using the mousewheel does give a EVT_SCROLL_THUMBRELEASEevent but NOT an EVT_SCROLL_ENDSCROLL event. Please see the widgets sample ("Slider" page) to see the difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_ENDSCROLL in action. See also Scrolling overview (p. 1636), Event handling overview (p. 1602), wxScrolledWindow (p. 1085)

wxScrollBar::wxScrollBar
wxScrollBar() Default constructor. wxScrollBar(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSB_HORIZONTAL, const wxValidator& validator = wxDefaultValidator, const wxString& name = "scrollBar") Constructor, creating and showing a scrollbar. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. pos Window position. If the position (-1, -1) is specified then a default position is chosen. size Window size. If the default size (-1, -1) is specified then a default size is chosen. style Window style. See wxScrollBar (p. 1079). validator Window validator.

1082


CHAPTER 7
name Window name. See also wxScrollBar::Create (p. 1083), wxValidator (p. 1358)

wxScrollBar::~wxScrollBar
void ~wxScrollBar() Destructor, destroying the scrollbar.

wxScrollBar::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSB_HORIZONTAL, const wxValidator& validator = wxDefaultValidator, const wxString& name = "scrollBar") Scrollbar creation function called by the scrollbar constructor. See wxScrollBar::wxScrollBar (p. 1082) for details.

wxScrollBar::GetRange
int GetRange() const Returns the length of the scrollbar. See also wxScrollBar::SetScrollbar (p. 1084)

wxScrollBar::GetPageSize
int GetPageSize() const Returns the page size of the scrollbar. This is the number of scroll units that will be scrolled when the user pages up or down. Often it is the same as the thumb size. See also wxScrollBar::SetScrollbar (p. 1084)

wxScrollBar::GetThumbPosition
int GetThumbPosition() const

1083


CHAPTER 7
Returns the current position of the scrollbar thumb. See also wxScrollBar::SetThumbPosition (p. 1084)

wxScrollBar::GetThumbLength
int GetThumbLength() const Returns the thumb or 'view' size. See also wxScrollBar::SetScrollbar (p. 1084)

wxScrollBar::SetThumbPosition
void SetThumbPosition(int viewStart) Sets the position of the scrollbar. Parameters viewStart The position of the scrollbar thumb. See also wxScrollBar::GetThumbPosition (p. 1083)

wxScrollBar::SetScrollbar
virtual void SetScrollbar(int position, int thumbSize, int range, int pageSize, const bool refresh = true) Sets the scrollbar properties. Parameters position The position of the scrollbar in scroll units. thumbSize The size of the thumb, or visible portion of the scrollbar, in scroll units. range The maximum position of the scrollbar.

1084


CHAPTER 7
pageSize The size of the page size in scroll units. This is the number of units the scrollbar will scroll when it is paged up or down. Often it is the same as the thumb size. refresh true to redraw the scrollbar, false otherwise. Remarks Let's say you wish to display 50 lines of text, using the same font. The window is sized so that you can only see 16 lines at a time. You would use:
scrollbar->SetScrollbar(0, 16, 50, 15);

The page size is 1 less than the thumb size so that the last line of the previous page will be visible on the next page, to help orient the user. Note that with the window at this size, the thumb position can never go above 50 minus 16, or 34. You can determine how many lines are currently visible by dividing the current view size by the character height in pixels. When defining your own scrollbar behaviour, you will always need to recalculate the scrollbar settings when the window size changes. You could therefore put your scrollbar calculations and SetScrollbar call into a function named AdjustScrollbars, which can be called initially and also from a wxSizeEvent (p. 1108) event handler function. See also Scrolling overview (p. 1636), wxWindow::SetScrollbar (p. 1426), wxScrolledWindow (p. 1085)

wxScrolledWindow
The wxScrolledWindow class manages scrolling for its client area, transforming the coordinates according to the scrollbar positions, and setting the scroll positions, thumb sizes and ranges according to the area in view. Starting from version 2.4 of wxWindows, there are several ways to use a wxScrolledWindow. In particular, there are now three ways to set the size of the scrolling area: One way is to set the scrollbars directly using a call towxScrolledWindow::SetScrollbars (p. 1093). This is the way it used to be in any previous version of wxWindows and it will be kept for backwards compatibility.

1085


CHAPTER 7
An additional method of manual control, which requires a little less computation of your own, is to set the total size of the scrolling area by calling either wxWindow::SetVirtualSize (p. 1431), or wxWindow::FitInside (p. 1399), and setting the scrolling increments for it by calling wxScrolledWindow::SetScrollRate (p. 1094). Scrolling in some orientation is enabled by setting a non zero increment for it. The most automatic and newest way is to simply let sizers determine the scrolling area. This is now the default when you set an interior sizer into a wxScrolledWindow with wxWindow::SetSizer (p. 1430). The scrolling area will be set to the size requested by the sizer and the scrollbars will be assigned for each orientation according to the need for them and the scrolling increment set by wxScrolledWindow::SetScrollRate (p. 1094). As above, scrolling is only enabled in orientations with a non-zero increment. You can influence the minimum size of the scrolled area controlled by a sizer by callingwxWindow::SetVirtualSizeHints (p. 1431). (calling wxScrolledWindow::SetScrollbars (p. 1093) has analogous effects in wxWindows 2.4 -in later versions it may not continue to override the sizer) Note: if Maximum size hints are still supported by SetVirtualSizeHints, use them at your own dire risk. They may or may not have been removed for 2.4, but it really only makes sense to set minimum size hints here. We should probably replace SetVirtualSizeHints with SetMinVirtualSize or similar and remove it entirely in future. As with all windows, an application can draw onto a wxScrolledWindow using a device context (p. 1641). You have the option of handling the OnPaint handler or overriding the OnDraw (p. 1092) function, which is passed a pre-scrolled device context (prepared by PrepareDC (p. 1091)). If you don't wish to calculate your own scrolling, you must call PrepareDC when not drawing from within OnDraw, to set the device origin for the device context according to the current scroll position. A wxScrolledW indow will normally scroll itself and therefore its child windows as well. It might however be desired to scroll a different window than itself: e.g. when designing a spreadsheet, you will normally only have to scroll the (usually white) cell area, whereas the (usually grey) label area will scroll very differently. For this special purpose, you can call SetTargetWindow (p. 1094) which means that pressing the scrollbars will scroll a different window. Note that the underlying system knows nothing about scrolling coordinates, so that all system functions (mouse events, expose events, refresh calls etc) as well as the position of subwindows are relative to the "physical" origin of the scrolled window. If the user insert a child window at position (10,10) and scrolls the window down 100 pixels (moving the child window out of the visible area), the child window will report a position of (10,90). Derived from wxPanel (p. 972) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954)

1086


CHAPTER 7
Include files <wx/scrolwin.h> Window styles wxRETAINED Uses a backing pixmap to speed refreshes. Motif only.

See also window styles overview (p. 1611). Remarks Use wxScrolledWindow for applications where the user scrolls by a fixed amount, and where a 'page' can be interpreted to be the current visible portion of the window. For more sophisticated applications, use the wxScrolledWindow implementation as a guide to build your own scroll behaviour. See also wxScrollBar (p. 1079), wxClientDC (p. 133), wxPaintDC (p. 966), wxVScrolledWindow (p. 1379)

wxScrolledWindow::wxScrolledWindow
wxScrolledWindow() Default constructor. wxScrolledWindow(wxWindow* parent, wxWindowID id = -1, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxHSCROLL | wxVSCROLL, const wxString& name = "scrolledWindow") Constructor. Parameters parent Parent window. id Window identifier. A value of -1 indicates a default value. pos Window position. If a position of (-1, -1) is specified then a default position is chosen. size Window size. If a size of (-1, -1) is specified then the window is sized appropriately.

1087


CHAPTER 7
style Window style. See wxScrolledWindow (p. 1085). name Window name. Remarks The window is initially created without visible scrollbars. Call wxScrolledWindow::SetScrollbars (p. 1093) to specify how big the virtual window size should be.

wxScrolledWindow::~wxScrolledWindow
~wxScrolledWindow() Destructor.

wxScrolledWindow::CalcScrolledPosition
void CalcScrolledPosition( int x, int y, int *xx int *yy) const Translates the logical coordinates to the device ones. For example, if a window is scrolled 10 pixels to the bottom, the device coordinates of the origin are (0, 0) (as always), but the logical coordinates are (0, 10) and so the call to CalcScrolledPosition(0, 10, &xx, &yy) will return 0 in yy. See also CalcUnscrolledPosition (p. 1088) wxPython note: The wxPython version of this methods accepts only two parameters and returns xx and yy as a tuple of values. wxPerl note: In wxPerl this method takes two parameters and returns a 2-element list ( xx, yy ).

wxScrolledWindow::CalcUnscrolledPosition
void CalcUnscrolledPosition( int x, int y, int *xx int *yy) const Translates the device coordinates to the logical ones. For example, if a window is scrolled 10 pixels to the bottom, the device coordinates of the origin are (0, 0) (as always), but the logical coordinates are (0, 10) and so the call to CalcUnscrolledPosition(0, 0, &xx, &yy) will return 10 in yy. See also

1088


CHAPTER 7
CalcScrolledPosition (p. 1088) wxPython note: The wxPython version of this methods accepts only two parameters and returns xx and yy as a tuple of values. wxPerl note: In wxPerl this method takes two parameters and returns a 2-element list ( xx, yy ).

wxScrolledWindow::Create
bool Create(wxWindow* parent, wxWindowID id = -1, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxHSCROLL | wxVSCROLL, const wxString& name = "scrolledWindow") Creates the window for two-step construction. Derived classes should call or replace this function. See wxScrolledWindow::wxScrolledWindow (p. 1087) for details.

wxScrolledWindow::EnableScrolling
void EnableScrolling(const bool xScrolling, const bool yScrolling) Enable or disable physical scrolling in the given direction. Physical scrolling is the physical transfer of bits up or down the screen when a scroll event occurs. If the application scrolls by a variable amount (e.g. if there are different font sizes) then physical scrolling will not work, and you should switch it off. Note that you will have to reposition child windows yourself, if physical scrolling is disabled. Parameters xScrolling If true, enables physical scrolling in the x direction. yScrolling If true, enables physical scrolling in the y direction. Remarks Physical scrolling may not be available on all platforms. Where it is available, it is enabled by default.

wxScrolledWindow::GetScrollPixelsPerUnit
void GetScrollPixelsPerUnit(int* xUnit, int* yUnit) const Get the number of pixels per scroll unit (line), in each direction, as set by wxScrolledWindow::SetScrollbars (p. 1093). A value of zero indicates no scrolling in that direction.

1089


CHAPTER 7
Parameters xUnit Receives the number of pixels per horizontal unit. yUnit Receives the number of pixels per vertical unit. See also wxScrolledWindow::SetScrollbars (p. 1093), wxScrolledWindow::GetVirtualSize (p. 1091) wxPython note: The wxPython version of this methods accepts no parameters and returns a tuple of values for xUnit and yUnit. wxPerl note: In wxPerl this method takes no parameters and returns a 2-element list ( xUnit, yUnit ).

wxScrolledWindow::GetViewStart
void GetViewStart(int* x, int* y) const Get the position at which the visible portion of the window starts. Parameters x Receives the first visible x position in scroll units. y Receives the first visible y position in scroll units. Remarks If either of the scrollbars is not at the home position, x and/or y will be greater than zero. Combined with wxWindow::GetClientSize (p. 1401), the application can use this function to efficiently redraw only the visible portion of the window. The positions are in logical scroll units, not pixels, so to convert to pixels you will have to multiply by the number of pixels per scroll increment. See also wxScrolledWindow::SetScrollbars (p. 1093) wxPython note: The wxPython version of this methods accepts no parameters and returns a tuple of values for x and y. wxPerl note: In wxPerl this method takes no parameters and returns a 2-element list ( x, y ).

1090


CHAPTER 7 wxScrolledWindow::GetVirtualSize
void GetVirtualSize(int* x, int* y) const Gets the size in device units of the scrollable window area (as opposed to the client size, which is the area of the window currently visible). Parameters x Receives the length of the scrollable window, in pixels. y Receives the height of the scrollable window, in pixels. Remarks Use wxDC::DeviceToLogicalX (p. 351) and wxDC::DeviceToLogicalY (p. 351) to translate these units to logical units. See also wxScrolledWindow::SetScrollbars (p. 1093), wxScrolledWindow::GetScrollPixelsPerUnit (p. 1089) wxPython note: The wxPython version of this methods accepts no parameters and returns a tuple of values for x and y. wxPerl note: In wxPerl this method takes no parameters and returns a 2-element list ( x, y ).

wxScrolledWindow::IsRetained
bool IsRetained() const Motif only: true if the window has a backing bitmap.

wxScrolledWindow::PrepareDC
void PrepareDC(wxDC& dc) Call this function to prepare the device context for drawing a scrolled image. It sets the device origin according to the current scroll position. PrepareDC is called automatically within the default wxScrolledWindow::OnPaint event handler, so your wxScrolledWindow::OnDraw (p. 1092) override will be passed a 'prescrolled' device context. However, if you wish to draw from outside of OnDraw (via OnPaint), or you wish to implement OnPaint yourself, you must call this function yourself. For example:

1091


CHAPTER 7
void MyWindow::OnEvent(wxMouseEvent& event) { wxClientDC dc(this); PrepareDC(dc); dc.SetPen(*wxBLACK_PEN); float x, y; event.Position(&x, &y); if (xpos > -1 && ypos > -1 && event.Dragging()) { dc.DrawLine(xpos, ypos, x, y); } xpos = x; ypos = y; }

wxScrolledWindow::OnDraw
virtual void OnDraw(wxDC& dc) Called by the default paint event handler to allow the application to define painting behaviour without having to worry about callingwxScrolledWindow::PrepareDC (p. 1091). Instead of overriding this function you may also just process the paint event in the derived class as usual, but then you will have to call PrepareDC() yourself.

wxScrolledWindow::Scroll
void Scroll(int x, int y) Scrolls a window so the view start is at the given point. Parameters x The x position to scroll to, in scroll units. y The y position to scroll to, in scroll units. Remarks The positions are in scroll units, not pixels, so to convert to pixels you will have to multiply by the number of pixels per scroll increment. If either parameter is -1, that position will be ignored (no change in that direction). See also wxScrolledWindow::SetScrollbars (p. 1093), wxScrolledWindow::GetScrollPixelsPerUnit (p. 1089)

1092


CHAPTER 7 wxScrolledWindow::SetScrollbars
void SetScrollbars(int pixelsPerUnitX, int pixelsPerUnitY, int noUnitsX, int noUnitsY, int xPos = 0, int yPos = 0, bool noRefresh = false) Sets up vertical and/or horizontal scrollbars. Parameters pixelsPerUnitX Pixels per scroll unit in the horizontal direction. pixelsPerUnitY Pixels per scroll unit in the vertical direction. noUnitsX Number of units in the horizontal direction. noUnitsY Number of units in the vertical direction. xPos Position to initialize the scrollbars in the horizontal direction, in scroll units. yPos Position to initialize the scrollbars in the vertical direction, in scroll units. noRefresh Will not refresh window if true. Remarks The first pair of parameters give the number of pixels per 'scroll step', i.e. amount moved when the up or down scroll arrows are pressed. The second pair gives the length of scrollbar in scroll steps, which sets the size of the virtual window. xPos and yPos optionally specify a position to scroll to immediately. For example, the following gives a window horizontal and vertical scrollbars with 20 pixels per scroll step, and a size of 50 steps (1000 pixels) in each direction.
window->SetScrollbars(20, 20, 50, 50);

wxScrolledWindow manages the page size itself, using the current client window size as the page size. Note that for more sophisticated scrolling applications, for example where scroll steps may be variable according to the position in the document, it will be necessary to derive a new class from wxWindow, overriding OnSize and adjusting the scrollbars

1093


CHAPTER 7
appropriately. See also wxWindow::SetVirtualSize (p. 1431)

wxScrolledWindow::SetScrollRate
void SetScrollRate(int xstep, int ystep) Set the horizontal and vertical scrolling increment only. See the pixelsPerUnit parameter in SetScrollbars.

wxScrolledWindow::SetTargetWindow
void SetTargetWindow(wxWindow* window) Call this function to tell wxScrolledWindow to perform the actual scrolling on a different window (and not on itself).

wxScrollEvent
A scroll event holds information about events sent from stand-alonescrollbars (p. 1079) and sliders (p. 1121). Note that starting from wxWindows 2.1, scrolled windows send the wxScrollWinEvent (p. 1097) which does not derive from wxCommandEvent, but from wxEvent directly - don't confuse these two kinds of events and use the event table macros mentioned below only for the scrollbar-like controls. Derived from wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a scroll event, use these event handler macros to direct input to member functions that take a wxScrollEvent argument. You can useEVT_COMMAND_SCROLL... macros with window IDs for when intercepting scroll events from controls, or EVT_SCROLL... macros without window IDs for intercepting scroll events from the receiving window - except for this, the macros behave exactly the same. EVT_SCROLL(func) EVT_SCROLL_TOP(func) Process all scroll events. Process wxEVT_SCROLL_TOP scroll-to-top events (minium

1094


CHAPTER 7
position). EVT_SCROLL_BOTTOM(func) Process wxEVT_SCROLL_TOP scroll-to-bottom events (maximum position). Process wxEVT_SCROLL_LINEUP line up events. Process wxEVT_SCROLL_LINEDOWN line down events. Process wxEVT_SCROLL_PAGEUP page up events. Process wxEVT_SCROLL_PAGEDOWN page down events. Process wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent as the user drags the thumbtrack). Process wxEVT_SCROLL_THUMBRELEAS E thumb release events. Process wxEVT_SCROLL_ENDSCROLL end of scrolling events (MSW only). Process all scroll events. Process wxEVT_SCROLL_TOP scroll-to-top events (minimum position). Process wxEVT_SCROLL_TOP scroll-to-bottom events (maximum position). Process wxEVT_SCROLL_LINEUP line up events.

EVT_SCROLL_LINEUP(func) EVT_SCROLL_LINEDOWN(func)

EVT_SCROLL_PAGEUP(func)

EVT_SCROLL_PAGEDOWN(func)

EVT_SCROLL_THUMBTRACK(func)

EVT_SCROLL_THUMBRELEASE(func)

EVT_SCROLL_ENDSCROLL(func)

EVT_COMMAND_SCROLL(id, func) EVT_COMMAND_SCROLL_TOP(id, func)

EVT_COMMAND_SCROLL_BOTTOM(id, func)

EVT_COMMAND_SCROLL_LINEUP(id, func)

EVT_COMMAND_SCROLL_LINEDOWN(id, func) Process wxEVT_SCROLL_LINEDOWN line down events. EVT_COMMAND_SCROLL_PAGEUP(id, func) Process wxEVT_SCROLL_PAGEUP page

1095


CHAPTER 7
up events. EVT_COMMAND_SCROLL_PAGEDOWN(id, func) Process wxEVT_SCROLL_PAGEDOWN page down events. EVT_COMMAND_SCROLL_THUMBTRACK(id, func) Process wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent as the user drags the thumbtrack). EVT_COMMAND_SCROLL_THUMBRELEASE(func) Process wxEVT_SCROLL_THUMBRELEAS E thumb release events. EVT_COMMAND_SCROLL_ENDSCROLL(func) Process wxEVT_SCROLL_ENDSCROLL end of scrolling events (MSW only).

The difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_ENDSCROLL The EVT_SCROLL_THUMBRELEASE event is only emitted when actually dragging the thumb using the mouse and releasing it (This EVT_SCROLL_THUMBRELEASEevent is also followed by an EVT_SCROLL_ENDSCROLL event). The EVT_SCROLL_ENDSCROLL event also occurs when using the keyboard to change the thumb position, and when clicking next to the thumb (In all these cases the EVT_SCROLL_THUMBRELEASE event does not happen). In short, the EVT_SCROLL_ENDSCROLL event is triggered when scrolling/ moving has finished. The only exception (unfortunately) is that changing the thumb position using the mousewheel does give a EVT_SCROLL_THUMBRELEASEevent but NOT an EVT_SCROLL_ENDSCROLL event. Please see the widgets sample ("Slider" page) to see the difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_ENDSCROLL in action. Remarks Note that unless specifying a scroll control identifier, you will need to test for scrollbar orientation with wxScrollEvent::GetOrientation (p. 1097), since horizontal and vertical scroll events are processed using the same event handler. See also wxScrollBar (p. 1079), wxSlider (p. 1121), wxSpinButton (p. 1154), wxScrollWinEvent (p. 1097), Event handling overview (p. 1602)

wxScrollEvent::wxScrollEvent 1096


CHAPTER 7
wxScrollEvent(WXTYPE commandType = 0, int id = 0, int pos = 0, int orientation = 0) Constructor.

wxScrollEvent::GetOrientation
int GetOrientation() const Returns wxHORIZONTAL or wxVERTICAL, depending on the orientation of the scrollbar.

wxScrollEvent::GetPosition
int GetPosition() const Returns the position of the scrollbar.

wxScrollWinEvent
A scroll event holds information about events sent from scrolling windows. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a scroll window event, use these event handler macros to direct input to member functions that take a wxScrollWinEvent argument. You can use the EVT_SCROLLWIN... macros for intercepting scroll window events from the receiving window. EVT_SCROLLWIN(func) EVT_SCROLLWIN_TOP(func) EVT_SCROLLWIN_BOTTOM(func) EVT_SCROLLWIN_LINEUP(func) Process all scroll events. Process wxEVT_SCROLLWIN_TOP scroll-totop events. Process wxEVT_SCROLLWIN_TOP scroll-tobottom events. Process wxEVT_SCROLLWIN_LINEUP line up events.

EVT_SCROLLWIN_LINEDOWN(func) Process wxEVT_SCROLLWIN_LINEDOWN line down events.

1097


CHAPTER 7
EVT_SCROLLWIN_PAGEUP(func) Process wxEVT_SCROLLWIN_PAGEUP page up events.

EVT_SCROLLWIN_PAGEDOWN(func) Process wxEVT_SCROLLWIN_PAGEDOWN page down events. EVT_SCROLLWIN_THUMBTRACK(func) Process wxEVT_SCROLLWIN_THUMBTRACK thumbtrack events (frequent events sent as the user drags the thumbtrack). EVT_SCROLLWIN_THUMBRELEASE(func) Process wxEVT_SCROLLWIN_THUMBRELEASE thumb release events. See also wxScrollEvent (p. 1094), Event handling overview (p. 1602)

wxScrollWinEvent::wxScrollWinEvent
wxScrollWinEvent(WXTYPE commandType = 0, int id = 0, int pos = 0, int orientation = 0) Constructor.

wxScrollWinEvent::GetOrientation
int GetOrientation() const Returns wxHORIZONTAL or wxVERTICAL, depending on the orientation of the scrollbar.

wxScrollWinEvent::GetPosition
int GetPosition() const Returns the position of the scrollbar for the thumb track and release events. Note that this field can't be used for the other events, you need to query the window itself for the current position in that case.

wxSemaphore
wxSemaphore is a counter limiting the number of threads concurrently accessing a shared resource. This counter is always between 0 and the maximum value specified during the semaphore creation. When the counter is strictly greater than 0, a call to Wait (p. 1100) returns immediately and decrements the counter. As soon as it reaches 0, any

1098


CHAPTER 7
subsequent calls toWait (p. 1100) block and only return when the semaphore counter becomes strictly positive again as the result of calling Post (p. 1099) which increments the counter. In general, the semaphores are useful to restrict access to a shared resource which can only be accessed by some fixed number of clients at once. For example, when modeling a hotel reservation system a semaphore with the counter equal to the total number of available rooms could be created. Each time a room is reserved, the semaphore should be acquired by calling Wait (p. 1100) and each time a room is freed it should be released by calling Post (p. 1099). Derived from No base class Include files <wx/thread.h>

wxSemaphore::wxSemaphore
wxSemaphore(int initialcount = 0, int maxcount = 0) Specifying a maxcount of 0 actually makes wxSemaphore behave as if there is no upper limit. If maxcount is 1 the semaphore behaves exactly as a mutex. initialcount is the initial value of the semaphore which must be between0 and maxcount (if it is not set to 0).

wxSemaphore::~wxSemaphore
~wxSemaphore() Destructor is not virtual, don't use this class polymorphically.

wxSemaphore::Post
wxSemaError Post() Increments the semaphore count and signals one of the waiting threads in an atomic way. Returns wxSEMA_OVERFLOW if the count would increase the counter past the maximum. Return value One of: wxSEMA_NO_ERROR There was no error.

1099


CHAPTER 7
wxSEMA_INVALID wxSEMA_OVERFLOW wxSEMA_MISC_ERROR Semaphore hasn't been initialized successfully. Post() would increase counter past the max. Miscellaneous error.

wxSemaphore::TryWait
wxSemaError TryWait() Same as Wait() (p. 1100), but returns immediately. Return value One of: wxSEMA_NO_ERROR wxSEMA_INVALID wxSEMA_BUSY wxSEMA_MISC_ERROR There was no error. Semaphore hasn't been initialized successfully. Returned by TryWait() if Wait() would block, i.e. the count is zero. Miscellaneous error.

wxSemaphore::Wait
wxSemaError Wait() Wait indefinitely until the semaphore count becomes strictly positive and then decrement it and return. Return value One of: wxSEMA_NO_ERROR wxSEMA_INVALID wxSEMA_MISC_ERROR There was no error. Semaphore hasn't been initialized successfully. Miscellaneous error.

wxSemaphore::WaitTimeout
wxSemaError WaitTimeout(unsigned longtimeout_millis) Same as Wait() (p. 1100), but with a timeout limit. Return value One of:

1100


CHAPTER 7
wxSEMA_NO_ERROR wxSEMA_INVALID wxSEMA_TIMEOUT wxSEMA_MISC_ERROR There was no error. Semaphore hasn't been initialized successfully. Timeout occurred without receiving semaphore. Miscellaneous error.

wxServer
A wxServer object represents the server part of a client-server DDE-like (Dynamic Data Exchange) conversation. The actual DDE-based implementation using wxDDEServer is available on Windows only, but a platform-independent, socket-based version of this API is available using wxTCPServer, which has the same API. To create a server which can communicate with a suitable client, you need to derive a class from wxConnection and another from wxServer. The custom wxConnection class will intercept communications in a 'conversation' with a client, and the custom wxServer is required so that a user-overridden wxServer::OnAcceptConnection (p. 1102) member can return a wxConnection of the required class, when a connection is made. Look at the IPC sample and the Interprocess communications overview (p. 1688) for an example of how to do this. Derived from wxServerBase Include files <wx/ipc.h> See also wxClient (p. 131),wxConnection (p. 191), IPC overview (p. 1688)

wxServer::wxServer
wxServer() Constructs a server object.

wxServer::Create
bool Create(const wxString& service) Registers the server using the given service name. Under Unix, the service name may be either an integer port identifier in which case an Internet domain socket will be used for the communications, or a valid file name (which shouldn't exist and will be deleted

1101


CHAPTER 7
afterwards) in which case a Unix domain socket is created. false is returned if the call failed (for example, the port number is already in use).

wxServer::OnAcceptConnection
virtual wxConnectionBase * OnAcceptConnection(const wxString& topic) When a client calls MakeConnection, the server receives the message and this member is called. The application should derive a member to intercept this message and return a connection object of either the standard wxConnection type, or (more likely) of a user-derived type. If the topic is STDIO, the application may wish to refuse the connection. Under UNIX, when a server is created the OnAcceptConnection message is always sent for standard input and output, but in the context of DDE messages it doesn't make a lot of sense.

wxSimpleHelpProvider
wxSimpleHelpProvider is an implementation of wxHelpProvider (p. 652) which supports only plain text help strings, and shows the string associated with the control (if any) in a tooltip. Derived from wxHelpProvider (p. 652) Include files <wx/cshelp.h> See also wxHelpProvider (p. 652), wxHelpControllerHelpProvider (p. 649), wxContextHelp (p. 195), wxWindow::SetHelpText (p. 1425), wxWindow::GetHelpText (p. 1403)

wxSingleChoiceDialog
This class represents a dialog that shows a list of strings, and allows the user to select one. Double-clicking on a list item is equivalent to single-clicking and then pressing OK. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files

1102


CHAPTER 7
<wx/choicdlg.h> See also wxSingleChoiceDialog overview (p. 1651)

wxSingleChoiceDialog::wxSingleChoiceDialog
wxSingleChoiceDialog(wxWindow* parent, const wxString& message, const wxString& caption, int n, const wxString* choices, void** clientData = NULL, long style = wxOK | wxCANCEL | wxCENTRE, const wxPoint& pos = wxDefaultPosition) Constructor, taking an array of wxString choices and optional client data. Parameters parent Parent window. message Message to show on the dialog. caption The dialog caption. n The number of choices. choices An array of strings, or a string list, containing the choices. style A dialog style (bitlist) containing flags chosen from the following: wxOK wxCANCEL wxCENTRE pos Dialog position. Not Windows. Remarks Show an OK button. Show a Cancel button. Centre the message. Not Windows.

1103


CHAPTER 7
Use wxSingleChoiceDialog::ShowModal (p. 1104) to show the dialog. wxPython note: For Python the two parameters n and choices are collapsed into a single parameter choices which is expected to be a Python list of strings. wxPerl note: In wxPerl there is just an array reference in place of nand choices, and the client data array, if present, must have the same length as the choices array.

wxSingleChoiceDialog::~wxSingleChoiceDialog
~wxSingleChoiceDialog() Destructor.

wxSingleChoiceDialog::GetSelection
int GetSelection() const Returns the index of selected item.

wxSingleChoiceDialog::GetSelectionClientData
char* GetSelectionClientData() const Returns the client data associated with the selection.

wxSingleChoiceDialog::GetStringSelection
wxString GetStringSelection() const Returns the selected string.

wxSingleChoiceDialog::SetSelection
void SetSelection(int selection) const Sets the index of the initially selected item.

wxSingleChoiceDialog::ShowModal
int ShowModal() Shows the dialog, returning either wxID_OK or wxID_CANCEL.

wxSingleInstanceChecker
1104


CHAPTER 7
wxSingleInstanceChecker class allows to check that only a single instance of a program is running. To do it, you should create an object of this class. As long as this object is alive, calls to IsAnotherRunning() (p. 1106) from other processes will return true. As the object should have the life span as big as possible, it makes sense to create it either as a global or in wxApp::OnInit (p. 36). For example:
bool MyApp::OnInit() { const wxString name = wxString::Format("MyApp-%s", wxGetUserId().c_str()); m_checker = new wxSingleInstanceChecker(name); if ( m_checker->IsAnotherRunning() ) { wxLogError(_("Another program instance is already running, aborting.")); return false; } ... more initializations ... return true; } int MyApp::OnExit() { delete m_checker; return 0; }

Note using wxGetUserId() (p. 1482) to construct the name: this allows different user to run the application concurrently which is usually the intended goal. If you don't use the user name in the wxSingleInstanceChecker name, only one user would be able to run the application at a time. This class is implemented for Win32 and Unix platforms (supporting fcntl()system call, but almost all of modern Unix systems do) only. Derived from No base class Include files <wx/snglinst.h>

wxSingleInstanceChecker::wxSingleInstanceChecker
wxSingleInstanceChecker() Default ctor, use Create() (p. 1106) after it.

wxSingleInstanceChecker::wxSingleInstanceChecker

1105


CHAPTER 7
wxSingleInstanceChecker(const wxString& name, const wxString& path = wxEmptyString) Like Create() (p. 1106) but without error checking.

wxSingleInstanceChecker::Create
bool Create(const wxString& name, const wxString& path = wxEmptyString) Initialize the object if it had been created using the default constructor. Note that you can't call Create() more than once, so calling it if the non default ctor (p. 1105) had been used is an error. Parameters name must be given and be as unique as possible. It is used as the mutex name under Win32 and the lock file name under Unix. GetAppName() (p. 32) and wxGetUserId() (p. 1482) are commonly used to construct this parameter. path is optional and is ignored under Win32 and used as the directory to create the lock file in under Unix (default is wxGetHomeDir() (p. 1481)) Return value Returns false if initialization failed, it doesn't mean that another instance is running use IsAnotherRunning() (p. 1106) to check for it.

wxSingleInstanceChecker::IsAnotherRunning
bool IsAnotherRunning() const Returns true if another copy of this program is already running, false otherwise.

wxSingleInstanceChecker::~wxSingleInstanceChecker
~wxSingleInstanceChecker() Destructor frees the associated resources. Note that it is not virtual, this class is not meant to be used polymorphically

wxSize
A wxSize is a useful data structure for graphics operations. It simply contains integer width and height members.

1106


CHAPTER 7
wxSize is used throughout wxWindows as well as wxPoint which, although almost equivalent to wxSize, has a different meaning: wxPoint represents a position while wxSize - the size. wxPython note: wxPython defines aliases for the x and y members named width and height since it makes much more sense for sizes. Derived from None Include files <wx/gdicmn.h> See also wxPoint (p. 991), wxRealPoint (p. 1041)

wxSize::wxSize
wxSize() wxSize(int width, int height) Creates a size object.

wxSize::DecTo
wxSize& DecTo(const wxSize& size) Decrements this object so that both of its dimensions are not greater than the corresponding dimensions of the size. See also IncTo (p. 1108)

wxSize::GetWidth
int GetWidth() const Gets the width member.

wxSize::GetHeight
int GetHeight() const

1107


CHAPTER 7
Gets the height member.

wxSize::IncTo
wxSize& IncTo(const wxSize& size) Increments this object so that both of its dimensions are not less than the corresponding dimensions of the size. See also DecTo (p. 1107)

wxSize::Set
void Set(int width, int height) Sets the width and height members.

wxSize::SetHeight
void SetHeight(int height) Sets the height.

wxSize::SetWidth
void SetWidth(int width) Sets the width.

wxSize::operator =
void operator =(const wxSize& sz) Assignment operator.

wxSizeEvent
A size event holds information about size change events. The EVT_SIZE handler function will be called when the window has been resized. You may wish to use this for frames to resize their child windows as appropriate. Note that the size passed is of the whole window: call wxWindow::GetClientSize (p.

1108


CHAPTER 7
1401) for the area which may be used by the application. When a window is resized, usually only a small part of the window is damaged and you may only need to repaint that area. However, if your drawing depends on the size of the window, you may need to clear the DC explicitly and repaint the whole window. In which case, you may need to call wxWindow::Refresh (p. 1414) to invalidate the entire window. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a size event, use this event handler macro to direct input to a member function that takes a wxSizeEvent argument. EVT_SIZE(func) Process a wxEVT_SIZE event.

See also wxSize (p. 1106), Event handling overview (p. 1602)

wxSizeEvent::wxSizeEvent
wxSizeEvent(const wxSize& sz, int id = 0) Constructor.

wxSizeEvent::GetSize
wxSize GetSize() const Returns the entire size of the window generating the size change event.

wxSizer
wxSizer is the abstract base class used for laying out subwindows in a window. You cannot use wxSizer directly; instead, you will have to use one of the sizer classes derived from it. Currently there are wxBoxSizer (p. 89), wxStaticBoxSizer (p. 1180),wxNotebookSizer (p. 952), wxGridSizer (p. 633) and wxFlexGridSizer (p. 506). The layout algorithm used by sizers in wxWindows is closely related to layout in other GUI toolkits, such as Java's AWT, the GTK toolkit or the Qt toolkit. It is based upon the idea of the individual subwindows reporting their minimal required size and their ability to

1109


CHAPTER 7
get stretched if the size of the parent window has changed. This will most often mean, that the programmer does not set the original size of a dialog in the beginning, rather the dialog will assigned a sizer and this sizer will be queried about the recommended size. The sizer in turn will query its children, which can be normal windows, empty space or other sizers, so that a hierarchy of sizers can be constructed. Note that wxSizer does not derive from wxWindow and thus do not interfere with tab ordering and requires very little resources compared to a real window on screen. What makes sizers so well fitted for use in wxWindows is the fact that every control reports its own minimal size and the algorithm can handle differences in font sizes or different window (dialog item) sizes on different platforms without problems. If e.g. the standard font as well as the overall design of Motif widgets requires more space than on Windows, the initial dialog size will automatically be bigger on Motif than on Windows. wxPython note: If you wish to create a sizer class in wxPython you should derive the class from wxPySizer in order to get Python-aware capabilities for the various virtual methods. Derived from wxObject (p. 954) See also Sizer overview (p. 1620)

wxSizer::wxSizer
wxSizer() The constructor. Note that wxSizer is an abstract base class and may not be instantiated.

wxSizer::~wxSizer
~wxSizer() The destructor.

wxSizer::Add
void Add(wxWindow* window, int proportion = 0,int flag = 0, int border = 0, wxObject* userData = NULL) void Add(wxSizer* sizer, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL) void Add(int width, int height, int proportion = 0, int flag = 0, int border = 0, wxObject*

1110


CHAPTER 7
userData = NULL) Appends a child to the sizer. wxSizer itself is an abstract class, but the parameters are equivalent in the derived classes that you will instantiate to use it so they are described here: window The window to be added to the sizer. Its initial size (either set explicitly by the user or calculated internally when using wxDefaultSize) is interpreted as the minimal and in many cases also the initial size. This is particularly useful in connection with SetSizeHints (p. 1115). sizer The (child-)sizer to be added to the sizer. This allows placing a child sizer in a sizer and thus to create hierarchies of sizers (typically a vertical box as the top sizer and several horizontal boxes on the level beneath). width and height The dimension of a spacer to be added to the sizer. Adding spacers to sizers gives more flexibility in the design of dialogs; imagine for example a horizontal box with two buttons at the bottom of a dialog: you might want to insert a space between the two buttons and make that space stretchable using the proportion flag and the result will be that the left button will be aligned with the left side of the dialog and the right button with the right side - the space in between will shrink and grow with the dialog. proportion Although the meaning of this parameter is undefined in wxSizer, it is used in wxBoxSizer to indicate if a child of a sizer can change its size in the main orientation of the wxBoxSizer - where 0 stands for not changeable and a value of more than zero is interpreted relative to the value of other children of the same wxBoxSizer. For example, you might have a horizontal wxBoxSizer with three children, two of which are supposed to change their size with the sizer. Then the two stretchable windows would get a value of 1 each to make them grow and shrink equally with the sizer's horizontal dimension. flag This parameter can be used to set a number of flags which can be combined using the binary OR operator |. Two main behaviours are defined using these flags. One is the border around a window: the borderparameter determines the border width whereas the flags given here determine where the border may be (wxTOP, wxBOTTOM, wxLEFT, wxRIGHT or wxALL). The other flags determine the child window's behaviour if the size of the sizer changes. However this is not - in contrast to the proportion flag - in the main orientation, but in the respectively other orientation. So if you created a wxBoxSizer with the wxVERTICAL option, these flags will be relevant if the sizer changes its horizontal size. A child may get resized to completely fill out the new size (using either wxGROW or wxEXPAND), it may get proportionally resized (wxSHAPED), it may get centered

1111


CHAPTER 7
(wxALIGN_CENTER or wxALIGN_CENTRE) or it may get aligned to either side (wxALIGN_LEFT and wxALIGN_TOP are set to 0 and thus represent the default, wxALIGN_RIGHT and wxALIGN_BOTTOM have their obvious meaning). With proportional resize, a child may also be centered in the main orientation using wxALIGN_CENTER_VERTICAL (same as wxALIGN_CENTRE_VERTICAL) and wxALIGN_CENTER_HORIZONTAL (same as wxALIGN_CENTRE_HORIZONTAL) flags. Finally, you can also specify wxADJUST_MINSIZE flag to make the minimal size of the control dynamically adjust to the value returned by its GetAdjustedBestSize() (p. 1399)method - this allows, for example, for correct relayouting of a static text control even if its text is changed during run-time. border Determines the border width, if the flag parameter is set to any border. userData Allows an extra object to be attached to the sizer item, for use in derived classes when sizing information is more complex than the proportion and flag will allow for.

wxSizer::CalcMin
wxSize CalcMin() This method is abstract and has to be overwritten by any derived class. Here, the sizer will do the actual calculation of its children minimal sizes.

wxSizer::Detach
bool Detach(wxWindow* window) bool Detach(wxSizer* sizer) bool Detach(size_t index) Detach a child from the sizer without destroying it. window is the window to be detached, sizer is the equivalent sizer and index is the position of the child in the sizer, typically 0 for the first item. This method does not cause any layout or resizing to take place, call wxSizer::Layout (p. 1114)to update the layout "on screen" after detaching a child from the sizer. Returns true if the child item was found and detached, false otherwise. See also wxSizer::Remove (p. 1114)

wxSizer::Fit

1112


CHAPTER 7
wxSize Fit(wxWindow* window) Tell the sizer to resize the window to match the sizer's minimal size. This is commonly done in the constructor of the window itself, see sample in the description of wxBoxSizer (p. 89). Returns the new size. For a top level window this is the total window size, not client size.

wxSizer::FitInside
void FitInside(wxWindow* window) Tell the sizer to resize the virtual size of the window to match the sizer's minimal size. This will not alter the on screen size of the window, but may cause the addition/removal/alteration of scrollbars required to view the virtual area in windows which manage it. See also wxScrolledWindow::SetScrollbars (p. 1093), wxSizer::SetVirtualSizeHints (p. 1116)

wxSizer::GetSize
wxSize GetSize() Returns the current size of the sizer.

wxSizer::GetPosition
wxPoint GetPosition() Returns the current position of the sizer.

wxSizer::GetMinSize
wxSize GetMinSize() Returns the minimal size of the sizer. This is either the combined minimal size of all the children and their borders or the minimal size set by SetMinSize (p. 1115), depending on which is bigger.

wxSizer::Insert
void Insert(size_t index, wxWindow* window, int proportion = 0,int flag = 0, int border = 0, wxObject* userData = NULL) void Insert(size_t index, wxSizer* sizer, int proportion = 0, int flag = 0, int border = 0,

1113


CHAPTER 7
wxObject* userData = NULL) void Insert(size_t index, int width, int height, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL) Insert a child into the sizer before any existing item at index. index The position this child should assume in the sizer. See wxSizer::Add (p. 1110) for the meaning of the other parameters.

wxSizer::Layout
void Layout() Call this to force layout of the children anew, e.g. after having added a child to or removed a child (window, other sizer or space) from the sizer while keeping the current dimension.

wxSizer::Prepend
void Prepend(wxWindow* window, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL) void Prepend(wxSizer* sizer, int proportion = 0, int flag = 0, int border = 0, wxObject* userData = NULL) void Prepend(int width, int height, int proportion = 0, int flag = 0, int border= 0, wxObject* userData = NULL) Same as wxSizer::Add (p. 1110), but prepends the items to the beginning of the list of items (windows, subsizers or spaces) owned by this sizer.

wxSizer::RecalcSizes
void RecalcSizes() This method is abstract and has to be overwritten by any derived class. Here, the sizer will do the actual calculation of its children's positions and sizes.

wxSizer::Remove
bool Remove(wxWindow* window) bool Remove(wxSizer* sizer) bool Remove(size_t index)

1114


CHAPTER 7
Removes a child from the sizer and destroys it. sizer is the wxSizer to be removed,index is the position of the child in the sizer, typically 0 for the first item. This method does not cause any layout or resizing to take place, callwxSizer::Layout (p. 1114) to update the layout "on screen" after removing a child from the sizer. NB: The method taking a wxWindow* parameter is deprecated. For historical reasons it does not destroy the window as would usually be expected from Remove. You should usewxSizer::Detach (p. 1112) in new code instead. There is currently no wxSizer method that will both detach and destroy a wxWindow item. Returns true if the child item was found and removed, false otherwise.

wxSizer::SetDimension
void SetDimension(int x, int y, int width, int height) Call this to force the sizer to take the given dimension and thus force the items owned by the sizer to resize themselves according to the rules defined by the parameter in the Add (p. 1110) and Prepend (p. 1114) methods.

wxSizer::SetMinSize
void SetMinSize(int width, int height) void SetMinSize(wxSize size) Call this to give the sizer a minimal size. Normally, the sizer will calculate its minimal size based purely on how much space its children need. After calling this method GetMinSize (p. 1113) will return either the minimal size as requested by its children or the minimal size set here, depending on which is bigger.

wxSizer::SetItemMinSize
void SetItemMinSize(wxWindow* window, int width, int height) void SetItemMinSize(wxSizer* sizer, int width, int height) void SetItemMinSize(size_t index, int width, int height) Set an item's minimum size by window, sizer, or position. The item will be found recursively in the sizer's descendants. This function enables an application to set the size of an item after initial creation.

wxSizer::SetSizeHints
void SetSizeHints(wxWindow* window) Tell the sizer to set (and Fit (p. 1112)) the minimal size of the window to match the

1115


CHAPTER 7
sizer's minimal size. This is commonly done in the constructor of the window itself, see sample in the description of wxBoxSizer (p. 89) if the window is resizable (as are many dialogs under Unix and frames on probably all platforms).

wxSizer::SetVirtualSizeHints
void SetVirtualSizeHints(wxWindow* window) Tell the sizer to set the minimal size of the window virtual area to match the sizer's minimal size. For windows with managed scrollbars this will set them appropriately. See also wxScrolledWindow::SetScrollbars (p. 1093)

wxSizer::Show
void Show(wxWindow* window, bool show = true) void Show(wxSizer* sizer, bool show = true) void Show(size_t index, bool show = true) Shows or hides the window, sizer, or item at index. To make a sizer item disappear or reappear, use Show() followed by Layout(). Note that this only works with wxBoxSizer and wxFlexGridSizer, since they are the only two sizer classes that can size rows/columns independently.

wxSizerItem
The wxSizerItem class is used to track the position, size and other attributes of each item managed by a wxSizer (p. 1109). In normal usage user code should never need to deal directly with a wxSizerItem, but derived sizer classes will. Derived from wxObject (p. 954) Include files <wx/sizer.h>

wxSizerItem::wxSizerItem
wxSizerItem(int width, int height, int proportion, int flag, int border, wxObject* userData)

1116


CHAPTER 7
Construct a sizer item for tracking a spacer. wxSizerItem(wxWindow* window, int proportion, int flag, int border, wxObject* userData) Construct a sizer item for tracking a window. wxSizerItem(wxSizer* sizer, int proportion, int flag, int border, wxObject* userData) Construct a sizer item for tracking a subsizer.

wxSizerItem::~wxSizerItem
~wxSizerItem() Deletes the user data and subsizer, if any.

wxSizerItem::CalcMin
wxSize CalcMin() Calculates the minimum desired size for the item, including any space needed by borders.

wxSizerItem::DeleteWindows
void DeleteWindows() Destroy the window or the windows in a subsizer, depending on the type of item.

wxSizerItem::DetachSizer
void DetachSizer() Enable deleting the SizerItem without destroying the contained sizer.

wxSizerItem::GetBorder
int GetBorder() const Return the border attribute.

wxSizerItem::GetFlag
int GetFlag() const

1117


CHAPTER 7
Return the flags attribute.

wxSizerItem::GetMinSize
wxSize GetMinSize() const Get the minimum size needed for the item.

wxSizerItem::GetPosition
wxPoint GetPosition() const What is the current position of the item, as set in the last Layout.

wxSizerItem::GetProportion
int GetProportion() const Get the proportion item attribute.

wxSizerItem::GetRatio
float GetRatio() const Get the ration item attribute.

wxSizerItem::GetSize
wxSize GetSize() const Get the current size of the item, as set in the last Layout.

wxSizerItem::GetSizer
wxSizer* GetSizer() const If this item is tracking a sizer, return it. NULL otherwise.

wxSizerItem::GetSpacer
const wxSize& GetSpacer() const If this item is tracking a spacer, return its size.

1118


CHAPTER 7 wxSizerItem::GetUserData
wxObject* GetUserData() const Get the userData item attribute.

wxSizerItem::GetWindow
wxWindow* GetWindow() const If this item is trackign a window then return it. NULL otherwise.

wxSizerItem::IsShown
bool IsShown() const Is this item shown?

wxSizerItem::IsSizer
bool IsSizer() const Is this item a sizer?

wxSizerItem::IsSpacer
bool IsSpacer() const Is this item a spacer?

wxSizerItem::IsWindow
bool IsWindow() const Is this item a window?

wxSizerItem::SetBorder
void SetBorder(int border) Set the border item attribute.

wxSizerItem::SetDimension
void SetDimension(wxPoint pos, wxSize size)

1119


CHAPTER 7
Set the position and size of the space allocated to the sizer, and adjust the position and size of the item to be within that space taking alignment and borders into account.

wxSizerItem::SetFlag
void SetFlag(int flag) Set the flag item attribute.

wxSizerItem::SetInitSize
void SetInitSize(int x, int y)

wxSizerItem::SetProportion
void SetProportion(int proportion) Set the proportion item attribute.

wxSizerItem::SetRatio
void SetRatio(int width, int height) void SetRatio(wxSize size) void SetRatio(float ratio) Set the ratio item attribute.

wxSizerItem::SetSizer
void SetSizer(wxSizer* sizer) Set the sizer tracked by this item.

wxSizerItem::SetSpacer
void SetSpacer(const wxSize& size) Set the size of the spacer tracked by this item.

wxSizerItem::SetWindow
void SetWindow(wxWindow* window)

1120


CHAPTER 7
Set the window to be tracked by thsi item.

wxSizerItem::Show
void Show(bool show) Set the show item attribute, which sizers use to determine if the item is to be made part of the layout or not. If the item is tracking a window then it is shown or hidden as needed.

wxSlider
A slider is a control with a handle which can be pulled back and forth to change the value. In Windows versions below Windows 95, a scrollbar is used to simulate the slider. In Windows 95, the track bar control is used. Slider events are handled in the same way as a scrollbar. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/slider.h> Window styles wxSL_HORIZONTAL wxSL_VERTICAL wxSL_AUTOTICKS wxSL_LABELS wxSL_LEFT wxSL_RIGHT wxSL_TOP wxSL_SELRANGE Displays the slider horizontally. Displays the slider vertically. Displays tick marks. Displays minimum, maximum and value labels. (NB: only displays the current value label under wxGTK) Displays ticks on the left, if a vertical slider. Displays ticks on the right, if a vertical slider. Displays ticks on the top, if a horizontal slider. Allows the user to select a range on the slider. Windows 95 only.

See also window styles overview (p. 1611).

1121


CHAPTER 7
Event table macros To process a scroll event, use these event handler macros to direct input to member functions that take a wxScrollEvent argument. You can useEVT_COMMAND_SCROLL... macros with window IDs for when intercepting scroll events from controls, or EVT_SCROLL... macros without window IDs for intercepting scroll events from the receiving window - except for this, the macros behave exactly the same. EVT_SCROLL(func) EVT_SCROLL_TOP(func) Process all scroll events. Process wxEVT_SCROLL_TOP scroll-to-top events (minium position). Process wxEVT_SCROLL_TOP scroll-to-bottom events (maximum position). Process wxEVT_SCROLL_LINEUP line up events. Process wxEVT_SCROLL_LINEDOWN line down events. Process wxEVT_SCROLL_PAGEUP page up events. Process wxEVT_SCROLL_PAGEDOWN page down events. Process wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent as the user drags the thumbtrack). Process wxEVT_SCROLL_THUMBRELEAS E thumb release events. Process wxEVT_SCROLL_ENDSCROLL end of scrolling events (MSW only). Process all scroll events. Process wxEVT_SCROLL_TOP scroll-to-top events (minimum position). Process wxEVT_SCROLL_TOP

EVT_SCROLL_BOTTOM(func)

EVT_SCROLL_LINEUP(func) EVT_SCROLL_LINEDOWN(func)

EVT_SCROLL_PAGEUP(func)

EVT_SCROLL_PAGEDOWN(func)

EVT_SCROLL_THUMBTRACK(func)

EVT_SCROLL_THUMBRELEASE(func)

EVT_SCROLL_ENDSCROLL(func)

EVT_COMMAND_SCROLL(id, func) EVT_COMMAND_SCROLL_TOP(id, func)

EVT_COMMAND_SCROLL_BOTTOM(id, func)

1122


CHAPTER 7
scroll-to-bottom events (maximum position). EVT_COMMAND_SCROLL_LINEUP(id, func) Process wxEVT_SCROLL_LINEUP line up events.

EVT_COMMAND_SCROLL_LINEDOWN(id, func) Process wxEVT_SCROLL_LINEDOWN line down events. EVT_COMMAND_SCROLL_PAGEUP(id, func) Process wxEVT_SCROLL_PAGEUP page up events.

EVT_COMMAND_SCROLL_PAGEDOWN(id, func) Process wxEVT_SCROLL_PAGEDOWN page down events. EVT_COMMAND_SCROLL_THUMBTRACK(id, func) Process wxEVT_SCROLL_THUMBTRACK thumbtrack events (frequent events sent as the user drags the thumbtrack). EVT_COMMAND_SCROLL_THUMBRELEASE(func) Process wxEVT_SCROLL_THUMBRELEAS E thumb release events. EVT_COMMAND_SCROLL_ENDSCROLL(func) Process wxEVT_SCROLL_ENDSCROLL end of scrolling events (MSW only).

The difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_ENDSCROLL The EVT_SCROLL_THUMBRELEASE event is only emitted when actually dragging the thumb using the mouse and releasing it (This EVT_SCROLL_THUMBRELEASEevent is also followed by an EVT_SCROLL_ENDSCROLL event). The EVT_SCROLL_ENDSCROLL event also occurs when using the keyboard to change the thumb position, and when clicking next to the thumb (In all these cases the EVT_SCROLL_THUMBRELEASE event does not happen). In short, the EVT_SCROLL_ENDSCROLL event is triggered when scrolling/ moving has finished. The only exception (unfortunately) is that changing the thumb position using the mousewheel does give a EVT_SCROLL_THUMBRELEASEevent but NOT an EVT_SCROLL_ENDSCROLL event. Please see the widgets sample ("Slider" page) to see the difference between EVT_SCROLL_THUMBRELEASE and EVT_SCROLL_ENDSCROLL in action. See also Event handling overview (p. 1602), wxScrollBar (p. 1079)

1123


CHAPTER 7

wxSlider::wxSlider
wxSlider() Default slider. wxSlider(wxWindow* parent, wxWindowID id, int value , int minValue, int maxValue, const wxPoint& point = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSL_HORIZONTAL, const wxValidator& validator = wxDefaultValidator, const wxString& name = "slider") Constructor, creating and showing a slider. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. value Initial position for the slider. minValue Minimum slider position. maxValue Maximum slider position. size Window size. If the default size (-1, -1) is specified then a default size is chosen. style Window style. See wxSlider (p. 1121). validator Window validator. name Window name. See also

1124


CHAPTER 7
wxSlider::Create (p. 1125), wxValidator (p. 1358)

wxSlider::~wxSlider
void ~wxSlider() Destructor, destroying the slider.

wxSlider::ClearSel
void ClearSel() Clears the selection, for a slider with the wxSL_SELRANGE style. Remarks Windows 95 only.

wxSlider::ClearTicks
void ClearTicks() Clears the ticks. Remarks Windows 95 only.

wxSlider::Create
bool Create(wxWindow* parent, wxWindowID id, int value , int minValue, int maxValue, const wxPoint& point = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSL_HORIZONTAL, const wxValidator& validator = wxDefaultValidator, const wxString& name = "slider") Used for two-step slider construction. See wxSlider::wxSlider (p. 1124) for further details.

wxSlider::GetLineSize
int GetLineSize() const Returns the line size. See also wxSlider::SetLineSize (p. 1128)

1125


CHAPTER 7 wxSlider::GetMax
int GetMax() const Gets the maximum slider value. See also wxSlider::GetMin (p. 1126), wxSlider::SetRange (p. 1127)

wxSlider::GetMin
int GetMin() const Gets the minimum slider value. See also wxSlider::GetMin (p. 1126), wxSlider::SetRange (p. 1127)

wxSlider::GetPageSize
int GetPageSize() const Returns the page size. See also wxSlider::SetPageSize (p. 1128)

wxSlider::GetSelEnd
int GetSelEnd() const Returns the selection end point. Remarks Windows 95 only. See also wxSlider::GetSelStart (p. 1126), wxSlider::SetSelection (p. 1129)

wxSlider::GetSelStart
int GetSelStart() const Returns the selection start point.

1126


CHAPTER 7
Remarks Windows 95 only. See also wxSlider::GetSelEnd (p. 1126), wxSlider::SetSelection (p. 1129)

wxSlider::GetThumbLength
int GetThumbLength() const Returns the thumb length. Remarks Windows 95 only. See also wxSlider::SetThumbLength (p. 1129)

wxSlider::GetTickFreq
int GetTickFreq() const Returns the tick frequency. Remarks Windows 95 only. See also wxSlider::SetTickFreq (p. 1128)

wxSlider::GetValue
int GetValue() const Gets the current slider value. See also wxSlider::GetMin (p. 1126), wxSlider::GetMax (p. 1126), wxSlider::SetValue (p. 1130)

wxSlider::SetRange
void SetRange(int minValue, int maxValue)

1127


CHAPTER 7
Sets the minimum and maximum slider values. See also wxSlider::GetMin (p. 1126), wxSlider::GetMax (p. 1126)

wxSlider::SetTickFreq
void SetTickFreq(int n, int pos) Sets the tick mark frequency and position. Parameters n Frequency. For example, if the frequency is set to two, a tick mark is displayed for every other increment in the slider's range. pos Position. Must be greater than zero. TODO: what is this for? Remarks Windows 95 only. See also wxSlider::GetTickFreq (p. 1127)

wxSlider::SetLineSize
void SetLineSize(int lineSize) Sets the line size for the slider. Parameters lineSize The number of steps the slider moves when the user moves it up or down a line. See also wxSlider::GetLineSize (p. 1125)

wxSlider::SetPageSize
void SetPageSize(int pageSize) Sets the page size for the slider.

1128


CHAPTER 7
Parameters pageSize The number of steps the slider moves when the user pages up or down. See also wxSlider::GetPageSize (p. 1126)

wxSlider::SetSelection
void SetSelection(int startPos, int endPos) Sets the selection. Parameters startPos The selection start position. endPos The selection end position. Remarks Windows 95 only. See also wxSlider::GetSelStart (p. 1126), wxSlider::GetSelEnd (p. 1126)

wxSlider::SetThumbLength
void SetThumbLength(int len) Sets the slider thumb length. Parameters len The thumb length. Remarks Windows 95 only. See also wxSlider::GetThumbLength (p. 1127)

1129


CHAPTER 7 wxSlider::SetTick
void SetTick(int tickPos) Sets a tick position. Parameters tickPos The tick position. Remarks Windows 95 only. See also wxSlider::SetTickFreq (p. 1128)

wxSlider::SetValue
void SetValue(int value) Sets the slider position. Parameters value The slider position. See also wxSlider::GetValue (p. 1127)

wxSockAddress
You are unlikely to need to use this class: only wxSocketBase uses it. Derived from wxObject (p. 954) Include files <wx/socket.h> See also wxSocketBase (p. 1131)wxIPaddress (p. 764)wxIPV4address (p. 766)

1130


CHAPTER 7 wxSockAddress::wxSockAddress
wxSockAddress() Default constructor.

wxSockAddress::~wxSockAddress
~wxSockAddress() Default destructor.

wxSockAddress::Clear
void Clear() Delete all informations about the address.

wxSockAddress::SockAddrLen
int SockAddrLen() Returns the length of the socket address.

wxSocketBase
wxSocketBase is the base class for all socket-related objects, and it defines all basic IO functionality. Derived from wxObject (p. 954) Include files <wx/socket.h> wxSocket errors wxSOCKET_NOERROR wxSOCKET_INVOP wxSOCKET_IOERR wxSOCKET_INVADDR wxSOCKET_INVSOCK No error happened. Invalid operation. Input/Output error. Invalid address passed to wxSocket. Invalid socket (uninitialized).

1131


CHAPTER 7
wxSOCKET_NOHOST wxSOCKET_INVPORT wxSOCKET_WOULDBLOCK wxSOCKET_TIMEDOUT wxSOCKET_MEMERR wxSocket events wxSOCKET_INPUT wxSOCKET_OUTPUT wxSOCKET_CONNECTION wxSOCKET_LOST A brief note on how to use these events: The wxSOCKET_INPUT event will be issued whenever there is data available for reading. This will be the case if the input queue was empty and new data arrives, or if the application has read some data yet there is still more data available. This means that the application does not need to read all available data in response to a wxSOCKET_INPUT event, as more events will be produced as necessary. The wxSOCKET_OUTPUT event is issued when a socket is first connected with Connect (p. 1148) or accepted with Accept (p. 1153). After that, new events will be generated only after an output operation fails with wxSOCKET_WOULDBLOCK and buffer space becomes available again. This means that the application should assume that it can write data to the socket until an wxSOCKET_WOULDBLOCK error occurs; after this, whenever the socket becomes writable again the application will be notified with another wxSOCKET_OUTPUT event. The wxSOCKET_CONNECTION event is issued when a delayed connection request completes successfully (client) or when a new connection arrives at the incoming queue (server). The wxSOCKET_LOST event is issued when a close indication is received for the socket. This means that the connection broke down or that it was closed by the peer. Also, this event will be issued if a connection request fails. Event handling To process events coming from a socket object, use the following event handler macro to direct events to member functions that take a wxSocketEvent (p. 1150) argument. EVT_SOCKET(id, func) See also Process a wxEVT_SOCKET event. There is data available for reading. The socket is ready to be written to. Incoming connection request (server), or successful connection establishment (client). The connection has been closed. No corresponding host. Invalid port. The socket is non-blocking and the operation would block. The timeout for this operation expired. Memory exhausted.

1132


CHAPTER 7
wxSocketEvent (p. 1150), wxSocketClient (p. 1148), wxSocketServer (p. 1152), Sockets sample (p. 1567)

Construction and destruction
wxSocketBase (p. 1134) ~wxSocketBase (p. 1134) Destroy (p. 1136)

Socket state
Functions to retrieve current state and miscellaneous info. Error (p. 1136) GetLocal (p. 1137) GetPeer (p. 1137)IsConnected (p. 1137) IsData (p. 1138) IsDisconnected (p. 1138) LastCount (p. 1138) LastError (p. 1138) Ok (p. 1138) SaveState (p. 1139) RestoreState (p. 1139)

Basic IO
Functions that perform basic IO functionality. Close (p. 1135) Discard (p. 1136) Peek (p. 1142) Read (p. 1142) ReadMsg (p. 1143) Unread (p. 1144) Write (p. 1146) WriteMsg (p. 1147) Functions that perform a timed wait on a certain IO condition. InterruptWait (p. 1137) Wait (p. 1144) WaitForLost (p. 1145) WaitForRead (p. 1145) WaitForWrite (p. 1146) and also:

1133


CHAPTER 7
wxSocketServer::WaitForAccept (p. 1154) wxSocketClient::WaitOnConnect (p. 1149) Functions that allow applications to customize socket IO as needed. GetFlags (p. 1137) SetFlags (p. 1140) SetTimeout (p. 1141)

Handling socket events
Functions that allow applications to receive socket events. Notify (p. 1138) SetNotify (p. 1141) GetClientData (p. 1136) SetClientData (p. 1139) SetEventHandler (p. 1139) Callback functions are also available, but they are provided for backwards compatibility only. Their use is strongly discouraged in favour of events, and should be considered deprecated. Callbacks may be unsupported in future releases of wxWindows. Callback (p. 1134) CallbackData (p. 1135)

wxSocketBase::wxSocketBase
wxSocketBase() Default constructor. Don't use it directly; instead, use wxSocketClient (p. 1148) to construct a socket client, or wxSocketServer (p. 1152) to construct a socket server.

wxSocketBase::~wxSocketBase
~wxSocketBase() Destructor. Do not destroy a socket using the delete operator directly; use Destroy (p. 1136) instead. Also, do not create socket objects in the stack.

wxSocketBase::Callback
wxSocketBase::wxSockCbk Callback(wxSocketBase::wxSockCbk callback) You can setup a callback function to be called when an event occurs. The function will be called only for those events for which notification has been enabled with Notify (p.

1134


CHAPTER 7
1138) and SetNotify (p. 1141). The prototype of the callback must be as follows:
void SocketCallback(wxSocketBase& sock, wxSocketNotify evt, char *cdata);

The first parameter is a reference to the socket object in which the event occurred. The second parameter tells you which event occurred. (See wxSocket events (p. 1131)). The third parameter is the user data you specified using CallbackData (p. 1135). Return value A pointer to the previous callback. Remark/Warning Note that callbacks are now deprecated and unsupported, and they remain for backwards compatibility only. Use events instead. See also wxSocketBase::CallbackData (p. 1135), wxSocketBase::SetNotify (p. 1141), wxSocketBase::Notify (p. 1138)

wxSocketBase::CallbackData
char * CallbackData(char *cdata) This function sets the the user data which will be passed to a callback function set via Callback (p. 1134). Return value A pointer to the previous user data. Remark/Warning Note that callbacks are now deprecated and unsupported, and they remain for backwards compatibility only. Use events instead. See also wxSocketBase::Callback (p. 1134), wxSocketBase::SetNotify (p. 1141), wxSocketBase::Notify (p. 1138)

wxSocketBase::Close
void Close() This function shuts down the socket, disabling further transmission and reception of data; it also disables events for the socket and frees the associated system resources. Upon socket destruction, Close is automatically called, so in most cases you won't need to do it yourself, unless you explicitly want to shut down the socket, typically to notify the peer that you are closing the connection.

1135


CHAPTER 7
Remark/Warning Although Close immediately disables events for the socket, it is possible that event messages may be waiting in the application's event queue. The application must therefore be prepared to handle socket event messages even after calling Close.

wxSocketBase::Destroy
bool Destroy() Destroys the socket safely. Use this function instead of the delete operator, since otherwise socket events could reach the application even after the socket has been destroyed. To prevent this problem, this function appends the wxSocket to a list of object to be deleted on idle time, after all events have been processed. For the same reason, you should avoid creating socket objects in the stack. Destroy calls Close (p. 1135) automatically. Return value Always true.

wxSocketBase::Discard
wxSocketBase& Discard() This function simply deletes all bytes in the incoming queue. This function always returns immediately and its operation is not affected by IO flags. Use LastCount (p. 1138) to verify the number of bytes actually discarded. If you use Error (p. 1136), it will always return false.

wxSocketBase::Error
bool Error() const Returns true if an error occurred in the last IO operation. Use this function to check for an error condition after one of the following calls: Discard, Peek, Read, ReadMsg, Unread, Write, WriteMsg.

wxSocketBase::GetClientData
void * GetClientData() const Returns a pointer of the client data for this socket, as set with SetClientData (p. 1139)

1136


CHAPTER 7 wxSocketBase::GetLocal
bool GetLocal(wxSockAddress& addr) const This function returns the local address field of the socket. The local address field contains the complete local address of the socket (local address, local port, ...). Return value true if no error happened, false otherwise.

wxSocketBase::GetFlags
wxSocketFlags GetFlags() const Returns current IO flags, as set with SetFlags (p. 1140)

wxSocketBase::GetPeer
bool GetPeer(wxSockAddress& addr) const This function returns the peer address field of the socket. The peer address field contains the complete peer host address of the socket (address, port, ...). Return value true if no error happened, false otherwise.

wxSocketBase::InterruptWait
void InterruptWait() Use this function to interrupt any wait operation currently in progress. Note that this is not intended as a regular way to interrupt a Wait call, but only as an escape mechanism for exceptional situations where it is absolutely necessary to use it, for example to abort an operation due to some exception or abnormal problem. InterruptWait is automatically called when you Close (p. 1135) a socket (and thus also upon socket destruction), so you don't need to use it in these cases. wxSocketBase::Wait (p. 1144), wxSocketServer::WaitForAccept (p. 1154), wxSocketBase::WaitForLost (p. 1145), wxSocketBase::WaitForRead (p. 1145), wxSocketBase::WaitForWrite (p. 1146), wxSocketClient::WaitOnConnect (p. 1149)

wxSocketBase::IsConnected
bool IsConnected() const Returns true if the socket is connected.

1137


CHAPTER 7 wxSocketBase::IsData
bool IsData() const This function waits until the socket is readable. This might mean that queued data is available for reading or, for streamed sockets, that the connection has been closed, so that a read operation will complete immediately without blocking (unless the wxSOCKET_WAITALL flag is set, in which case the operation might still block).

wxSocketBase::IsDisconnected
bool IsDisconnected() const Returns true if the socket is not connected.

wxSocketBase::LastCount
wxUint32 LastCount() const Returns the number of bytes read or written by the last IO call. Use this function to get the number of bytes actually transferred after using one of the following IO calls: Discard, Peek, Read, ReadMsg, Unread, Write, WriteMsg.

wxSocketBase::LastError
wxSocketError LastError() const Returns the last wxSocket error. See wxSocket errors (p. 1131). Please note that this function merely returns the last error code, but it should not be used to determine if an error has occurred (this is because successful operations do not change the LastError value). Use Error (p. 1136) first, in order to determine if the last IO call failed. If this returns true, use LastError to discover the cause of the error.

wxSocketBase::Notify
void Notify(bool notify) According to the notify value, this function enables or disables socket events. If notify is true, the events configured with SetNotify (p. 1141) will be sent to the application. If notify is false; no events will be sent.

wxSocketBase::Ok
bool Ok() const

1138


CHAPTER 7
Returns true if the socket is initialized and ready and false in other cases. Remark/Warning For wxSocketClient (p. 1148), Ok won't return true unless the client is connected to a server. For wxSocketServer (p. 1152), Ok will return true if the server could bind to the specified address and is already listening for new connections. Ok does not check for IO errors; use Error (p. 1136) instead for that purpose.

wxSocketBase::RestoreState
void RestoreState() This function restores the previous state of the socket, as saved with SaveState (p. 1139) Calls to SaveState and RestoreState can be nested. See also wxSocketBase::SaveState (p. 1139)

wxSocketBase::SaveState
void SaveState() This function saves the current state of the socket in a stack. Socket state includes flags, as set with SetFlags (p. 1140), event mask, as set with SetNotify (p. 1141) and Notify (p. 1138), user data, as set with SetClientData (p. 1139), and asynchronous callback settings, as set with Callback (p. 1134) and CallbackData (p. 1135). Calls to SaveState and RestoreState can be nested. See also wxSocketBase::RestoreState (p. 1139)

wxSocketBase::SetClientData
void SetClientData(void *data) Sets user-supplied client data for this socket. All socket events will contain a pointer to this data, which can be retrieved with the wxSocketEvent::GetClientData (p. 1151) function.

wxSocketBase::SetEventHandler

1139


CHAPTER 7
void SetEventHandler(wxEvtHandler& handler, int id = -1) Sets an event handler to be called when a socket event occurs. The handler will be called for those events for which notification is enabled with SetNotify (p. 1141) and Notify (p. 1138). Parameters handler Specifies the event handler you want to use. id The id of socket event. See also wxSocketBase::SetNotify (p. 1141), wxSocketBase::Notify (p. 1138), wxSocketEvent (p. 1150), wxEvtHandler (p. 443)

wxSocketBase::SetFlags
void SetFlags(wxSocketFlags flags) Use SetFlags to customize IO operation for this socket. The flags parameter may be a combination of flags ORed together. The following flags can be used: wxSOCKET_NONE wxSOCKET_NOWAIT wxSOCKET_WAITALL wxSOCKET_BLOCK Normal functionality. Read/write as much data as possible and return immediately. Wait for all required data to be read/written unless an error occurs. Block the GUI (do not yield) while reading/writing data.

A brief overview on how to use these flags follows. If no flag is specified (this is the same as wxSOCKET_NONE), IO calls will return after some data has been read or written, even when the transfer might not be complete. This is the same as issuing exactly one blocking low-level call to recv() or send(). Note that blocking here refers to when the function returns, not to whether the GUI blocks during this time. If wxSOCKET_NOWAIT is specified, IO calls will return immediately. Read operations will retrieve only available data. Write operations will write as much data as possible, depending on how much space is available in the output buffer. This is the same as issuing exactly one nonblocking low-level call to recv() or send(). Note that nonblocking here refers to when the function returns, not to whether the GUI blocks during this time.

1140


CHAPTER 7
If wxSOCKET_WAITALL is specified, IO calls won't return until ALL the data has been read or written (or until an error occurs), blocking if necessary, and issuing several low level calls if necessary. This is the same as having a loop which makes as many blocking low-level calls to recv() or send() as needed so as to transfer all the data. Note that blocking here refers to when the function returns, not to whether the GUI blocks during this time. The wxSOCKET_BLOCK flag controls whether the GUI blocks during IO operations. If this flag is specified, the socket will not yield during IO calls, so the GUI will remain blocked until the operation completes. If it is not used, then the application must take extra care to avoid unwanted reentrance. So: wxSOCKET_NONE will try to read at least SOME data, no matter how much. wxSOCKET_NOWAIT will always return immediately, even if it cannot read or write ANY data. wxSOCKET_WAITALL will only return when it has read or written ALL the data. wxSOCKET_BLOCK has nothing to do with the previous flags and it controls whether the GUI blocks.

wxSocketBase::SetNotify
void SetNotify(wxSocketEventFlags flags) SetNotify specifies which socket events are to be sent to the event handler. The flags parameter may be combination of flags ORed together. The following flags can be used: wxSOCKET_INPUT_FLAG wxSOCKET_OUTPUT_FLAG wxSOCKET_CONNECTION_FLAG wxSOCKET_LOST_FLAG For example:
sock.SetNotify(wxSOCKET_INPUT_FLAG | wxSOCKET_LOST_FLAG); sock.Notify(true);

to receive wxSOCKET_INPUT to receive wxSOCKET_OUTPUT to receive wxSOCKET_CONNECTION to receive wxSOCKET_LOST

In this example, the user will be notified about incoming socket data and whenever the connection is closed. For more information on socket events see wxSocket events (p. 1131).

wxSocketBase::SetTimeout
void SetTimeout(int seconds)

1141


CHAPTER 7
This function sets the default socket timeout in seconds. This timeout applies to all IO calls, and also to the Wait (p. 1144) family of functions if you don't specify a wait interval. Initially, the default timeout is 10 minutes.

wxSocketBase::Peek
wxSocketBase& Peek(void * buffer, wxUint32 nbytes) This function peeks a buffer of nbytes bytes from the socket. Peeking a buffer doesn't delete it from the socket input queue. Use LastCount (p. 1138) to verify the number of bytes actually peeked. Use Error (p. 1136) to determine if the operation succeeded. Parameters buffer Buffer where to put peeked data. nbytes Number of bytes. Return value Returns a reference to the current object. Remark/Warning The exact behaviour of wxSocketBase::Peek depends on the combination of flags being used. For a detailed explanation, see wxSocketBase::SetFlags (p. 1140) See also wxSocketBase::Error (p. 1136), wxSocketBase::LastError (p. 1138), wxSocketBase::LastCount (p. 1138), wxSocketBase::SetFlags (p. 1140)

wxSocketBase::Read
wxSocketBase& Read(void * buffer, wxUint32 nbytes) This function reads a buffer of nbytes bytes from the socket. Use LastCount (p. 1138) to verify the number of bytes actually read. Use Error (p. 1136) to determine if the operation succeeded. Parameters buffer

1142


CHAPTER 7
Buffer where to put read data. nbytes Number of bytes. Return value Returns a reference to the current object. Remark/Warning The exact behaviour of wxSocketBase::Read depends on the combination of flags being used. For a detailed explanation, see wxSocketBase::SetFlags (p. 1140). See also wxSocketBase::Error (p. 1136), wxSocketBase::LastError (p. 1138), wxSocketBase::LastCount (p. 1138), wxSocketBase::SetFlags (p. 1140)

wxSocketBase::ReadMsg
wxSocketBase& ReadMsg(void * buffer, wxUint32 nbytes) This function reads a buffer sent by WriteMsg (p. 1147) on a socket. If the buffer passed to the function isn't big enough, the remaining bytes will be discarded. This function always waits for the buffer to be entirely filled, unless an error occurs. Use LastCount (p. 1138) to verify the number of bytes actually read. Use Error (p. 1136) to determine if the operation succeeded. Parameters buffer Buffer where to put read data. nbytes Size of the buffer. Return value Returns a reference to the current object. Remark/Warning wxSocketBase::ReadMsg will behave as if the wxSOCKET_WAITALL flag was always set and it will always ignore the wxSOCKET_NOWAIT flag. The exact behaviour of ReadMsg depends on the wxSOCKET_BLOCK flag. For a detailed explanation, see wxSocketBase::SetFlags (p. 1140). See also

1143


CHAPTER 7
wxSocketBase::Error (p. 1136), wxSocketBase::LastError (p. 1138), wxSocketBase::LastCount (p. 1138), wxSocketBase::SetFlags (p. 1140), wxSocketBase::WriteMsg (p. 1147)

wxSocketBase::Unread
wxSocketBase& Unread(const void * buffer, wxUint32 nbytes) This function unreads a buffer. That is, the data in the buffer is put back in the incoming queue. This function is not affected by wxSocket flags. If you use LastCount (p. 1138), it will always return nbytes. If you use Error (p. 1136), it will always return false. Parameters buffer Buffer to be unread. nbytes Number of bytes. Return value Returns a reference to the current object. See also wxSocketBase::Error (p. 1136), wxSocketBase::LastCount (p. 1138), wxSocketBase::LastError (p. 1138)

wxSocketBase::Wait
bool Wait(long seconds = -1, long millisecond = 0) This function waits until any of the following conditions is true:      The socket becomes readable. The socket becomes writable. An ongoing connection request has completed (wxSocketClient (p. 1148) only) An incoming connection request has arrived (wxSocketServer (p. 1152) only) The connection has been closed.

Note that it is recommended to use the individual Wait functions to wait for the required condition, instead of this one.

1144


CHAPTER 7
Parameters seconds Number of seconds to wait. If -1, it will wait for the default timeout, as set with SetTimeout (p. 1141). millisecond Number of milliseconds to wait. Return value Returns true when any of the above conditions is satisfied, false if the timeout was reached. See also wxSocketBase::InterruptWait (p. 1137), wxSocketServer::WaitForAccept (p. 1154), wxSocketBase::WaitForLost (p. 1145), wxSocketBase::WaitForRead (p. 1145), wxSocketBase::WaitForWrite (p. 1146), wxSocketClient::WaitOnConnect (p. 1149)

wxSocketBase::WaitForLost
bool Wait(long seconds = -1, long millisecond = 0) This function waits until the connection is lost. This may happen if the peer gracefully closes the connection or if the connection breaks. Parameters seconds Number of seconds to wait. If -1, it will wait for the default timeout, as set with SetTimeout (p. 1141). millisecond Number of milliseconds to wait. Return value Returns true if the connection was lost, false if the timeout was reached. See also wxSocketBase::InterruptWait (p. 1137),wxSocketBase::Wait (p. 1144)

wxSocketBase::WaitForRead
bool WaitForRead(long seconds = -1, long millisecond = 0) This function waits until the socket is readable. This might mean that queued data is

1145


CHAPTER 7
available for reading or, for streamed sockets, that the connection has been closed, so that a read operation will complete immediately without blocking (unless the wxSOCKET_WAITALL flag is set, in which case the operation might still block). Parameters seconds Number of seconds to wait. If -1, it will wait for the default timeout, as set with SetTimeout (p. 1141). millisecond Number of milliseconds to wait. Return value Returns true if the socket becomes readable, false on timeout. See also wxSocketBase::InterruptWait (p. 1137), wxSocketBase::Wait (p. 1144)

wxSocketBase::WaitForWrite
bool WaitForWrite(long seconds = -1, long millisecond = 0) This function waits until the socket becomes writable. This might mean that the socket is ready to send new data, or for streamed sockets, that the connection has been closed, so that a write operation is guaranteed to complete immediately (unless the wxSOCKET_WAITALL flag is set, in which case the operation might still block). Parameters seconds Number of seconds to wait. If -1, it will wait for the default timeout, as set with SetTimeout (p. 1141). millisecond Number of milliseconds to wait. Return value Returns true if the socket becomes writable, false on timeout. See also wxSocketBase::InterruptWait (p. 1137), wxSocketBase::Wait (p. 1144)

wxSocketBase::Write

1146


CHAPTER 7
wxSocketBase& Write(const void * buffer, wxUint32 nbytes) This function writes a buffer of nbytes bytes to the socket. Use LastCount (p. 1138) to verify the number of bytes actually written. Use Error (p. 1136) to determine if the operation succeeded. Parameters buffer Buffer with the data to be sent. nbytes Number of bytes. Return value Returns a reference to the current object. Remark/Warning The exact behaviour of wxSocketBase::Write depends on the combination of flags being used. For a detailed explanation, see wxSocketBase::SetFlags (p. 1140). See also wxSocketBase::Error (p. 1136), wxSocketBase::LastError (p. 1138), wxSocketBase::LastCount (p. 1138), wxSocketBase::SetFlags (p. 1140)

wxSocketBase::WriteMsg
wxSocketBase& WriteMsg(const void * buffer, wxUint32 nbytes) This function writes a buffer of nbytes bytes from the socket, but it writes a short header before so that ReadMsg (p. 1143) knows how much data should it actually read. So, a buffer sent with WriteMsg must be read with ReadMsg. This function always waits for the entire buffer to be sent, unless an error occurs. Use LastCount (p. 1138) to verify the number of bytes actually written. Use Error (p. 1136) to determine if the operation succeeded. Parameters buffer Buffer with the data to be sent. nbytes Number of bytes to send.

1147


CHAPTER 7
Return value Returns a reference to the current object. Remark/Warning wxSocketBase::WriteMsg will behave as if the wxSOCKET_WAITALL flag was always set and it will always ignore the wxSOCKET_NOWAIT flag. The exact behaviour of WriteMsg depends on the wxSOCKET_BLOCK flag. For a detailed explanation, see wxSocketBase::SetFlags (p. 1140). See also wxSocketBase::Error (p. 1136), wxSocketBase::LastError (p. 1138), wxSocketBase::LastCount (p. 1138), wxSocketBase::SetFlags (p. 1140), wxSocketBase::ReadMsg (p. 1143)

wxSocketClient
Derived from wxSocketBase (p. 1131) Include files <wx/socket.h>

wxSocketClient::wxSocketClient
wxSocketClient(wxSocketFlags flags = wxSOCKET_NONE) Constructor. Parameters flags Socket flags (See wxSocketBase::SetFlags (p. 1140))

wxSocketClient::~wxSocketClient
~wxSocketClient() Destructor. Please see wxSocketBase::Destroy (p. 1136).

wxSocketClient::Connect

1148


CHAPTER 7
bool Connect(wxSockAddress& address, bool wait = true) Connects to a server using the specified address. If wait is true, Connect will wait until the connection completes. Warning: This will block the GUI. If wait is false, Connect will try to establish the connection and return immediately, without blocking the GUI. When used this way, even if Connect returns false, the connection request can be completed later. To detect this, use WaitOnConnect (p. 1149), or catch wxSOCKET_CONNECTION events (for successful establishment) and wxSOCKET_LOST events (for connection failure). Parameters address Address of the server. wait If true, waits for the connection to complete. Return value Returns true if the connection is established and no error occurs. If wait was true, and Connect returns false, an error occurred and the connection failed. If wait was false, and Connect returns false, you should still be prepared to handle the completion of this connection request, either with WaitOnConnect (p. 1149) or by watching wxSOCKET_CONNECTION and wxSOCKET_LOST events. See also wxSocketClient::WaitOnConnect (p. 1149), wxSocketBase::SetNotify (p. 1141), wxSocketBase::Notify (p. 1138)

wxSocketClient::WaitOnConnect
bool WaitOnConnect(long seconds = -1, long milliseconds = 0) Wait until a connection request completes, or until the specified timeout elapses. Use this function after issuing a call to Connect (p. 1148) with wait set to false. Parameters seconds Number of seconds to wait. If -1, it will wait for the default timeout, as set with SetTimeout (p. 1141). millisecond

1149


CHAPTER 7
Number of milliseconds to wait. Return value WaitOnConnect returns true if the connection request completes. This does not necessarily mean that the connection was successfully established; it might also happen that the connection was refused by the peer. Use IsConnected (p. 1137) to distinguish between these two situations. If the timeout elapses, WaitOnConnect returns false. These semantics allow code like this:
// Issue the connection request client->Connect(addr, false); // Wait until the request completes or until we decide to give up bool waitmore = true; while ( !client >WaitOnConnect(seconds, millis) && waitmore ) { // possibly give some feedback to the user, // and update waitmore as needed. } bool success = client->IsConnected();

See also wxSocketClient::Connect (p. 1148), wxSocketBase::InterruptWait (p. 1137), wxSocketBase::IsConnected (p. 1137)

wxSocketEvent
This event class contains information about socket events. Derived from wxEvent (p. 439) Include files <wx/socket.h> Event table macros To process a socket event, use these event handler macros to direct input to member functions that take a wxSocketEvent argument. EVT_SOCKET(id, func) See also wxSocketBase (p. 1131), wxSocketClient (p. 1148), wxSocketServer (p. 1152) Process a socket event, supplying the member function.

1150


CHAPTER 7 wxSocketEvent::wxSocketEvent
wxSocketEvent(int id = 0) Constructor.

wxSocketEvent::GetClientData
void * GetClientData() Gets the client data of the socket which generated this event, as set with wxSocketBase::SetClientData (p. 1139).

wxSocketEvent::GetSocket
wxSocketBase * GetSocket() const Returns the socket object to which this event refers to. This makes it possible to use the same event handler for different sockets.

wxSocketEvent::GetSocketEvent
wxSocketNotify GetSocketEvent() const Returns the socket event type.

wxSocketInputStream
This class implements an input stream which reads data from a connected socket. Note that this stream is purely sequential and it does not support seeking. Derived from wxInputStream (p. 762) Include files <wx/sckstrm.h> See also wxSocketBase (p. 1131)

wxSocketInputStream::wxSocketInputStream

1151


CHAPTER 7
wxSocketInputStream(wxSocketBase& s) Creates a new read-only socket stream using the specified initialized socket connection.

wxSocketOutputStream
This class implements an output stream which writes data from a connected socket. Note that this stream is purely sequential and it does not support seeking. Derived from wxOutputStream (p. 958) Include files <wx/sckstrm.h> See also wxSocketBase (p. 1131)

wxSocketOutputStream::wxSocketOutputStream
wxSocketInputStream(wxSocketBase& s) Creates a new write-only socket stream using the specified initialized socket connection.

wxSocketServer
Derived from wxSocketBase (p. 1131) Include files <wx/socket.h>

wxSocketServer::wxSocketServer
wxSocketServer(wxSockAddress& address, wxSocketFlags flags = wxSOCKET_NONE) Constructs a new server and tries to bind to the specified address. Before trying to accept new connections, test whether it succeeded with wxSocketBase::Ok (p. 1138).

1152


CHAPTER 7
Parameters address Specifies the local address for the server (e.g. port number). flags Socket flags (See wxSocketBase::SetFlags (p. 1140))

wxSocketServer::~wxSocketServer
~wxSocketServer() Destructor (it doesn't close the accepted connections).

wxSocketServer::Accept
wxSocketBase * Accept(bool wait = true) Accepts an incoming connection request, and creates a new wxSocketBase (p. 1131) object which represents the server-side of the connection. If wait is true and there are no pending connections to be accepted, it will wait for the next incoming connection to arrive. Warning: This will block the GUI. If wait is false, it will try to accept a pending connection if there is one, but it will always return immediately without blocking the GUI. If you want to use Accept in this way, you can either check for incoming connections with WaitForAccept (p. 1154) or catch wxSOCKET_CONNECTION events, then call Accept once you know that there is an incoming connection waiting to be accepted. Return value Returns an opened socket connection, or NULL if an error occurred or if the wait parameter was false and there were no pending connections. See also wxSocketServer::WaitForAccept (p. 1154), wxSocketBase::SetNotify (p. 1141), wxSocketBase::Notify (p. 1138), wxSocketServer::AcceptWith (p. 1153)

wxSocketServer::AcceptWith
bool AcceptWith(wxSocketBase& socket, bool wait = true) Accept an incoming connection using the specified socket object. Parameters socket

1153


CHAPTER 7
Socket to be initialized Return value Returns true on success, or false if an error occurred or if thewait parameter was false and there were no pending connections. wxSocketServer::WaitForAccept (p. 1154), wxSocketBase::SetNotify (p. 1141), wxSocketBase::Notify (p. 1138), wxSocketServer::Accept (p. 1153)

wxSocketServer::WaitForAccept
bool WaitForAccept(long seconds = -1, long millisecond = 0) This function waits for an incoming connection. Use it if you want to call Accept (p. 1153) or AcceptWith (p. 1153) with wait set to false, to detect when an incoming connection is waiting to be accepted. Parameters seconds Number of seconds to wait. If -1, it will wait for the default timeout, as set with SetTimeout (p. 1141). millisecond Number of milliseconds to wait. Return value Returns true if an incoming connection arrived, false if the timeout elapsed. See also wxSocketServer::Accept (p. 1153), wxSocketServer::AcceptWith (p. 1153),wxSocketBase::InterruptWait (p. 1137)

wxSpinButton
A wxSpinButton has two small up and down (or left and right) arrow buttons. It is often used next to a text control for increment and decrementing a value. Portable programs should try to use wxSpinCtrl (p. 1158) instead as wxSpinButton is not implemented for all platforms (Win32 and GTK only currently). NB: the range supported by this control (and wxSpinCtrl) depends on the platform but is at least -0x8000 to 0x7fff. Under GTK and Win32 with sufficiently new version of comctrl32.dll (at least 4.71 is required, 5.80 is recommended) the full 32 bit range is supported. Derived from

1154


CHAPTER 7
wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) See also wxSpinCtrl (p. 1158) Include files <wx/spinbutt.h> Window styles wxSP_HORIZONTAL wxSP_VERTICAL wxSP_ARROW_KEYS wxSP_WRAP Specifies a horizontal spin button (note that this style is not supported in wxGTK). Specifies a vertical spin button. The user can use arrow keys. The value wraps at the minimum and maximum.

See also window styles overview (p. 1611). Event handling To process input from a spin button, use one of these event handler macros to direct input to member functions that take a wxSpinEvent (p. 1161) argument: EVT_SPIN(id, func) EVT_SPIN_UP(id, func) EVT_SPIN_DOWN(id, func) Generated whenever an arrow is pressed. Generated when left/up arrow is pressed. Generated when right/down arrow is pressed.

Note that if you handle both SPIN and UP or DOWN events, you will be notified about each of them twice: first the UP/DOWN event will be receieved and then, if it wasn't vetoed, the SPIN event will be sent.See also Event handling overview (p. 1602)

wxSpinButton::wxSpinButton
wxSpinButton() Default constructor. wxSpinButton(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSP_HORIZONTAL, const wxString& name = "spinButton")

1155


CHAPTER 7
Constructor, creating and showing a spin button. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. pos Window position. If the position (-1, -1) is specified then a default position is chosen. size Window size. If the default size (-1, -1) is specified then a default size is chosen. style Window style. See wxSpinButton (p. 1154). validator Window validator. name Window name. See also wxSpinButton::Create (p. 1156), wxValidator (p. 1358)

wxSpinButton::~wxSpinButton
void ~wxSpinButton() Destructor, destroys the spin button control.

wxSpinButton::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSP_HORIZONTAL, const wxString& name = "spinButton") Scrollbar creation function called by the spin button constructor. See wxSpinButton::wxSpinButton (p. 1155) for details.

1156


CHAPTER 7 wxSpinButton::GetMax
int GetMax() const Returns the maximum permissible value. See also wxSpinButton::SetRange (p. 1157)

wxSpinButton::GetMin
int GetMin() const Returns the minimum permissible value. See also wxSpinButton::SetRange (p. 1157)

wxSpinButton::GetValue
int GetValue() const Returns the current spin button value. See also wxSpinButton::SetValue (p. 1158)

wxSpinButton::SetRange
void SetRange(int min, int max) Sets the range of the spin button. Parameters min The minimum value for the spin button. max The maximum value for the spin button. See also wxSpinButton::GetMin (p. 1157), wxSpinButton::GetMax (p. 1157)

1157


CHAPTER 7 wxSpinButton::SetValue
void SetValue(int value) Sets the value of the spin button. Parameters value The value for the spin button. See also wxSpinButton::GetValue (p. 1157)

wxSpinCtrl
wxSpinCtrl combines wxTextCtrl (p. 1248) and wxSpinButton (p. 1154) in one control. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/spinctrl.h> Window styles wxSP_ARROW_KEYS wxSP_WRAP Event handling To process input from a spin button, use one of these event handler macros to direct input to member functions that take a wxSpinEvent (p. 1161) argument: EVT_SPINCTRL(id, func) Generated whenever the numeric value of the spinctrl is updated The user can use arrow keys. The value wraps at the minimum and maximum.

You may also use the wxSpinButton (p. 1154) event macros, however the corresponding events will not be generated under all platforms. Finally, if the user modifies the text in the edit part of the spin control directly, theEVT_TEXT is generated, like for the wxTextCtrl (p. 1248). See also Event handling overview (p. 1602),wxSpinButton (p. 1154),wxControl (p. 198)

1158


CHAPTER 7

wxSpinCtrl::wxSpinCtrl
wxSpinCtrl() Default constructor. wxSpinCtrl(wxWindow* parent, wxWindowID id = -1, const wxString& value = wxEmptyString, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSP_ARROW_KEYS, int min = 0, int max = 100, int initial = 0, const wxString& name = _T("wxSpinCtrl")) Constructor, creating and showing a spin control. Parameters parent Parent window. Must not be NULL. value Default value. id Window identifier. A value of -1 indicates a default value. pos Window position. If the position (-1, -1) is specified then a default position is chosen. size Window size. If the default size (-1, -1) is specified then a default size is chosen. style Window style. See wxSpinButton (p. 1154). min Minimal value. max Maximal value. initial Initial value.

1159


CHAPTER 7
name Window name. See also wxSpinCtrl::Create (p. 1160)

wxSpinCtrl::Create
bool Create(wxWindow* parent, wxWindowID id = -1, const wxString& value = wxEmptyString, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxSP_ARROW_KEYS, int min = 0, int max = 100, int initial = 0, const wxString& name = _T("wxSpinCtrl")) Creation function called by the spin control constructor. See wxSpinCtrl::wxSpinCtrl (p. 1159) for details.

wxSpinCtrl::SetValue
void SetValue(const wxString& text) void SetValue(int value) Sets the value of the spin control.

wxSpinCtrl::GetValue
int GetValue() const Gets the value of the spin control.

wxSpinCtrl::SetRange
void SetRange(int minVal, int maxVal) Sets range of allowable values.

wxSpinCtrl::SetSelection
void SetSelection(long from, long to) Select the text in the text part of the control between positions from (inclusive) and to (exclusive). This is similar to wxTextCtrl::SetSelection (p. 1264). NB: this is currently only implemented for Windows and generic versions of the control.

1160


CHAPTER 7 wxSpinCtrl::GetMin
int GetMin() const Gets minimal allowable value.

wxSpinCtrl::GetMax
int GetMax() const Gets maximal allowable value.

wxSpinEvent
This event class is used for the events generated by wxSpinButton (p. 1154) and wxSpinCtrl (p. 1158). Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/spinbutt.h> or <wx/spinctrl.h> Event handling To process input from a spin button, use one of these event handler macros to direct input to member functions that take a wxSpinEvent (p. 1161) argument: EVT_SPIN(id, func) EVT_SPIN_UP(id, func) EVT_SPIN_DOWN(id, func) Generated whenever an arrow is pressed. Generated when left/up arrow is pressed. Generated when right/down arrow is pressed.

Note that if you handle both SPIN and UP or DOWN events, you will be notified about each of them twice: first the UP/DOWN event will be receieved and then, if it wasn't vetoed, the SPIN event will be sent.See also wxSpinButton (p. 1154) and wxSpinCtrl (p. 1158)

wxSpinEvent::wxSpinEvent
wxSpinEvent(wxEventType commandType = wxEVT_NULL, int id = 0)

1161


CHAPTER 7
The constructor is not normally used by the user code.

wxSpinEvent::GetPosition
int GetPosition() const Retrieve the current spin button or control value.

wxSpinEvent::SetPosition
void SetPosition(int pos) Set the value associated with the event.

wxSplashScreen
wxSplashScreen shows a window with a thin border, displaying a bitmap describing your application. Show it in application initialisation, and then either explicitly destroy it or let it time-out. Example usage:
wxBitmap bitmap; if (bitmap.LoadFile("splash16.png", wxBITMAP_TYPE_PNG)) { wxSplashScreen* splash = new wxSplashScreen(bitmap, wxSPLASH_CENTRE_ON_SCREEN|wxSPLASH_TIMEOUT, 6000, NULL, -1, wxDefaultPosition, wxDefaultSize, wxSIMPLE_BORDER|wxSTAY_ON_TOP); } wxYield();

Derived from wxFrame (p. 530) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/splash.h>

wxSplashScreen::wxSplashScreen
wxSplashScreen(const wxBitmap& bitmap, long splashStyle, int milliseconds, wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style =

1162


CHAPTER 7
wxSIMPLE_BORDER|wxFRAME_NO_TASKBAR|wxSTAY_ON_TOP) Construct the splash screen passing a bitmap, a style, a timeout, a window id, optional position and size, and a window style. splashStyle is a bitlist of some of the following:      wxSPLASH_CENTRE_ON_PARENT wxSPLASH_CENTRE_ON_SCREEN wxSPLASH_NO_CENTRE wxSPLASH_TIMEOUT wxSPLASH_NO_TIMEOUT

milliseconds is the timeout in milliseconds.

wxSplashScreen::~wxSplashScreen
~wxSplashScreen() Destroys the splash screen.

wxSplashScreen::OnCloseWindow
void OnCloseWindow(wxCloseEvent& event) Reimplement this event handler if you want to set an application variable on window destruction, for example.

wxSplashScreen::GetSplashStyle
long GetSplashStyle() const Returns the splash style (see wxSplashScreen::wxSplashScreen (p. 1162) for details).

wxSplashScreen::GetSplashWindow
wxSplashScreenWindow* GetSplashWindow() const Returns the window used to display the bitmap.

wxSplashScreen::GetTimeout
int GetTimeout() const

1163


CHAPTER 7
Returns the timeout in milliseconds.

wxSplitterEvent
This class represents the events generated by a splitter control. Also there is only one event class, the data associated to the different events is not the same and so not all accessor functions may be called for each event. The documentation mentions the kind of event(s) for which the given accessor function makes sense: calling it for other types of events will result in assert failure (in debug mode) and will return meaningless results. Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/splitter.h> Event table macros To process a splitter event, use these event handler macros to direct input to member functions that take a wxSplitterEvent argument. EVT_SPLITTER_SASH_POS_CHANGING(id, func) The sash position is in the process of being changed. You may prevent this change from happening by calling Veto (p. 954) or you may also modify the position of the tracking bar to properly reflect the position that would be set if the drag were to be completed at this point. Processes a wxEVT_COMMAND_SPLITT ER_SASH_POS_CHANGIN G event. The sash position was changed. May be used to modify the sash position before it is set, or to prevent the change from taking place. Processes a wxEVT_COMMAND_SPLITT ER_SASH_POS_CHANGED event.

EVT_SPLITTER_SASH_POS_CHANGED(id, func)

1164


CHAPTER 7
EVT_SPLITTER_UNSPLIT(id, func) The splitter has been just unsplit. Processes a wxEVT_COMMAND_SPLITT ER_UNSPLIT event. This event can't be vetoed. The sash was double clicked. The default behaviour is to unsplit the window when this happens (unless the minimum pane size has been set to a value greater than zero). This won't happen if you veto this event. Processes a wxEVT_COMMAND_SPLITT ER_DOUBLECLICKED event.

EVT_SPLITTER_DCLICK(id, func)

See also wxSplitterWindow (p. 1166), Event handling overview (p. 1602)

wxSplitterEvent::wxSplitterEvent
wxSplitterEvent(wxEventType eventType = wxEVT_NULL, wxSplitterWindow * splitter = NULL) Constructor. Used internally by wxWindows only.

wxSplitterEvent::GetSashPosition
int GetSashPosition() const Returns the new sash position. May only be called while processing wxEVT_COMMAND_SPLITTER_SASH_POS_CHANGING and wxEVT_COMMAND_SPLITTER_SASH_POS_CHANGED events.

wxSplitterEvent::GetX
int GetX() const Returns the x coordinate of the double-click point. May only be called while processing wxEVT_COMMAND_SPLITTER_DOUBLECLICKED events.

1165


CHAPTER 7 wxSplitterEvent::GetY
int GetY() const Returns the y coordinate of the double-click point. May only be called while processing wxEVT_COMMAND_SPLITTER_DOUBLECLICKED events.

wxSplitterEvent::GetWindowBeingRemoved
wxWindow* GetWindowBeingRemoved() const Returns a pointer to the window being removed when a splitter window is unsplit. May only be called while processing wxEVT_COMMAND_SPLITTER_UNSPLIT events.

wxSplitterEvent::SetSashPosition
void SetSashPosition(int pos) In the case of wxEVT_COMMAND_SPLITTER_SASH_POS_CHANGED events, sets the the new sash position. In the case of wxEVT_COMMAND_SPLITTER_SASH_POS_CHANGING events, sets the new tracking bar position so visual feedback during dragging will represent that change that will actually take place. Set to -1 from the event handler code to prevent repositioning. May only be called while processing wxEVT_COMMAND_SPLITTER_SASH_POS_CHANGING and wxEVT_COMMAND_SPLITTER_SASH_POS_CHANGED events. Parameters pos New sash position.

wxSplitterWindow
wxSplitterWindow overview (p. 1644) This class manages up to two subwindows. The current view can be split into two programmatically (perhaps from a menu command), and unsplit either programmatically or via the wxSplitterWindow user interface. Appropriate 3D shading for the Windows 95 user interface is an option - this is also recommended for GTK. Optionally, the sash can be made to look more like the native control under MacOS X. Window styles

1166


CHAPTER 7
wxSP_3D wxSP_3DSASH wxSP_3DBORDER wxSP_BORDER wxSP_NOBORDER wxSP_PERMIT_UNSPLIT Draws a 3D effect border and sash. Draws a 3D effect sash. Synonym for wxSP_BORDER. Draws a standard border. No border (default). Always allow to unsplit, even with the minimum pane size other than zero. Don't draw XOR line but resize the child windows immediately.

wxSP_LIVE_UPDATE

See also window styles overview (p. 1611). Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/splitter.h> Event handling To process input from a splitter control, use the following event handler macros to direct input to member functions that take a wxSplitterEvent (p. 1164) argument. EVT_SPLITTER_SASH_POS_CHANGING(id, func) The sash position is in the process of being changed. May be used to modify the position of the tracking bar to properly reflect the position that would be set if the drag were to be completed at this point. Processes a wxEVT_COMMAND_SPLITT ER_SASH_POS_CHANGIN G event. The sash position was changed. May be used to modify the sash position before it is set, or to prevent the change from taking place.

EVT_SPLITTER_SASH_POS_CHANGED(id, func)

1167


CHAPTER 7
Processes a wxEVT_COMMAND_SPLITT ER_SASH_POS_CHANGED event. EVT_SPLITTER_UNSPLIT(id, func) The splitter has been just unsplit. Processes a wxEVT_COMMAND_SPLITT ER_UNSPLIT event. The sash was double clicked. The default behaviour is to unsplit the window when this happens (unless the minimum pane size has been set to a value greater than zero). Processes a wxEVT_COMMAND_SPLITT ER_DOUBLECLICKED event.

EVT_SPLITTER_DCLICK(id, func)

See also wxSplitterEvent (p. 1164)

wxSplitterWindow::wxSplitterWindow
wxSplitterWindow() Default constructor. wxSplitterWindow(wxWindow* parent, wxWindowID id, const wxPoint& point = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style=wxSP_3D, const wxString& name = "splitterWindow") Constructor for creating the window. Parameters parent The parent of the splitter window. id The window identifier. pos The window position. size

1168


CHAPTER 7
The window size. style The window style. See wxSplitterWindow (p. 1166). name The window name. Remarks After using this constructor, you must create either one or two subwindows with the splitter window as parent, and then call one of wxSplitterWindow::Initialize (p. 1170), wxSplitterWindow::SplitVertically (p. 1174) and wxSplitterWindow::SplitHorizontally (p. 1174) in order to set the pane(s). You can create two windows, with one hidden when not being shown; or you can create and delete the second pane on demand. See also wxSplitterWindow::Initialize (p. 1170), wxSplitterWindow::SplitVertically (p. 1174), wxSplitterWindow::SplitHorizontally (p. 1174), wxSplitterWindow::Create (p. 1169)

wxSplitterWindow::~wxSplitterWindow
~wxSplitterWindow() Destroys the wxSplitterWindow and its children.

wxSplitterWindow::Create
bool Create(wxWindow* parent, wxWindowID id, int x, const wxPoint& point = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style=wxSP_3D, const wxString& name = "splitterWindow") Creation function, for two-step construction. See wxSplitterWindow::wxSplitterWindow (p. 1168) for details.

wxSplitterWindow::GetMinimumPaneSize
int GetMinimumPaneSize() const Returns the current minimum pane size (defaults to zero). See also wxSplitterWindow::SetMinimumPaneSize (p. 1173)

1169


CHAPTER 7 wxSplitterWindow::GetSashPosition
int GetSashPosition() Returns the current sash position. See also wxSplitterWindow::SetSashPosition (p. 1172)

wxSplitterWindow::GetSplitMode
int GetSplitMode() const Gets the split mode. See also wxSplitterWindow::SetSplitMode (p. 1173), wxSplitterWindow::SplitVertically (p. 1174), wxSplitterWindow::SplitHorizontally (p. 1174).

wxSplitterWindow::GetWindow1
wxWindow* GetWindow1() const Returns the left/top or only pane.

wxSplitterWindow::GetWindow2
wxWindow* GetWindow2() const Returns the right/bottom pane.

wxSplitterWindow::Initialize
void Initialize(wxWindow* window) Initializes the splitter window to have one pane. Parameters window The pane for the unsplit window. Remarks This should be called if you wish to initially view only a single pane in the splitter window. See also

1170


CHAPTER 7
wxSplitterWindow::SplitVertically (p. 1174), wxSplitterWindow::SplitHorizontally (p. 1174)

wxSplitterWindow::IsSplit
bool IsSplit() const Returns true if the window is split, false otherwise.

wxSplitterWindow::OnDoubleClickSash
virtual void OnDoubleClickSash(int x, int y) Application-overridable function called when the sash is double-clicked with the left mouse button. Parameters x The x position of the mouse cursor. y The y position of the mouse cursor. Remarks The default implementation of this function calls Unsplit (p. 1175) if the minimum pane size is zero. See also wxSplitterWindow::Unsplit (p. 1175)

wxSplitterWindow::OnUnsplit
virtual void OnUnsplit(wxWindow* removed) Application-overridable function called when the window is unsplit, either programmatically or using the wxSplitterWindow user interface. Parameters removed The window being removed. Remarks The default implementation of this function simply hides removed. You may wish to delete the window.

1171


CHAPTER 7 wxSplitterWindow::OnSashPositionChange
virtual bool OnSashPositionChange(int newSashPosition) Application-overridable function called when the sash position is changed by user. It may return false to prevent the change or true to allow it. Parameters newSashPosition The new sash position (always positive or zero) Remarks The default implementation of this function verifies that the sizes of both panes of the splitter are greater than minimum pane size.

wxSplitterWindow::ReplaceWindow
bool ReplaceWindow(wxWindow * winOld, wxWindow * winNew) This function replaces one of the windows managed by the wxSplitterWindow with another one. It is in general better to use it instead of calling Unsplit() and then resplitting the window back because it will provoke much less flicker (if any). It is valid to call this function whether the splitter has two windows or only one. Both parameters should be non-NULL and winOld must specify one of the windows managed by the splitter. If the parameters are incorrect or the window couldn't be replaced, false is returned. Otherwise the function will return true, but please notice that it will not delete the replaced window and you may wish to do it yourself. See also wxSplitterWindow::GetMinimumPaneSize (p. 1169) See also wxSplitterWindow::Unsplit (p. 1175) wxSplitterWindow::SplitVertically (p. 1174) wxSplitterWindow::SplitHorizontally (p. 1174)

wxSplitterWindow::SetSashPosition
void SetSashPosition(int position, const bool redraw = true) Sets the sash position. Parameters position

1172


CHAPTER 7
The sash position in pixels. redraw If true, resizes the panes and redraws the sash and border. Remarks Does not currently check for an out-of-range value. See also wxSplitterWindow::GetSashPosition (p. 1170)

wxSplitterWindow::SetMinimumPaneSize
void SetMinimumPaneSize(int paneSize) Sets the minimum pane size. Parameters paneSize Minimum pane size in pixels. Remarks The default minimum pane size is zero, which means that either pane can be reduced to zero by dragging the sash, thus removing one of the panes. To prevent this behaviour (and veto out-of-range sash dragging), set a minimum size, for example 20 pixels. If the wxSP_PERMIT_UNSPLIT style is used when a splitter window is created, the window may be unsplit even if minimum size is non-zero. See also wxSplitterWindow::GetMinimumPaneSize (p. 1169)

wxSplitterWindow::SetSplitMode
void SetSplitMode(int mode) Sets the split mode. Parameters mode Can be wxSPLIT_VERTICAL or wxSPLIT_HORIZONTAL. Remarks Only sets the internal variable; does not update the display.

1173


CHAPTER 7
See also wxSplitterWindow::GetSplitMode (p. 1170), wxSplitterWindow::SplitVertically (p. 1174), wxSplitterWindow::SplitHorizontally (p. 1174).

wxSplitterWindow::SplitHorizontally
bool SplitHorizontally(wxWindow* window1, wxWindow* window2, int sashPosition = 0) Initializes the top and bottom panes of the splitter window. Parameters window1 The top pane. window2 The bottom pane. sashPosition The initial position of the sash. If this value is positive, it specifies the size of the upper pane. If it is negative, it is absolute value gives the size of the lower pane. Finally, specify 0 (default) to choose the default position (half of the total window height). Return value true if successful, false otherwise (the window was already split). Remarks This should be called if you wish to initially view two panes. It can also be called at any subsequent time, but the application should check that the window is not currently split using IsSplit (p. 1171). See also wxSplitterWindow::SplitVertically (p. 1174), wxSplitterWindow::IsSplit (p. 1171), wxSplitterWindow::Unsplit (p. 1175)

wxSplitterWindow::SplitVertically
bool SplitVertically(wxWindow* window1, wxWindow* window2, int sashPosition = 0) Initializes the left and right panes of the splitter window. Parameters

1174


CHAPTER 7
window1 The left pane. window2 The right pane. sashPosition The initial position of the sash. If this value is positive, it specifies the size of the left pane. If it is negative, it is absolute value gives the size of the right pane. Finally, specify 0 (default) to choose the default position (half of the total window width). Return value true if successful, false otherwise (the window was already split). Remarks This should be called if you wish to initially view two panes. It can also be called at any subsequent time, but the application should check that the window is not currently split using IsSplit (p. 1171). See also wxSplitterWindow::SplitHorizontally (p. 1174), wxSplitterWindow::IsSplit (p. 1171), wxSplitterWindow::Unsplit (p. 1175).

wxSplitterWindow::Unsplit
bool Unsplit(wxWindow* toRemove = NULL) Unsplits the window. Parameters toRemove The pane to remove, or NULL to remove the right or bottom pane. Return value true if successful, false otherwise (the window was not split). Remarks This call will not actually delete the pane being removed; it calls OnUnsplit (p. 1171) which can be overridden for the desired behaviour. By default, the pane being removed is hidden. See also

1175


CHAPTER 7
wxSplitterWindow::SplitHorizontally (p. 1174), wxSplitterWindow::SplitVertically (p. 1174), wxSplitterWindow::IsSplit (p. 1171), wxSplitterWindow::OnUnsplit (p. 1171)

wxSplitterRenderParams
This is just a simple struct used as a return value of wxRendererNative::GetSplitterParams (p. 1062). It doesn't have any methods and all of its fields are constant and so can be only examined but not modified. Include files <wx/renderer.h>

wxEvent::widthSash
const wxCoord widthSash The width of the splitter sash.

wxSplitterRenderParams::border
const wxCoord border The width of the border drawn by the splitter inside it, may be 0.

wxSplitterRenderParams::isHotSensitive
const bool isHotSensitive true if the sash changes appearance when the mouse passes over it, falseotherwise.

wxStaticBitmap
A static bitmap control displays a bitmap. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files

1176


CHAPTER 7
<wx/statbmp.h> Window styles There are no special styles for this control. See also window styles overview (p. 1611). See also wxStaticBitmap (p. 1176), wxStaticBox (p. 1178) Remarks The bitmap to be displayed should have a small number of colours, such as 16, to avoid palette problems.

wxStaticBitmap::wxStaticBitmap
wxStaticBitmap() Default constructor. wxStaticBitmap(wxWindow* parent, wxWindowID id, const wxBitmap& label, const wxPoint& pos, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "staticBitmap") Constructor, creating and showing a text control. Parameters parent Parent window. Should not be NULL. id Control identifier. A value of -1 denotes a default value. label Bitmap label. pos Window position. size Window size. style

1177


CHAPTER 7
Window style. See wxStaticBitmap (p. 1176). name Window name. See also wxStaticBitmap::Create (p. 1178)

wxStaticBitmap::Create
bool Create(wxWindow* parent, wxWindowID id, const wxBitmap& label, const wxPoint& pos, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "staticBitmap") Creation function, for two-step construction. For details see wxStaticBitmap::wxStaticBitmap (p. 1177).

wxStaticBitmap::GetBitmap
wxBitmap& GetBitmap() const Returns a reference to the label bitmap. See also wxStaticBitmap::SetBitmap (p. 1178)

wxStaticBitmap::SetBitmap
virtual void SetBitmap(const wxBitmap& label) Sets the bitmap label. Parameters label The new bitmap. See also wxStaticBitmap::GetBitmap (p. 1178)

wxStaticBox
A static box is a rectangle drawn around other panel items to denote a logical grouping of items.

1178


CHAPTER 7
Please note that a static box should not be used as the parent for the controls it contains, instead they should be siblings of each other. Although using a static box as a parent might work in some versions of wxWindows, it results in a crash under, for example, wxGTK. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/statbox.h> Window styles There are no special styles for this control. See also window styles overview (p. 1611). See also wxStaticText (p. 1183)

wxStaticBox::wxStaticBox
wxStaticBox() Default constructor. wxStaticBox(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "staticBox") Constructor, creating and showing a static box. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. label Text to be displayed in the static box, the empty string for no label.

1179


CHAPTER 7
pos Window position. If the position (-1, -1) is specified then a default position is chosen. size Checkbox size. If the size (-1, -1) is specified then a default size is chosen. style Window style. See wxStaticBox (p. 1178). name Window name. See also wxStaticBox::Create (p. 1180)

wxStaticBox::~wxStaticBox
void ~wxStaticBox() Destructor, destroying the group box.

wxStaticBox::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "staticBox") Creates the static box for two-step construction. See wxStaticBox::wxStaticBox (p. 1179) for further details.

wxStaticBoxSizer
wxStaticBoxSizer is a sizer derived from wxBoxSizer but adds a static box around the sizer. Note that this static box has to be created separately. Derived from wxBoxSizer (p. 89) wxSizer (p. 1109) wxObject (p. 954) See also wxSizer (p. 1109), wxStaticBox (p. 1178), wxBoxSizer (p. 89), Sizer overview (p. 1620)

1180


CHAPTER 7

wxStaticBoxSizer::wxStaticBoxSizer
wxStaticBoxSizer(wxStaticBox* box, int orient) Constructor. It takes an associated static box and the orientation orient as parameters orient can be either of wxVERTICAL or wxHORIZONTAL.

wxStaticBoxSizer::GetStaticBox
wxStaticBox* GetStaticBox() Returns the static box associated with the sizer.

wxStaticLine
A static line is just a line which may be used in a dialog to separate the groups of controls. The line may be only vertical or horizontal. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/statline.h> Window styles wxLI_HORIZONTAL wxLI_VERTICAL See also wxStaticBox (p. 1178) Creates a horizontal line. Creates a vertical line.

wxStaticLine::wxStaticLine
wxStaticLine() Default constructor.

1181


CHAPTER 7
wxStaticLine(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxLI_HORIZONTAL, const wxString& name = "staticLine") Constructor, creating and showing a static line. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. pos Window position. If the position (-1, -1) is specified then a default position is chosen. size Size. Note that either the height or the width (depending on whether the line if horizontal or vertical) is ignored. style Window style (either wxLI_HORIZONTAL or wxLI_VERTICAL). name Window name. See also wxStaticLine::Create (p. 1182)

wxStaticLine::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "staticLine") Creates the static line for two-step construction. See wxStaticLine::wxStaticLine (p. 1181) for further details.

wxStaticLine::IsVertical
bool IsVertical() const Returns true if the line is vertical, false if horizontal.

1182


CHAPTER 7 wxStaticLine::GetDefaultSize
int GetDefaultSize() This static function returns the size which will be given to the smaller dimension of the static line, i.e. its height for a horizontal line or its width for a vertical one.

wxStaticText
A static text control displays one or more lines of read-only text. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/stattext.h> Window styles wxALIGN_LEFT wxALIGN_RIGHT wxALIGN_CENTRE wxST_NO_AUTORESIZE Align the text to the left Align the text to the right Center the text (horizontally) By default, the control will adjust its size to exactly fit to the size of the text when SetLabel (p. 1185) is called. If this style flag is given, the control will not change its size (this style is especially useful with controls which also have wxALIGN_RIGHT or CENTER style because otherwise they won't make sense any longer after a call to SetLabel)

See also window styles overview (p. 1611). See also wxStaticBitmap (p. 1176), wxStaticBox (p. 1178)

wxStaticText::wxStaticText
wxStaticText() Default constructor. wxStaticText(wxWindow* parent, wxWindowID id, const wxString& label, const

1183


CHAPTER 7
wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "staticText") Constructor, creating and showing a text control. Parameters parent Parent window. Should not be NULL. id Control identifier. A value of -1 denotes a default value. label Text label. pos Window position. size Window size. style Window style. See wxStaticText (p. 1183). name Window name. See also wxStaticText::Create (p. 1184)

wxStaticText::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = "staticText") Creation function, for two-step construction. For details see wxStaticText::wxStaticText (p. 1183).

wxStaticText::GetLabel
wxString GetLabel() const Returns the contents of the control.

1184


CHAPTER 7 wxStaticText::SetLabel
virtual void SetLabel(const wxString& label) Sets the static text label and updates the controls size to exactly fit the label unless the control has wxST_NO_AUTORESIZE flag. Parameters label The new label to set. It may contain newline characters.

wxStatusBar
A status bar is a narrow window that can be placed along the bottom of a frame to give small amounts of status information. It can contain one or more fields, one or more of which can be variable length according to the size of the window. wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Derived from wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/statusbr.h> Window styles wxST_SIZEGRIP On Windows 95, displays a gripper at right-hand side of the status bar.

See also window styles overview (p. 1611). Remarks It is possible to create controls and other windows on the status bar. Position these windows from an OnSize event handler. See also wxFrame (p. 530), Status bar sample (p. 1568)

wxStatusBar::wxStatusBar 1185


CHAPTER 7
wxStatusBar() Default constructor. wxStatusBar(wxWindow* parent, wxWindowID id, long style = wxST_SIZEGRIP, const wxString& name = "statusBar") Constructor, creating the window. Parameters parent The window parent, usually a frame. id The window identifier. It may take a value of -1 to indicate a default value. style The window style. See wxStatusBar (p. 1185). name The name of the window. This parameter is used to associate a name with the item, allowing the application user to set Motif resource values for individual windows. See also wxStatusBar::Create (p. 1186)

wxStatusBar::~wxStatusBar
void ~wxStatusBar() Destructor.

wxStatusBar::Create
bool Create(wxWindow* parent, wxWindowID id, long style = wxST_SIZEGRIP, const wxString& name = "statusBar") Creates the window, for two-step construction. See wxStatusBar::wxStatusBar (p. 1185) for details.

wxStatusBar::GetFieldRect
virtual bool GetFieldRect(int i, wxRect& rect) const

1186


CHAPTER 7
Returns the size and position of a field's internal bounding rectangle. Parameters i The field in question. rect The rectangle values are placed in this variable. Return value true if the field index is valid, false otherwise. See also wxRect (p. 1042) wxPerl note: In wxPerl this function returns a Wx::Rect if the field index is valid, undef otherwise.

wxStatusBar::GetFieldsCount
int GetFieldsCount() const Returns the number of fields in the status bar.

wxStatusBar::GetStatusText
virtual wxString GetStatusText(int i = 0) const Returns the string associated with a status bar field. Parameters i The number of the status field to retrieve, starting from zero. Return value The status field string if the field is valid, otherwise the empty string. See also wxStatusBar::SetStatusText (p. 1188)

wxStatusBar::PopStatusText
void PopStatusText(int field = 0)

1187


CHAPTER 7
Sets the field text to the top of the stack, and pops the stack of saved strings. See also wxStatusBar::PushStatusText (p. 1188)

wxStatusBar::PushStatusText
void PushStatusText(const wxString& string, int field = 0) Saves the current field text in a per field stack, and sets the field text to the string passed as argument.

wxStatusBar::SetFieldsCount
virtual void SetFieldsCount(int number = 1, int* widths = NULL) Sets the number of fields, and optionally the field widths. wxPython note: Only the first parameter is accepted. Use SetStatusWidths to set the widths of the fields. wxPerl note: In wxPerl this function accepts only the n parameter. Use SetStatusWidths to set the field widths. Parameters number The number of fields. widths An array of n integers interpreted in the same way as in SetStatusWidths (p. 1189)

wxStatusBar::SetMinHeight
void SetMinHeight(int height) Sets the minimal possible height for the status bar. The real height may be bigger than the height specified here depending on the size of the font used by the status bar.

wxStatusBar::SetStatusText
virtual void SetStatusText(const wxString& text, int i = 0) Sets the text for one field. Parameters

1188


CHAPTER 7
text The text to be set. Use an empty string ("") to clear the field. i The field to set, starting from zero. See also wxStatusBar::GetStatusText (p. 1187), wxFrame::SetStatusText (p. 541)

wxStatusBar::SetStatusWidths
virtual void SetStatusWidths(int n, int *widths) Sets the widths of the fields in the status line. There are two types of fields: fixed widths one and variable width fields. For the fixed width fields you should specify their (constant) width in pixels. For the variable width fields, specify a negative number which indicates how should the field expand: the space left for all variable width fields is divided between them according to the absolute value of this number. A variable width field with width of -2gets twice as much of it as a field with width -1 and so on. For example, to create one fixed width field of width 50 in the right part of the status bar and two more fields which get 66% and 33% of the remaining space correspondingly, you should use an array containing -2, -1 and 100. Parameters n The number of fields in the status bar. Must be equal to the number passed to SetFieldsCount (p. 1188) the last time it was called. widths Contains an array of n integers, each of which is either an absolute status field width in pixels if positive or indicates a variable width field if negative Remarks The widths of the variable fields are calculated from the total width of all fields, minus the sum of widths of the non-variable fields, divided by the number of variable fields. See also wxStatusBar::SetFieldsCount (p. 1188), wxFrame::SetStatusWidths (p. 541) wxPython note: Only a single parameter is required, a Python list of integers. wxPerl note: In wxPerl this method takes as parameters the field widths.

1189


CHAPTER 7

wxStopWatch
The wxStopWatch class allow you to measure time intervals. For example, you may use it to measure the time elapsed by some function:
wxStopWatch sw; CallLongRunningFunction(); wxLogMessage("The long running function took %ldms to execute", sw.Time()); sw.Pause(); ... stopwatch is stopped now ... sw.Resume(); CallLongRunningFunction(); wxLogMessage("And calling it twice took $ldms in all", sw.Time());

Include files <wx/timer.h> See also ::wxStartTimer (p. 1528), ::wxGetElapsedTime (p. 1527), wxTimer (p. 1294)

wxStopWatch::wxStopWatch
wxStopWatch() Constructor. This starts the stop watch.

wxStopWatch::Pause
void Pause() Pauses the stop watch. Call wxStopWatch::Resume (p. 1190) to resume time measuring again. If this method is called several times, Resume() must be called the same number of times to really resume the stop watch. You may, however, call Start (p. 1190) to resume it unconditionally.

wxStopWatch::Resume
void Resume() Resumes the stop watch which had been paused with wxStopWatch::Pause (p. 1190).

wxStopWatch::Start
void Start(long milliseconds = 0)

1190


CHAPTER 7
(Re)starts the stop watch with a given initial value.

wxStopWatch::Time
long Time() const Returns the time in milliseconds since the start (or restart) or the last call of wxStopWatch::Pause (p. 1190).

wxStreamBase
This class is the base class of most stream related classes in wxWindows. It must not be used directly. Derived from None Include files <wx/stream.h> See also wxStreamBuffer (p. 1193)

wxStreamBase::wxStreamBase
wxStreamBase() Creates a dummy stream object. It doesn't do anything.

wxStreamBase::~wxStreamBase
~wxStreamBase() Destructor.

wxStreamBase::IsOk
wxStreamError IsOk() const Returns true if no error occurred on the stream. See also

1191


CHAPTER 7
GetLastError (p. 1192)

wxStreamBase::GetLastError
wxStreamError GetLastError() const This function returns the last error. wxSTREAM_NO_ERROR wxSTREAM_EOF No error occurred. An End-Of-File occurred. A generic error occurred on the last write call. A generic error occurred on the last read call.

wxSTREAM_WRITE_ERROR wxSTREAM_READ_ERROR

wxStreamBase::OnSysRead
size_t OnSysRead(void* buffer, size_t bufsize) Internal function. It is called when the stream wants to read data of the specified size. It should return the size that was actually read.

wxStreamBase::OnSysSeek
off_t OnSysSeek(off_t pos, wxSeekMode mode) Internal function. It is called when the stream needs to change the current position.

wxStreamBase::OnSysTell
off_t OnSysTell() const Internal function. Is is called when the stream needs to know the real position.

wxStreamBase::OnSysWrite
size_t OnSysWrite(void *buffer, size_t bufsize) See OnSysRead (p. 1192).

wxStreamBase::GetSize
size_t GetSize() const This function returns the size of the stream. For example, for a file it is the size of the file.

1192


CHAPTER 7
Warning There are streams which do not have size by definition, such as socket streams. In that cases, GetSize returns 0 so you should always test its return value.

wxStreamBuffer
Derived from None Include files <wx/stream.h> See also wxStreamBase (p. 1191)

wxStreamBuffer::wxStreamBuffer
wxStreamBuffer(wxStreamBase& stream, BufMode mode) Constructor, creates a new stream buffer using stream as a parent stream and mode as the IO mode. mode can be: wxStreamBuffer::read, wxStreamBuffer::write, wxStreamBuffer::read_write. One stream can have many stream buffers but only one is used internally to pass IO call (e.g. wxInputStream::Read() -> wxStreamBuffer::Read()), but you can call directly wxStreamBuffer::Read without any problems. Note that all errors and messages linked to the stream are stored in the stream, not the stream buffers:
streambuffer.Read(...); streambuffer2.Read(...); /* This call erases previous error messages set by ``streambuffer'' */

wxStreamBuffer(BufMode mode) Constructor, creates a new empty stream buffer which won't flush any data to a stream. mode specifies the type of the buffer (read, write, read_write). This stream buffer has the advantage to be stream independent and to work only on memory buffers but it is still compatible with the rest of the wxStream classes. You can write, read to this special stream and it will grow (if it is allowed by the user) its internal buffer. Briefly, it has all functionality of a "normal'' stream. Warning The "read_write" mode may not work: it isn't completely finished.

1193


CHAPTER 7
wxStreamBuffer(const wxStreamBuffer&buffer) Constructor. It initializes the stream buffer with the data of the specified stream buffer. The new stream buffer has the same attributes, size, position and they share the same buffer. This will cause problems if the stream to which the stream buffer belong is destroyed and the newly cloned stream buffer continues to be used, trying to call functions in the (destroyed) stream. It is advised to use this feature only in very local area of the program. See also wxStreamBuffer:SetBufferIO (p. 1196)

wxStreamBuffer::~wxStreamBuffer
wxStreamBuffer(~wxStreamBuffer) Destructor. It finalizes all IO calls and frees all internal buffers if necessary.

wxStreamBuffer::Read
size_t Read(void *buffer, size_t size) Reads a block of the specified size and stores the data in buffer. This function tries to read from the buffer first and if more data has been requested, reads more data from the associated stream and updates the buffer accordingly until all requested data is read. Return value It returns the size of the data read. If the returned size is different of the specified size, an error has occurred and should be tested using GetLastError (p. 1192). size_t Read(wxStreamBuffer *buffer) Reads a buffer. The function returns when buffer is full or when there isn't data anymore in the current buffer. See also wxStreamBuffer::Write (p. 1194)

wxStreamBuffer::Write
size_t Write(const void *buffer, size_t size) Writes a block of the specified size using data of buffer. The data are cached in a buffer before being sent in one block to the stream. size_t Write(wxStreamBuffer *buffer)

1194


CHAPTER 7
See Read (p. 1194).

wxStreamBuffer::GetChar
char GetChar() Gets a single char from the stream buffer. It acts like the Read call. Problem You aren't directly notified if an error occurred during the IO call. See also wxStreamBuffer::Read (p. 1194)

wxStreamBuffer::PutChar
void PutChar(char c) Puts a single char to the stream buffer. Problem You aren't directly notified if an error occurred during the IO call. See also wxStreamBuffer::Read (p. 1194)

wxStreamBuffer::Tell
off_t Tell() const Gets the current position in the stream. This position is calculated from the real position in the stream and from the internal buffer position: so it gives you the position in the real stream counted from the start of the stream. Return value Returns the current position in the stream if possible, wxInvalidOffset in the other case.

wxStreamBuffer::Seek
off_t Seek(off_t pos, wxSeekMode mode) Changes the current position. mode may be one of the following:

1195


CHAPTER 7
wxFromStart wxFromCurrent wxFromEnd Return value Upon successful completion, it returns the new offset as measured in bytes from the beginning of the stream. Otherwise, it returns wxInvalidOffset. The position is counted from the start of the stream. The position is counted from the current position of the stream. The position is counted from the end of the stream.

wxStreamBuffer::ResetBuffer
void ResetBuffer() Resets to the initial state variables concerning the buffer.

wxStreamBuffer::SetBufferIO
void SetBufferIO(char* buffer_start, char* buffer_end) Specifies which pointers to use for stream buffering. You need to pass a pointer on the start of the buffer end and another on the end. The object will use this buffer to cache stream data. It may be used also as a source/destination buffer when you create an empty stream buffer (See wxStreamBuffer::wxStreamBuffer (p. 1193)). Remarks When you use this function, you will have to destroy the IO buffers yourself after the stream buffer is destroyed or don't use it anymore. In the case you use it with an empty buffer, the stream buffer will not resize it when it is full. See also wxStreamBuffer constructor (p. 1193) wxStreamBuffer::Fixed (p. 1198) wxStreamBuffer::Flushable (p. 1198) void SetBufferIO(size_t bufsize) Destroys or invalidates the previous IO buffer and allocates a new one of the specified size. Warning All previous pointers aren't valid anymore. Remark The created IO buffer is growable by the object.

1196


CHAPTER 7
See also wxStreamBuffer::Fixed (p. 1198) wxStreamBuffer::Flushable (p. 1198)

wxStreamBuffer::GetBufferStart
char * GetBufferStart() const Returns a pointer on the start of the stream buffer.

wxStreamBuffer::GetBufferEnd
char * GetBufferEnd() const Returns a pointer on the end of the stream buffer.

wxStreamBuffer::GetBufferPos
char * GetBufferPos() const Returns a pointer on the current position of the stream buffer.

wxStreamBuffer::GetIntPosition
off_t GetIntPosition() const Returns the current position (counted in bytes) in the stream buffer.

wxStreamBuffer::SetIntPosition
void SetIntPosition(size_t pos) Sets the current position (in bytes) in the stream buffer. Warning Since it is a very low-level function, there is no check on the position: specifing an invalid position can induce unexpected results.

wxStreamBuffer::GetLastAccess
size_t GetLastAccess() const Returns the amount of bytes read during the last IO call to the parent stream.

1197


CHAPTER 7 wxStreamBuffer::Fixed
void Fixed(bool fixed) Toggles the fixed flag. Usually this flag is toggled at the same time as flushable. This flag allows (when it has the false value) or forbids (when it has the true value) the stream buffer to resize dynamically the IO buffer. See also wxStreamBuffer::SetBufferIO (p. 1196)

wxStreamBuffer::Flushable
void Flushable(bool flushable) Toggles the flushable flag. If flushable is disabled, no data are sent to the parent stream.

wxStreamBuffer::FlushBuffer
bool FlushBuffer() Flushes the IO buffer.

wxStreamBuffer::FillBuffer
bool FillBuffer() Fill the IO buffer.

wxStreamBuffer::GetDataLeft
size_t GetDataLeft() Returns the amount of available data in the buffer.

wxStreamBuffer::Stream
wxStreamBase* Stream() Returns the parent stream of the stream buffer.

wxStreamToTextRedirector
This class can be used to (temporarily) redirect all output sent to a C++ ostream object to a wxTextCtrl (p. 1248) instead.

1198


CHAPTER 7
NB: Some compilers and/or build configurations don't support multiply inheriting wxTextCtrl (p. 1248) from std::streambuf in which case this class is not compiled in. You also must have wxUSE_STD_IOSTREAM option on (i.e. set to 1) in your setup.h to be able to use it. Under Unix, specify --enable-std_iostreams switch when running configure for this.
Example of usage: using namespace std;

wxTextCtrl *text = new wxTextCtrl(...); { wxStreamToTextRedirector redirect(text); // this goes to the text control cout << "Hello, text!" << endl; } // this goes soemwhere else, presumably to stdout cout << "Hello, console!" << endl;

Derived from No base class Include files <wx/textctrl.h> See also wxTextCtrl (p. 1248)

wxStreamToTextRedirector::wxStreamToTextRedirector
wxStreamToTextRedirector(wxTextCtrl *text, ostream *ostr = NULL) The constructor starts redirecting output sent to ostr or cout for the default parameter value to the text control text. Parameters text The text control to append output too, must be non NULL ostr The C++ stream to redirect, cout is used if it is NULL

wxStreamToTextRedirector::~wxStreamToTextRedirector
~wxStreamToTextRedirector()

1199


CHAPTER 7
When a wxStreamToTextRedirector object is destroyed, the redirection is ended and any output sent to the C++ ostream which had been specified at the time of the object construction will go to its original destination.

wxString
wxString is a class representing a character string. Please see the wxString overview (p. 1574) for more information about it. As explained there, wxString implements about 90% of methods of the std::string class (iterators are not supported, nor all methods which use them). These standard functions are not documented in this manual so please see the STL documentation. The behaviour of all these functions is identical to the behaviour described there (except that wxString is sensitive to null character). You may notice that wxString sometimes has many functions which do the same thing like, for example, Length() (p. 1213), Len() (p. 1213) and length() which all return the string length. In all cases of such duplication the std::string-compatible method (length() in this case, always the lowercase version) should be used as it will ensure smoother transition to std::string when wxWindows starts using it instead of wxString. Derived from None Include files <wx/string.h> Predefined objects Objects: wxEmptyString See also Overview (p. 1574)

Constructors and assignment operators
A string may be constructed either from a C string, (some number of copies of) a single character or a wide (UNICODE) string. For all constructors (except the default which creates an empty string) there is also a corresponding assignment operator. wxString (p. 1206) operator = (p. 1219) ~wxString (p. 1207)

1200


CHAPTER 7 String length
These functions return the string length and check whether the string is empty or empty it. Len (p. 1213) IsEmpty (p. 1212) operator! (p. 1219) Empty (p. 1209) Clear (p. 1209)

Character access
Many functions in this section take a character index in the string. As with C strings and/or arrays, the indices start from 0, so the first character of a string is string[0]. Attempt to access a character beyond the end of the string (which may be even 0 if the string is empty) will provoke an assert failure in debug build (p. 1598), but no checks are done in release builds. This section also contains both implicit and explicit conversions to C style strings. Although implicit conversion is quite convenient, it is advised to use explicit c_str() (p. 1208) method for the sake of clarity. Also see overview (p. 1576) for the cases where it is necessary to use it. GetChar (p. 1211) GetWritableChar (p. 1211) SetChar (p. 1216) Last (p. 1213) operator [] (p. 1220) c_str (p. 1208) operator const char* (p. 1220)

Concatenation
Anything may be concatenated (appended to) with a string. However, you can't append something to a C string (including literal constants), so to do this it should be converted to a wxString first. operator << (p. 1220) operator += (p. 1219) operator + (p. 1219) Append (p. 1208) Prepend (p. 1215)

Comparison
The default comparison function Cmp (p. 1209) is case-sensitive and so is the default version of IsSameAs (p. 1212). For case insensitive comparisons you should use

1201


CHAPTER 7
CmpNoCase (p. 1209) or give a second parameter to IsSameAs. This last function is may be more convenient if only equality of the strings matters because it returns a boolean true value if the strings are the same and not 0 (which is usually false in C) as Cmp() does. Matches (p. 1214) is a poor man's regular expression matcher: it only understands '*' and '?' metacharacters in the sense of DOS command line interpreter. StartsWith (p. 1216) is helpful when parsing a line of text which should start with some predefined prefix and is more efficient than doing direct string comparison as you would also have to precalculate the length of the prefix then. Cmp (p. 1209) CmpNoCase (p. 1209) IsSameAs (p. 1212) Matches (p. 1214) StartsWith (p. 1216)

Substring extraction
These functions allow to extract substring from this string. All of them don't modify the original string and return a new string containing the extracted substring. Mid (p. 1214) operator() (p. 1220) Left (p. 1213) Right (p. 1216) BeforeFirst (p. 1208) BeforeLast (p. 1208) AfterFirst (p. 1208) AfterLast (p. 1208) StartsWith (p. 1216)

Case conversion
The MakeXXX() variants modify the string in place, while the other functions return a new string which contains the original text converted to the upper or lower case and leave the original string unchanged. MakeUpper (p. 1214) Upper (p. 1218) MakeLower (p. 1214) Lower (p. 1214)

Searching and replacing
These functions replace the standard strchr() and strstr() functions. Find (p. 1210)

1202


CHAPTER 7
Replace (p. 1215)

Conversion to numbers
The string provides functions for conversion to signed and unsigned integer and floating point numbers. All three functions take a pointer to the variable to put the numeric value in and return true if the entire string could be converted to a number. ToLong (p. 1217) ToULong (p. 1218) ToDouble (p. 1217)

Writing values into the string
Both formatted versions (Printf (p. 1215)) and stream-like insertion operators exist (for basic types only). Additionally, the Format (p. 1210) function allows to use simply append formatted value to a string:
// the following 2 snippets are equivalent wxString s = "..."; s += wxString::Format("%d", n); wxString s; s.Printf("...%d", n);

Format (p. 1210) FormatV (p. 1210) Printf (p. 1215) PrintfV (p. 1215) operator << (p. 1220)

Memory management
These are "advanced" functions and they will be needed quite rarely. Alloc (p. 1207) and Shrink (p. 1216) are only interesting for optimization purposes. GetWriteBuf (p. 1211) may be very useful when working with some external API which requires the caller to provide a writable buffer, but extreme care should be taken when using it: before performing any other operation on the string UngetWriteBuf (p. 1218) must be called! Alloc (p. 1207) Shrink (p. 1216) GetWriteBuf (p. 1211) UngetWriteBuf (p. 1218)

Miscellaneous
Other string functions.

1203


CHAPTER 7
Trim (p. 1218) Pad (p. 1214) Truncate (p. 1218)

wxWindows 1.xx compatibility functions
These functions are deprecated, please consider using new wxWindows 2.0 functions instead of them (or, even better, std::string compatible variants). SubString (p. 1216) sprintf (p. 1216) CompareTo (p. 1209) Length (p. 1213) Freq (p. 1211) LowerCase (p. 1214) UpperCase (p. 1219) Strip (p. 1216) Index (p. 1211) Remove (p. 1215) First (p. 1210) Last (p. 1213) Contains (p. 1209) IsNull (p. 1212) IsAscii (p. 1212) IsNumber (p. 1212) IsWord (p. 1213)

std::string compatibility functions
The supported functions are only listed here, please see any STL reference for their documentation.
// take nLen chars starting at nPos wxString(const wxString& str, size_t nPos, size_t nLen); // take all characters from pStart to pEnd (poor man's iterators) wxString(const void *pStart, const void *pEnd); // lib.string.capacity // return the length of the string size_t size() const; // return the length of the string size_t length() const; // return the maximum size of the string size_t max_size() const; // resize the string, filling the space with c if c != 0 void resize(size_t nSize, char ch = '\0'); // delete the contents of the string void clear(); // returns true if the string is empty bool empty() const; // lib.string.access // return the character at position n char at(size_t n) const; // returns the writable character at position n char& at(size_t n);

1204


CHAPTER 7

// lib.string.modifiers // append a string wxString& append(const wxString& str); // append elements str[pos], ..., str[pos+n] wxString& append(const wxString& str, size_t pos, size_t n); // append first n (or all if n == npos) characters of sz wxString& append(const char *sz, size_t n = npos); // append n copies of ch wxString& append(size_t n, char ch); // same wxString& // same wxString& // same wxString& // same wxString& as `this_string = str' assign(const wxString& str); as ` = str[pos..pos + n] assign(const wxString& str, size_t pos, size_t n); as `= first n (or all if n == npos) characters of sz' assign(const char *sz, size_t n = npos); as `= n copies of ch' assign(size_t n, char ch);

// insert another string wxString& insert(size_t nPos, const wxString& str); // insert n chars of str starting at nStart (in str) wxString& insert(size_t nPos, const wxString& str, size_t nStart, size_t n); // insert first n (or wxString& insert(size_t // insert n copies of wxString& insert(size_t all if n == npos) characters of sz nPos, const char *sz, size_t n = npos); ch nPos, size_t n, char ch);

// delete characters from nStart to nStart + nLen wxString& erase(size_t nStart = 0, size_t nLen = npos); // replaces the substring of length nLen starting at nStart wxString& replace(size_t nStart, size_t nLen, const char* sz); // replaces the substring with nCount copies of ch wxString& replace(size_t nStart, size_t nLen, size_t nCount, char ch); // replaces a substring with another substring wxString& replace(size_t nStart, size_t nLen, const wxString& str, size_t nStart2, size_t nLen2); // replaces the substring with first nCount chars of sz wxString& replace(size_t nStart, size_t nLen, const char* sz, size_t nCount); // swap two strings void swap(wxString& str); // All find() functions take the nStart argument which specifies the // position to start the search on, the default value is 0. All functions // return npos if there were no match. // find a substring size_t find(const wxString& str, size_t nStart = 0) const; // find first n characters of sz size_t find(const char* sz, size_t nStart = 0, size_t n = npos) const; // find the first occurrence of character ch after nStart size_t find(char ch, size_t nStart = 0) const; // rfind() family is exactly like find() but works right to left // as find, but from the end size_t rfind(const wxString& str, size_t nStart = npos) const; // as find, but from the end size_t rfind(const char* sz, size_t nStart = npos, size_t n = npos) const; // as find, but from the end

1205


CHAPTER 7
size_t rfind(char ch, size_t nStart = npos) const; // find first/last occurrence of any character in the set // size_t find_first_of(const wxString& str, size_t nStart = 0) const; // size_t find_first_of(const char* sz, size_t nStart = 0) const; // same as find(char, size_t) size_t find_first_of(char c, size_t nStart = 0) const; // size_t find_last_of (const wxString& str, size_t nStart = npos) const; // size_t find_last_of (const char* s, size_t nStart = npos) const; // same as rfind(char, size_t) size_t find_last_of (char c, size_t nStart = npos) const; // find first/last occurrence of any character not in the set // size_t // size_t // size_t // size_t // size_t // size_t find_first_not_of(const wxString& str, size_t nStart = 0) const; find_first_not_of(const char* s, size_t nStart = 0) const; find_first_not_of(char ch, size_t nStart = 0) const; find_last_not_of(const wxString& str, size_t nStart=npos) const; find_last_not_of(const char* s, size_t nStart = npos) const; find_last_not_of(char ch, size_t nStart = npos) const;

// All compare functions return a negative, zero or positive value // if the [sub]string is less, equal or greater than the compare() argument. // just like strcmp() int compare(const wxString& str) const; // comparison with a substring int compare(size_t nStart, size_t nLen, const wxString& str) const; // comparison of 2 substrings int compare(size_t nStart, size_t nLen, const wxString& str, size_t nStart2, size_t nLen2) const; // just like strcmp() int compare(const char* sz) const; // substring comparison with first nCount characters of sz int compare(size_t nStart, size_t nLen, const char* sz, size_t nCount = npos) const; // substring extraction wxString substr(size_t nStart = 0, size_t nLen = npos) const;

wxString::wxString
wxString() Default constructor. wxString(const wxString& x) Copy constructor. wxString(char ch, size_t n = 1)

1206


CHAPTER 7
Constructs a string of n copies of character ch. wxString(const char* psz, size_t nLength = wxSTRING_MAXLEN) Takes first nLength characters from the C string psz. The default value of wxSTRING_MAXLEN means to take all the string. Note that this constructor may be used even if psz points to a buffer with binary data (i.e. containing NUL characters) as long as you provide the correct value for nLength. However, the default form of it works only with strings without intermediate NULs because it uses strlen() to calculate the effective length and it would not give correct results otherwise. wxString(const unsigned char* psz, size_t nLength = wxSTRING_MAXLEN) For compilers using unsigned char: takes first nLength characters from the C string psz. The default value of wxSTRING_MAXLEN means take all the string. wxString(const wchar_t* psz) Constructs a string from the wide (UNICODE) string.

wxString::~wxString
~wxString() String destructor. Note that this is not virtual, so wxString must not be inherited from.

wxString::Alloc
void Alloc(size_t nLen) Preallocate enough space for wxString to store nLen characters. This function may be used to increase speed when the string is constructed by repeated concatenation as in
// delete all vowels from the string wxString DeleteAllVowels(const wxString& original) { wxString result; size_t len = original.length(); result.Alloc(len); for ( size_t n = 0; n < len; n++ ) { if ( strchr("aeuio", tolower(original[n])) == NULL ) result += original[n]; } return result; }

because it will avoid the need of reallocating string memory many times (in case of long strings). Note that it does not set the maximal length of a string - it will still expand if

1207


CHAPTER 7
more than nLen characters are stored in it. Also, it does not truncate the existing string (use Truncate() (p. 1218) for this) even if its current length is greater than nLen

wxString::Append
wxString& Append(const char* psz) Concatenates psz to this string, returning a reference to it. wxString& Append(char ch, int count = 1) Concatenates character ch to this string, count times, returning a reference to it.

wxString::AfterFirst
wxString AfterFirst(char ch) const Gets all the characters after the first occurrence of ch. Returns the empty string if ch is not found.

wxString::AfterLast
wxString AfterLast(char ch) const Gets all the characters after the last occurrence of ch. Returns the whole string if ch is not found.

wxString::BeforeFirst
wxString BeforeFirst(char ch) const Gets all characters before the first occurrence of ch. Returns the whole string if ch is not found.

wxString::BeforeLast
wxString BeforeLast(char ch) const Gets all characters before the last occurrence of ch. Returns the empty string if ch is not found.

wxString::c_str
const char * c_str() const Returns a pointer to the string data.

1208


CHAPTER 7 wxString::Clear
void Clear() Empties the string and frees memory occupied by it. See also: Empty (p. 1209)

wxString::Cmp
int Cmp(const char* psz) const Case-sensitive comparison. Returns a positive value if the string is greater than the argument, zero if it is equal to it or a negative value if it is less than the argument (same semantics as the standard strcmp() function). See also CmpNoCase (p. 1209), IsSameAs (p. 1212).

wxString::CmpNoCase
int CmpNoCase(const char* psz) const Case-insensitive comparison. Returns a positive value if the string is greater than the argument, zero if it is equal to it or a negative value if it is less than the argument (same semantics as the standard strcmp() function). See also Cmp (p. 1209), IsSameAs (p. 1212).

wxString::CompareTo
#define NO_POS ((int)(-1)) // undefined position enum caseCompare {exact, ignoreCase};

int CompareTo(const char* psz, caseCompare cmp = exact) const Case-sensitive comparison. Returns 0 if equal, 1 if greater or -1 if less.

wxString::Contains
bool Contains(const wxString& str) const Returns 1 if target appears anyhere in wxString; else 0.

wxString::Empty 1209


CHAPTER 7
void Empty() Makes the string empty, but doesn't free memory occupied by the string. See also: Clear() (p. 1209).

wxString::Find
int Find(char ch, bool fromEnd = false) const Searches for the given character. Returns the starting index, or -1 if not found. int Find(const char* sz) const Searches for the given string. Returns the starting index, or -1 if not found.

wxString::First
int First(char c) int First(const char* psz) const int First(const wxString& str) const Same as Find (p. 1210).

wxString::Format
static wxString Format(const wxChar *format, ...) This static function returns the string containing the result of calling Printf (p. 1215) with the passed parameters on it. See also FormatV (p. 1210), Printf (p. 1215)

wxString::FormatV
static wxString Format(const wxChar *format, va_list argptr) This static function returns the string containing the result of calling PrintfV (p. 1215) with the passed parameters on it. See also Format (p. 1210), PrintfV (p. 1215)

1210


CHAPTER 7 wxString::Freq
int Freq(char ch) const Returns the number of occurrences of ch in the string.

wxString::FromAscii
static wxString FromAscii(const char* s) static wxString FromAscii(const char c) Converts the string or character from an ASCII, 7-bit form to the native wxString representation. Most useful when using a Unicode build of wxWindows.

wxString::GetChar
char GetChar(size_t n) const Returns the character at position n (read-only).

wxString::GetData
const char* GetData() const wxWindows compatibility conversion. Returns a constant pointer to the data in the string.

wxString::GetWritableChar
char& GetWritableChar(size_t n) Returns a reference to the character at position n.

wxString::GetWriteBuf
wxChar* GetWriteBuf(size_t len) Returns a writable buffer of at least len bytes. It returns a pointer to a new memory block, and the existing data will not be copied. Call wxString::UngetWriteBuf (p. 1218) as soon as possible to put the string back into a reasonable state.

wxString::Index
size_t Index(char ch) const

1211


CHAPTER 7
size_t Index(const char* sz) const Same as wxString::Find (p. 1210). size_t Index(const char* sz, bool caseSensitive = true, bool fromEnd = false) const Search the element in the array, starting from either side. If fromEnd is true, reverse search direction. If caseSensitive, comparison is case sensitive (the default). Returns the index of the first item matched, or wxNOT_FOUND.

wxString::IsAscii
bool IsAscii() const Returns true if the string contains only ASCII characters.

wxString::IsEmpty
bool IsEmpty() const Returns true if the string is empty.

wxString::IsNull
bool IsNull() const Returns true if the string is empty (same as IsEmpty (p. 1212)).

wxString::IsNumber
bool IsNumber() const Returns true if the string is an integer (with possible sign).

wxString::IsSameAs
bool IsSameAs(const char* psz, bool caseSensitive = true) const Test for string equality, case-sensitive (default) or not. caseSensitive is true by default (case matters). Returns true if strings are equal, false otherwise.

1212


CHAPTER 7
See also Cmp (p. 1209), CmpNoCase (p. 1209), IsSameAs (p. 1213)

wxString::IsSameAs
bool IsSameAs(char c, bool caseSensitive = true) const Test whether the string is equal to the single character c. The test is case-sensitive if caseSensitive is true (default) or not if it is false. Returns true if the string is equal to the character, false otherwise. See also Cmp (p. 1209), CmpNoCase (p. 1209), IsSameAs (p. 1212)

wxString::IsWord
bool IsWord() const Returns true if the string is a word. TODO: what's the definition of a word?

wxString::Last
char Last() const Returns the last character. char& Last() Returns a reference to the last character (writable).

wxString::Left
wxString Left(size_t count) const Returns the first count characters of the string.

wxString::Len
size_t Len() const Returns the length of the string.

wxString::Length
size_t Length() const Returns the length of the string (same as Len).

1213


CHAPTER 7 wxString::Lower
wxString Lower() const Returns this string converted to the lower case.

wxString::LowerCase
void LowerCase() Same as MakeLower.

wxString::MakeLower
wxString& MakeLower() Converts all characters to lower case and returns the result.

wxString::MakeUpper
wxString& MakeUpper() Converts all characters to upper case and returns the result.

wxString::Matches
bool Matches(const char* szMask) const Returns true if the string contents matches a mask containing '*' and '?'.

wxString::Mid
wxString Mid(size_t first, size_t count = wxSTRING_MAXLEN) const Returns a substring starting at first, with length count, or the rest of the string if count is the default value.

wxString::Pad
wxString& Pad(size_t count, char pad = ' ', bool fromRight = true) Adds count copies of pad to the beginning, or to the end of the string (the default). Removes spaces from the left or from the right (default).

1214


CHAPTER 7 wxString::Prepend
wxString& Prepend(const wxString& str) Prepends str to this string, returning a reference to this string.

wxString::Printf
int Printf(const char* pszFormat, ...) Similar to the standard function sprintf(). Returns the number of characters written, or an integer less than zero on error. NB: This function will use a safe version of vsprintf() (usually called vsnprintf()) whenever available to always allocate the buffer of correct size. Unfortunately, this function is not available on all platforms and the dangerous vsprintf() will be used then which may lead to buffer overflows.

wxString::PrintfV
int PrintfV(const char* pszFormat, va_list argPtr) Similar to vprintf. Returns the number of characters written, or an integer less than zero on error.

wxString::Remove
wxString& Remove(size_t pos) Same as Truncate. Removes the portion from pos to the end of the string. wxString& Remove(size_t pos, size_t len) Removes the len characters from the string, starting at pos.

wxString::RemoveLast
wxString& RemoveLast() Removes the last character.

wxString::Replace
size_t Replace(const char* szOld, const char* szNew, bool replaceAll = true) Replace first (or all) occurrences of substring with another one. replaceAll: global replace (default), or only the first occurrence.

1215


CHAPTER 7
Returns the number of replacements made.

wxString::Right
wxString Right(size_t count) const Returns the last count characters.

wxString::SetChar
void SetChar(size_t n, charch) Sets the character at position n.

wxString::Shrink
void Shrink() Minimizes the string's memory. This can be useful after a call to Alloc() (p. 1207) if too much memory were preallocated.

wxString::sprintf
void sprintf(const char* fmt) The same as Printf.

wxString::StartsWith
bool StartsWith(const wxChar *prefix, wxString *rest = NULL) const This function can be used to test if the string starts with the specified prefix. If it does, the function will return true and put the rest of the string (i.e. after the prefix) into rest string if it is not NULL. Otherwise, the function returns false and doesn't modify the rest.

wxString::Strip
enum stripType {leading = 0x1, trailing = 0x2, both = 0x3};

wxString Strip(stripType s = trailing) const Strip characters at the front and/or end. The same as Trim except that it doesn't change this string.

wxString::SubString 1216


CHAPTER 7
wxString SubString(size_t from, size_t to) const Deprecated, use Mid (p. 1214) instead (but note that parameters have different meaning). Returns the part of the string between the indices from and toinclusive.

wxString::ToAscii
const char* ToAscii() const Converts the string to an ASCII, 7-bit string (ANSI builds only). const wxCharBuffer ToAscii() const Converts the string to an ASCII, 7-bit string in the form of a wxCharBuffer (Unicode builds only).

wxString::ToDouble
bool ToDouble(double *val) const Attempts to convert the string to a floating point number. Returns true on success (the number is stored in the location pointed to by val) or false if the string does not represent such number. See also wxString::ToLong (p. 1217), wxString::ToULong (p. 1218)

wxString::ToLong
bool ToLong(long *val, int base = 10) const Attempts to convert the string to a signed integer in base base. Returnstrue on success in which case the number is stored in the location pointed to by val or false if the string does not represent a valid number in the given base. The value of base must be comprised between 2 and 36, inclusive, or be a special value 0 which means that the usual rules of C numbers are applied: if the number starts with 0x it is considered to be in base16, if it starts with 0 - in base 8 and in base 10 otherwise. Note that you may not want to specify the base 0 if you are parsing the numbers which may have leading zeroes as they can yield unexpected (to the user not familiar with C) results. See also wxString::ToDouble (p. 1217), wxString::ToULong (p. 1218)

1217


CHAPTER 7 wxString::ToULong
bool ToULong(unsigned long *val, int base = 10) const Attempts to convert the string to a ansigned integer in base base. Returns true on success in which case the number is stored in the location pointed to by val or false if the string does not represent a valid number in the given base. See wxString::ToLong (p. 1217) for the more detailed description of the base parameter. See also wxString::ToDouble (p. 1217), wxString::ToLong (p. 1217)

wxString::Trim
wxString& Trim(bool fromRight = true) Removes spaces from the left or from the right (default).

wxString::Truncate
wxString& Truncate(size_t len) Truncate the string to the given length.

wxString::UngetWriteBuf
void UngetWriteBuf() void UngetWriteBuf(size_t len) Puts the string back into a reasonable state (in which it can be used normally), after wxString::GetWriteBuf (p. 1211) was called. The version of the function without the len parameter will calculate the new string length itself assuming that the string is terminated by the firstNUL character in it while the second one will use the specified length and thus is the only version which should be used with the strings with embedded NULs (it is also slightly more efficient as strlen() doesn't have to be called).

wxString::Upper
wxString Upper() const Returns this string converted to upper case.

1218


CHAPTER 7 wxString::UpperCase
void UpperCase() The same as MakeUpper.

wxString::operator!
bool operator!() const Empty string is false, so !string will only return true if the string is empty. This allows the tests for NULLness of a const char * pointer and emptyness of the string to look the same in the code and makes it easier to port old code to wxString. See also IsEmpty() (p. 1212).

wxString::operator =
wxString& operator =(const wxString& str) wxString& operator =(const char* psz) wxString& operator =(char c) wxString& operator =(const unsigned char* psz) wxString& operator =(const wchar_t* pwz) Assignment: the effect of each operation is the same as for the corresponding constructor (see wxString constructors (p. 1206)).

wxString::operator +
Concatenation: all these operators return a new strign equal to the sum of the operands. wxString operator +(const wxString& x, const wxString& y) wxString operator +(const wxString& x, const char* y) wxString operator +(const wxString& x, char y) wxString operator +(const char* x, const wxString& y)

wxString::operator +=
void operator +=(const wxString& str) void operator +=(const char* psz)

1219


CHAPTER 7
void operator +=(char c) Concatenation in place: the argument is appended to the string.

wxString::operator []
char& operator [](size_t i) char operator [](size_t i) char operator [](int i) Element extraction.

wxString::operator ()
wxString operator ()(size_t start, size_t len) Same as Mid (substring extraction).

wxString::operator <<
wxString& operator <<(const wxString& str) wxString& operator <<(const char* psz) wxString& operator <<(char ch) Same as +=. wxString& operator <<(int i) wxString& operator <<(float f) wxString& operator <<(double d) These functions work as C++ stream insertion operators: they insert the given value into the string. Precision or format cannot be set using them, you can use Printf (p. 1215) for this.

wxString::operator >>
friend istream& operator >>(istream& is, wxString& str) Extraction from a stream.

wxString::operator const char*

1220


CHAPTER 7
operator const char*() const Implicit conversion to a C string.

Comparison operators
bool operator ==(const wxString& x, const wxString& y) bool operator ==(const wxString& x, const char* t) bool operator !=(const wxString& x, const wxString& y) bool operator !=(const wxString& x, const char* t) bool operator >(const wxString& x, const wxString& y) bool operator >(const wxString& x, const char* t) bool operator >=(const wxString& x, const wxString& y) bool operator >=(const wxString& x, const char* t) bool operator <(const wxString& x, const wxString& y) bool operator <(const wxString& x, const char* t) bool operator <=(const wxString& x, const wxString& y) bool operator <=(const wxString& x, const char* t) Remarks These comparisons are case-sensitive.

wxStringBuffer
This tiny class allows to conveniently access the wxString (p. 1200) internal buffer as a writable pointer without any risk to forget to restore the string to the usable state later. For example, assuming you have a low-level OS function called GetMeaningOfLifeAsString(char *) returning the value in the provided buffer (which must be writable, of course) you might call it like this:
wxString theAnswer; GetMeaningOfLifeAsString(wxStringBuffer(theAnswer, 1024)); if ( theAnswer != "42" ) { wxLogError("Something is very wrong!"); }

Derived from None

1221


CHAPTER 7
Include files <wx/string.h>

wxStringBuffer::wxStringBuffer
wxStringBuffer(const wxString& str, size_t len) Constructs a writable string buffer object associated with the given string and containing enough space for at least len characters. Basically, this is equivalent to calling GetWriteBuf (p. 1211) and saving the result.

wxStringBuffer::~wxStringBuffer
~wxStringBuffer() Restores the string passed to the constructor to the usable state by calling UngetWriteBuf (p. 1218) on it.

wxStringBuffer::operator wxChar *
wxChar * operator wxChar *() const Returns the writable pointer to a buffer of the size at least equal to the length specified in the constructor.

wxStringClientData
Predefined client data class for holding a string. Derived from wxClientData (p. 134) Include files <clntdata.h> Data structures

wxStringClientData::wxStringClientData
wxStringClientData()

1222


CHAPTER 7
Empty constructor. wxStringClientData(const wxString& data) Create client data with string.

wxStringClientData::GetData
const wxString& GetData() const Get string client data.

wxStringClientData::SetData
void SetData(const wxString& data) Set string client data.

wxStringList
NB: This class is obsolete, please don't use it any longer. You can use either wxArrayString (p. 53) or a type safe (p. 786) list class instead. A string list is a list which is assumed to contain strings. Memory is allocated when strings are added to the list, and deallocated by the destructor or by the Delete member. Derived from wxList (p. 786) wxObject (p. 954) Include files <wx/list.h> See also wxString (p. 1200), wxList (p. 786)

wxStringList::wxStringList
wxStringList() Constructor. void wxStringList(char* first, ...)

1223


CHAPTER 7
Constructor, taking NULL-terminated string argument list. wxStringList allocates memory for the strings.

wxStringList::~wxStringList
~wxStringList() Deletes string list, deallocating strings.

wxStringList::Add
wxNode * Add(const wxString& s) Adds string to list, allocating memory.

wxStringList::Clear
void Clear() Clears all strings from the list.

wxStringList::Delete
void Delete(const wxString& s) Searches for string and deletes from list, deallocating memory.

wxStringList::ListToArray
char* ListToArray(bool new_copies = false) Converts the list to an array of strings, only allocating new memory if new_copies is true.

wxStringList::Member
bool Member(const wxString& s) Returns true if s is a member of the list (tested using strcmp).

wxStringList::Sort
void Sort() Sorts the strings in ascending alphabetical order. Note that all nodes (but not strings) get

1224


CHAPTER 7
deallocated and new ones allocated.

wxStringTokenizer
wxStringTokenizer helps you to break a string up into a number of tokens. It replaces the standard C function strtok() and also extends it in a number of ways. To use this class, you should create a wxStringTokenizer object, give it the string to tokenize and also the delimiters which separate tokens in the string (by default, white space characters will be used). Then GetNextToken (p. 1226) may be called repeatedly until it HasMoreTokens (p. 1226) returns false. For example:
wxStringTokenizer tkz(wxT("first:second:third:fourth"), wxT(":")); while ( tkz.HasMoreTokens() ) { wxString token = tkz.GetNextToken(); // process token here }

By default, wxStringTokenizer will behave in the same way as strtok() if the delimiters string only contains white space characters but, unlike the standard function, it will return empty tokens if this is not the case. This is helpful for parsing strictly formatted data where the number of fields is fixed but some of them may be empty (i.e. TAB or comma delimited text files). The behaviour is governed by the last constructor (p. 1226)/SetString (p. 1227) parameter mode which may be one of the following: wxTOKEN_DEFAULT Default behaviour (as described above): same as wxTOKEN_STRTOK if the delimiter string contains only whitespaces, same as wxTOKEN_RET_EMPTY otherwise In this mode, the empty tokens in the middle of the string will be returned, i.e. "a::b:" will be tokenized in three tokens 'a', '' and 'b'.

wxTOKEN_RET_EMPTY

wxTOKEN_RET_EMPTY_ALL In this mode, empty trailing token (after the last delimiter character) will be returned as well. The string as above will contain four tokens: the already mentioned ones and another empty one as the last one. wxTOKEN_RET_DELIMS In this mode, the delimiter character after the end of the current token (there may be none if this is the last token) is returned appended to the token. Otherwise, it is the same mode as wxTOKEN_RET_EMPTY. In this mode the class behaves exactly like the standard strtok() function. The empty tokens are never returned.

wxTOKEN_STRTOK

1225


CHAPTER 7
Derived from wxObject (p. 954) Include files <wx/tokenzr.h>

wxStringTokenizer::wxStringTokenizer
wxStringTokenizer() Default constructor. You must call SetString (p. 1227) before calling any other methods. wxStringTokenizer(const wxString& str, const wxString& delims = " \t\r\n", wxStringTokenizerMode mode = wxTOKEN_DEFAULT) Constructor. Pass the string to tokenize, a string containing delimiters and the mode specifying how the string should be tokenized.

wxStringTokenizer::CountTokens
int CountTokens() const Returns the number of tokens in the input string.

wxStringTokenizer::HasMoreTokens
bool HasMoreTokens() const Returns true if the tokenizer has further tokens, false if none are left.

wxStringTokenizer::GetNextToken
wxString GetNextToken() Returns the next token or empty string if the end of string was reached.

wxStringTokenizer::GetPosition
size_t GetPosition() const Returns the current position (i.e. one index after the last returned token or 0 if GetNextToken() has never been called) in the original string.

1226


CHAPTER 7 wxStringTokenizer::GetString
wxString GetString() const Returns the part of the starting string without all token already extracted.

wxStringTokenizer::SetString
void SetString(const wxString& to_tokenize, const wxString& delims = " \t\r\n", wxStringTokenizerMode mode = wxTOKEN_DEFAULT) Initializes the tokenizer. Pass the string to tokenize, a string containing delimiters, and the mode specifying how the string should be tokenized.

wxSysColourChangedEvent
This class is used for system colour change events, which are generated when the user changes the colour settings using the control panel. This is only appropriate under Windows. Derived from wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process a system colour changed event, use this event handler macro to direct input to a member function that takes a wxSysColourChanged argument. EVT_SYS_COLOUR_CHANGED(func) Process a wxEVT_SYS_COLOUR_CHANGED event. Remarks The default event handler for this event propagates the event to child windows, since Windows only sends the events to top-level windows. If intercepting this event for a toplevel window, remember to call the base class handler, or to pass the event on to the window's children explicitly. See also Event handling overview (p. 1602)

1227


CHAPTER 7 wxSysColourChangedEvent::wxSysColourChanged
wxSysColourChanged() Constructor.

wxSystemOptions
wxSystemOptions stores option/value pairs that wxWindows itself or applications can use to alter behaviour at run-time. It can be used to optimize behaviour that doesn't deserve a distinct API, but is still important to be able to configure. These options are currently recognised by wxWindows: Option no-maskblt Value 1 to never use WIN32's MaskBlt function, 0 to allow it to be used where possible. Default: 0. In some circumstances the MaskBlt function can be slower than using the fallback code, especially if using DC cacheing. By default, MaskBlt will be used where it is implemented by the operating system and driver. mgl.aa-threshold (wxMGL only) Set this integer option to point size below which fonts are not antialiased. Default: 10. (wxMGL only) Screen refresh rate in Hz. Reasonable default is used if not specified.

mgl.aa-threshold

The compile-time option to include or exclude this functionality is wxUSE_SYSTEM_OPTIONS. Derived from wxObject (p. 954) Include files <wx/sysopt.h>

wxSystemOptions::wxSystemOptions
wxSystemOptions() Default constructor. You don't need to create an instance of wxSystemOptions since all of its functions are static.

1228


CHAPTER 7 wxSystemOptions::GetOption
wxString GetOption(const wxString& name) const Gets an option. The function is case-insensitive to name. See also wxSystemOptions::SetOption (p. 1229), wxSystemOptions::GetOptionInt (p. 1229), wxSystemOptions::HasOption (p. 1229)

wxSystemOptions::GetOptionInt
int GetOptionInt(const wxString& name) const Gets an option as an integer. The function is case-insensitive to name. See also wxSystemOptions::SetOption (p. 1229), wxSystemOptions::GetOption (p. 1229), wxSystemOptions::HasOption (p. 1229)

wxSystemOptions::HasOption
bool HasOption(const wxString& name) const Returns true if the given option is present. The function is case-insensitive to name. See also wxSystemOptions::SetOption (p. 1229), wxSystemOptions::GetOption (p. 1229), wxSystemOptions::GetOptionInt (p. 1229)

wxSystemOptions::SetOption
void SetOption(const wxString& name, const wxString& value) void SetOption(const wxString& name, int value) Sets an option. The function is case-insensitive to name. See also wxSystemOptions::GetOption (p. 1229), wxSystemOptions::GetOptionInt (p. 1229), wxSystemOptions::HasOption (p. 1229)

wxSystemSettings
wxSystemSettings allows the application to ask for details about the system. This can

1229


CHAPTER 7
include settings such as standard colours, fonts, and user interface element sizes. Derived from wxObject (p. 954) Include files <wx/settings.h> See also wxFont (p. 510), wxColour (p. 150)

wxSystemSettings::wxSystemSettings
wxSystemSettings() Default constructor. You don't need to create an instance of wxSystemSettings since all of its functions are static.

wxSystemSettings::GetColour
static wxColour GetColour(wxSystemColour index) Returns a system colour. index can be one of: wxSYS_COLOUR_SCROLLBAR wxSYS_COLOUR_BACKGROUND wxSYS_COLOUR_ACTIVECAPTION The scrollbar grey area. The desktop colour. Active window caption.

wxSYS_COLOUR_INACTIVECAPTION Inactive window caption. wxSYS_COLOUR_MENU wxSYS_COLOUR_WINDOW wxSYS_COLOUR_WINDOWFRAME wxSYS_COLOUR_MENUTEXT wxSYS_COLOUR_WINDOWTEXT wxSYS_COLOUR_CAPTIONTEXT wxSYS_COLOUR_ACTIVEBORDER Menu background. Window background. Window frame. Menu text. Text in windows. Text in caption, size box and scrollbar arrow box. Active window border.

1230


CHAPTER 7
wxSYS_COLOUR_INACTIVEBORDER Inactive window border. wxSYS_COLOUR_APPWORKSPACE Background colour MDI applications. wxSYS_COLOUR_HIGHLIGHT wxSYS_COLOUR_HIGHLIGHTTEXT wxSYS_COLOUR_BTNFACE wxSYS_COLOUR_BTNSHADOW wxSYS_COLOUR_GRAYTEXT wxSYS_COLOUR_BTNTEXT Item(s) selected in a control. Text of item(s) selected in a control. Face shading on push buttons. Edge shading on push buttons. Greyed (disabled) text. Text on push buttons. Colour of text in active captions.

wxSYS_COLOUR_INACTIVECAPTIONTEXT wxSYS_COLOUR_BTNHIGHLIGHT wxSYS_COLOUR_3DDKSHADOW wxSYS_COLOUR_3DLIGHT wxSYS_COLOUR_INFOTEXT wxSYS_COLOUR_INFOBK wxSYS_COLOUR_DESKTOP wxSYS_COLOUR_3DFACE wxSYS_COLOUR_3DSHADOW wxSYS_COLOUR_3DHIGHLIGHT wxSYS_COLOUR_3DHILIGHT wxSYS_COLOUR_BTNHILIGHT

Highlight colour for buttons (same as wxSYS_COLOUR_3DHILIGHT). Dark shadow for three-dimensional display elements. Light colour for three-dimensional display elements. Text colour for tooltip controls. Background colour for tooltip controls. Same as wxSYS_COLOUR_BACKGROUND. Same as wxSYS_COLOUR_BTNFACE. Same as wxSYS_COLOUR_BTNSHADOW. Same as wxSYS_COLOUR_BTNHIGHLIGHT. Same as wxSYS_COLOUR_BTNHIGHLIGHT. Same as wxSYS_COLOUR_BTNHIGHLIGHT.

wxPython note: This static method is implemented in Python as a standalone function named wxSystemSettings_GetColour

wxSystemSettings::GetFont
static wxFont GetFont(wxSystemFont index) Returns a system font. index can be one of:

1231


CHAPTER 7
wxSYS_OEM_FIXED_FONT wxSYS_ANSI_FIXED_FONT wxSYS_ANSI_VAR_FONT wxSYS_SYSTEM_FONT wxSYS_DEVICE_DEFAULT_FONT wxSYS_DEFAULT_GUI_FONT wxSYS_ICONTITLE_FONT Original equipment manufacturer dependent fixed-pitch font. Windows fixed-pitch font. Windows variable-pitch (proportional) font. System font. Device-dependent font (Windows NT only). Default font for user interface objects such as menus and dialog boxes. Font for the icon titles (Windows only, same as default GUI font on other platforms

wxPython note: This static method is implemented in Python as a standalone function named wxSystemSettings_GetFont

wxSystemSettings::GetMetric
static int GetMetric(wxSystemMetric index) Returns a system metric. index can be one of: wxSYS_MOUSE_BUTTONS wxSYS_BORDER_X wxSYS_BORDER_Y wxSYS_CURSOR_X wxSYS_CURSOR_Y wxSYS_DCLICK_X Number of buttons on mouse, or zero if no mouse was installed. Width of single border. Height of single border. Width of cursor. Height of cursor. Width in pixels of rectangle within which two successive mouse clicks must fall to generate a double-click. Height in pixels of rectangle within which two successive mouse clicks must fall to generate a double-click. Width in pixels of a rectangle centered on a drag point to allow for limited movement of the mouse pointer before a drag operation begins. Height in pixels of a rectangle centered on a drag point to allow for limited movement of the

wxSYS_DCLICK_Y

wxSYS_DRAG_X

wxSYS_DRAG_Y

1232


CHAPTER 7
mouse pointer before a drag operation begins. wxSYS_EDGE_X wxSYS_EDGE_Y wxSYS_HSCROLL_ARROW_X wxSYS_HSCROLL_ARROW_Y wxSYS_HTHUMB_X wxSYS_ICON_X wxSYS_ICON_Y wxSYS_ICONSPACING_X Width of a 3D border, in pixels. Height of a 3D border, in pixels. Width of arrow bitmap on horizontal scrollbar. Height of arrow bitmap on horizontal scrollbar. Width of horizontal scrollbar thumb. The default width of an icon. The default height of an icon. Width of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of this size when arranged. Height of a grid cell for items in large icon view, in pixels. Each item fits into a rectangle of this size when arranged. Minimum width of a window. Minimum height of a window. Width of the screen in pixels. Height of the screen in pixels. Width of the window frame for a wxTHICK_FRAME window. Height of the window frame for a wxTHICK_FRAME window. Recommended width of a small icon (in window captions, and small icon view). Recommended height of a small icon (in window captions, and small icon view). Height of horizontal scrollbar in pixels. Width of vertical scrollbar in pixels. Width of arrow bitmap on a vertical scrollbar. Height of arrow bitmap on a vertical scrollbar. Height of vertical scrollbar thumb. Height of normal caption area.

wxSYS_ICONSPACING_Y

wxSYS_WINDOWMIN_X wxSYS_WINDOWMIN_Y wxSYS_SCREEN_X wxSYS_SCREEN_Y wxSYS_FRAMESIZE_X wxSYS_FRAMESIZE_Y wxSYS_SMALLICON_X wxSYS_SMALLICON_Y wxSYS_HSCROLL_Y wxSYS_VSCROLL_X wxSYS_VSCROLL_ARROW_X wxSYS_VSCROLL_ARROW_Y wxSYS_VTHUMB_Y wxSYS_CAPTION_Y

1233


CHAPTER 7
wxSYS_MENU_Y wxSYS_NETWORK_PRESENT wxSYS_PENWINDOWS_PRESENT wxSYS_SHOW_SOUNDS Height of single-line menu bar. 1 if there is a network present, 0 otherwise. 1 if PenWindows is installed, 0 otherwise. Non-zero if the user requires an application to present information visually in situations where it would otherwise present the information only in audible form; zero otherwise. Non-zero if the meanings of the left and right mouse buttons are swapped; zero otherwise.

wxSYS_SWAP_BUTTONS

wxPython note: This static method is implemented in Python as a standalone function named wxSystemSettings_GetMetric

wxTabCtrl
This class represents a tab control, which manages multiple tabs. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/tabctrl.h> See also wxTabEvent (p. 1239), wxImageList (p. 754), wxNotebook (p. 943)

wxTabCtrl::wxTabCtrl
wxTabCtrl() Default constructor. wxTabCtrl(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size, long style = 0, const wxString& name = "tabCtrl") Constructs a tab control. Parameters

1234


CHAPTER 7
parent The parent window. Must be non-NULL. id The window identifier. pos The window position. size The window size. style The window style. Its value is a bit list of zero or more of wxTC_MULTILINE, wxTC_RIGHTJUSTIFY, wxTC_FIXEDWIDTH and wxTC_OWNERDRAW.

wxTabCtrl::~wxTabCtrl
~wxTabCtrl() Destroys the wxTabCtrl object.

wxTabCtrl::Create
bool Create(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size, long style = 0, const wxString& name = "tabCtrl") Creates a tab control. See wxTabCtrl::wxTabCtrl (p. 1234) for a description of the parameters.

wxTabCtrl::DeleteAllItems
bool DeleteAllItems() Deletes all tab items.

wxTabCtrl::DeleteItem
bool DeleteItem(int item) Deletes the specified tab item.

1235


CHAPTER 7 wxTabCtrl::GetCurFocus
int GetCurFocus() const Returns the index for the tab with the focus, or -1 if none has the focus.

wxTabCtrl::GetImageList
wxImageList* GetImageList() const Returns the associated image list. See also wxImageList (p. 754), wxTabCtrl::SetImageList (p. 1238)

wxTabCtrl::GetItemCount
int GetItemCount() const Returns the number of tabs in the tab control.

wxTabCtrl::GetItemData
void* GetItemData() const Returns the client data for the given tab.

wxTabCtrl::GetItemImage
int GetItemImage() const Returns the image index for the given tab.

wxTabCtrl::GetItemRect
bool GetItemRect(int item, wxRect& rect) const Returns the rectangle bounding the given tab. See also wxRect (p. 1042)

wxTabCtrl::GetItemText

1236


CHAPTER 7
wxString GetItemText() const Returns the string for the given tab.

wxTabCtrl::GetRowCount
int GetRowCount() const Returns the number of rows in the tab control.

wxTabCtrl::GetSelection
int GetSelection() const Returns the index for the currently selected tab. See also wxTabCtrl::SetSelection (p. 1239)

wxTabCtrl::HitTest
int HitTest(const wxPoint& pt, long& flags) Tests whether a tab is at the specified position. Parameters pt Specifies the point for the hit test. flags Return value for detailed information. One of the following values: wxTAB_HITTEST_NOWHERE wxTAB_HITTEST_ONICON wxTAB_HITTEST_ONLABEL wxTAB_HITTEST_ONITEM There was no tab under this point. The point was over an icon. The point was over a label. The point was over an item, but not on the label or icon.

Return value Returns the zero-based tab index or -1 if no tab is at the specified position.

1237


CHAPTER 7 wxTabCtrl::InsertItem
void InsertItem(int item, const wxString& text, int imageId = -1, void* clientData = NULL) Inserts a new tab. Parameters item Specifies the index for the new item. text Specifies the text for the new item. imageId Specifies the optional image index for the new item. clientData Specifies the optional client data for the new item. Return value true if successful, false otherwise.

wxTabCtrl::SetItemData
bool SetItemData(int item, void* data) Sets the client data for a tab.

wxTabCtrl::SetItemImage
bool SetItemImage(int item, int image) Sets the image index for the given tab. image is an index into the image list which was set with wxTabCtrl::SetImageList (p. 1238).

wxTabCtrl::SetImageList
void SetImageList(wxImageList* imageList) Sets the image list for the tab control. See also wxImageList (p. 754)

1238


CHAPTER 7 wxTabCtrl::SetItemSize
void SetItemSize(const wxSize& size) Sets the width and height of the tabs.

wxTabCtrl::SetItemText
bool SetItemText(int item, const wxString& text) Sets the text for the given tab.

wxTabCtrl::SetPadding
void SetPadding(const wxSize& padding) Sets the amount of space around each tab's icon and label.

wxTabCtrl::SetSelection
int SetSelection(int item) Sets the selection for the given tab, returning the index of the previously selected tab. Returns -1 if the call was unsuccessful. See also wxTabCtrl::GetSelection (p. 1237)

wxTabEvent
This class represents the events generated by a tab control. Derived from wxCommandEvent (p. 164) wxEvent (p. 439) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/tabctrl.h> Event table macros To process a tab event, use these event handler macros to direct input to member functions that take a wxTabEvent argument.

1239


CHAPTER 7
EVT_TAB_SEL_CHANGED(id, func) Process a wxEVT_TAB_SEL_CHANGED event, indicating that the tab selection has changed.

EVT_TAB_SEL_CHANGING(id, func) Process a wxEVT_TAB_SEL_CHANGING event, indicating that the tab selection is changing. See also wxTabCtrl (p. 1234)

wxTabEvent::wxTabEvent
wxTabEvent(WXTYPE commandType = 0, int id = 0) Constructor.

wxTaskBarIcon
This class represents a taskbar icon, appearing in the 'system tray' and responding to mouse clicks. An icon has an optional tooltip. This class is only supported for Windows 95/NT and for X Window System ports (wxGTK, wxMotif, wxX11), assuming the window manager supports KDE and GNOME 1.2 systray methods. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/taskbar.h> Event handling To process input from a taskbar icon, use the following event handler macros to direct input to member functions that take a wxTaskBarIconEvent argument. EVT_TASKBAR_MOVE(func) EVT_TASKBAR_LEFT_DOWN(func) EVT_TASKBAR_LEFT_UP(func) Process a wxEVT_TASKBAR_MOVE event. Process a wxEVT_TASKBAR_LEFT_DOWN event. Process a wxEVT_TASKBAR_LEFT_UP event.

EVT_TASKBAR_RIGHT_DOWN(func) Process a wxEVT_TASKBAR_RIGHT_DOWN event. EVT_TASKBAR_RIGHT_UP(func) Process a wxEVT_TASKBAR_RIGHT_UP

1240


CHAPTER 7
event. EVT_TASKBAR_LEFT_DCLICK(func) Process a wxEVT_TASKBAR_LEFT_DCLICK event. EVT_TASKBAR_RIGHT_DCLICK(func)Process a wxEVT_TASKBAR_RIGHT_DCLICK event.

wxTaskBarIcon::wxTaskBarIcon
wxTaskBarIcon() Default constructor.

wxTaskBarIcon::~wxTaskBarIcon
~wxTaskBarIcon() Destroys the wxTaskBarIcon object, removing the icon if not already removed.

wxTaskBarIcon::IsIconInstalled
bool IsIconInstalled() Returns true if SetIcon (p. 1242) was called with no subsequent RemoveIcon (p. 1241).

wxTaskBarIcon::IsOk
bool IsOk() Returns true if the object initialized successfully.

wxTaskBarIcon::PopupMenu
bool PopupMenu(wxMenu* menu) Pops up a menu at the current mouse position. The events can be handled by a class derived from wxTaskBarIcon.

wxTaskBarIcon::RemoveIcon
bool RemoveIcon() Removes the icon previously set with SetIcon (p. 1242).

1241


CHAPTER 7 wxTaskBarIcon::SetIcon
bool SetIcon(const wxIcon& icon, const wxString& tooltip) Sets the icon, and optional tooltip text.

wxTempFile
wxTempFile provides a relatively safe way to replace the contents of the existing file. The name is explained by the fact that it may be also used as just a temporary file if you don't replace the old file contents. Usually, when a program replaces the contents of some file it first opens it for writing, thus losing all of the old data and then starts recreating it. This approach is not very safe because during the regeneration of the file bad things may happen: the program may find that there is an internal error preventing it from completing file generation, the user may interrupt it (especially if file generation takes long time) and, finally, any other external interrupts (power supply failure or a disk error) will leave you without either the original file or the new one. wxTempFile addresses this problem by creating a temporary file which is meant to replace the original file - but only after it is fully written. So, if the user interrupts the program during the file generation, the old file won't be lost. Also, if the program discovers itself that it doesn't want to replace the old file there is no problem - in fact, wxTempFile will not replace the old file by default, you should explicitly call Commit (p. 1243) to do it. Calling Discard (p. 1244) explicitly discards any modifications: it closes and deletes the temporary file and leaves the original file unchanged. If you don't call neither of Commit() and Discard(), the destructor will call Discard() automatically. To summarize: if you want to replace another file, create an instance of wxTempFile passing the name of the file to be replaced to the constructor (you may also use default constructor and pass the file name to Open (p. 1243)). Then you can write (p. 1243) to wxTempFile using wxFile (p. 458)-like functions and later call Commit() to replace the old file (and close this one) or call Discard() to cancel the modifications. Derived from No base class Include files <wx/file.h> See also: wxFile (p. 458)

wxTempFile::wxTempFile

1242


CHAPTER 7
wxTempFile() Default constructor - Open (p. 1243) must be used to open the file.

wxTempFile::wxTempFile
wxTempFile(const wxString& strName) Associates wxTempFile with the file to be replaced and opens it. You should use IsOpened (p. 1243) to verify if the constructor succeeded.

wxTempFile::Open
bool Open(const wxString& strName) Open the temporary file, returns true on success, false if an error occurred. strName is the name of file to be replaced. The temporary file is always created in the directory where strName is. In particular, if strName doesn't include the path, it is created in the current directory and the program should have write access to it for the function to succeed.

wxTempFile::IsOpened
bool IsOpened() const Returns true if the file was successfully opened.

wxTempFile::Write
bool Write(const void *p, size_t n) Write to the file, return true on success, false on failure.

wxTempFile::Write
bool Write(const wxString& str, wxMBConv& conv = wxConvLibc) Write to the file, return true on success, false on failure. The second argument is only meaningful in Unicode build of wxWindows whenconv is used to convert str to multibyte representation.

wxTempFile::Commit
bool Commit()

1243


CHAPTER 7
Validate changes: deletes the old file of name m_strName and renames the new file to the old name. Returns true if both actions succeeded. If false is returned it may unfortunately mean two quite different things: either that either the old file couldn't be deleted or that the new file couldn't be renamed to the old name.

wxTempFile::Discard
void Discard() Discard changes: the old file contents is not changed, temporary file is deleted.

wxTempFile::~wxTempFile
~wxTempFile() Destructor calls Discard() (p. 1244) if temporary file is still opened.

wxTextAttr
wxTextAttr represents the character and paragraph attributes, or style, for a range of text in a wxTextCtrl (p. 1248). When setting up a wxTextAttr object, pass a bitlist mask to SetFlags to indicate which style elements should be changed. As a convenience, when you call a setter such as SetFont, the relevant bit will be set. Derived from No base class Include files <wx/textctrl.h> Typedefs wxTextPos is the type containing the index of a position in a text control. wxTextCoord contains the index of a column or a row in the control. Note that alghough both of these types should probably have been unsigned, due to backwards compatibility reasons, are defined as long currently. Their use (instead of plain long) is still encouraged as it makes the code more readable. Constants The following values can be passed to SetAlignment to determine paragraph alignment.
enum wxTextAttrAlignment { wxTEXT_ALIGNMENT_DEFAULT, wxTEXT_ALIGNMENT_LEFT,

1244


CHAPTER 7
wxTEXT_ALIGNMENT_CENTRE, wxTEXT_ALIGNMENT_CENTER = wxTEXT_ALIGNMENT_CENTRE, wxTEXT_ALIGNMENT_RIGHT, wxTEXT_ALIGNMENT_JUSTIFIED };

These values are passed in a bitlist to SetFlags to determine what attributes will be considered when setting the attributes for a text control.
#define wxTEXT_ATTR_TEXT_COLOUR 0x0001 #define wxTEXT_ATTR_BACKGROUND_COLOUR 0x0002 #define wxTEXT_ATTR_FONT_FACE 0x0004 #define wxTEXT_ATTR_FONT_SIZE 0x0008 #define wxTEXT_ATTR_FONT_WEIGHT 0x0010 #define wxTEXT_ATTR_FONT_ITALIC 0x0020 #define wxTEXT_ATTR_FONT_UNDERLINE 0x0040 #define wxTEXT_ATTR_FONT \ wxTEXT_ATTR_FONT_FACE | wxTEXT_ATTR_FONT_SIZE | wxTEXT_ATTR_FONT_WEIGHT \ | wxTEXT_ATTR_FONT_ITALIC | wxTEXT_ATTR_FONT_UNDERLINE #define wxTEXT_ATTR_ALIGNMENT 0x0080 #define wxTEXT_ATTR_LEFT_INDENT 0x0100 #define wxTEXT_ATTR_RIGHT_INDENT 0x0200 #define wxTEXT_ATTR_TABS 0x0400

The values below are the possible return codes of the HitTest (p. 1258) method:// the point asked is ... enum wxTextCtrlHitTestResult { wxTE_HT_UNKNOWN = -2, // this means HitTest() is simply not implemented wxTE_HT_BEFORE, // either to the left or upper wxTE_HT_ON_TEXT, // directly on wxTE_HT_BELOW, // below [the last line] wxTE_HT_BEYOND // after [the end of line] }; // ... the character returned

wxTextAttr::wxTextAttr
wxTextAttr() wxTextAttr(const wxColour& colText, const wxColour& colBack = wxNullColour, const wxFont& font = wxNullFont, wxTextAttrAlignment alignment = wxTEXT_ALIGNMENT_DEFAULT) The constructors initialize one or more of the text foreground colour, background colour, font, and alignment. The values not initialized in the constructor can be set later, otherwise wxTextCtrl::SetStyle (p. 1264) will use the default values for them.

wxTextAttr::GetAlignment 1245


CHAPTER 7
wxTextAttrAlignment GetAlignment() const Returns the paragraph alignment.

wxTextAttr::GetBackgroundColour
const wxColour& GetBackgroundColour() const Return the background colour specified by this attribute.

wxTextAttr::GetFont
const wxFont& GetFont() const Return the text font specified by this attribute.

wxTextAttr::GetLeftIndent
int GetLeftIndent() const Returns the left indent in tenths of a millimetre.

wxTextAttr::GetRightIndent
int GetRightIndent() const Returns the right indent in tenths of a millimetre.

wxTextAttr::GetTabs
const wxArrayInt& GetTabs() const Returns the array of integers representing the tab stops. Each array element specifies the tab stop in tenths of a millimetre.

wxTextAttr::GetTextColour
const wxColour& GetTextColour() const Return the text colour specified by this attribute.

wxTextAttr::HasBackgroundColour
bool HasBackgroundColour() const

1246


CHAPTER 7
Returns true if this style specifies the background colour to use.

wxTextAttr::HasFont
bool HasFont() const Returns true if this style specifies the font to use.

wxTextAttr::HasTextColour
bool HasTextColour() const Returns true if this style specifies the foreground colour to use.

wxTextAttr::GetFlags
long GetFlags() Returns a bitlist indicating which attributes will be set.

wxTextAttr::IsDefault
bool IsDefault() const Returns true if this style specifies any non-default attributes.

wxTextAttr::SetAlignment
void SetAlignment(wxTextAttrAlignment alignment) Sets the paragraph alignment.

wxTextAttr::SetBackgroundColour
void SetBackgroundColour(const wxColour& colour) Sets the background colour.

wxTextAttr::SetFlags
void SetFlags(long flags) Pass a bitlist indicating which attributes will be set.

1247


CHAPTER 7 wxTextAttr::SetFont
void SetFont(const wxFont& font) Sets the text font.

wxTextAttr::SetLeftIndent
void SetLeftIndent(int indent) Sets the left indent in tenths of a millimetre.

wxTextAttr::SetRightIndent
void SetRightIndent(int indent) Sets the right indent in tenths of a millimetre.

wxTextAttr::SetTabs
void SetTabs(const wxArrayInt& tabs) Sets the array of integers representing the tab stops. Each array element specifies the tab stop in tenths of a millimetre.

wxTextAttr::SetTextColour
void SetTextColour(const wxColour& colour) Sets the text colour.

wxTextCtrl
A text control allows text to be displayed and edited. It may be single line or multi-line. Derived from streambuf wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/textctrl.h>

1248


CHAPTER 7
Window styles wxTE_PROCESS_ENTER The control will generate the message wxEVENT_TYPE_TEXT_ENTER_COMMAND (otherwise pressing Enter key is either processed internally by the control or used for navigation between dialog controls). wxTE_PROCESS_TAB The control will receive EVT_CHAR messages for TAB pressed - normally, TAB is used for passing to the next control in a dialog instead. For the control created with this style, you can still use Ctrl-Enter to pass to the next control from the keyboard. The text control allows multiple lines. The text will be echoed as asterisks. The text will not be user-editable. Use rich text control under Win32, this allows to have more than 64Kb of text in the control even under Win9x. This style is ignored under other platforms. Use rich text control version 2.0 or 3.0 under Win32, this style is ignored under other platforms Highlight the URLs and generate the wxTextUrlEvents when mouse events occur over them. This style is supported under Win32 only and requires wxTE_RICH. By default, the Windows text control doesn't show the selection when it doesn't have focus - use this style to force it to always show it. It doesn't do anything under other platforms. A horizontal scrollbar will be created and used, so that text won't be wrapped. No effect under GTK+. The text in the control will be left-justified (default). The text in the control will be centered. The text in the control will be right-justified. Same as wxHSCROLL style. Wrap the lines too long to be shown entirely at any position (wxUniv only currently). Wrap the lines too long to be shown entirely at word boundaries only (wxUniv only currently).

wxTE_MULTILINE wxTE_PASSWORD wxTE_READONLY wxTE_RICH

wxTE_RICH2 wxTE_AUTO_URL

wxTE_NOHIDESEL

wxHSCROLL wxTE_LEFT wxTE_CENTRE wxTE_RIGHT wxTE_DONTWRAP wxTE_LINEWRAP wxTE_WORDWRAP

See also window styles overview (p. 1611) andwxTextCtrl::wxTextCtrl (p. 1252).

1249


CHAPTER 7
wxTextCtrl text format The multiline text controls always store the text as a sequence of lines separated by \n characters, i.e. in the Unix text format even on non-Unix platforms. This allows the user code to ignore the differences between the platforms but at a price: the indices in the control such as those returned by GetInsertionPoint (p. 1255) or GetSelection (p. 1257) can not be used as indices into the string returned by GetValue (p. 1258) as they're going to be slightly off for platforms using \r\n as separator (as Windows does), for example. Instead, if you need to obtain a substring between the 2 indices obtained from the control with the help of the functions mentioned above, you should use GetRange (p. 1257). And the indices themselves can only be passed to other methods, for example SetInsertionPoint (p. 1263) or SetSelection (p. 1264). To summarize: never use the indices returned by (multiline) wxTextCtrl as indices into the string it contains, but only as arguments to be passed back to the other wxTextCtrl methods. wxTextCtrl styles Multi-line text controls support the styles, i.e. provide a possibility to set colours and font for individual characters in it (note that under Windows wxTE_RICH style is required for style support). To use the styles you can either call SetDefaultStyle (p. 1262) before inserting the text or call SetStyle (p. 1264) later to change the style of the text already in the control (the first solution is much more efficient). In either case, if the style doesn't specify some of the attributes (for example you only want to set the text colour but without changing the font nor the text background), the values of the default style will be used for them. If there is no default style, the attributes of the text control itself are used. So the following code correctly describes what it does: the second call to SetDefaultStyle (p. 1262) doesn't change the text foreground colour (which stays red) while the last one doesn't change the background colour (which stays grey):
text->SetDefaultStyle(wxTextAttr(*wxRED)); text->AppendText("Red text\n"); text->SetDefaultStyle(wxTextAttr(wxNullColour, *wxLIGHT_GREY)); text->AppendText("Red on grey text\n"); text->SetDefaultStyle(wxTextAttr(*wxBLUE); text->AppendText("Blue on grey text\n");

wxTextCtrl and C++ streams This class multiply-inherits from streambuf where compilers allow, allowing code such as the following:
wxTextCtrl *control = new wxTextCtrl(...); ostream stream(control) stream << 123.456 << " some text\n"; stream.flush();

If your compiler does not support derivation from streambuf and gives a compile error,

1250


CHAPTER 7
define the symbol NO_TEXT_WINDOW_STREAM in the wxTextCtrl header file. Note that independently of this setting you can always use wxTextCtrl itself in a streamlike manner:
wxTextCtrl *control = new wxTextCtrl(...); *control << 123.456 << " some text\n";

always works. However the possibility to create an ostream associated with wxTextCtrl may be useful if you need to redirect the output of a function taking an ostream as parameter to a text control. Another commonly requested need is to redirect std::cout to the text control. This could be done in the following way:
#include <iostream> wxTextCtrl *control = new wxTextCtrl(...); std::streambuf *sbOld = std::cout.rdbuf(); std::cout.rdbuf(*control); // use cout as usual, the output appears in the text control ... std::cout.rdbuf(sbOld);

But wxWindows provides a convenient class to make it even simpler so instead you may just do
#include <iostream> wxTextCtrl *control = new wxTextCtrl(...); wxStreamToTextRedirector redirect(control); // all output to cout goes into the text control until the exit from current // scope

See wxStreamToTextRedirector (p. 1198) for more details. Event handling The following commands are processed by default event handlers in wxTextCtrl: wxID_CUT, wxID_COPY, wxID_PASTE, wxID_UNDO, wxID_REDO. The associated UI update events are also processed automatically, when the control has the focus. To process input from a text control, use these event handler macros to direct input to member functions that take a wxCommandEvent (p. 164) argument. EVT_TEXT(id, func) Respond to a wxEVT_COMMAND_TEXT_UPDATED event, generated when the text changes. Notice that this event will always be sent when the text controls contents changes - whether this is due to user input or comes from the program itself (for example, if SetValue() is called)

1251


CHAPTER 7
EVT_TEXT_ENTER(id, func) Respond to a wxEVT_COMMAND_TEXT_ENTER event, generated when enter is pressed in a text control (which must have wxTE_PROCESS_ENTER style for this event to be generated). A mouse event occured over an URL in the text control (Win32 only) User tried to enter more text into the control than the limit set bySetMaxLength (p. 1263).

EVT_TEXT_URL(id, func) EVT_TEXT_MAXLEN(id, func)

wxTextCtrl::wxTextCtrl
wxTextCtrl() Default constructor. wxTextCtrl(wxWindow* parent, wxWindowID id, const wxString& value = "", const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = wxTextCtrlNameStr) Constructor, creating and showing a text control. Parameters parent Parent window. Should not be NULL. id Control identifier. A value of -1 denotes a default value. value Default text value. pos Text control position. size Text control size. style Window style. See wxTextCtrl (p. 1248). validator

1252


CHAPTER 7
Window validator. name Window name. Remarks The horizontal scrollbar (wxHSCROLL style flag) will only be created for multi-line text controls. Without a horizontal scrollbar, text lines that don't fit in the control's size will be wrapped (but no newline character is inserted). Single line controls don't have a horizontal scrollbar, the text is automatically scrolled so that the insertion point (p. 1255) is always visible. See also wxTextCtrl::Create (p. 1254), wxValidator (p. 1358)

wxTextCtrl::~wxTextCtrl
~wxTextCtrl() Destructor, destroying the text control.

wxTextCtrl::AppendText
void AppendText(const wxString& text) Appends the text to the end of the text control. Parameters text Text to write to the text control. Remarks After the text is appended, the insertion point will be at the end of the text control. If this behaviour is not desired, the programmer should use GetInsertionPoint (p. 1255) and SetInsertionPoint (p. 1263). See also wxTextCtrl::WriteText (p. 1265)

wxTextCtrl::CanCopy
virtual bool CanCopy() Returns true if the selection can be copied to the clipboard.

1253


CHAPTER 7 wxTextCtrl::CanCut
virtual bool CanCut() Returns true if the selection can be cut to the clipboard.

wxTextCtrl::CanPaste
virtual bool CanPaste() Returns true if the contents of the clipboard can be pasted into the text control. On some platforms (Motif, GTK) this is an approximation and returns true if the control is editable, false otherwise.

wxTextCtrl::CanRedo
virtual bool CanRedo() Returns true if there is a redo facility available and the last operation can be redone.

wxTextCtrl::CanUndo
virtual bool CanUndo() Returns true if there is an undo facility available and the last operation can be undone.

wxTextCtrl::Clear
virtual void Clear() Clears the text in the control. Note that this function will generate a wxEVT_COMMAND_TEXT_UPDATEDevent.

wxTextCtrl::Copy
virtual void Copy() Copies the selected text to the clipboard under Motif and MS Windows.

wxTextCtrl::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& value = "", const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& validator = wxDefaultValidator, const wxString& name = wxTextCtrlNameStr)

1254


CHAPTER 7
Creates the text control for two-step construction. Derived classes should call or replace this function. See wxTextCtrl::wxTextCtrl (p. 1252) for further details.

wxTextCtrl::Cut
virtual void Cut() Copies the selected text to the clipboard and removes the selection.

wxTextCtrl::DiscardEdits
void DiscardEdits() Resets the internal 'modified' flag as if the current edits had been saved.

wxTextCtrl::EmulateKeyPress
bool EmulateKeyPress(const wxKeyEvent& event) This functions inserts into the control the character which would have been inserted if the given key event had occured in the text control. The event object should be the same as the one passed to EVT_KEY_DOWNhandler previously by wxWindows. Please note that this function doesn't currently work correctly for all keys under any platform but MSW. Return value true if the event resulted in a change to the control, falseotherwise.

wxTextCtrl::GetDefaultStyle
const wxTextAttr& GetDefaultStyle() const Returns the style currently used for the new text. See also SetDefaultStyle (p. 1262)

wxTextCtrl::GetInsertionPoint
virtual long GetInsertionPoint() const Returns the insertion point. This is defined as the zero based index of the character position to the right of the insertion point. For example, if the insertion point is at the end of the text control, it is equal to both GetValue() (p. 1258).Length() andGetLastPosition() (p. 1256).

1255


CHAPTER 7
The following code snippet safely returns the character at the insertion point or the zero character if the point is at the end of the control.
char GetCurrentChar(wxTextCtrl *tc) { if (tc> GetInsertionPoint() == tc->GetLastPosition()) return '\0'; return tc->GetValue[tc->GetInsertionPoint()]; }

wxTextCtrl::GetLastPosition
virtual long GetLastPosition() const Returns the zero based index of the last position in the text control, which is equal to the number of characters in the control.

wxTextCtrl::GetLineLength
int GetLineLength(long lineNo) const Gets the length of the specified line, not including any trailing newline character(s). Parameters lineNo Line number (starting from zero). Return value The length of the line, or -1 if lineNo was invalid.

wxTextCtrl::GetLineText
wxString GetLineText(long lineNo) const Returns the contents of a given line in the text control, not including any trailing newline character(s). Parameters lineNo The line number, starting from zero. Return value The contents of the line.

wxTextCtrl::GetNumberOfLines

1256


CHAPTER 7
int GetNumberOfLines() const Returns the number of lines in the text control buffer. Remarks Note that even empty text controls have one line (where the insertion point is), so GetNumberOfLines() never returns 0. For gtk_text (multi-line) controls, the number of lines is calculated by actually counting newline characters in the buffer. You may wish to avoid using functions that work with line numbers if you are working with controls that contain large amounts of text.

wxTextCtrl::GetRange
virtual wxString GetRange(long from, long to) const Returns the string containing the text staring in the positions from and up to to in the control. The positions must have been returned by another wxTextCtrl method. Please note that the positions in a multiline wxTextCtrl do notcorrespond to the indices in the string returned by GetValue (p. 1258) because of the different new line representations (CR or CR LF) and so this method should be used to obtain the correct results instead of extracting parts of the entire value. It may also be more efficient, especially if the control contains a lot of data.

wxTextCtrl::GetSelection
virtual void GetSelection(long* from, long* to) const Gets the current selection span. If the returned values are equal, there was no selection. Please note that the indices returned may be used with the other wxTextctrl methods but don't necessarily represent the correct indices into the string returned by GetValue() (p. 1258) for multiline controls under Windows (at least,) you should useGetStringSelection() (p. 1258) to get the selected text. Parameters from The returned first position. to The returned last position. wxPython note: The wxPython version of this method returns a tuple consisting of the from and to values. wxPerl note: In wxPerl this method takes no parameter and returns a 2-element list ( from, to ).

1257


CHAPTER 7 wxTextCtrl::GetStringSelection
virtual wxString GetStringSelection() Gets the text currently selected in the control. If there is no selection, the returned string is empty.

wxTextCtrl::GetStyle
bool GetStyle(long position, wxTextAttr& style) Returns the style at this position in the text control. Not all platforms support this function. Return value true on success, false if an error occured - it may also mean that the styles are not supported under this platform. See also wxTextCtrl::SetStyle (p. 1264), wxTextAttr (p. 1244)

wxTextCtrl::GetValue
wxString GetValue() const Gets the contents of the control. Notice that for a multiline text control, the lines will be separated by (Unix-style) \n characters, even under Windows where they are separated by a \r\n sequence in the native control.

wxTextCtrl::HitTest
wxTextCtrlHitTestResult HitTest(const wxPoint& pt, wxTextCoord *col, wxTextCoord *row) const This function finds the character at the specified position expressed in pixels. If the return code is not wxTE_HT_UNKNOWN the row and column of the character closest to this position are returned in the col and row parameters (unless the pointers are NULL which is allowed). Please note that this function is currently only implemented in wxUniv and wxMSW ports. See also PositionToXY (p. 1260), XYToPosition (p. 1266),

wxTextCtrl::IsEditable 1258


CHAPTER 7
bool IsEditable() const Returns true if the controls contents may be edited by user (note that it always can be changed by the program), i.e. if the control hasn't been put in read-only mode by a previous call to SetEditable (p. 1262).

wxTextCtrl::IsModified
bool IsModified() const Returns true if the text has been modified by user. Note that calling SetValue (p. 1264) doesn't make the control modified.

wxTextCtrl::IsMultiLine
bool IsMultiLine() const Returns true if this is a multi line edit control and falseotherwise. See also IsSingleLine (p. 1259)

wxTextCtrl::IsSingleLine
bool IsSingleLine() const Returns true if this is a single line edit control and falseotherwise. See also IsMultiLine (p. 1259)

wxTextCtrl::LoadFile
bool LoadFile(const wxString& filename) Loads and displays the named file, if it exists. Parameters filename The filename of the file to load. Return value true if successful, false otherwise.

1259


CHAPTER 7 wxTextCtrl::OnDropFiles
void OnDropFiles(wxDropFilesEvent& event) This event handler function implements default drag and drop behaviour, which is to load the first dropped file into the control. Parameters event The drop files event. Remarks This is not implemented on non-Windows platforms. See also wxDropFilesEvent (p. 425)

wxTextCtrl::Paste
virtual void Paste() Pastes text from the clipboard to the text item.

wxTextCtrl::PositionToXY
bool PositionToXY(long pos, long *x, long *y) const Converts given position to a zero-based column, line number pair. Parameters pos Position. x Receives zero based column number. y Receives zero based line number. Return value true on success, false on failure (most likely due to a too large position parameter). See also

1260


CHAPTER 7
wxTextCtrl::XYToPosition (p. 1266) wxPython note: In Python, PositionToXY() returns a tuple containing the x and y values, so (x,y) = PositionToXY() is equivalent to the call described above. wxPerl note: In wxPerl this method only takes the pos parameter, and returns a 2element list ( x, y ).

wxTextCtrl::Redo
virtual void Redo() If there is a redo facility and the last operation can be redone, redoes the last operation. Does nothing if there is no redo facility.

wxTextCtrl::Remove
virtual void Remove(long from, long to) Removes the text starting at the first given position up to (but not including) the character at the last position. Parameters from The first position. to The last position.

wxTextCtrl::Replace
virtual void Replace(long from, long to, const wxString& value) Replaces the text starting at the first position up to (but not including) the character at the last position with the given text. Parameters from The first position. to The last position. value

1261


CHAPTER 7
The value to replace the existing text with.

wxTextCtrl::SaveFile
bool SaveFile(const wxString& filename) Saves the contents of the control in a text file. Parameters filename The name of the file in which to save the text. Return value true if the operation was successful, false otherwise.

wxTextCtrl::SetDefaultStyle
bool SetDefaultStyle(const wxTextAttr& style) Changes the default style to use for the new text which is going to be added to the control using WriteText (p. 1265) or AppendText (p. 1253). If either of the font, foreground, or background colour is not set in style, the values of the previous default style are used for them. If the previous default style didn't set them neither, the global font or colours of the text control itself are used as fall back. However if the style parameter is the default wxTextAttr, then the default style is just reset (instead of being combined with the new style which wouldn't change it at all). Parameters style The style for the new text. Return value true on success, false if an error occured - may also mean that the styles are not supported under this platform. See also GetDefaultStyle (p. 1255)

wxTextCtrl::SetEditable
virtual void SetEditable(const bool editable)

1262


CHAPTER 7
Makes the text item editable or read-only, overriding the wxTE_READONLY flag. Parameters editable If true, the control is editable. If false, the control is read-only. See also IsEditable (p. 1258)

wxTextCtrl::SetInsertionPoint
virtual void SetInsertionPoint(long pos) Sets the insertion point at the given position. Parameters pos Position to set.

wxTextCtrl::SetInsertionPointEnd
virtual void SetInsertionPointEnd() Sets the insertion point at the end of the text control. This is equivalent to SetInsertionPoint (p. 1263)(GetLastPosition (p. 1256)()).

wxTextCtrl::SetMaxLength
virtual void SetMaxLength(unsigned long len) This function sets the maximum number of characters the user can enter into the control. In other words, it allows to limit the text value length to lennot counting the terminating NUL character. If len is 0, the previously set max length limit, if any, is discarded and the user may enter as much text as the underlying native text control widget supports (typically at least 32Kb). If the user tries to enter more characters into the text control when it already is filled up to the maximal length, awxEVT_COMMAND_TEXT_MAXLEN event is sent to notify the program about it (giving it the possibility to show an explanatory message, for example) and the extra input is discarded. Note that this function may only be used with single line text controls. Compatibility

1263


CHAPTER 7
Only implemented in wxMSW/wxGTK starting with wxWindows 2.3.2.

wxTextCtrl::SetSelection
virtual void SetSelection(long from, long to) Selects the text starting at the first position up to (but not including) the character at the last position. If both parameters are equal to -1 all text in the control is selected. Parameters from The first position. to The last position.

wxTextCtrl::SetStyle
bool SetStyle(long start, long end, const wxTextAttr& style) Changes the style of the given range. If any attribute within style is not set, the correspondign attribute from GetDefaultStyle() (p. 1255) is used. Parameters start The start of the range to change. end The end of the range to change. style The new style for the range. Return value true on success, false if an error occured - it may also mean that the styles are not supported under this platform. See also wxTextCtrl::GetStyle (p. 1258), wxTextAttr (p. 1244)

wxTextCtrl::SetValue

1264


CHAPTER 7
virtual void SetValue(const wxString& value) Sets the text value and marks the control as not-modified (which means that IsModified (p. 1259) would return false immediately after the call to SetValue). Note that this function will generate a wxEVT_COMMAND_TEXT_UPDATEDevent. Parameters value The new value to set. It may contain newline characters if the text control is multiline.

wxTextCtrl::ShowPosition
void ShowPosition(long pos) Makes the line containing the given position visible. Parameters pos The position that should be visible.

wxTextCtrl::Undo
virtual void Undo() If there is an undo facility and the last operation can be undone, undoes the last operation. Does nothing if there is no undo facility.

wxTextCtrl::WriteText
void WriteText(const wxString& text) Writes the text into the text control at the current insertion position. Parameters text Text to write to the text control. Remarks Newlines in the text string are the only control characters allowed, and they will cause appropriate line breaks. See wxTextCtrl::<< (p. 1266) and wxTextCtrl::AppendText (p. 1253) for more convenient ways of writing to the window.

1265


CHAPTER 7
After the write operation, the insertion point will be at the end of the inserted text, so subsequent write operations will be appended. To append text after the user may have interacted with the control, call wxTextCtrl::SetInsertionPointEnd (p. 1263) before writing.

wxTextCtrl::XYToPosition
long XYToPosition(long x, long y) Converts the given zero based column and line number to a position. Parameters x The column number. y The line number. Return value The position value.

wxTextCtrl::operator <<
wxTextCtrl& operator <<(const wxString& s) wxTextCtrl& operator <<(int i) wxTextCtrl& operator <<(long i) wxTextCtrl& operator <<(float f) wxTextCtrl& operator <<(double d) wxTextCtrl& operator <<(char c) Operator definitions for appending to a text control, for example:
wxTextCtrl *wnd = new wxTextCtrl(my_frame); (*wnd) << "Welcome to text control number " << 1 << ".\n";

wxTextDataObject
wxTextDataObject is a specialization of wxDataObject for text data. It can be used without change to paste data into the wxClipboard (p. 136) or a wxDropSource (p. 427). A user may wish to derive a new class from this class for providing text on-demand in order to minimize memory consumption when offering data in several formats, such as plain text and RTF because by default the text is stored in a string in this class, but it

1266


CHAPTER 7
might as well be generated when requested. For this, GetTextLength (p. 1267) and GetText (p. 1267) will have to be overridden. Note that if you already have the text inside a string, you will not achieve any efficiency gain by overriding these functions because copying wxStrings is already a very efficient operation (data is not actually copied because wxStrings are reference counted). wxPython note: If you wish to create a derived wxTextDataObject class in wxPython you should derive the class from wxPyTextDataObject in order to get Python-aware capabilities for the various virtual methods. Virtual functions to override This class may be used as is, but all of the data transfer functions may be overridden to increase efficiency. Derived from wxDataObjectSimple (p. 226) wxDataObject (p. 222) Include files <wx/dataobj.h> See also Clipboard and drag and drop overview (p. 1666), wxDataObject (p. 222), wxDataObjectSimple (p. 226), wxFileDataObject (p. 465), wxBitmapDataObject (p. 84)

wxTextDataObject::wxTextDataObject
wxTextDataObject(const wxString& text = wxEmptyString) Constructor, may be used to initialise the text (otherwise SetText (p. 1268) should be used later).

wxTextDataObject::GetTextLength
virtual size_t GetTextLength() const Returns the data size. By default, returns the size of the text data set in the constructor or using SetText (p. 1268). This can be overridden to provide text size data on-demand. It is recommended to return the text length plus 1 for a trailing zero, but this is not strictly required.

wxTextDataObject::GetText

1267


CHAPTER 7
virtual wxString GetText() const Returns the text associated with the data object. You may wish to override this method when offering data on-demand, but this is not required by wxWindows' internals. Use this method to get data in text form from the wxClipboard (p. 136).

wxTextDataObject::SetText
virtual void SetText(const wxString& strText) Sets the text associated with the data object. This method is called when the data object receives the data and, by default, copies the text into the member variable. If you want to process the text on the fly you may wish to override this function.

wxTextDropTarget
A predefined drop target for dealing with text data. Derived from wxDropTarget (p. 429) Include files <wx/dnd.h> See also Drag and drop overview (p. 1666), wxDropSource (p. 427), wxDropTarget (p. 429), wxFileDropTarget (p. 470)

wxTextDropTarget::wxTextDropTarget
wxTextDropTarget() Constructor.

wxTextDropTarget::OnDrop
virtual bool OnDrop(long x, long y, const void *data, size_t size) See wxDropTarget::OnDrop (p. 431). This function is implemented appropriately for text, and calls wxTextDropTarget::OnDropText (p. 1268).

wxTextDropTarget::OnDropText

1268


CHAPTER 7
virtual bool OnDropText(long x, long y, const char *data) Override this function to receive dropped text. Parameters x The x coordinate of the mouse. y The y coordinate of the mouse. data The data being dropped: a NULL-terminated string. Return value Return true to accept the data, false to veto the operation.

wxTextEntryDialog
This class represents a dialog that requests a one-line text string from the user. It is implemented as a generic wxWindows dialog. Derived from wxDialog (p. 367) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/textdlg.h> See also wxTextEntryDialog overview (p. 1650)

wxTextEntryDialog::wxTextEntryDialog
wxTextEntryDialog(wxWindow* parent, const wxString& message, const wxString& caption = "Please enter text", const wxString& defaultValue = "", long style = wxOK | wxCANCEL | wxCENTRE, const wxPoint& pos = wxDefaultPosition) Constructor. Use wxTextEntryDialog::ShowModal (p. 1270) to show the dialog.

1269


CHAPTER 7
Parameters parent Parent window. message Message to show on the dialog. defaultValue The default value, which may be the empty string. style A dialog style, specifying the buttons (wxOK, wxCANCEL) and an optional wxCENTRE style. Additionally, wxTextCtrl styles (such aswxTE_PASSWORD may be specified here. pos Dialog position.

wxTextEntryDialog::~wxTextEntryDialog
~wxTextEntryDialog() Destructor.

wxTextEntryDialog::GetValue
wxString GetValue() const Returns the text that the user has entered if the user has pressed OK, or the original value if the user has pressed Cancel.

wxTextEntryDialog::SetValue
void SetValue(const wxString& value) Sets the default text value.

wxTextEntryDialog::ShowModal
int ShowModal() Shows the dialog, returning wxID_OK if the user pressed OK, and wxOK_CANCEL otherwise.

1270


CHAPTER 7

wxTextFile
The wxTextFile is a simple class which allows to work with text files on line by line basis. It also understands the differences in line termination characters under different platforms and will not do anything bad to files with "non native" line termination sequences - in fact, it can be also used to modify the text files and change the line termination characters from one type (say DOS) to another (say Unix). One word of warning: the class is not at all optimized for big files and so it will load the file entirely into memory when opened. Of course, you should not work in this way with large files (as an estimation, anything over 1 Megabyte is surely too big for this class). On the other hand, it is not a serious limitation for the small files like configuration files or programs sources which are well handled by wxTextFile. The typical things you may do with wxTextFile in order are:  Create and open it: this is done with either Create (p. 1272) or Open (p. 1276) function which opens the file (name may be specified either as the argument to these functions or in the constructor), reads its contents in memory (in the case of Open()) and closes it. Work with the lines in the file: this may be done either with "direct access" functions like GetLineCount (p. 1273) and GetLine (p. 1273) (operator[] does exactly the same but looks more like array addressing) or with "sequential access" functions which include GetFirstLine (p. 1274)/GetNextLine (p. 1274) and also GetLastLine (p. 1275)/GetPrevLine (p. 1275). For the sequential access functions the current line number is maintained: it is returned by GetCurrentLine (p. 1273) and may be changed with GoToLine (p. 1274). Add/remove lines to the file: AddLine (p. 1272) and InsertLine (p. 1275) add new lines while RemoveLine (p. 1276) deletes the existing ones.Clear (p. 1276) resets the file to empty. Save your changes: notice that the changes you make to the file will not be saved automatically; calling Close (p. 1272) or doing nothing discards them! To save the changes you must explicitly call Write (p. 1276) - here, you may also change the line termination type if you wish.







Derived from No base class Include files <wx/textfile.h> Data structures The following constants identify the line termination type:
enum wxTexFileType t { wxTextFileType_None, wxTextFileType_Unix,

// incomplete (the last line of the file only) // line is terminated with 'LF' = 0xA = 10 =

1271


CHAPTER 7
'\n' wxTextFileType_Dos, wxTextFileType_Mac '\r' }; // // 'CR' 'LF' 'CR' = 0xD = 13 =

See also wxFile (p. 458)

wxTextFile::wxTextFile
wxTextFile() const Default constructor, use Create (p. 1272) or Open (p. 1276) with a file name parameter to initialize the object.

wxTextFile::wxTextFile
wxTextFile(const wxString& strFile) const Constructor does not load the file into memory, use Open() to do it.

wxTextFile::~wxTextFile
~wxTextFile() const Destructor does nothing.

wxTextFile::AddLine
void AddLine(const wxString& str, wxTextFileType type = typeDefault) const Adds a line to the end of file.

wxTextFile::Close
bool Close() const Closes the file and frees memory, losing all changes. Use Write() (p. 1276) if you want to save them.

wxTextFile::Create
bool Create() const

1272


CHAPTER 7
bool Create(const wxString& strFile) const Creates the file with the given name or the name which was given in theconstructor (p. 1272). The array of file lines is initially empty. It will fail if the file already exists, Open (p. 1276) should be used in this case.

wxTextFile::Exists
bool Exists() const Return true if file exists - the name of the file should have been specified in the constructor before calling Exists().

wxTextFile::IsOpened
bool IsOpened() const Returns true if the file is currently opened.

wxTextFile::GetLineCount
size_t GetLineCount() const Get the number of lines in the file.

wxTextFile::GetLine
wxString& GetLine(size_t n) const Retrieves the line number n from the file. The returned line may be modified but you shouldn't add line terminator at the end - this will be done by wxTextFile.

wxTextFile::operator[]
wxString& operator[](size_t n) const The same as GetLine (p. 1273).

wxTextFile::GetCurrentLine
size_t GetCurrentLine() const Returns the current line: it has meaning only when you're using GetFirstLine()/GetNextLine() functions, it doesn't get updated when you're using "direct access" functions like GetLine(). GetFirstLine() and GetLastLine() also change the value

1273


CHAPTER 7
of the current line, as well as GoToLine().

wxTextFile::GoToLine
void GoToLine(size_t n) const Changes the value returned by GetCurrentLine (p. 1273) and used by GetFirstLine() (p. 1274)/GetNextLine() (p. 1274).

wxTextFile::Eof
bool Eof() const Returns true if the current line is the last one.

wxTextFile::GetEOL
static const char* GetEOL(wxTextFileType type = typeDefault) const Get the line termination string corresponding to given constant. typeDefault is the value defined during the compilation and corresponds to the native format of the platform, i.e. it will be wxTextFileType_Dos under Windows, wxTextFileType_Unix under Unix (including Mac OS X when compiling with the Apple Developer Tools) and wxTextFileType_Mac under Mac OS (including Mac OS X when compiling with CodeWarrior).

wxTextFile::GetFirstLine
wxString& GetFirstLine() const This method together with GetNextLine() (p. 1274) allows more "iterator-like" traversal of the list of lines, i.e. you may write something like:
wxTextFile file; ... for ( str = file.GetFirstLine(); !file.Eof(); str = file.GetNextLine() ) { // do something with the current line in str } // do something with the last line in str

wxTextFile::GetNextLine
wxString& GetNextLine() Gets the next line (see GetFirstLine (p. 1274) for the example).

1274


CHAPTER 7 wxTextFile::GetPrevLine
wxString& GetPrevLine() Gets the previous line in the file.

wxTextFile::GetLastLine
wxString& GetLastLine() Gets the last line of the file. Together with GetPrevLine (p. 1275) it allows to enumerate the lines in the file from the end to the beginning like this:
wxTextFile file; ... for ( str = file.GetLastLine(); file.GetCurrentLine() > 0; str = file.GetPrevLine() ) { // do something with the current line in str } // do something with the first line in str

wxTextFile::GetLineType
wxTextFileType GetLineType(size_t n) const Get the type of the line (see also GetEOL (p. 1274))

wxTextFile::GuessType
wxTextFileType GuessType() const Guess the type of file (which is supposed to be opened). If sufficiently many lines of the file are in DOS/Unix/Mac format, the corresponding value will be returned. If the detection mechanism fails wxTextFileType_None is returned.

wxTextFile::GetName
const char* GetName() const Get the name of the file.

wxTextFile::InsertLine
void InsertLine(const wxString& str, size_t n, wxTextFileType type = typeDefault) const Insert a line before the line number n.

1275


CHAPTER 7 wxTextFile::Open
bool Open(wxMBConv& conv = wxConvUTF8) const bool Open(const wxString& strFile, wxMBConv& conv = wxConvUTF8) const Open() opens the file with the given name or the name which was given in theconstructor (p. 1272) and also loads file in memory on success. It will fail if the file does not exist, Create (p. 1272) should be used in this case. The conv argument is only meaningful in Unicode build of wxWindows when it is used to convert the file to wide character representation.

wxTextFile::RemoveLine
void RemoveLine(size_t n) const Delete line number n from the file.

wxTextFile::Clear
void Clear() const Delete all lines from the file, set current line number to 0.

wxTextFile::Write
bool Write(wxTextFileType typeNew = wxTextFileType_None, wxMBConv& conv = wxConvUTF8) const Change the file on disk. The typeNew parameter allows you to change the file format (default argument means "don't change type") and may be used to convert, for example, DOS files to Unix. The conv argument is only meaningful in Unicode build of wxWindows when it is used to convert all lines to multibyte representation before writing them them to physical file. Returns true if operation succeeded, false if it failed.

wxTextInputStream
This class provides functions that read text datas using an input stream. So, you can read text floats, integers. The wxTextInputStream correctly reads text files (or streams) in DOS, Macintosh and Unix formats and reports a single newline char as a line ending. Operator >> is overloaded and you can use this class like a standard C++ iostream.

1276


CHAPTER 7
Note, however, that the arguments are the fixed size types wxUint32, wxInt32 etc and on a typical 32-bit computer, none of these match to the "long" type (wxInt32 is defined as int on 32-bit architectures) so that you cannot use long. To avoid problems (here and elsewhere), make use of wxInt32, wxUint32 and similar types. If you're scanning through a file using wxTextInputStream, you should check for EOF beforereading the next item (word / number), because otherwise the last item may get lost. You should however be prepared to receive an empty item (empty string / zero number) at the end of file, especially on Windows systems. This is unavoidable because most (but not all) files end with whitespace (i.e. usually a newline). For example:
wxFileInputStream input( "mytext.txt" ); wxTextInputStream text( input ); wxUint8 i1; float f2; wxString line; text >> i1; // read a 8 bit integer. text >> i1 >> f2; // read a 8 bit integer followed by float. text >> line; // read a text line

Include files <wx/txtstrm.h>

wxTextInputStream::wxTextInputStream
wxTextInputStream(wxInputStream& stream, const wxString& sep=" \t", wxMBConv& conv = wxConvUTF8 ) Constructs a text stream object from an input stream. Only read methods will be available. Parameters stream The underlying input stream. sep The initial string separator characters. conv In Unicode build only: The encoding converter used to convert the bytes in the underlying input stream to characters.

wxTextInputStream::~wxTextInputStream

1277


CHAPTER 7
~wxTextInputStream() Destroys the wxTextInputStream object.

wxTextInputStream::Read8
wxUint8 Read8(int base = 10) Reads a single unsigned byte from the stream, given in base base. The value of base must be comprised between 2 and 36, inclusive, or be a special value 0 which means that the usual rules of C numbers are applied: if the number starts with 0x it is considered to be in base16, if it starts with 0 - in base 8 and in base 10 otherwise. Note that you may not want to specify the base 0 if you are parsing the numbers which may have leading zeroes as they can yield unexpected (to the user not familiar with C) results.

wxTextInputStream::Read8S
wxInt8 Read8S(int base = 10) Reads a single signed byte from the stream. See wxTextInputStream::Read8 (p. 1278) for the description of the base parameter.

wxTextInputStream::Read16
wxUint16 Read16(int base = 10) Reads a unsigned 16 bit integer from the stream. See wxTextInputStream::Read8 (p. 1278) for the description of the base parameter.

wxTextInputStream::Read16S
wxInt16 Read16S(int base = 10) Reads a signed 16 bit integer from the stream. See wxTextInputStream::Read8 (p. 1278) for the description of the base parameter.

wxTextInputStream::Read32
wxUint32 Read32(int base = 10) Reads a 32 bit unsigned integer from the stream. See wxTextInputStream::Read8 (p. 1278) for the description of the base parameter.

1278


CHAPTER 7 wxTextInputStream::Read32S
wxInt32 Read32S(int base = 10) Reads a 32 bit signed integer from the stream. See wxTextInputStream::Read8 (p. 1278) for the description of the base parameter.

wxTextInputStream::ReadChar
wxChar wxTextInputStream::ReadChar() Reads a character, returns 0 if there are no more characters in the stream.

wxTextInputStream::ReadDouble
double ReadDouble() Reads a double (IEEE encoded) from the stream.

wxTextInputStream::ReadLine
wxString wxTextInputStream::ReadLine() Reads a line from the input stream and returns it (without the end of line character).

wxTextInputStream::ReadString
wxString wxTextInputStream::ReadString() NB: This method is deprecated, use ReadLine (p. 1279) or ReadWord (p. 1279) instead. Same as ReadLine (p. 1279).

wxTextInputStream::ReadWord
wxString wxTextInputStream::ReadWord() Reads a word (a sequence of characters until the next separator) from the input stream. See also SetStringSeparators (p. 1279)

wxTextInputStream::SetStringSeparators

1279


CHAPTER 7
void SetStringSeparators(const wxString& sep) Sets the characters which are used to define the word boundaries in ReadWord (p. 1279). The default separators are the space and TAB characters.

wxTextOutputStream
This class provides functions that write text datas using an output stream. So, you can write text floats, integers. You can also simulate the C++ cout class:
wxFFileOutputStream output( stderr ); wxTextOutputStream cout( output ); cout << "This is a text line" << endl; cout << 1234; cout << 1.23456;

The wxTextOutputStream writes text files (or streams) on DOS, Macintosh and Unix in their native formats (concerning the line ending).

wxTextOutputStream::wxTextOutputStream
wxTextOutputStream(wxOutputStream& stream, wxEOL mode = wxEOL_NATIVE) Constructs a text stream object from an output stream. Only write methods will be available. Parameters stream The output stream. mode The end-of-line mode. One of wxEOL_NATIVE, wxEOL_DOS, wxEOL_MAC and wxEOL_UNIX.

wxTextOutputStream::~wxTextOutputStream
~wxTextOutputStream() Destroys the wxTextOutputStream object.

1280


CHAPTER 7 wxTextOutputStream::GetMode
wxEOL wxTextOutputStream::GetMode() Returns the end-of-line mode. One of wxEOL_DOS, wxEOL_MAC and wxEOL_UNIX.

wxTextOutputStream::SetMode
void wxTextOutputStream::SetMode(wxEOL mode = wxEOL_NATIVE) Set the end-of-line mode. One of wxEOL_NATIVE, wxEOL_DOS, wxEOL_MAC and wxEOL_UNIX.

wxTextOutputStream::Write8
void wxTextOutputStream::Write8(wxUint8 i8) Writes the single byte i8 to the stream.

wxTextOutputStream::Write16
void wxTextOutputStream::Write16(wxUint16 i16) Writes the 16 bit integer i16 to the stream.

wxTextOutputStream::Write32
void wxTextOutputStream::Write32(wxUint32 i32) Writes the 32 bit integer i32 to the stream.

wxTextOutputStream::WriteDouble
virtual void wxTextOutputStream::WriteDouble(double f) Writes the double f to the stream using the IEEE format.

wxTextOutputStream::WriteString
virtual void wxTextOutputStream::WriteString(const wxString& string) Writes string as a line. Depending on the end-of-line mode the end of line ('\n') characters in the string are converted to the correct line ending terminator.

wxTextValidator
1281


CHAPTER 7
wxTextValidator validates text controls, providing a variety of filtering behaviours. For more information, please see Validator overview (p. 1614). Derived from wxValidator (p. 1358) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/valtext.h> See also Validator overview (p. 1614), wxValidator (p. 1358),wxGenericValidator (p. 564)

wxTextValidator::wxTextValidator
wxTextValidator(const wxTextValidator& validator) Copy constructor. wxTextValidator(long style = wxFILTER_NONE, wxString* valPtr = NULL) Constructor, taking a style and optional pointer to a wxString variable. Parameters style A bitlist of flags, which can be: wxFILTER_NONE wxFILTER_ASCII wxFILTER_ALPHA No filtering takes place. Non-ASCII characters are filtered out. Non-alpha characters are filtered out.

wxFILTER_ALPHANUMERIC Non-alphanumeric characters are filtered out. wxFILTER_NUMERIC Non-numeric characters are filtered out.

wxFILTER_INCLUDE_LIST Use an include list. The validator checks if the user input is on the list, complaining if not. See wxTextValidator::SetIncludeList (p. 1284). wxFILTER_EXCLUDE_LIST Use an exclude list. The validator checks if the user input is on the list, complaining if it is. See wxTextValidator::SetExcludeList (p. 1284).

1282


CHAPTER 7
wxFILTER_INCLUDE_CHAR_LIST Use an include list. The validator checks if each input character is in the list (one character per list element), complaining if not. See wxTextValidator::SetIncludeList (p. 1284). wxFILTER_EXCLUDE_CHAR_LIST Use an include list. The validator checks if each input character is in the list (one character per list element), complaining if it is. See wxTextValidator::SetExcludeList (p. 1284). valPtr A pointer to a wxString variable that contains the value. This variable should have a lifetime equal to or longer than the validator lifetime (which is usually determined by the lifetime of the window).

wxTextValidator::~wxTextValidator
~wxTextValidator() Destructor.

wxTextValidator::Clone
virtual wxValidator* Clone() const Clones the text validator using the copy constructor.

wxTextValidator::GetExcludeList
wxStringList& GetExcludeList() const Returns a reference to the exclude list (the list of invalid values).

wxTextValidator::GetIncludeList
wxStringList& GetIncludeList() const Returns a reference to the include list (the list of valid values).

wxTextValidator::GetStyle
long GetStyle() const Returns the validator style.

1283


CHAPTER 7 wxTextValidator::OnChar
void OnChar(wxKeyEvent& event) Receives character input from the window and filters it according to the current validator style.

wxTextValidator::SetExcludeList
void SetExcludeList(const wxStringList& stringList) Sets the exclude list (invalid values for the user input).

wxTextValidator::SetIncludeList
void SetIncludeList(const wxStringList& stringList) Sets the include list (valid values for the user input).

wxTextValidator::SetStyle
void SetStyle(long style) Sets the validator style.

wxTextValidator::TransferFromWindow
virtual bool TransferFromWindow() Transfers the value in the text control to the string.

wxTextValidator::TransferToWindow
virtual bool TransferToWindow() Transfers the string value to the text control.

wxTextValidator::Validate
virtual bool Validate(wxWindow* parent) Validates the window contents against the include or exclude lists, depending on the validator style.

wxThread
1284


CHAPTER 7
A thread is basically a path of execution through a program. Threads are sometimes called light-weight processes, but the fundamental difference between threads and processes is that memory spaces of different processes are separated while all threads share the same address space. While it makes it much easier to share common data between several threads, it also makes much easier to shoot oneself in the foot, so careful use of synchronization objects such as mutexes (p. 938) and/or critical sections (p. 206) is recommended. There are two types of threads in wxWindows: detached and joinableones, just as in the POSIX thread API (but unlike Win32 threads where all threads are joinable). The difference between the two is that only joinable threads can return a return code -- this is returned by the Wait() function. Detached threads (the default type) cannot be waited for. You shouldn't hurry to create all the threads joinable, however, because this has a disadvantage as well: you must Wait() for a joinable thread or the system resources used by it will never be freed, and you also must delete the corresponding wxThread object yourself. In contrast, detached threads are of the "fire-and-forget" kind: you only have to start a detached thread and it will terminate and destroy itself. This means, of course, that all detached threads must be created on the heap because the thread will call delete this; upon termination. Joinable threads may be created on the stack although more usually they will be created on the heap as well. Don't create global thread objects because they allocate memory in their constructor, which will cause problems for the memory checking system. Derived from None. Include files <wx/thread.h> See also wxMutex (p. 938), wxCondition (p. 173), wxCriticalSection (p. 206)

wxThread::wxThread
wxThread(wxThreadKind kind = wxTHREAD_DETACHED) This constructor creates a new detached (default) or joinable C++ thread object. It does not create or start execution of the real thread -- for this you should use the Create (p. 1286) and Run (p. 1290) methods. The possible values for kind parameters are: wxTHREAD_DETACHED wxTHREAD_JOINABLE Create a detached thread. Create a joinable thread

1285


CHAPTER 7 wxThread::~wxThread
~wxThread() The destructor frees the resources associated with the thread. Notice that you should never delete a detached thread -- you may only callDelete (p. 1286) on it or wait until it terminates (and auto destructs) itself. Because the detached threads delete themselves, they can only be allocated on the heap. Joinable threads should be deleted explicitly. The Delete (p. 1286) and Kill (p. 1289) functions will not delete the C++ thread object. It is also safe to allocate them on stack.

wxThread::Create
wxThreadError Create(unsigned int stackSize = 0) Creates a new thread. The thread object is created in the suspended state, and you should call Run (p. 1290) to start running it. You may optionally specify the stack size to be allocated to it (Ignored on platforms that don't support setting it explicitly, eg. Unix). Return value One of: wxTHREAD_NO_ERROR wxTHREAD_NO_RESOURCE wxTHREAD_RUNNING There was no error. There were insufficient resources to create a new thread. The thread is already running.

wxThread::Delete
void Delete() Calling Delete (p. 1286) is a graceful way to terminate the thread. It asks the thread to terminate and, if the thread code is well written, the thread will terminate after the next call toTestDestroy (p. 1291) which should happen quite soon. However, if the thread doesn't call TestDestroy (p. 1291)often enough (or at all), the function will not return immediately, but wait until the thread terminates. As it may take a long time, and the message processing is not stopped during this function execution, message handlers may be called from inside it! Delete() may be called for a thread in any state: running, paused or even not yet created. Moreover, it must be called if Create (p. 1286) orRun (p. 1290) fail in order to free the memory occupied by the thread object. However, you should not call Delete() on a detached thread which already terminated -- doing so will probably result in a crash because the thread object doesn't exist any more. For detached threads Delete() will also delete the C++ thread object, but it will not do

1286


CHAPTER 7
this for joinable ones. This function can only be called from another thread context.

wxThread::Entry
virtual ExitCode Entry() This is the entry point of the thread. This function is pure virtual and must be implemented by any derived class. The thread execution will start here. The returned value is the thread exit code which is only useful for joinable threads and is the value returned by Wait (p. 1291). This function is called by wxWindows itself and should never be called directly.

wxThread::Exit
void Exit(ExitCode exitcode = 0) This is a protected function of the wxThread class and thus can only be called from a derived class. It also can only be called in the context of this thread, i.e. a thread can only exit from itself, not from another thread. This function will terminate the OS thread (i.e. stop the associated path of execution) and also delete the associated C++ object for detached threads.wxThread::OnExit (p. 1289) will be called just before exiting.

wxThread::GetCPUCount
static int GetCPUCount() Returns the number of system CPUs or -1 if the value is unknown. See also SetConcurrency (p. 1290)

wxThread::GetCurrentId
static unsigned long GetCurrentId() Returns the platform specific thread ID of the current thread as a long. This can be used to uniquely identify threads, even if they are not wxThreads.

wxThread::GetId
unsigned long GetId() const

1287


CHAPTER 7
Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e. the thread identifiers may be reused).

wxThread::GetPriority
int GetPriority() const Gets the priority of the thread, between zero and 100. The following priorities are defined: WXTHREAD_MIN_PRIORITY WXTHREAD_DEFAULT_PRIORITY WXTHREAD_MAX_PRIORITY 0 50 100

wxThread::IsAlive
bool IsAlive() const Returns true if the thread is alive (i.e. started and not terminating). Note that this function can only be saely used with joinable threads, not detached ones as the latter delete themselves and so when the real thread is not alive any longer it is not possible to call this function neither because the wxThread object doesn't exist any more as well.

wxThread::IsDetached
bool IsDetached() const Returns true if the thread is of the detached kind, false if it is a joinable one.

wxThread::IsMain
static bool IsMain() Returns true if the calling thread is the main application thread.

wxThread::IsPaused
bool IsPaused() const Returns true if the thread is paused.

1288


CHAPTER 7 wxThread::IsRunning
bool IsRunning() const Returns true if the thread is running. This method may only be safely used for joinable threads, see the remark in IsAlive (p. 1288).

wxThread::Kill
wxThreadError Kill() Immediately terminates the target thread. This function is dangerous and should be used with extreme care (and not used at all whenever possible)! The resources allocated to the thread will not be freed and the state of the C runtime library may become inconsistent. Use Delete() (p. 1286) instead. For detached threads Kill() will also delete the associated C++ object. However this will not happen for joinable threads and this means that you will still have to delete the wxThread object yourself to avoid memory leaks. In neither case OnExit (p. 1289) of the dying thread will be called, so no thread-specific cleanup will be performed. This function can only be called from another thread context, i.e. a thread cannot kill itself. It is also an error to call this function for a thread which is not running or paused (in the latter case, the thread will be resumed first) -- if you do it, a wxTHREAD_NOT_RUNNING error will be returned.

wxThread::OnExit
void OnExit() Called when the thread exits. This function is called in the context of the thread associated with the wxThread object, not in the context of the main thread. This function will not be called if the thread waskilled (p. 1289). This function should never be called directly.

wxThread::Pause
wxThreadError Pause() Suspends the thread. Under some implementations (Win32), the thread is suspended immediately, under others it will only be suspended when it callsTestDestroy (p. 1291) for the next time (hence, if the thread doesn't call it at all, it won't be suspended). This function can only be called from another thread context.

1289


CHAPTER 7 wxThread::Run
wxThreadError Run() Starts the thread execution. Should be called afterCreate (p. 1286). This function can only be called from another thread context.

wxThread::SetPriority
void SetPriority(int priority) Sets the priority of the thread, between 0 and 100. It can only be set after calling Create() (p. 1286) but before callingRun() (p. 1290). The following priorities are already defined: WXTHREAD_MIN_PRIORITY WXTHREAD_DEFAULT_PRIORITY WXTHREAD_MAX_PRIORITY 0 50 100

wxThread::Sleep
static void Sleep(unsigned long milliseconds) Pauses the thread execution for the given amount of time. This function should be used instead of wxSleep (p. 1528) by all worker threads (i.e. all except the main one).

wxThread::Resume
wxThreadError Resume() Resumes a thread suspended by the call to Pause (p. 1289). This function can only be called from another thread context.

wxThread::SetConcurrency
static bool SetConcurrency(size_t level) Sets the thread concurrency level for this process. This is, roughly, the number of threads that the system tries to schedule to run in parallel. The value of 0 for level may be used to set the default one. Returns true on success or false otherwise (for example, if this function is not

1290


CHAPTER 7
implemented for this platform -- currently everything except Solaris).

wxThread::TestDestroy
bool TestDestroy() This function should be called periodically by the thread to ensure that calls to Pause (p. 1289) and Delete (p. 1286) will work. If it returns true, the thread should exit as soon as possible.

wxThread::This
static wxThread * This() Return the thread object for the calling thread. NULL is returned if the calling thread is the main (GUI) thread, but IsMain (p. 1288) should be used to test whether the thread is really the main one because NULL may also be returned for the thread not created with wxThread class. Generally speaking, the return value for such a thread is undefined.

wxThread::Yield
void Yield() Give the rest of the thread time slice to the system allowing the other threads to run. See also Sleep() (p. 1290).

wxThread::Wait
ExitCode Wait() const Waits until the thread terminates and returns its exit code or (ExitCode)-1 on error. You can only Wait() for joinable (not detached) threads. This function can only be called from another thread context.

wxThreadHelper
The wxThreadHelper class is a mix-in class that manages a single background thread. By deriving from wxThreadHelper, a class can implement the thread code in its own wxThreadHelper::Entry (p. 1293) method and easily share data and synchronization objects between the main thread and the worker thread. Doing this prevents the awkward passing of pointers that is needed when the original object in the main thread needs to synchronize with its worker thread in its own wxThread derived object. For example, wxFrame (p. 530) may need to make some calculations in a background thread and then display the results of those calculations in the main window.

1291


CHAPTER 7
Ordinarily, a wxThread (p. 1284) derived object would be created with the calculation code implemented inwxThread::Entry (p. 1287). To access the inputs to the calculation, the frame object would often to pass a pointer to itself to the thread object. Similiarly, the frame object would hold a pointer to the thread object. Shared data and synchronization objects could be stored in either object though the object without the data would have to access the data through a pointer. However, with wxThreadHelper, the frame object and the thread object are treated as the same object. Shared data and synchronization variables are stored in the single object, eliminating a layer of indirection and the associated pointers. Derived from None. Include files <wx/thread.h> See also wxThread (p. 1284)

wxThreadHelper::wxThreadHelper
wxThreadHelper() This constructor simply initializes a member variable.

wxThreadHelper::m_thread
wxThread * m_thread the actual wxThread (p. 1284) object.

wxThread::~wxThreadHelper
~wxThreadHelper() The destructor frees the resources associated with the thread.

wxThreadHelper::Create
wxThreadError Create(unsigned int stackSize = 0) Creates a new thread. The thread object is created in the suspended state, and you should call GetThread()->Run() (p. 1290) to start running it. You may optionally specify

1292


CHAPTER 7
the stack size to be allocated to it (Ignored on platforms that don't support setting it explicitly, eg. Unix). Return value One of: wxTHREAD_NO_ERROR wxTHREAD_NO_RESOURCE wxTHREAD_RUNNING There was no error. There were insufficient resources to create a new thread. The thread is already running.

wxThreadHelper::Entry
virtual ExitCode Entry() This is the entry point of the thread. This function is pure virtual and must be implemented by any derived class. The thread execution will start here. The returned value is the thread exit code which is only useful for joinable threads and is the value returned byGetThread()->Wait() (p. 1291). This function is called by wxWindows itself and should never be called directly.

wxThreadHelper::GetThread
wxThread * GetThread() This is a public function that returns the wxThread (p. 1284) object associated with the thread.

wxThreadHelperThread
The wxThreadHelperThread class is used internally by thewxThreadHelper (p. 1291) mix-in class. This class simply calls wxThreadHelper::Entry (p. 1293) in its owner class when the thread runs. Derived from wxThread (p. 1284) Include files <wx/thread.h> See also wxThread (p. 1284), wxThreadHelper (p. 1291)

1293


CHAPTER 7

wxThreadHelperThread::wxThreadHelperThread
wxThreadHelperThread() This constructor simply initializes member variables.

wxThreadHelperThread::m_owner
wxThreadHelperThread& m_owner the wxThreadHelper (p. 1291) object which holds the code to run inside the thread.

wxThreadHelperThread::Entry
virtual ExitCode Entry() This is the entry point of the thread. This function eventually callswxThreadHelper::Entry (p. 1293). The actual worker thread code should be implemented inwxThreadHelper::Entry (p. 1293), not here, so all shared data and synchronization objects can be shared easily between the main thread and the worker thread. The returned value is the thread exit code which is the value returned byWait() (p. 1291). This function is called by wxWindows itself and should never be called directly.

wxThreadHelperThread::CallEntry
virtual ExitCode CallEntry() This is a convenience method that actually callswxThreadHelper::Entry (p. 1293). This function eventually calls wxThreadHelper::Entry (p. 1293). The actual worker thread code should be implemented inwxThreadHelper::Entry (p. 1293), not here, so all shared data and synchronization objects can be shared easily between the main thread and the worker thread. It must be declared after wxThreadHelper (p. 1291) so it can access wxThreadHelper::Entry (p. 1293) and avoid circular dependencies. Thus, it uses the inline keyword to allow its definition outside of the class definition. To avoid any conflicts between the virtual and inline keywords, it is a non-virtual method. The returned value is the thread exit code which is the value returned byWait() (p. 1291). This function is called by wxWindows itself and should never be called directly.

wxTimer
1294


CHAPTER 7
The wxTimer class allows you to execute code at specified intervals. Its precision is platform-dependent, but in general will not be better than 1ms nor worse than 1s. There are two different ways to use this class: 1. 2. You may derive a new class from wxTimer and override the Notify (p. 1296) member to perform the required action. Or you may redirect the notifications to any wxEvtHandler (p. 443) derived object by using the non default constructor or SetOwner (p. 1296). Then use the EVT_TIMER macro to connect it to the event handler which will receive wxTimerEvent (p. 1297) notifications. Or you may use a derived class and the EVT_TIMER macro to connect it to an event handler defined in the derived class. If the default constructor is used, the timer object will be its own owner object, since it is derived from wxEvtHandler.

3.

In any case, you must start the timer with Start (p. 1296) after constructing it before it actually starts sending notifications. It can be stopped later with Stop (p. 1297). NB: note that timer can only be used from the main thread currently. Derived from wxEvtHandler (p. 443) Include files <wx/timer.h> See also ::wxStartTimer (p. 1528), ::wxGetElapsedTime (p. 1527), wxStopWatch (p. 1190)

wxTimer::wxTimer
wxTimer() Default constructor. If you use it to construct the object and don't call SetOwner (p. 1296) later, you must override Notify (p. 1296) method to process the notifications. wxTimer(wxEvtHandler *owner, int id = -1) Creates a timer and associates it with owner. Please see SetOwner (p. 1296) for the description of parameters.

wxTimer::~wxTimer
~wxTimer()

1295


CHAPTER 7
Destructor. Stops the timer if it is running.

wxTimer::GetInterval
int GetInterval() const Returns the current interval for the timer (in milliseconds).

wxTimer::IsOneShot
bool IsOneShot() const Returns true if the timer is one shot, i.e. if it will stop after firing the first notification automatically.

wxTimer::IsRunning
bool IsRunning() const Returns true if the timer is running, false if it is stopped.

wxTimer::Notify
void Notify() This member should be overridden by the user if the default constructor was used and SetOwner (p. 1296) wasn't called. Perform whatever action which is to be taken periodically here.

wxTimer::SetOwner
void SetOwner(wxEvtHandler *owner, int id = -1) Associates the timer with the given owner object. When the timer is running, the owner will receive timer events (p. 1297) with id equal to id specified here.

wxTimer::Start
bool Start(intmilliseconds = -1, bool oneShot = false) (Re)starts the timer. If milliseconds parameter is -1 (value by default), the previous value is used. Returns false if the timer could not be started,true otherwise (in MS Windows timers are a limited resource). If oneShot is false (the default), the Notify (p. 1296) function will be called repeatedly

1296


CHAPTER 7
until the timer is stopped. If true, it will be called only once and the timer will stop automatically. To make your code more readable you may also use the following symbolic constants: wxTIMER_CONTINUOUS wxTIMER_ONE_SHOT Start a normal, continuously running, timer Start a one shot timer

If the timer was already running, it will be stopped by this method before restarting it.

wxTimer::Stop
void Stop() Stops the timer.

wxTimerEvent
wxTimerEvent object is passed to the event handler of timer events. For example:
class MyFrame : public wxFrame { public: ... void OnTimer(wxTimerEvent& event); private: wxTimer m_timer; }; BEGIN_EVENT_TABLE(MyFrame, wxFrame) EVT_TIMER(TIMER_ID, MyFrame::OnTimer) END_EVENT_TABLE() MyFrame::MyFrame() : m_timer(this, TIMER_ID) { m_timer.Start(1000); // 1 second interval } void MyFrame::OnTimer(wxTimerEvent& event) { // do whatever you want to do every second here }

Include files <wx/timer.h> See also wxTimer (p. 1294)

1297


CHAPTER 7 wxTimerEvent::GetInterval
int GetInterval() const Returns the interval of the timer which generated this event.

wxTimeSpan
wxTimeSpan class represents a time interval. Derived from No base class Include files <wx/datetime.h> See also Date classes overview (p. 1579), wxDateTime (p. 236)

Static functions
Seconds (p. 1303) Second (p. 1303) Minutes (p. 1302) Minute (p. 1302) Hours (p. 1301) Hour (p. 1301) Days (p. 1299) Day (p. 1300) Weeks (p. 1304) Week (p. 1304)

Constructors
wxTimeSpan (p. 1304)

Accessors
GetSeconds (p. 1301) GetMinutes (p. 1301) GetHours (p. 1300) GetDays (p. 1300) GetWeeks (p. 1301)

1298


CHAPTER 7
GetValue (p. 1301)

Operations
Add (p. 1299) Substract (p. 1303) Multiply (p. 1303) Negate (p. 1303) Neg (p. 1303) Abs (p. 1299)

Tests
IsNull (p. 1302) IsPositive (p. 1302) IsNegative (p. 1302) IsEqualTo (p. 1302) IsLongerThan (p. 1302) IsShorterThan (p. 1302)

Formatting time spans
Format (p. 1300)

wxTimeSpan::Abs
wxTimeSpan Abs() const Returns the absolute value of the timespan: does not modify the object.

wxTimeSpan::Add
wxTimeSpan Add(const wxTimeSpan& diff) const wxTimeSpan& Add(const wxTimeSpan& diff) wxTimeSpan& operator+=(const wxTimeSpan&diff) Returns the sum of two timespans.

wxTimeSpan::Days
static wxTimespan Days(long days)

1299


CHAPTER 7
Returns the timespan for the given number of days.

wxTimeSpan::Day
static wxTimespan Day() Returns the timespan for one day.

wxTimeSpan::Format
wxString Format(const wxChar * format = "%H:%M:%S") Returns the string containing the formatted representation of the time span. The following format specifiers are allowed after %: H M S l D E % number of Hours number of Minutes number of Seconds number of milliseconds number of Days number of wEeks the percent character

Note that, for example, the number of hours in the description above is not well defined: it can be either the total number of hours (for example, for a time span of 50 hours this would be 50) or just the hour part of the time span, which would be 2 in this case as 50 hours is equal to 2 days and2 hours. wxTimeSpan resolves this ambiguity in the following way: if there had been, indeed, the %D format specified preceding the %H, then it is interpreted as 2. Otherwise, it is 50. The same applies to all other format specifiers: if they follow a specifier of larger unit, only the rest part is taken, otherwise the full value is used.

wxTimeSpan::GetDays
int GetDays() const Returns the difference in number of days.

wxTimeSpan::GetHours
int GetHours() const

1300


CHAPTER 7
Returns the difference in number of hours.

wxTimeSpan::GetMilliseconds
wxLongLong GetMilliseconds() const Returns the difference in number of milliseconds.

wxTimeSpan::GetMinutes
int GetMinutes() const Returns the difference in number of minutes.

wxTimeSpan::GetSeconds
wxLongLong GetSeconds() const Returns the difference in number of seconds.

wxTimeSpan::GetValue
wxLongLong GetValue() const Returns the internal representation of timespan.

wxTimeSpan::GetWeeks
int GetWeeks() const Returns the difference in number of weeks.

wxTimeSpan::Hours
static wxTimespan Hours(long hours) Returns the timespan for the given number of hours.

wxTimeSpan::Hour
static wxTimespan Hour() Returns the timespan for one hour.

1301


CHAPTER 7 wxTimeSpan::IsEqualTo
bool IsEqualTo(const wxTimeSpan& ts) const Returns true if two timespans are equal.

wxTimeSpan::IsLongerThan
bool IsLongerThan(const wxTimeSpan& ts) const Compares two timespans: works with the absolute values, i.e. -2 hours is longer than 1 hour. Also, it will return false if the timespans are equal in absolute value.

wxTimeSpan::IsNegative
bool IsNegative() const Returns true if the timespan is negative.

wxTimeSpan::IsNull
bool IsNull() const Returns true if the timespan is empty.

wxTimeSpan::IsPositive
bool IsPositive() const Returns true if the timespan is positive.

wxTimeSpan::IsShorterThan
bool IsShorterThan(const wxTimeSpan& ts) const Compares two timespans: works with the absolute values, i.e. 1 hour is shorter than -2 hours. Also, it will return false if the timespans are equal in absolute value.

wxTimeSpan::Minutes
static wxTimespan Minutes(long min) Returns the timespan for the given number of minutes.

wxTimeSpan::Minute 1302


CHAPTER 7
static wxTimespan Minute() Returns the timespan for one minute.

wxTimeSpan::Multiply
wxTimeSpan Multiply(int n) const wxTimeSpan& Multiply(int n) wxTimeSpan& operator*=(int n) Multiplies timespan by a scalar.

wxTimeSpan::Negate
wxTimeSpan Negate() const Returns timespan with inversed sign.

wxTimeSpan::Neg
wxTimeSpan& Neg() wxTimeSpan& operator-() Negate the value of the timespan.

wxTimeSpan::Seconds
static wxTimespan Seconds(long sec) Returns the timespan for the given number of seconds.

wxTimeSpan::Second
static wxTimespan Second() Returns the timespan for one second.

wxTimeSpan::Substract
wxTimeSpan Substract(const wxTimeSpan&diff) const wxTimeSpan& Substract(const wxTimeSpan& diff) wxTimeSpan& operator-=(const wxTimeSpan&diff)

1303


CHAPTER 7
Returns the difference of two timespans.

wxTimeSpan::Weeks
static wxTimespan Weeks(long weeks) Returns the timespan for the given number of weeks.

wxTimeSpan::Week
static wxTimespan Week() Returns the timespan for one week.

wxTimeSpan::wxTimeSpan
wxTimeSpan() Default constructor, constructs a zero timespan. wxTimeSpan(long hours, long min, long sec, long msec) Constructs timespan from separate values for each component, with the date set to 0. Hours are not restricted to 0..24 range, neither are minutes, seconds or milliseconds.

wxTipProvider
This is the class used together with wxShowTip (p. 1497) function. It must implement GetTip (p. 1305) function and return the current tip from it (different tip each time it is called). You will never use this class yourself, but you need it to show startup tips with wxShowTip. Also, if you want to get the tips text from elsewhere than a simple text file, you will want to derive a new class from wxTipProvider and use it instead of the one returned by wxCreateFileTipProvider (p. 1489). Derived from None. Include files <wx/tipdlg.h> See also Startup tips overview (p. 1663), ::wxShowTip (p. 1497)

1304


CHAPTER 7 wxTipProvider::wxTipProvider
wxTipProvider(size_t currentTip) Constructor. currentTip The starting tip index.

wxTipProvider::GetTip
wxString GetTip() Return the text of the current tip and pass to the next one. This function is pure virtual, it should be implemented in the derived classes.

wxTipProvider::PreprocessTip
virtual wxString PreProcessTip(const wxString&tip) Returns a modified tip. This function will be called immediately after read, and before being check whether it is a comment, an empty string or a string to translate. You can optionally override this in your custom user-derived class to optionally to modify the tip as soon as it is read. You can return any modification to the string. If you return wxEmptyString, then this tip is skipped, and the next one is read.

wxCurrentTipProvider::GetCurrentTip
size_t GetCurrentTip() const Returns the index of the current tip (i.e. the one which would be returned by GetTip). The program usually remembers the value returned by this function after calling wxShowTip (p. 1497). Note that it is not the same as the value which was passed to wxShowTip + 1 because the user might have pressed the "Next" button in the tip dialog.

wxTipWindow
Shows simple text in a popup tip window on creation. This is used by wxSimpleHelpProvider (p. 1102) to show popup help. The window automatically destroys itself when the user clicks on it or it loses the focus. You may also use this class to emulate the tooltips when you need finer control over them than what the standard tooltips provide. Derived from

1305


CHAPTER 7
wxPopupTransientWindow wxPopupWindow wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/tipwin.h>

wxTipWindow::wxTipWindow
wxTipWindow(wxWindow* parent, const wxString& text, wxCoord maxLength = 100, wxTipWindow** windowPtr) Constructor. The tip is shown immediately the window is constructed. Parameters parent The parent window, must be non NULL te x t The text to show, may contain the new line characters windowPtr Simply passed to SetTipWindowPtr (p. 1306) below, please see its documentation for the description of this parameter rectBounds If non NULL, passed to SetBoundingRect (p. 1306) below, please see its documentation for the description of this parameter

wxTipWindow::SetTipWindowPtr
void SetTipWindowPtr(wxTipWindow** windowPtr) When the tip window closes itself (which may happen at any moment and unexpectedly to the caller) it may NULL out the pointer pointed to by windowPtr. This is helpful to avoid dereferencing the tip window which had been already closed and deleted.

wxTipWindow::SetBoundingRect
void SetBoundingRect(const wxRect& rectBound)

1306


CHAPTER 7
By default, the tip window disappears when the user clicks the mouse or presses a keyboard key or if it loses focus in any other way - for example because the user switched to another application window. Additionally, if a non empty rectBound is provided, the tip window will also automatically close if the mouse leaves this area. This is useful to dismiss the tip mouse when the mouse leaves the object it is associated with. Parameters rectBound The bounding rectangle for the mouse in the screen coordinates

wxToggleButton
wxToggleButton is a button that stays pressed when clicked by the user. In other words, it is similar to wxCheckBox (p. 120) in functionality but looks like a wxButton (p. 103). You can see wxToggleButton in action in the sixth page of the controls (p. 1562) sample. NB: This class is only available under wxMSW, wxGTK and wxMotif currently. Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/tglbtn.h> Window styles There are no special styles for wxToggleButton. See also window styles overview (p. 1611). Event handling EVT_TOGGLEBUTTON(id, func) See also wxCheckBox (p. 120), wxButton (p. 103) Handles button click event.

wxToggleButton::wxToggleButton

1307


CHAPTER 7
wxToggleButton() Default constructor. wxToggleButton(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& val, const wxString& name = "checkBox") Constructor, creating and showing a toggle button. Parameters parent Parent window. Must not be NULL. id Toggle button identifier. A value of -1 indicates a default value. label Text to be displayed next to the toggle button. pos Toggle button position. If the position (-1, -1) is specified then a default position is chosen. size Toggle button size. If the default size (-1, -1) is specified then a default size is chosen. style Window style. See wxToggleButton (p. 1307). validator Window validator. name Window name. See also wxToggleButton::Create (p. 1309), wxValidator (p. 1358)

wxToggleButton::~wxToggleButton
~wxToggleButton()

1308


CHAPTER 7
Destructor, destroying the toggle button.

wxToggleButton::Create
bool Create(wxWindow* parent, wxWindowID id, const wxString& label, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxValidator& val, const wxString& name = "checkBox") Creates the toggle button for two-step construction. See wxToggleButton::wxToggleButton (p. 1307) for details.

wxToggleButton::GetValue
bool GetValue() const Gets the state of the toggle button. Return value Returns true if it is pressed, false otherwise.

wxToggleButton::SetValue
void SetValue(const bool state) Sets the toggle button to the given state. This does not cause a EVT_TOGGLEBUTTON event to be emitted. Parameters state If true, the button is pressed.

wxToolBar
The name wxToolBar is defined to be a synonym for one of the following classes:     wxToolBar95 The native Windows 95 toolbar. Used on Windows 95, NT 4 and above. wxToolBarMSW A Windows implementation. Used on 16-bit Windows. wxToolBarGTK The GTK toolbar. wxToolBarSimple A simple implementation, with scrolling. Used on platforms with no native toolbar control, or where scrolling is required.

Note that the base class wxToolBarBase defines automatic scrolling management

1309


CHAPTER 7
functionality which is similar to wxScrolledWindow (p. 1085), so please refer to this class also. Not all toolbars support scrolling, but wxToolBarSimple does. Derived from wxToolBarBase wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/toolbar.h> (to allow wxWindows to select an appropriate toolbar class) <wx/tbarbase.h> (the base class) <wx/tbarmsw.h> (the non-Windows 95 Windows toolbar class) <wx/tbar95.h> (the Windows 95/98 toolbar class) <wx/tbarsmpl.h> (the generic simple toolbar class) Remarks You may also create a toolbar that is managed by the frame, by calling wxFrame::CreateToolBar (p. 534). Due to the use of native toolbars on the various platforms, certain adaptions will often have to be made in order to get optimal look on all platforms as some platforms ignore the values for explicit placement and use their own layout and the meaning of a "separator" is a vertical line under Windows95 vs. simple space under GTK etc. wxToolBar95: Note that this toolbar paints tools to reflect system-wide colours. If you use more than 16 colours in your tool bitmaps, you may wish to suppress this behaviour, otherwise system colours in your bitmaps will inadvertently be mapped to system colours. To do this, set the msw.remap system option before creating the toolbar:
wxSystemOptions::SetOption(wxT("msw.remap"), 0);

Window styles wxTB_FLAT wxTB_DOCKABLE wxTB_HORIZONTAL wxTB_VERTICAL wxTB_TEXT wxTB_NOICONS wxTB_NODIVIDER Gives the toolbar a flat look (Windows and GTK only). Makes the toolbar floatable and dockable (GTK only). Specifies horizontal layout (default). Specifies vertical layout. Shows the text in the toolbar buttons; by default only icons are shown. Specifies no icons in the toolbar buttons; by default they are shown. Specifies no divider (border) above the toolbar (Windows only).

1310


CHAPTER 7
wxTB_NOALIGN wxTB_HORZ_LAYOUT Specifies no alignment with the parent window (Windows only, not very useful). Shows the text and the icons alongside, not vertically stacked (Windows and GTK 2 only). This style must be used with wxTB_TEXT. Combination of wxTB_HORZ_LAYOUT and wxTB_TEXT.

wxTB_HORZ_TEXT

See also window styles overview (p. 1611). Note that the Win32 native toolbar ignores wxTB_NOICONS style. Also, toggling the wxTB_TEXT works only if the style was initially on. Event handling The toolbar class emits menu commands in the same was that a frame menubar does, so you can use one EVT_MENU macro for both a menu item and a toolbar button. The event handler functions take a wxCommandEvent argument. For most event macros, the identifier of the tool is passed, but for EVT_TOOL_ENTER the toolbar window identifier is passed and the tool identifier is retrieved from the wxCommandEvent. This is because the identifier may be -1 when the mouse moves off a tool, and -1 is not allowed as an identifier in the event system. EVT_TOOL(id, func) Process a wxEVT_COMMAND_TOOL_CLICKED event (a synonym for wxEVT_COMMAND_MENU_SELECTED). Pass the id of the tool. The same as EVT_TOOL. Process a wxEVT_COMMAND_TOOL_CLICKED event for a range of identifiers. Pass the ids of the tools. The same as EVT_TOOL_RANGE. Process a wxEVT_COMMAND_TOOL_RCLICKED event. Pass the id of the tool.

EVT_MENU(id, func) EVT_TOOL_RANGE(id1, id2, func)

EVT_MENU_RANGE(id1, id2, func) EVT_TOOL_RCLICKED(id, func)

EVT_TOOL_RCLICKED_RANGE(id1, id2, func) Process a wxEVT_COMMAND_TOOL_RCLICKED event for a range of ids. Pass the ids of the tools. EVT_TOOL_ENTER(id, func) Process a wxEVT_COMMAND_TOOL_ENTER event. Pass the id of the toolbar itself. The value of wxCommandEvent::GetSelection is the tool id, or -1 if the mouse cursor has moved off a tool.

See also

1311


CHAPTER 7
Toolbar overview (p. 1657), wxScrolledWindow (p. 1085)

wxToolBar::wxToolBar
wxToolBar() Default constructor. wxToolBar(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxTB_HORIZONTAL | wxNO_BORDER, const wxString& name = wxPanelNameStr) Constructs a toolbar. Parameters parent Pointer to a parent window. id Window identifier. If -1, will automatically create an identifier. pos Window position. wxDefaultPosition is (-1, -1) which indicates that wxWindows should generate a default position for the window. If using the wxWindow class directly, supply an actual position. size Window size. wxDefaultSize is (-1, -1) which indicates that wxWindows should generate a default size for the window. style Window style. See wxToolBar (p. 1309) for details. name Window name. Remarks After a toolbar is created, you use wxToolBar::AddTool (p. 1313) and perhaps wxToolBar::AddSeparator (p. 1313), and then you must call wxToolBar::Realize (p. 1322) to construct and display the toolbar tools. You may also create a toolbar that is managed by the frame, by calling wxFrame::CreateToolBar (p. 534).

1312


CHAPTER 7 wxToolBar::~wxToolBar
void ~wxToolBar() Toolbar destructor.

wxToolBar::AddControl
bool AddControl(wxControl* control) Adds any control to the toolbar, typically e.g. a combobox. control The control to be added.

wxToolBar::AddSeparator
void AddSeparator() Adds a separator for spacing groups of tools. See also wxToolBar::AddTool (p. 1313), wxToolBar::SetToolSeparation (p. 1325)

wxToolBar::AddTool
wxToolBarTool* AddTool(int toolId, const wxString& label, const wxBitmap& bitmap1, const wxString& shortHelpString = "", wxItemKind kind = wxITEM_NORMAL) wxToolBarTool* AddTool(int toolId, const wxString& label, const wxBitmap& bitmap1, const wxBitmap& bitmap2 = wxNullBitmap, wxItemKind kind = wxITEM_NORMAL, const wxString& shortHelpString = "",const wxString& longHelpString = "", wxObject* clientData = NULL) wxToolBarTool* AddTool(wxToolBarTool* tool) Adds a tool to the toolbar. The first (short and most commonly used) version has fewer parameters than the full version at the price of not being able to specify some of the more rarely used button features. The last version allows to add an existing tool. Parameters toolId An integer by which the tool may be identified in subsequent operations. kind May be wxITEM_NORMAL for a normal button (default), wxITEM_CHECK for a

1313


CHAPTER 7
checkable tool (such tool stays pressed after it had been toggled) or wxITEM_RADIO for a checkable tool which makes part of a radio group of tools each of which is automatically unchecked whenever another button in the group is checked bitmap1 The primary tool bitmap for toggle and button tools. bitmap2 The second bitmap specifies the on-state bitmap for a toggle tool. If this is wxNullBitmap, either an inverted version of the primary bitmap is used for the onstate of a toggle tool (monochrome displays) or a black border is drawn around the tool (colour displays) or the pixmap is shown as a pressed button (GTK). shortHelpString This string is used for the tools tooltip longHelpString This string is shown in the statusbar (if any) of the parent frame when the mouse pointer is inside the tool clientData An optional pointer to client data which can be retrieved later using wxToolBar::GetToolClientData (p. 1317). tool The tool to be added. Remarks After you have added tools to a toolbar, you must call wxToolBar::Realize (p. 1322) in order to have the tools appear. See also wxToolBar::AddSeparator (p. 1313), wxToolBar::AddCheckTool (p. 1314), wxToolBar::AddRadioTool (p. 1315), wxToolBar::InsertTool (p. 1320), wxToolBar::DeleteTool (p. 1315), wxToolBar::Realize (p. 1322)

wxToolBar::AddCheckTool
wxToolBarTool* AddCheckTool(int toolId, const wxString& label, const wxBitmap& bitmap1, const wxBitmap& bitmap2, const wxString& shortHelpString = "", const wxString& longHelpString = "", wxObject* clientData = NULL) Adds a new check (or toggle) tool to the toolbar. The parameters are the same as in wxToolBar::AddTool (p. 1313).

1314


CHAPTER 7
See also wxToolBar::AddTool (p. 1313)

wxToolBar::AddRadioTool
wxToolBarTool* AddRadioTool(int toolId, const wxString& label, const wxBitmap& bitmap1, const wxBitmap& bitmap2, const wxString& shortHelpString = "", const wxString& longHelpString = "", wxObject* clientData = NULL) Adds a new radio tool to the toolbar. Consecutive radio tools form a radio group such that exactly one button in the group is pressed at any moment, in other words whenever a button in the group is pressed the previously pressed button is automatically released. You should avoid having the radio groups of only one element as it would be impossible for the user to use such button. By default, the first button in the radio group is initially pressed, the others are not. See also wxToolBar::AddTool (p. 1313)

wxToolBar::DeleteTool
bool DeleteTool(int toolId) Removes the specified tool from the toolbar and deletes it. If you don't want to delete the tool, but just to remove it from the toolbar (to possibly add it back later), you may use RemoveTool (p. 1322) instead. Note that it is unnecessary to call Realize (p. 1322) for the change to take place, it will happen immediately. Returns true if the tool was deleted, false otherwise. See also DeleteToolByPos (p. 1315)

wxToolBar::DeleteToolByPos
bool DeleteToolByPos(size_t pos) This function behaves like DeleteTool (p. 1315) but it deletes the tool at the specified position and not the one with the given id.

wxToolBar::EnableTool
void EnableTool(int toolId, const bool enable)

1315


CHAPTER 7
Enables or disables the tool. Parameters toolId Tool to enable or disable. enable If true, enables the tool, otherwise disables it. NB: This function should only be called after Realize (p. 1322). Remarks For wxToolBarSimple, does nothing. Some other implementations will change the visible state of the tool to indicate that it is disabled. See also wxToolBar::GetToolEnabled (p. 1318), wxToolBar::ToggleTool (p. 1325)

wxToolBar::FindById
wxToolBarTool* FindById(int id) Returns a pointer to the tool identified by id or NULL if no corresponding tool is found.

wxToolBar::FindControl
wxControl* FindControl(int id) Returns a pointer to the control identified by id or NULL if no corresponding control is found.

wxToolBar::FindToolForPosition
wxToolBarTool* FindToolForPosition(const float x, const float y) const Finds a tool for the given mouse position. Parameters x X position. y Y position.

1316


CHAPTER 7
Return value A pointer to a tool if a tool is found, or NULL otherwise. Remarks Used internally, and should not need to be used by the programmer.

wxToolBar::GetToolSize
wxSize GetToolSize() Returns the size of a whole button, which is usually larger than a tool bitmap because of added 3D effects. See also wxToolBar::SetToolBitmapSize (p. 1323), wxToolBar::GetToolBitmapSize (p. 1317)

wxToolBar::GetToolBitmapSize
wxSize GetToolBitmapSize() Returns the size of bitmap that the toolbar expects to have. The default bitmap size is 16 by 15 pixels. Remarks Note that this is the size of the bitmap you pass to wxToolBar::AddTool (p. 1313), and not the eventual size of the tool button. See also wxToolBar::SetToolBitmapSize (p. 1323), wxToolBar::GetToolSize (p. 1317)

wxToolBar::GetMargins
wxSize GetMargins() const Returns the left/right and top/bottom margins, which are also used for inter-toolspacing. See also wxToolBar::SetMargins (p. 1323)

wxToolBar::GetToolClientData
wxObject* GetToolClientData(int toolId) const Get any client data associated with the tool.

1317


CHAPTER 7
Parameters toolId Id of the tool, as passed to wxToolBar::AddTool (p. 1313). Return value Client data, or NULL if there is none.

wxToolBar::GetToolEnabled
bool GetToolEnabled(int toolId) const Called to determine whether a tool is enabled (responds to user input). Parameters toolId Id of the tool in question. Return value true if the tool is enabled, false otherwise. See also wxToolBar::EnableTool (p. 1315)

wxToolBar::GetToolLongHelp
wxString GetToolLongHelp(int toolId) const Returns the long help for the given tool. Parameters toolId The tool in question. See also wxToolBar::SetToolLongHelp (p. 1324), wxToolBar::SetToolShortHelp (p. 1325)

wxToolBar::GetToolPacking
int GetToolPacking() const Returns the value used for packing tools.

1318


CHAPTER 7
See also wxToolBar::SetToolPacking (p. 1324)

wxToolBar::GetToolPos
int GetToolPos(int toolId) const Returns the tool position in the toolbar, or wxNOT_FOUND if the tool is not found.

wxToolBar::GetToolSeparation
int GetToolSeparation() const Returns the default separator size. See also wxToolBar::SetToolSeparation (p. 1325)

wxToolBar::GetToolShortHelp
wxString GetToolShortHelp(int toolId) const Returns the short help for the given tool. Parameters toolId The tool in question. See also wxToolBar::GetToolLongHelp (p. 1318), wxToolBar::SetToolShortHelp (p. 1325)

wxToolBar::GetToolState
bool GetToolState(int toolId) const Gets the on/off state of a toggle tool. Parameters toolId The tool in question. Return value

1319


CHAPTER 7
true if the tool is toggled on, false otherwise. See also wxToolBar::ToggleTool (p. 1325)

wxToolBar::InsertControl
wxToolBarTool * InsertControl(size_t pos, wxControl *control) Inserts the control into the toolbar at the given position. You must call Realize (p. 1322) for the change to take place. See also AddControl (p. 1313), InsertTool (p. 1320)

wxToolBar::InsertSeparator
wxToolBarTool * InsertSeparator(size_t pos) Inserts the separator into the toolbar at the given position. You must call Realize (p. 1322) for the change to take place. See also AddSeparator (p. 1313), InsertTool (p. 1320)

wxToolBar::InsertTool
wxToolBarTool * InsertTool(size_t pos, int toolId, const wxBitmap& bitmap1, const wxBitmap& bitmap2 = wxNullBitmap, bool isToggle = false, wxObject* clientData = NULL, const wxString& shortHelpString = "", const wxString& longHelpString = "") wxToolBarTool * InsertTool(size_t pos, wxToolBarTool* tool) Inserts the tool with the specified attributes into the toolbar at the given position. You must call Realize (p. 1322) for the change to take place. See also AddTool (p. 1313), InsertControl (p. 1320), InsertSeparator (p. 1320)

1320


CHAPTER 7 wxToolBar::OnLeftClick
bool OnLeftClick(int toolId, bool toggleDown) Called when the user clicks on a tool with the left mouse button. This is the old way of detecting tool clicks; although it will still work, you should use the EVT_MENU or EVT_TOOL macro instead. Parameters toolId The identifier passed to wxToolBar::AddTool (p. 1313). toggleDown true if the tool is a toggle and the toggle is down, otherwise is false. Return value If the tool is a toggle and this function returns false, the toggle toggle state (internal and visual) will not be changed. This provides a way of specifying that toggle operations are not permitted in some circumstances. See also wxToolBar::OnMouseEnter (p. 1321), wxToolBar::OnRightClick (p. 1322)

wxToolBar::OnMouseEnter
void OnMouseEnter(int toolId) This is called when the mouse cursor moves into a tool or out of the toolbar. This is the old way of detecting mouse enter events; although it will still work, you should use the EVT_TOOL_ENTER macro instead. Parameters toolId Greater than -1 if the mouse cursor has moved into the tool, or -1 if the mouse cursor has moved. The programmer can override this to provide extra information about the tool, such as a short description on the status line. Remarks With some derived toolbar classes, if the mouse moves quickly out of the toolbar, wxWindows may not be able to detect it. Therefore this function may not always be called when expected.

1321


CHAPTER 7 wxToolBar::OnRightClick
void OnRightClick(int toolId, float x, float y) Called when the user clicks on a tool with the right mouse button. The programmer should override this function to detect right tool clicks. This is the old way of detecting tool right clicks; although it will still work, you should use the EVT_TOOL_RCLICKED macro instead. Parameters toolId The identifier passed to wxToolBar::AddTool (p. 1313). x The x position of the mouse cursor. y The y position of the mouse cursor. Remarks A typical use of this member might be to pop up a menu. See also wxToolBar::OnMouseEnter (p. 1321), wxToolBar::OnLeftClick (p. 1321)

wxToolBar::Realize
bool Realize() This function should be called after you have added tools.

wxToolBar::RemoveTool
wxToolBarTool * RemoveTool(int id) Removes the given tool from the toolbar but doesn't delete it. This allows to insert/add this tool back to this (or another) toolbar later. Note that it is unnecessary to call Realize (p. 1322) for the change to take place, it will happen immediately. See also DeleteTool (p. 1315)

1322


CHAPTER 7 wxToolBar::SetMargins
void SetMargins(const wxSize& size) void SetMargins(int x, int y) Set the values to be used as margins for the toolbar. Parameters size Margin size. x Left margin, right margin and inter-tool separation value. y Top margin, bottom margin and inter-tool separation value. Remarks This must be called before the tools are added if absolute positioning is to be used, and the default (zero-size) margins are to be overridden. See also wxToolBar::GetMargins (p. 1317), wxSize (p. 1106)

wxToolBar::SetToolBitmapSize
void SetToolBitmapSize(const wxSize& size) Sets the default size of each tool bitmap. The default bitmap size is 16 by 15 pixels. Parameters size The size of the bitmaps in the toolbar. Remarks This should be called to tell the toolbar what the tool bitmap size is. Call it before you add tools. Note that this is the size of the bitmap you pass to wxToolBar::AddTool (p. 1313), and not the eventual size of the tool button. See also wxToolBar::GetToolBitmapSize (p. 1317), wxToolBar::GetToolSize (p. 1317)

1323


CHAPTER 7 wxToolBar::SetToolClientData
void SetToolClientData(int id, wxObject* clientData) Sets the client data associated with the tool.

wxToolBar::SetToolLongHelp
void SetToolLongHelp(int toolId, const wxString& helpString) Sets the long help for the given tool. Parameters toolId The tool in question. helpString A string for the long help. Remarks You might use the long help for displaying the tool purpose on the status line. See also wxToolBar::GetToolLongHelp (p. 1318), wxToolBar::SetToolShortHelp (p. 1325),

wxToolBar::SetToolPacking
void SetToolPacking(int packing) Sets the value used for spacing tools. The default value is 1. Parameters packing The value for packing. Remarks The packing is used for spacing in the vertical direction if the toolbar is horizontal, and for spacing in the horizontal direction if the toolbar is vertical. See also wxToolBar::GetToolPacking (p. 1318)

1324


CHAPTER 7 wxToolBar::SetToolShortHelp
void SetToolShortHelp(int toolId, const wxString& helpString) Sets the short help for the given tool. Parameters toolId The tool in question. helpString The string for the short help. Remarks An application might use short help for identifying the tool purpose in a tooltip. See also wxToolBar::GetToolShortHelp (p. 1319), wxToolBar::SetToolLongHelp (p. 1324)

wxToolBar::SetToolSeparation
void SetToolSeparation(int separation) Sets the default separator size. The default value is 5. Parameters separation The separator size. See also wxToolBar::AddSeparator (p. 1313)

wxToolBar::ToggleTool
void ToggleTool(int toolId, const bool toggle) Toggles a tool on or off. This does not cause any event to get emitted. Parameters toolId Tool in question. toggle

1325


CHAPTER 7
If true, toggles the tool on, otherwise toggles it off. Remarks Only applies to a tool that has been specified as a toggle tool. See also wxToolBar::GetToolState (p. 1319)

wxToolTip
This class holds information about a tooltip associated with a window (see wxWindow::SetToolTip (p. 1431)). The two static methods, wxToolTip::Enable (p. 1326) andwxToolTip::SetDelay (p. 1326) can be used to globally alter tooltips behaviour. Derived from wxObject (p. 954)

wxToolTip::Enable
static void Enable(bool flag) Enable or disable tooltips globally.

wxToolTip::SetDelay
static void SetDelay(long msecs) Set the delay after which the tooltip appears.

wxToolTip::wxToolTip
wxToolTip(const wxString& tip) Constructor.

wxToolTip::SetTip
void SetTip(const wxString& tip) Set the tooltip text.

1326


CHAPTER 7 wxToolTip::GetTip
wxString GetTip() const Get the tooltip text.

wxToolTip::GetWindow
wxWindow* GetWindow() const Get the associated window.

wxTreeCtrl
A tree control presents information as a hierarchy, with items that may be expanded to show further items. Items in a tree control are referenced by wxTreeItemId handles, which may be tested for validity by calling wxTreeItemId::IsOk. To intercept events from a tree control, use the event table macros described in wxTreeEvent (p. 1345). Derived from wxControl (p. 198) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/treectrl.h> Window styles wxTR_EDIT_LABELS wxTR_NO_BUTTONS wxTR_HAS_BUTTONS wxTR_TWIST_BUTTONS Use this style if you wish the user to be able to edit labels in the tree control. For convenience to document that no buttons are to be drawn. Use this style to show + and - buttons to the left of parent items. Use this style to show Mac-style twister buttons to the left of parent items. If both wxTR_HAS_BUTTONS and wxTR_TWIST_BUTTONS are given, twister buttons are generated. Generic only. Use this style to hide vertical level connectors. Use this style to have the background colour and

wxTR_NO_LINES

wxTR_FULL_ROW_HIGHLIGHT

1327


CHAPTER 7
the selection highlight extend over the entire horizontal row of the tree control window. (This flag is ignored under Windows unless you specify wxTR_NO_LINES as well.) wxTR_LINES_AT_ROOT Use this style to show lines between root nodes. Only applicable if wxTR_HIDE_ROOT is set and wxTR_NO_LINES is not set. Use this style to suppress the display of the root node, effectively causing the first-level nodes to appear as a series of root nodes. Use this style to draw a contrasting border between displayed rows.

wxTR_HIDE_ROOT

wxTR_ROW_LINES

wxTR_HAS_VARIABLE_ROW_HEIGHT Use this style to cause row heights to be just big enough to fit the content. If not set, all rows use the largest row height. The default is that this flag is unset. Generic only. wxTR_SINGLE For convenience to document that only one item may be selected at a time. Selecting another item causes the current selection, if any, to be deselected. This is the default. Use this style to allow a range of items to be selected. If a second range is selected, the current range, if any, is deselected. Use this style to allow disjoint items to be selected. (Only partially implemented; may not work in all cases.) The set of flags that are closest to the defaults for the native control for a particular toolkit.

wxTR_MULTIPLE

wxTR_EXTENDED wxTR_DEFAULT_STYLE

See also window styles overview (p. 1611). Event handling To process input from a tree control, use these event handler macros to direct input to member functions that take a wxTreeEvent (p. 1345) argument. EVT_TREE_BEGIN_DRAG(id, func) Begin dragging with the left mouse button.

EVT_TREE_BEGIN_RDRAG(id, func) Begin dragging with the right mouse button. Begin editing a label. This can be EVT_TREE_BEGIN_LABEL_EDIT(id, func) prevented by calling Veto() (p. 954). EVT_TREE_END_LABEL_EDIT(id, func) Finish editing a label. This can be prevented by calling Veto() (p. 954). EVT_TREE_DELETE_ITEM(id, func) Delete an item.

1328


CHAPTER 7
EVT_TREE_GET_INFO(id, func) EVT_TREE_SET_INFO(id, func) Request information from the application. Information is being supplied.

EVT_TREE_ITEM_ACTIVATED(id, func) The item has been activated, i.e. chosen by double clicking it with mouse or from keyboard EVT_TREE_ITEM_COLLAPSED(id, func) The item has been collapsed. EVT_TREE_ITEM_COLLAPSING(id, func) The item is being collapsed. This can be prevented by calling Veto() (p. 954). EVT_TREE_ITEM_EXPANDED(id, func) The item has been expanded.

EVT_TREE_ITEM_EXPANDING(id, func) The item is being expanded. This can be prevented by calling Veto() (p. 954). EVT_TREE_SEL_CHANGED(id, func) Selection has changed. EVT_TREE_SEL_CHANGING(id, func) Selection is changing. This can be prevented by calling Veto() (p. 954). EVT_TREE_KEY_DOWN(id, func) A key has been pressed.

EVT_TREE_ITEM_GETTOOLTIP(id, func) The opportunity to set the item tooltip is being given to the application (call wxTreeEvent::SetToolTip). Windows only. See also wxTreeItemData (p. 1348), wxTreeCtrl overview (p. 1646), wxListBox (p. 793), wxListCtrl (p. 799), wxImageList (p. 754), wxTreeEvent (p. 1345) Win32 notes wxTreeCtrl class uses the standard common treeview control under Win32 implemented in the system library comctl32.dll. Some versions of this library are known to have bugs with handling the tree control colours: the usual symptom is that the expanded items leave black (or otherwise incorrectly coloured) background behind them, especially for the controls using non default background colour. The recommended solution is to upgrade the comctl32.dllto a newer version: seehttp://www.microsoft.com/msdownload/ieplatform/ie/comctrlx86.asp (http://www.microsoft.com/msdownload/ieplatform/ie/comctrlx86.asp) .

wxTreeCtrl::wxTreeCtrl
wxTreeCtrl() Default constructor.

1329


CHAPTER 7
wxTreeCtrl(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxTR_HAS_BUTTONS, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listCtrl") Constructor, creating and showing a tree control. Parameters parent Parent window. Must not be NULL. id Window identifier. A value of -1 indicates a default value. pos Window position. size Window size. If the default size (-1, -1) is specified then the window is sized appropriately. style Window style. See wxTreeCtrl (p. 1327). validator Window validator. name Window name. See also wxTreeCtrl::Create (p. 1332), wxValidator (p. 1358)

wxTreeCtrl::~wxTreeCtrl
void ~wxTreeCtrl() Destructor, destroying the list control.

wxTreeCtrl::AddRoot
wxTreeItemId AddRoot(const wxString& text, int image = -1, int selImage = -1, wxTreeItemData* data = NULL)

1330


CHAPTER 7
Adds the root node to the tree, returning the new item. The image and selImage parameters are an index within the normal image list specifying the image to use for unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both selected and unselected items.

wxTreeCtrl::AppendItem
wxTreeItemId AppendItem(const wxTreeItemId& parent, const wxString& text, int image = -1, int selImage = -1, wxTreeItemData* data = NULL) Appends an item to the end of the branch identified by parent, return a new item id. The image and selImage parameters are an index within the normal image list specifying the image to use for unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both selected and unselected items.

wxTreeCtrl::AssignButtonsImageList
void AssignButtonsImageList(wxImageList* imageList) Sets the buttons image list. The button images assigned with this method will be automatically deleted by wxTreeCtrl as appropriate (i.e. it takes ownership of the list). Setting or assigning the button image list enables the display of image buttons. Once enabled, the only way to disable the display of button images is to set the button image list to NULL. This function is only available in the generic version. See also SetButtonsImageList (p. 1342).

wxTreeCtrl::AssignImageList
void AssignImageList(wxImageList* imageList) Sets the normal image list. Image list assigned with this method will be automatically deleted by wxTreeCtrl as appropriate (i.e. it takes ownership of the list). See also SetImageList (p. 1342).

wxTreeCtrl::AssignStateImageList
void AssignStateImageList(wxImageList* imageList) Sets the state image list. Image list assigned with this method will be automatically deleted by wxTreeCtrl as appropriate (i.e. it takes ownership of the list). See also SetStateImageList (p. 1344).

1331


CHAPTER 7 wxTreeCtrl::Collapse
void Collapse(const wxTreeItemId& item) Collapses the given item.

wxTreeCtrl::CollapseAndReset
void CollapseAndReset(const wxTreeItemId& item) Collapses the given item and removes all children.

wxTreeCtrl::Create
bool wxTreeCtrl(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = wxTR_HAS_BUTTONS, const wxValidator& validator = wxDefaultValidator, const wxString& name = "listCtrl") Creates the tree control. See wxTreeCtrl::wxTreeCtrl (p. 1329) for further details.

wxTreeCtrl::Delete
void Delete(const wxTreeItemId& item) Deletes the specified item. A EVT_TREE_DELETE_ITEM event will be generated. This function may cause a subsequent call to GetNextChild to fail.

wxTreeCtrl::DeleteAllItems
void DeleteAllItems() Deletes all the items in the control. Note that this may not generate EVT_TREE_DELETE_ITEM events under some Windows versions although normally such event is generated for each removed item.

wxTreeCtrl::DeleteChildren
void DeleteChildren(const wxTreeItemId& item) Deletes all children of the given item (but not the item itself). Note that this will not generate any events unlike Delete (p. 1332) method. If you have called wxTreeCtrl::SetItemHasChildren (p. 1343), you may need to call it again since DeleteChildren does not automatically clear the setting.

1332


CHAPTER 7 wxTreeCtrl::EditLabel
void EditLabel(const wxTreeItemId& item) Starts editing the label of the given item. This function generates a EVT_TREE_BEGIN_LABEL_EDIT event which can be vetoed so that no text control will appear for in-place editing. If the user changed the label (i.e. s/he does not press ESC or leave the text control without changes, a EVT_TREE_END_LABEL_EDIT event will be sent which can be vetoed as well. See also wxTreeCtrl::EndEditLabel (p. 1333),wxTreeEvent (p. 1345)

wxTreeCtrl::EndEditLabel
void EndEditLabel(bool cancelEdit) Ends label editing. If cancelEdit is true, the edit will be cancelled. This function is currently supported under Windows only. See also wxTreeCtrl::EditLabel (p. 1333)

wxTreeCtrl::EnsureVisible
void EnsureVisible(const wxTreeItemId& item) Scrolls and/or expands items to ensure that the given item is visible.

wxTreeCtrl::Expand
void Expand(const wxTreeItemId& item) Expands the given item.

wxTreeCtrl::GetBoundingRect
bool GetBoundingRect(const wxTreeItemId& item, wxRect& rect, bool textOnly = false) const Retrieves the rectangle bounding the item. If textOnly is true, only the rectangle around the item's label will be returned, otherwise the item's image is also taken into account. The return value is true if the rectangle was successfully retrieved or falseif it was not

1333


CHAPTER 7
(in this case rect is not changed) - for example, if the item is currently invisible. wxPython note: The wxPython version of this method requires only theitem and textOnly parameters. The return value is either awxRect object or None. wxPerl note: In wxPerl this method only takes the parameters item and textOnly, and returns a Wx::Rect ( or undef ).

wxTreeCtrl::GetButtonsImageList
wxImageList* GetButtonsImageList() const Returns the buttons image list (from which application-defined button images are taken). This function is only available in the generic version.

wxTreeCtrl::GetChildrenCount
size_t GetChildrenCount(const wxTreeItemId& item, bool recursively = true) const Returns the number of items in the branch. If recursively is true, returns the total number of descendants, otherwise only one level of children is counted.

wxTreeCtrl::GetCount
int GetCount() const Returns the number of items in the control.

wxTreeCtrl::GetEditControl
wxTextCtrl * GetEditControl() const Returns the edit control being currently used to edit a label. Returns NULLif no label is being edited. NB: It is currently only implemented for wxMSW.

wxTreeCtrl::GetFirstChild
wxTreeItemId GetFirstChild(const wxTreeItemId& item, wxTreeItemIdValue & cookie) const Returns the first child; call wxTreeCtrl::GetNextChild (p. 1337) for the next child. For this enumeration function you must pass in a 'cookie' parameter which is opaque for the application but is necessary for the library to make these functions reentrant (i.e. allow more than one enumeration on one and the same object simultaneously). The

1334


CHAPTER 7
cookie passed to GetFirstChild and GetNextChild should be the same variable. Returns an invalid tree item if there are no further children. See also wxTreeCtrl::GetNextChild (p. 1337),wxTreeCtrl::GetNextSibling (p. 1337) wxPython note: In wxPython the returned wxTreeItemId and the new cookie value are both returned as a tuple containing the two values. wxPerl note: In wxPerl this method only takes the item parameter, and returns a 2element list ( item, cookie ).

wxTreeCtrl::GetFirstVisibleItem
wxTreeItemId GetFirstVisibleItem() const Returns the first visible item.

wxTreeCtrl::GetImageList
wxImageList* GetImageList() const Returns the normal image list.

wxTreeCtrl::GetIndent
int GetIndent() const Returns the current tree control indentation.

wxTreeCtrl::GetItemBackgroundColour
wxColour GetItemBackgroundColour(const wxTreeItemId& item) const Returns the background colour of the item.

wxTreeCtrl::GetItemData
wxTreeItemData* GetItemData(const wxTreeItemId& item) const Returns the tree item data associated with the item. See also wxTreeItemData (p. 1348)

1335


CHAPTER 7
wxPython note: wxPython provides the following shortcut method: GetPyData(item) Returns the Python Object associated with the wxTreeItemData for the given item Id.

wxPerl note: wxPerl provides the following shortcut method:GetPlData( item ) Returns the Perl data associated with the Wx::TreeItemData. It is just the same as tree->GetItemData(item)>GetData().

wxTreeCtrl::GetItemFont
wxFont GetItemFont(const wxTreeItemId& item) const Returns the font of the item label.

wxTreeCtrl::GetItemImage
int GetItemImage(const wxTreeItemId& item, wxTreeItemIcon which = wxTreeItemIcon_Normal) const Gets the specified item image. The value of which may be: _Normal to get the normal item image _Selected to get the selected item image (i.e. the image which is shown when the item is currently selected) _Expanded to get the expanded image (this only makes sense for items which have children - then this image is shown when the item is expanded and the normal image is shown when it is collapsed) _SelectedExpanded to get the selected expanded image (which is shown when an expanded item is currently selected)

wxTreeCtrl::GetItemText
wxString GetItemText(const wxTreeItemId& item) const Returns the item label.

wxTreeCtrl::GetItemTextColour 1336


CHAPTER 7
wxColour GetItemTextColour(const wxTreeItemId& item) const Returns the colour of the item label.

wxTreeCtrl::GetLastChild
wxTreeItemId GetLastChild(const wxTreeItemId& item) const Returns the last child of the item (or an invalid tree item if this item has no children). See also GetFirstChild (p. 1334),wxTreeCtrl::GetNextSibling (p. 1337),GetLastChild (p. 1337)

wxTreeCtrl::GetNextChild
wxTreeItemId GetNextChild(const wxTreeItemId& item, wxTreeItemIdValue & cookie) const Returns the next child; call wxTreeCtrl::GetFirstChild (p. 1334) for the first child. For this enumeration function you must pass in a 'cookie' parameter which is opaque for the application but is necessary for the library to make these functions reentrant (i.e. allow more than one enumeration on one and the same object simultaneously). The cookie passed to GetFirstChild and GetNextChild should be the same. Returns an invalid tree item if there are no further children. See also wxTreeCtrl::GetFirstChild (p. 1334) wxPython note: In wxPython the returned wxTreeItemId and the new cookie value are both returned as a tuple containing the two values. wxPerl note: In wxPerl this method returns a 2-element list ( item, cookie ), instead of modifying its parameters.

wxTreeCtrl::GetNextSibling
wxTreeItemId GetNextSibling(const wxTreeItemId& item) const Returns the next sibling of the specified item; call wxTreeCtrl::GetPrevSibling (p. 1338) for the previous sibling. Returns an invalid tree item if there are no further siblings. See also wxTreeCtrl::GetPrevSibling (p. 1338)

1337


CHAPTER 7 wxTreeCtrl::GetNextVisible
wxTreeItemId GetNextVisible(const wxTreeItemId& item) const Returns the next visible item.

wxTreeCtrl::GetItemParent
wxTreeItemId GetItemParent(const wxTreeItemId& item) const Returns the item's parent.

wxTreeCtrl::GetParent
wxTreeItemId GetParent(const wxTreeItemId& item) const NOTE: This function is deprecated and will only work if WXWIN_COMPATIBILITY_2_2is defined. Use wxTreeCtrl::GetItemParent (p. 1338) instead. Returns the item's parent. wxPython note: This method is named GetItemParent to avoid a name clash with wxWindow::GetParent.

wxTreeCtrl::GetPrevSibling
wxTreeItemId GetPrevSibling(const wxTreeItemId& item) const Returns the previous sibling of the specified item; call wxTreeCtrl::GetNextSibling (p. 1337) for the next sibling. Returns an invalid tree item if there are no further children. See also wxTreeCtrl::GetNextSibling (p. 1337)

wxTreeCtrl::GetPrevVisible
wxTreeItemId GetPrevVisible(const wxTreeItemId& item) const Returns the previous visible item.

wxTreeCtrl::GetRootItem
wxTreeItemId GetRootItem() const Returns the root item for the tree control.

1338


CHAPTER 7 wxTreeCtrl::GetItemSelectedImage
int GetItemSelectedImage(const wxTreeItemId& item) const Gets the selected item image (this function is obsolete, useGetItemImage(item, wxTreeItemIcon_Selected) instead).

wxTreeCtrl::GetSelection
wxTreeItemId GetSelection() const Returns the selection, or an invalid item if there is no selection. This function only works with the controls without wxTR_MULTIPLE style, useGetSelections (p. 1339) for the controls which do have this style.

wxTreeCtrl::GetSelections
size_t GetSelections(wxArrayTreeItemIds& selection) const Fills the array of tree items passed in with the currently selected items. This function can be called only if the control has the wxTR_MULTIPLE style. Returns the number of selected items. wxPython note: The wxPython version of this method accepts no parameters and returns a Python list of wxTreeItemIds. wxPerl note: In wxPerl this method takes no parameters and returns a list of Wx::TreeItemIds.

wxTreeCtrl::GetStateImageList
wxImageList* GetStateImageList() const Returns the state image list (from which application-defined state images are taken).

wxTreeCtrl::HitTest
wxTreeItemId HitTest(const wxPoint& point, int& flags) Calculates which (if any) item is under the given point, returning the tree item id at this point plus extra information flags. flags is a bitlist of the following: wxTREE_HITTEST_ABOVE Above the client area. wxTREE_HITTEST_BELOW Below the client area. wxTREE_HITTEST_NOWHERE In the client area but below the last item.

1339


CHAPTER 7
wxTREE_HITTEST_ONITEMBUTTON On the button associated with an item.

wxTREE_HITTEST_ONITEMICON On the bitmap associated with an item. wxTREE_HITTEST_ONITEMINDENT In the indentation associated with an item.

wxTREE_HITTEST_ONITEMLABEL On the label (string) associated with an item. wxTREE_HITTEST_ONITEMRIGHT In the area to the right of an item. wxTREE_HITTEST_ONITEMSTATEICON On the state icon for a tree view item that is in a user-defined state. wxTREE_HITTEST_TOLEFT To the right of the client area. wxTREE_HITTEST_TORIGHT To the left of the client area.

wxPython note: in wxPython both the wxTreeItemId and the flags are returned as a tuple. wxPerl note: In wxPerl this method only takes the point parameter and returns a 2element list ( item, flags ).

wxTreeCtrl::InsertItem
wxTreeItemId InsertItem(const wxTreeItemId& parent, const wxTreeItemId& previous, const wxString& text, int image = -1, int selImage = -1, wxTreeItemData* data = NULL) wxTreeItemId InsertItem(const wxTreeItemId& parent, size_t before, const wxString& text, int image = -1, int selImage = -1, wxTreeItemData* data = NULL) Inserts an item after a given one (previous) or before one identified by its position (before).before must be less than the number of children. The image and selImage parameters are an index within the normal image list specifying the image to use for unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both selected and unselected items. wxPython note: The second form of this method is calledInsertItemBefore in wxPython.

wxTreeCtrl::IsBold
bool IsBold(const wxTreeItemId& item) const Returns true if the given item is in bold state. See also: SetItemBold (p. 1343)

1340


CHAPTER 7 wxTreeCtrl::IsExpanded
bool IsExpanded(const wxTreeItemId& item) const Returns true if the item is expanded (only makes sense if it has children).

wxTreeCtrl::IsSelected
bool IsSelected(const wxTreeItemId& item) const Returns true if the item is selected.

wxTreeCtrl::IsVisible
bool IsVisible(const wxTreeItemId& item) const Returns true if the item is visible (it might be outside the view, or not expanded).

wxTreeCtrl::ItemHasChildren
bool ItemHasChildren(const wxTreeItemId& item) const Returns true if the item has children.

wxTreeCtrl::OnCompareItems
int OnCompareItems(const wxTreeItemId& item1, const wxTreeItemId& item2) Override this function in the derived class to change the sort order of the items in the tree control. The function should return a negative, zero or positive value if the first item is less than, equal to or greater than the second one. The base class version compares items alphabetically. See also: SortChildren (p. 1344)

wxTreeCtrl::PrependItem
wxTreeItemId PrependItem(const wxTreeItemId& parent, const wxString& text, int image = -1, int selImage = -1, wxTreeItemData* data = NULL) Appends an item as the first child of parent, return a new item id. The image and selImage parameters are an index within the normal image list specifying the image to use for unselected and selected items, respectively. If image > -1 and selImage is -1, the same image is used for both selected and unselected items.

1341


CHAPTER 7 wxTreeCtrl::ScrollTo
void ScrollTo(const wxTreeItemId& item) Scrolls the specified item into view.

wxTreeCtrl::SelectItem
bool SelectItem(const wxTreeItemId& item, bool select = true) Selects the given item. In multiple selection controls, can be also used to deselect a currently selected item if the value of select is false.

wxTreeCtrl::SetButtonsImageList
void SetButtonsImageList(wxImageList* imageList) Sets the buttons image list (from which application-defined button images are taken). The button images assigned with this method willnot be deleted by wxTreeCtrl's destructor, you must delete it yourself. Setting or assigning the button image list enables the display of image buttons. Once enabled, the only way to disable the display of button images is to set the button image list to NULL. This function is only available in the generic version. See also AssignButtonsImageList (p. 1331).

wxTreeCtrl::SetIndent
void SetIndent(int indent) Sets the indentation for the tree control.

wxTreeCtrl::SetImageList
void SetImageList(wxImageList* imageList) Sets the normal image list. Image list assigned with this method willnot be deleted by wxTreeCtrl's destructor, you must delete it yourself. See also AssignImageList (p. 1331).

wxTreeCtrl::SetItemBackgroundColour
void SetItemBackgroundColour(const wxTreeItemId& item, const wxColour& col)

1342


CHAPTER 7
Sets the colour of the item's background.

wxTreeCtrl::SetItemBold
void SetItemBold(const wxTreeItemId& item, bool bold = true) Makes item appear in bold font if bold parameter is true or resets it to the normal state. See also: IsBold (p. 1340)

wxTreeCtrl::SetItemData
void SetItemData(const wxTreeItemId& item, wxTreeItemData* data) Sets the item client data. wxPython note: wxPython provides the following shortcut method: SetPyData(item, obj) Associate the given Python Object with the wxTreeItemData for the given item Id.

wxPerl note: wxPerl provides the following shortcut method:SetPlData( item, data ) Sets the Perl data associated with the Wx::TreeItemData. It is just the same as tree->GetItemData(item)->SetData(data).

wxTreeCtrl::SetItemFont
void SetItemFont(const wxTreeItemId& item, const wxFont& font) Sets the item's font. All items in the tree should have the same height to avoid text clipping, so the fonts height should be the same for all of them, although font attributes may vary. See also SetItemBold (p. 1343)

wxTreeCtrl::SetItemHasChildren
void SetItemHasChildren(const wxTreeItemId& item, bool hasChildren = true) Force appearance of the button next to the item. This is useful to allow the user to expand the items which don't have any children now, but instead adding them only when needed, thus minimizing memory usage and loading time.

1343


CHAPTER 7 wxTreeCtrl::SetItemImage
void SetItemImage(const wxTreeItemId& item, int image, wxTreeItemIcon which = wxTreeItemIcon_Normal) Sets the specified item image. See GetItemImage (p. 1336)for the description of the which parameter.

wxTreeCtrl::SetItemSelectedImage
void SetItemSelectedImage(const wxTreeItemId& item, int selImage) Sets the selected item image (this function is obsolete, use SetItemImage(item, wxTreeItemIcon_Selected) instead).

wxTreeCtrl::SetItemText
void SetItemText(const wxTreeItemId& item, const wxString& text) Sets the item label.

wxTreeCtrl::SetItemTextColour
void SetItemTextColour(const wxTreeItemId& item, const wxColour& col) Sets the colour of the item's text.

wxTreeCtrl::SetStateImageList
void SetStateImageList(wxImageList* imageList) Sets the state image list (from which application-defined state images are taken). Image list assigned with this method willnot be deleted by wxTreeCtrl's destructor, you must delete it yourself. See also AssignStateImageList (p. 1331).

wxTreeCtrl::SetWindowStyle
void SetWindowStyle(longstyles) Sets the mode flags associated with the display of the tree control. The new mode takes effect immediately. (Generic only; MSW ignores changes.)

wxTreeCtrl::SortChildren

1344


CHAPTER 7
void SortChildren(const wxTreeItemId& item) Sorts the children of the given item usingOnCompareItems (p. 1341) method of wxTreeCtrl. You should override that method to change the sort order (the default is ascending case-sensitive alphabetical order). See also wxTreeItemData (p. 1348), OnCompareItems (p. 1341)

wxTreeCtrl::Toggle
void Toggle(const wxTreeItemId& item) Toggles the given item between collapsed and expanded states.

wxTreeCtrl::ToggleItemSelection
void ToggleItemSelection(const wxTreeItemId& item) Toggles the given item between selected and unselected states. For multiselection controls only.

wxTreeCtrl::Unselect
void Unselect() Removes the selection from the currently selected item (if any).

wxTreeCtrl::UnselectAll
void UnselectAll() This function either behaves the same as Unselect (p. 1345)if the control doesn't have wxTR_MULTIPLE style, or removes the selection from all items if it does have this style.

wxTreeCtrl::UnselectItem
void UnselectItem(const wxTreeItemId& item) Unselects the given item. This works in multiselection controls only.

wxTreeEvent
A tree event holds information about events associated with wxTreeCtrl objects.

1345


CHAPTER 7
Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/treectrl.h> Event table macros To process input from a tree control, use these event handler macros to direct input to member functions that take a wxTreeEvent argument. EVT_TREE_BEGIN_DRAG(id, func) The user has started dragging an item with the left mouse button. The event handler must call wxTreeEvent::Allow() for the drag operation to continue. The user has started dragging an item with the right mouse button. The event handler must call wxTreeEvent::Allow() for the drag operation to continue. Begin editing a label. This can be prevented by calling Veto() (p. 954). The user has released the mouse after dragging an item. The user has finished editing a label. This can be prevented by calling Veto() (p. 954). A tree item has been deleted. An item has been activated (e.g. double clicked). The item has been collapsed. The item is being collapsed. This can be prevented by calling Veto() (p. 954). The item has been expanded. The item is being expanded. This can be prevented by calling Veto()

EVT_TREE_BEGIN_RDRAG(id, func)

EVT_TREE_BEGIN_LABEL_EDIT(id, func)

EVT_TREE_END_DRAG(id, func) EVT_TREE_END_LABEL_EDIT(id, func)

EVT_TREE_DELETE_ITEM(id, func) EVT_TREE_ITEM_ACTIVATED(id, func) EVT_TREE_ITEM_COLLAPSED(id, func) EVT_TREE_ITEM_COLLAPSING(id, func)

EVT_TREE_ITEM_EXPANDED(id, func) EVT_TREE_ITEM_EXPANDING(id, func)

1346


CHAPTER 7
(p. 954). EVT_TREE_ITEM_RIGHT_CLICK(id, func) EVT_TREE_ITEM_MIDDLE_CLICK(id, func) EVT_TREE_KEY_DOWN(id, func) EVT_TREE_SEL_CHANGED(id, func) EVT_TREE_SEL_CHANGING(id, func) The user has clicked the item with the right mouse button. The user has clicked the item with the middle mouse button. A key has been pressed. Selection has changed. Selection is changing. This can be prevented by calling Veto() (p. 954). A key has been pressed. The opportunity to set the item tooltip is being given to the application (call wxTreeEvent::SetToolTip). Windows only.

EVT_TREE_KEY_DOWN(id, func) EVT_TREE_ITEM_GETTOOLTIP(id, func)

See also wxTreeCtrl (p. 1327)

wxTreeEvent::wxTreeEvent
wxTreeEvent(WXTYPE commandType = 0, int id = 0) Constructor.

wxTreeEvent::GetKeyCode
int GetKeyCode() const Returns the key code if the event was is a key event. Use GetKeyEvent (p. 1347) to get the values of the modifier keys for this event (i.e. Shift or Ctrl).

wxTreeEvent::GetItem
wxTreeItemId GetItem() const Returns the item (valid for all events).

wxTreeEvent::GetKeyEvent 1347


CHAPTER 7
const wxKeyEvent& GetKeyEvent() const Returns the key event for EVT_TREE_KEY_DOWN events.

wxTreeEvent::GetLabel
const wxString& GetLabel() const Returns the label if the event was a begin or end edit label event.

wxTreeEvent::GetOldItem
wxTreeItemId GetOldItem() const Returns the old item index (valid for EVT_TREE_ITEM_CHANGING and CHANGED events)

wxTreeEvent::GetPoint()
wxPoint GetPoint() const Returns the position of the mouse pointer if the event is a drag event.

wxTreeEvent::IsEditCancelled()
bool IsEditCancelled() const Returns true if the label edit was cancelled. This should be called from within an EVT_TREE_END_LABEL_EDIT handler.

wxTreeEvent::SetToolTip
void SetToolTip(const wxString& tooltip) Set the tooltip for the item (valid for EVT_TREE_ITEM_GETTOOLTIP events). Windows only.

wxTreeItemData
wxTreeItemData is some (arbitrary) user class associated with some item. The main advantage of having this class is that wxTreeItemData objects are destroyed automatically by the tree and, as this class has virtual destructor, it means that the memory and any other resources associated with a tree item will be automatically freed when it is deleted. Note that we don't use wxObject as the base class for wxTreeItemData because the size of this class is critical: in many applications, each tree

1348


CHAPTER 7
leaf will have wxTreeItemData associated with it and number of leaves may be quite big. Also please note that because the objects of this class are deleted by the tree using the operator delete, they must always be allocated on the heap using new. Derived from wxClientData (p. 134) Include files <wx/treectrl.h> See also wxTreeCtrl (p. 1327)

wxTreeItemData::wxTreeItemData
wxTreeItemData() Default constructor. wxPython note: The wxPython version of this constructor optionally accepts any Python object as a parameter. This object is then associated with the tree item using the wxTreeItemData as a container. In addition, the following methods are added in wxPython for accessing the object: GetData() SetData(obj) Returns a reference to the Python Object Associates a new Python Object with the wxTreeItemData

wxPerl note: In wxPerl the constructor accepts as parameter an optional scalar, and stores it as client data. You may retrieve this data by calling GetData(), and set it by calling SetData( data ).

wxTreeItemData::~wxTreeItemData
void ~wxTreeItemData() Virtual destructor.

wxTreeItemData::GetId

1349


CHAPTER 7
const wxTreeItem& GetId() Returns the item associated with this node.

wxTreeItemData::SetId
void SetId(const wxTreeItemId& id) Sets the item associated with this node.

wxUpdateUIEvent
This class is used for pseudo-events which are called by wxWindows to give an application the chance to update various user interface elements. Derived from wxCommandEvent (p. 164) wxEvent (p. 439) wxObject (p. 954) Include files <wx/event.h> Event table macros To process an update event, use these event handler macros to direct input to member functions that take a wxUpdateUIEvent argument. EVT_UPDATE_UI(id, func) Process a wxEVT_UPDATE_UI event for the command with the given id.

EVT_UPDATE_UI_RANGE(id1, id2, func) Process a wxEVT_UPDATE_UI event for any command with id included in the given range. Remarks Without update UI events, an application has to work hard to check/uncheck, enable/disable, and set the text for elements such as menu items and toolbar buttons. The code for doing this has to be mixed up with the code that is invoked when an action is invoked for a menu item or button. With update UI events, you define an event handler to look at the state of the application and change UI elements accordingly. wxWindows will call your member functions in idle time, so you don't have to worry where to call this code. In addition to being a clearer and more declarative method, it also means you don't have to worry whether you're updating a toolbar or menubar identifier. The same handler can update a menu item and toolbar button, if the identifier is the same.

1350


CHAPTER 7
Instead of directly manipulating the menu or button, you call functions in the event object, such as wxUpdateUIEvent::Check (p. 1353). wxWindows will determine whether such a call has been made, and which UI element to update. These events will work for popup menus as well as menubars. Just before a menu is popped up, wxMenu::UpdateUI (p. 898) is called to process any UI events for the window that owns the menu. If you find that the overhead of UI update processing is affecting your application, you can do one or both of the following: 1. Call wxUpdateUIEvent::SetMode (p. 1354) with a value of wxUPDATE_UI_PROCESS_SPECIFIED, and set the extra style wxWS_EX_PROCESS_UPDATE_EVENTS for every window that should receive update events. No other windows will receive update events. Call wxUpdateUIEvent::SetUpdateInterval (p. 1355) with a millisecond value to set the delay between updates. You may need to call wxWindow::UpdateWindowUI (p. 1434) at critical points, for example when a dialog is about to be shown, in case the user sees a slight delay before windows are updated.

2.

Note that although events are sent in idle time, defining a wxIdleEvent handler for a window does not affect this because the events are sent from wxWindow::OnInternalIdle (p. 1412) which is always called in idle time. wxWindows tries to optimize update events on some platforms. On Windows and GTK+, events for menubar items are only sent when the menu is about to be shown, and not in idle time. See also Event handling overview (p. 1602)

wxUpdateUIEvent::wxUpdateUIEvent
wxUpdateUIEvent(wxWindowID commandId = 0) Constructor.

wxUpdateUIEvent::m_checked
bool m_checked true if the element should be checked, false otherwise.

wxUpdateUIEvent::m_enabled

1351


CHAPTER 7
bool m_checked true if the element should be enabled, false otherwise.

wxUpdateUIEvent::m_setChecked
bool m_setChecked true if the application has set the m_checked member.

wxUpdateUIEvent::m_setEnabled
bool m_setEnabled true if the application has set the m_enabled member.

wxUpdateUIEvent::m_setText
bool m_setText true if the application has set the m_text member.

wxUpdateUIEvent::m_text
wxString m_text Holds the text with which the the application wishes to update the UI element.

wxUpdateUIEvent::CanUpdate
static bool CanUpdate(wxWindow* window) Returns true if it is appropriate to update (send UI update events to) this window. This function looks at the mode used (see wxUpdateUIEvent::SetMode (p. 1354)), the wxWS_EX_PROCESS_UPDATE_EVENTS flag in window, the time update events were last sent in idle time, and the update interval, to determine whether events should be sent to this window now. By default this will always return true because the update mode is initially wxUPDATE_UI_PROCESS_ALL and the interval is set to 0; so update events will be sent as often as possible. You can reduce the frequency that events are sent by changing the mode and/or setting an update interval. See also wxUpdateUIEvent::ResetUpdateTime (p. 1354), wxUpdateUIEvent::SetUpdateInterval (p. 1355), wxUpdateUIEvent::SetMode (p. 1354)

1352


CHAPTER 7 wxUpdateUIEvent::Check
void Check(bool check) Check or uncheck the UI element.

wxUpdateUIEvent::Enable
void Enable(bool enable) Enable or disable the UI element.

wxUpdateUIEvent::GetChecked
bool GetChecked() const Returns true if the UI element should be checked.

wxUpdateUIEvent::GetEnabled
bool GetEnabled() const Returns true if the UI element should be enabled.

wxUpdateUIEvent::GetSetChecked
bool GetSetChecked() const Returns true if the application has called SetChecked. For wxWindows internal use only.

wxUpdateUIEvent::GetSetEnabled
bool GetSetEnabled() const Returns true if the application has called SetEnabled. For wxWindows internal use only.

wxUpdateUIEvent::GetSetText
bool GetSetText() const Returns true if the application has called SetText. For wxWindows internal use only.

wxUpdateUIEvent::GetText
wxString GetText() const

1353


CHAPTER 7
Returns the text that should be set for the UI element.

wxUpdateUIEvent::GetMode
static wxUpdateUIMode GetMode() Static function returning a value specifying how wxWindows will send update events: to all windows, or only to those which specify that they will process the events. See wxUpdateUIEvent::SetMode (p. 1354).

wxUpdateUIEvent::GetUpdateInterval
static long GetUpdateInterval() Returns the current interval between updates in milliseconds. -1 disables updates, 0 updates as frequently as possible. See wxUpdateUIEvent::SetUpdateInterval (p. 1355).

wxUpdateUIEvent::ResetUpdateTime
static void ResetUpdateTime() Used internally to reset the last-updated time to the current time. It is assumed that update events are normally sent in idle time, so this is called at the end of idle processing. See also wxUpdateUIEvent::CanUpdate (p. 1352), wxUpdateUIEvent::SetUpdateInterval (p. 1355), wxUpdateUIEvent::SetMode (p. 1354)

wxUpdateUIEvent::SetMode
static void SetMode(wxIdleMode mode) Specify how wxWindows will send update events: to all windows, or only to those which specify that they will process the events. mode may be one of the following values. The default is wxUPDATE_UI_PROCESS_ALL.
enum wxUpdateUIMode { // Send UI update events to all windows wxUPDATE_UI_PROCESS_ALL, // Send UI update events to windows that have // the wxWS_EX_PROCESS_UI_UPDATES flag specified wxUPDATE_UI_PROCESS_SPECIFIED

1354


CHAPTER 7
};

wxUpdateUIEvent::SetText
void SetText(const wxString& text) Sets the text for this UI element.

wxUpdateUIEvent::SetUpdateInterval
static void SetUpdateInterval(long updateInterval) Sets the interval between updates in milliseconds. Set to -1 to disable updates, or to 0 to update as frequently as possible. The default is 0. Use this to reduce the overhead of UI update events if your application has a lot of windows. If you set the value to -1 or greater than 0, you may also need to call wxWindow::UpdateWindowUI (p. 1434) at appropriate points in your application, such as when a dialog is about to be shown.

wxURL
Derived from wxObject (p. 954) Include files <wx/url.h> See also wxSocketBase (p. 1131), wxProtocol (p. 1027) Example
wxURL url("http://a.host/a.dir/a.file"); wxInputStream *in_stream; in_stream = url.GetInputStream(); // Then, you can use all IO calls of in_stream (See wxStream)

wxURL::wxURL
wxURL(const wxString& url) Constructs a URL object from the string. The URL must be valid according to RFC 1738. In particular, file URLs must be of the format 'file://hostname/path/to/file'. It is

1355


CHAPTER 7
valid to leave out the hostname but slashes must remain in place-- i.e. a file URL without a hostname must contain three consecutive slashes. Parameters url Url string to parse.

wxURL::~wxURL
~wxURL() Destroys the URL object.

wxURL::GetProtocolName
wxString GetProtocolName() const Returns the name of the protocol which will be used to get the URL.

wxURL::GetProtocol
wxProtocol& GetProtocol() Returns a reference to the protocol which will be used to get the URL.

wxURL::GetPath
wxString GetPath() Returns the path of the file to fetch. This path was encoded in the URL.

wxURL::GetError
wxURLError GetError() const Returns the last error. This error refers to the URL parsing or to the protocol. It can be one of these errors: wxURL_NOERR wxURL_SNTXERR wxURL_NOPROTO wxURL_NOHOST No error. Syntax error in the URL string. Found no protocol which can get this URL. An host name is required for this protocol.

1356


CHAPTER 7
wxURL_NOPATH wxURL_CONNERR wxURL_PROTOERR A path is required for this protocol. Connection error. An error occurred during negotiation.

wxURL::GetInputStream
wxInputStream * GetInputStream() Creates a new input stream on the the specified URL. You can use all but seek functionality of wxStream. Seek isn't available on all stream. For example, http or ftp streams doesn't deal with it. Return value Returns the initialized stream. You will have to delete it yourself. See also wxInputStream (p. 762)

wxURL::SetDefaultProxy
static void SetDefaultProxy(const wxString& url_proxy) Sets the default proxy server to use to get the URL. The string specifies the proxy like this: <hostname>:<port number>. Parameters url_proxy Specifies the proxy to use See also wxURL::SetProxy (p. 1357)

wxURL::SetProxy
void SetProxy(const wxString& url_proxy) Sets the proxy to use for this URL. See also wxURL::SetDefaultProxy (p. 1357)

wxURL::ConvertToValidURI 1357


CHAPTER 7
static wxString ConvertToValidURI(const wxString& uri) It converts a non-standardized URI to a valid network URI. It encodes non standard characters.

wxValidator
wxValidator is the base class for a family of validator classes that mediate between a class of control, and application data. A validator has three major roles: 1. 2. 3. to transfer data from a C++ variable or own storage to and from a control; to validate data in a control, and show an appropriate error message; to filter events (such as keystrokes), thereby changing the behaviour of the associated control.

Validators can be plugged into controls dynamically. To specify a default, 'null' validator, use the symbol wxDefaultValidator. For more information, please see Validator overview (p. 1614). wxPython note: If you wish to create a validator class in wxPython you should derive the class from wxPyValidator in order to get Python-aware capabilities for the various virtual methods. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/validate.h> See also Validator overview (p. 1614), wxTextValidator (p. 1281), wxGenericValidator (p. 564),

wxValidator::wxValidator
wxValidator() Constructor.

wxValidator::~wxValidator 1358


CHAPTER 7
~wxValidator() Destructor.

wxValidator::Clone
virtual wxObject* Clone() const All validator classes must implement the Clone function, which returns an identical copy of itself. This is because validators are passed to control constructors as references which must be copied. Unlike objects such as pens and brushes, it does not make sense to have a reference counting scheme to do this cloning, because all validators should have separate data. This base function returns NULL.

wxValidator::GetWindow
wxWindow* GetWindow() const Returns the window associated with the validator.

wxValidator::SetBellOnError
wxvalidatorsetbellonerror void SetBellOnError(bool doIt = true) This functions switches on or turns off the error sound produced by the validators if an invalid key is pressed.

wxValidator::SetWindow
void SetWindow(wxWindow* window) Associates a window with the validator.

wxValidator::TransferFromWindow
virtual bool TransferToWindow() This overridable function is called when the value in the window must be transferred to the validator. Return false if there is a problem.

wxValidator::TransferToWindow

1359


CHAPTER 7
virtual bool TransferToWindow() This overridable function is called when the value associated with the validator must be transferred to the window. Return false if there is a problem.

wxValidator::Validate
virtual bool Validate(wxWindow* parent) This overridable function is called when the value in the associated window must be validated. Return false if the value in the window is not valid; you may pop up an error dialog.

wxVariant
The wxVariant class represents a container for any type. A variant's value can be changed at run time, possibly to a different type of value. As standard, wxVariant can store values of type bool, char, double, long, string, string list, time, date, void pointer, list of strings, and list of variants. However, an application can extend wxVariant's capabilities by deriving from the class wxVariantData (p. 1367) and using the wxVariantData form of the wxVariant constructor or assignment operator to assign this data to a variant. Actual values for user-defined types will need to be accessed via the wxVariantData object, unlike the case for basic data types where convenience functions such as GetLong can be used. This class is useful for reducing the programming for certain tasks, such as an editor for different data types, or a remote procedure call protocol. An optional name member is associated with a wxVariant. This might be used, for example, in CORBA or OLE automation classes, where named parameters are required. Derived from wxObject (p. 954) Include files <wx/variant.h> See also wxVariantData (p. 1367)

wxVariant::wxVariant
wxVariant()

1360


CHAPTER 7
Default constructor. wxVariant(const wxVariant& variant) Copy constructor. wxVariant(const char* value, const wxString& name = "") wxVariant(const wxString& value, const wxString& name = "") Construction from a string value. wxVariant(char value, const wxString& name = "") Construction from a character value. wxVariant(long value, const wxString& name = "") Construction from an integer value. You may need to cast to (long) to avoid confusion with other constructors (such as the bool constructor). wxVariant(bool value, const wxString& name = "") Construction from a boolean value. wxVariant(double value, const wxString& name = "") Construction from a double-precision floating point value. wxVariant(const wxList& value, const wxString& name = "") Construction from a list of wxVariant objects. This constructor copies value, the application is still responsible for deleting value and its contents. wxVariant(const wxStringList& value, const wxString& name = "") Construction from a list of strings. This constructor copies value, the application is still responsible for deleting value and its contents. wxVariant(void* value, const wxString& name = "") Construction from a void pointer. wxVariant(wxObject* value, const wxString& name = "") Construction from a wxObject pointer. wxVariant(wxVariantData* data, const wxString& name = "") Construction from user-defined data. The variant holds on to the data pointer.

wxVariant::~wxVariant
~wxVariant()

1361


CHAPTER 7
Destructor.

wxVariant::Append
void Append(const wxVariant& value) Appends a value to the list.

wxVariant::ClearList
void ClearList() Deletes the contents of the list.

wxVariant::GetCount
int GetCount() const Returns the number of elements in the list.

wxVariant::Delete
bool Delete(int item) Deletes the zero-based item from the list.

wxVariant::GetBool
bool GetBool() const Returns the boolean value.

wxVariant::GetChar
char GetChar() const Returns the character value.

wxVariant::GetData
wxVariantData* GetData() const Returns a pointer to the internal variant data.

1362


CHAPTER 7 wxVariant::GetDouble
double GetDouble() const Returns the floating point value.

wxVariant::GetLong
long GetLong() const Returns the integer value.

wxVariant::GetName
const wxString& GetName() const Returns a constant reference to the variant name.

wxVariant::GetString
wxString GetString() const Gets the string value.

wxVariant::GetType
wxString GetType() const Returns the value type as a string. The built-in types are: bool, char, date, double, list, long, string, stringlist, time, void*. If the variant is null, the value type returned is the string "null" (not the empty string).

wxVariant::GetVoidPtr
void* GetVoidPtr() const Gets the void pointer value.

wxVariant::GetWxObjectPtr
void* GetWxObjectPtr() const Gets the wxObject pointer value.

1363


CHAPTER 7 wxVariant::Insert
void Insert(const wxVariant& value) Inserts a value at the front of the list.

wxVariant::IsNull
bool IsNull() const Returns true if there is no data associated with this variant, false if there is data.

wxVariant::IsType
bool IsType(const wxString& type) const Returns true if type matches the type of the variant, false otherwise.

wxVariant::IsValueKindOf
bool IsValueKindOf(const wxClassInfo* type type) const Returns true if the data is derived from the class described by type, false otherwise.

wxVariant::MakeNull
void MakeNull() Makes the variant null by deleting the internal data.

wxVariant::MakeString
wxString MakeString() const Makes a string representation of the variant value (for any type).

wxVariant::Member
bool Member(const wxVariant& value) const Returns true if value matches an element in the list.

wxVariant::NullList
void NullList()

1364


CHAPTER 7
Makes an empty list. This differs from a null variant which has no data; a null list is of type list, but the number of elements in the list is zero.

wxVariant::SetData
void SetData(wxVariantData* data) Sets the internal variant data, deleting the existing data if there is any.

wxVariant::operator =
void operator =(const wxVariant& value) void operator =(wxVariantData* value) void operator =(const wxString& value) void operator =(const char* value) void operator =(char value) void operator =(const long value) void operator =(const bool value) void operator =(const double value) void operator =(void* value) void operator =(const wxList& value) void operator =(const wxStringList& value) Assignment operators.

wxVariant::operator ==
bool operator ==(const wxVariant& value) bool operator ==(const wxString& value) bool operator ==(const char* value) bool operator ==(char value) bool operator ==(const long value) bool operator ==(const bool value) bool operator ==(const double value) bool operator ==(void* value)

1365


CHAPTER 7
bool operator ==(const wxList& value) bool operator ==(const wxStringList& value) Equality test operators.

wxVariant::operator !=
bool operator !=(const wxVariant& value) bool operator !=(const wxString& value) bool operator !=(const char* value) bool operator !=(char value) bool operator !=(const long value) bool operator !=(const bool value) bool operator !=(const double value) bool operator !=(void* value) bool operator !=(const wxList& value) bool operator !=(const wxStringList& value) Inequality test operators.

wxVariant::operator []
wxVariant operator [](size_t idx) const Returns the value at idx (zero-based). wxVariant& operator [](size_t idx) Returns a reference to the value at idx (zero-based). This can be used to change the value at this index.

wxVariant::operator char
char operator char() const Operator for implicit conversion to a char, using wxVariant::GetChar (p. 1362).

wxVariant::operator double
double operator double() const

1366


CHAPTER 7
Operator for implicit conversion to a double, using wxVariant::GetDouble (p. 1363). long operator long() const Operator for implicit conversion to a long, using wxVariant::GetLong (p. 1363).

wxVariant::operator wxString
wxString operator wxString() const Operator for implicit conversion to a string, using wxVariant::MakeString (p. 1364).

wxVariant::operator void*
void* operator void*() const Operator for implicit conversion to a pointer to a void, using wxVariant::GetVoidPtr (p. 1363).

wxVariantData
The wxVariantData is used to implement a new type for wxVariant. Derive from wxVariantData, and override the pure virtual functions. Derived from wxObject (p. 954) Include files <wx/variant.h> See also wxVariant (p. 1360)

wxVariantData::wxVariantData
wxVariantData() Default constructor.

wxVariantData::Copy
void Copy(wxVariantData& data)

1367


CHAPTER 7
Copy the data from 'this' object to data.

wxVariantData::Eq
bool Eq(wxVariantData& data) const Returns true if this object is equal to data.

wxVariantData::GetType
wxString GetType() const Returns the string type of the data.

wxVariantData::GetValueClassInfo
wxClassInfo* GetValueClassInfo() const If the data is a wxObject returns a pointer to the objects wxClassInfo structure, if the data isn't a wxObject the method returns NULL.

wxVariantData::Read
bool Read(ostream& stream) bool Read(wxString& string) Reads the data from stream or string.

wxVariantData::Write
bool Write(ostream& stream) const bool Write(wxString& string) const Writes the data to stream or string.

wxGetVariantCast
classname * wxGetVariantCast(wxVariant&, classname) This macro returns the data stored in variant cast to the type classname * if the data is of this type (the check is done during the run-time) orNULL otherwise. See also

1368


CHAPTER 7
RTTI overview (p. 1572) wxDynamicCast (p. 1519)

wxView
The view class can be used to model the viewing and editing component of an application's file-based data. It is part of the document/view framework supported by wxWindows, and cooperates with the wxDocument (p. 413), wxDocTemplate (p. 408) and wxDocManager (p. 394) classes. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/docview.h> See also wxView overview (p. 1653), wxDocument (p. 413), wxDocTemplate (p. 408), wxDocManager (p. 394)

wxView::m_viewDocument
wxDocument* m_viewDocument The document associated with this view. There may be more than one view per document, but there can never be more than one document for one view.

wxView::m_viewFrame
wxFrame* m_viewFrame Frame associated with the view, if any.

wxView::m_viewTypeName
wxString m_viewTypeName The view type name given to the wxDocTemplate constructor, copied to this variable when the view is created. Not currently used by the framework.

wxView::wxView 1369


CHAPTER 7
wxView() Constructor. Define your own default constructor to initialize application-specific data.

wxView::~wxView
~wxView() Destructor. Removes itself from the document's list of views.

wxView::Activate
virtual void Activate(bool activate) Call this from your view frame's OnActivate member to tell the framework which view is currently active. If your windowing system doesn't call OnActivate, you may need to call this function from OnMenuCommand or any place where you know the view must be active, and the framework will need to get the current view. The prepackaged view frame wxDocChildFrame calls wxView::Activate from its OnActivate member and from its OnMenuCommand member. This function calls wxView::OnActivateView.

wxView::Close
virtual bool Close(bool deleteWindow = true) Closes the view by calling OnClose. If deleteWindow is true, this function should delete the window associated with the view.

wxView::GetDocument
wxDocument* GetDocument() const Gets a pointer to the document associated with the view.

wxView::GetDocumentManager
wxDocumentManager* GetDocumentManager() const Returns a pointer to the document manager instance associated with this view.

wxView::GetFrame
wxWindow * GetFrame()

1370


CHAPTER 7
Gets the frame associated with the view (if any). Note that this "frame'' is not a wxFrame at all in the generic MDI implementation which uses the notebook pages instead of the frames and this is why this method returns a wxWindow and not a wxFrame.

wxView::GetViewName
wxString GetViewName() const Gets the name associated with the view (passed to the wxDocTemplate constructor). Not currently used by the framework.

wxView::OnActivateView
virtual void OnActivateView(bool activate, wxView *activeView, wxView *deactiveView) Called when a view is activated by means of wxView::Activate. The default implementation does nothing.

wxView::OnChangeFilename
virtual void OnChangeFilename() Called when the filename has changed. The default implementation constructs a suitable title and sets the title of the view frame (if any).

wxView::OnClose
virtual bool OnClose(bool deleteWindow) Implements closing behaviour. The default implementation calls wxDocument::Close to close the associated document. Does not delete the view. The application may wish to do some cleaning up operations in this function, if a call to wxDocument::Close succeeded. For example, if your application's all share the same window, you need to disassociate the window from the view and perhaps clear the window. If deleteWindow is true, delete the frame associated with the view.

wxView::OnClosingDocument
virtual void OnClosingDoocument() Override this to clean up the view when the document is being closed.

wxView::OnCreate

1371


CHAPTER 7
virtual bool OnCreate(wxDocument* doc, long flags) wxDocManager or wxDocument creates a wxView via a wxDocTemplate. Just after the wxDocTemplate creates the wxView, it calls wxView::OnCreate. In its OnCreate member function, the wxView can create a wxDocChildFrame or a derived class. This wxDocChildFrame provides user interface elements to view and/or edit the contents of the wxDocument. By default, simply returns true. If the function returns false, the view will be deleted.

wxView::OnCreatePrintout
virtual wxPrintout* OnCreatePrintout() If the printing framework is enabled in the library, this function returns a wxPrintout (p. 1010) object for the purposes of printing. It should create a new object every time it is called; the framework will delete objects it creates. By default, this function returns an instance of wxDocPrintout, which prints and previews one page by calling wxView::OnDraw. Override to return an instance of a class other than wxDocPrintout.

wxView::OnUpdate
virtual void OnUpdate(wxView* sender, wxObject* hint) Called when the view should be updated. sender is a pointer to the view that sent the update request, or NULL if no single view requested the update (for instance, when the document is opened). hint is as yet unused but may in future contain application-specific information for making updating more efficient.

wxView::SetDocument
void SetDocument(wxDocument* doc) Associates the given document with the view. Normally called by the framework.

wxView::SetFrame
void SetFrame(wxWindow* frame) Sets the frame associated with this view. The application should call this if possible, to tell the view about the frame. See GetFrame (p. 1370) for the explanation about the mismatch between the "Frame'' in the method name and the type of its parameter.

1372


CHAPTER 7 wxView::SetViewName
void SetViewName(const wxString& name) Sets the view type name. Should only be called by the framework.

wxVListBox
wxVListBox is a listbox-like control with the following two main differences from a regular listbox: it can have an arbitrarily huge number of items because it doesn't store them itself but uses OnDrawItem() (p. 1377) callback to draw them (so it is a Virtual listbox) and its items can have variable height as determined by OnMeasureItem() (p. 1377) (so it is also a listbox with the lines of Variable height). Also, as a consequence of its virtual nature, it doesn't have any methods to append or insert items in it as it isn't necessary to do it: you just have to call SetItemCount() (p. 1378) to tell the control how many items it should display. Of course, this also means that you will never use this class directly because it has pure virtual functions, but will need to derive your own class, such as wxHtmlListBox (p. 683), from it. However it emits the same events as wxListBox (p. 793) and the same event macros may be used with it. Derived from wxVScrolledWindow (p. 1379) Include files <wx/vlbox.h>

wxVListBox::wxVListBox
wxVListBox(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, size_t countItems = 0, long style = 0, const wxString& name = wxVListBoxNameStr) Normal constructor which calls Create() (p. 1374) internally. wxVListBox() Default constructor, you must call Create() (p. 1374) later.

wxVListBox::Clear
void Clear() Deletes all items from the control.

1373


CHAPTER 7 wxVListBox::Create
bool Create(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = wxVListBoxNameStr) Creates the control. To finish creating it you also should call SetItemCount() (p. 1378) to let it know about the number of items it contains. The only special style which may be used with wxVListBox is wxLB_MULTIPLE which indicates that the listbox should support multiple selection. Returns true on success or false if the control couldn't be created

wxVListBox::DeselectAll
bool DeselectAll() Deselects all the items in the listbox. Returns true if any items were changed, i.e. if there had been any selected items before, or false if all the items were already deselected. This method is only valid for multi selection listboxes. See also SelectAll (p. 1378), Select (p. 1378)

wxVListBox::GetFirstSelected
int GetFirstSelected(unsigned long& cookie) const Returns the index of the first selected item in the listbox or wxNOT_FOUND if no items are currently selected. cookie is an opaque parameter which should be passed to the subsequent calls to GetNextSelected (p. 1375). It is needed in order to allow parallel iterations over the selected items.
Here is a typical example of using these functions:unsigned long cookie; int item = hlbox->GetFirstSelected(cookie); while ( item != wxNOT_FOUND ) { ... process item ... item = hlbox->GetNextSelected(cookie); }

This method is only valid for multi selection listboxes.

wxVListBox::GetItemCount

1374


CHAPTER 7
size_t GetItemCount() const Get the number of items in the control. See also SetItemCount() (p. 1378)

wxVListBox::GetMargins
wxPoint GetMargins() const Returns the margins used by the control. The x field of the returned point is the horizontal margine and the y field is the vertical one. See also SetMargins (p. 1379)

wxVListBox::GetNextSelected
int GetNextSelected(unsigned long& cookie) const Returns the index of the next selected item or wxNOT_FOUND if there are no more. This method is only valid for multi selection listboxes. See also GetFirstSelected (p. 1374)

wxVListBox::GetSelectedCount
size_t GetSelectedCount() const Returns the number of the items currently selected. It is valid for both single and multi selection controls. In the former case it may only return 0 or 1 however. See also IsSelected (p. 1376), GetFirstSelected (p. 1374), GetNextSelected (p. 1375)

wxVListBox::GetSelection
int GetSelection() const

1375


CHAPTER 7
Get the currently selected item or -1 if there is no selection.

wxVListBox::GetSelectionBackground
const wxColour& GetSelectionBackground() const Returns the background colour used for the selected cells. By default the standard system colour is used. See also wxSystemSettings::GetColour (p. 1230), SetSelectionBackground (p. 1379)

wxVListBox::HasMultipleSelection
bool HasMultipleSelection() const Returns true if the listbox was created with wxLB_MULTIPLE style and so supports multiple selection or false if it is a single selection listbox.

wxVListBox::IsCurrent
bool IsCurrent(size_t item) const Returns true if this item is the current one, false otherwise. Current item is always the same as selected one for the single selection listbox and in this case this method is equivalent to IsSelected (p. 1376) but they are different for multi selection listboxes where many items may be selected but only one (at most) is current.

wxVListBox::IsSelected
bool IsSelected(size_t item) const Returns true if this item is selected, false otherwise.

wxVListBox::OnDrawBackground
void OnDrawBackground(wxDC& dc, const wxRect& rect, size_t n) const This method is used to draw the items background and, maybe, a border around it. The base class version implements a reasonable default behaviour which consists in drawing the selected item with the standard background colour and drawing a border around the item if it is either selected or current.

1376


CHAPTER 7 wxVListBox::OnDrawItem
void OnDrawItem(wxDC& dc, const wxRect& rect, size_t n) const The derived class must implement this function to actually draw the item with the given index on the provided DC. Parameters dc The device context to use for drawing rect The bounding rectangle for the item being drawn (DC clipping region is set to this rectangle before calling this function) n The index of the item to be drawn

wxVListBox::OnDrawSeparator
void OnDrawSeparator(wxDC& dc, wxRect& rect, size_t n) const This method may be used to draw separators between the lines. The rectangle passed to it may be modified, typically to deflate it a bit before passing toOnDrawItem() (p. 1377). The base class version of this method doesn't do anything. Parameters dc The device context to use for drawing rect The bounding rectangle for the item n The index of the item

wxVListBox::OnMeasureItem
wxCoord OnMeasureItem(size_t n) const The derived class must implement this method to return the height of the specified item (in pixels).

1377


CHAPTER 7 wxVListBox::Select
bool Select(size_t item, bool select = true) Selects or deselects the specified item which must be valid (i.e. not equal to wxNOT_FOUND). Return true if the items selection status has changed or falseotherwise. This function is only valid for the multiple selection listboxes, use SetSelection (p. 1379) for the single selection ones.

wxVListBox::SelectAll
bool SelectAll() Selects all the items in the listbox. Returns true if any items were changed, i.e. if there had been any unselected items before, or false if all the items were already selected. This method is only valid for multi selection listboxes. See also DeselectAll (p. 1374), Select (p. 1378)

wxVListBox::SelectRange
bool SelectRange(size_t from, size_t to) Selects all items in the specified range which may be given in any order. Return true if the items selection status has changed or falseotherwise. This method is only valid for multi selection listboxes. See also SelectAll (p. 1378), Select (p. 1378)

wxVListBox::SetItemCount
void SetItemCount(size_t count) Set the number of items to be shown in the control. This is just a synonym forwxVScrolledWindow::SetLineCount() (p. 1384).

1378


CHAPTER 7 wxVListBox::SetMargins
void SetMargins(const wxPoint& pt) void SetMargins(wxCoord x, wxCoord y) Set the margins: horizontal margin is the distance between the window border and the item contents while vertical margin is half of the distance between items. By default both margins are 0.

wxVListBox::SetSelection
void SetSelection(int selection) Set the selection to the specified item, if it is -1 the selection is unset. The selected item will be automatically scrolled into view if it isn't currently visible. This method may be used both with single and multiple selection listboxes.

wxVListBox::SetSelectionBackground
void SetSelectionBackground(const wxColour& col) Sets the colour to be used for the selected cells background. The background of the standard cells may be changed by simply calling SetBackgroundColour (p. 1420). See also GetSelectionBackground (p. 1376)

wxVListBox::Toggle
void Toggle(size_t item) Toggles the state of the specified item, i.e. selects it if it was unselected and deselects it if it was selected. This method is only valid for multi selection listboxes. See also Select (p. 1378)

wxVScrolledWindow
In the name of this class, "V" may stand for "variable" because it can be used for scrolling lines of variable heights; "virtual" because it is not necessary to know the heights of all lines in advance -- only those which are shown on the screen need to be

1379


CHAPTER 7
measured; or, even, "vertical" because this class only supports scrolling in one direction currently (this could and probably will change in the future however). In any case, this is a generalization of the wxScrolledWindow (p. 1085) class which can be only used when all lines have the same height. It lacks some other wxScrolledWindow features however, notably there is currently no support for horizontal scrolling; it can't scroll another window nor only a rectangle of the window and not its entire client area. To use this class, you need to derive from it and implement OnGetLineHeight() (p. 1382) pure virtual method. You also must call SetLineCount (p. 1384) to let the base class know how many lines it should display but from that moment on the scrolling is handled entirely by wxVScrolledWindow, you only need to draw the visible part of contents in your OnPaint() method as usual. You should use GetFirstVisibleLine() (p. 1381) and GetLastVisibleLine() (p. 1382) to select the lines to display. ote that the device context origin is not shifted so the first visible line always appears at the point (0, 0) in physical as well as logical coordinates. Derived from wxPanel (p. 972) Include files <wx/vscroll.h>

wxVScrolledWindow::wxVScrolledWindow
wxVScrolledWindow(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = wxPanelNameStr) This is the normal constructor, no need to call Create() after using this one. Note that wxVSCROLL is always automatically added to our style, there is no need to specify it explicitly. wxVScrolledWindow() Default constructor, you must call Create() (p. 1381) later. Parameters parent The parent window, must not be NULL id The identifier of this window, wxID_ANY by default pos

1380


CHAPTER 7
The initial window position size The initial window size style The window style. There are no special style bits defined for this class. name The name for this window; usually not used

wxVScrolledWindow::Create
bool Create(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = wxPanelNameStr) Same as the non default ctor (p. 1380) but returns status code: true if ok, false if the window couldn't have been created. Just as with the ctor above, wxVSCROLL style is always used, there is no need to specify it explicitly.

wxVScrolledWindow::EstimateTotalHeight
virtual wxCoord EstimateTotalHeight() const This protected function is used internally by wxVScrolledWindow to estimate the total height of the window when SetLineCount (p. 1384) is called. The default implementation uses the brute force approach if the number of the items in the control is small enough. Otherwise, it tries to find the average line height using some lines in the beginning, middle and the end. If it is undesirable to access all these lines (some of which might be never shown) just for the total height calculation, you may override the function and provide your own guess better and/or faster. Note that although returning a totally wrong value would still work, it risks to result in very strange scrollbar behaviour so this function should really try to make the best guess possible.

wxVScrolledWindow::GetFirstVisibleLine
size_t GetFirstVisibleLine() const Returns the index of the first currently visible line.

1381


CHAPTER 7 wxVScrolledWindow::GetLastVisibleLine
size_t GetLastVisibleLine() const Returns the index of the last currently visible line.

wxVScrolledWindow::GetLineCount
size_t GetLineCount() const Get the number of lines this window contains (previously set by SetLineCount() (p. 1384))

wxVScrolledWindow::HitTest
int HitTest(wxCoord x, wxCoord y) const int HitTest(const wxPoint& pt) const Return the item at the specified (in physical coordinates) position orwxNOT_FOUND if none, i.e. if it is below the last item.

wxVScrolledWindow::IsVisible
bool IsVisible(size_t line) const Returns true if the given line is (at least partially) visible or false otherwise.

wxVScrolledWindow::OnGetLineHeight
wxCoord OnGetLineHeight(size_t n) const This protected virtual function must be overridden in the derived class and it should return the height of the given line in pixels. See also OnGetLinesHint (p. 1382)

wxVScrolledWindow::OnGetLinesHint
void OnGetLinesHint(size_t lineMin, size_t lineMax) const This function doesn't have to be overridden but it may be useful to do it if calculating the lines heights is a relatively expensive operation as it gives the user code a possibility to calculate several of them at once. OnGetLinesHint() is normally called just before OnGetLineHeight() (p. 1382) but you

1382


CHAPTER 7
shouldn't rely on the latter being called for all lines in the interval specified here. It is also possible that OnGetLineHeight() will be called for the lines outside of this interval, so this is really just a hint, not a promise. Finally note that lineMin is inclusive, while lineMax is exclusive, as usual.

wxVScrolledWindow::RefreshLine
void RefreshLine(size_t line) Refreshes the specified line -- it will be redrawn during the next main loop iteration. See also RefreshLines (p. 1383)

wxVScrolledWindow::RefreshLines
void RefreshLines(size_t from, size_t to) Refreshes all lines between from and to, inclusive. fromshould be less than or equal to to. See also RefreshLine (p. 1383)

wxVScrolledWindow::RefreshAll
void RefreshAll() This function completely refreshes the control, recalculating the number of items shown on screen and repaining them. It should be called when the values returned by OnGetLineHeight (p. 1382) change for some reason and the window must be updated to reflect this.

wxVScrolledWindow::ScrollLines
bool ScrollLines(int lines) Scroll by the specified number of lines which may be positive (to scroll down) or negative (to scroll up). Returns true if the window was scrolled, false otherwise (for example if we're trying to scroll down but we are already showing the last line). See also LineUp (p. 1411), LineDown (p. 1411)

1383


CHAPTER 7 wxVScrolledWindow::ScrollPages
bool ScrollPages(int pages) Scroll by the specified number of pages which may be positive (to scroll down) or negative (to scroll up). See also ScrollLines (p. 1383), PageUp (p. 1412), PageDown (p. 1412)

wxVScrolledWindow::ScrollToLine
bool ScrollToLine(size_t line) Scroll to the specified line: it will become the first visible line in the window. Return true if we scrolled the window, false if nothing was done.

wxVScrolledWindow::SetLineCount
void SetLineCount(size_t count) Set the number of lines the window contains: the derived class must provide the heights for all lines with indices up to the one given here in its OnGetLineHeight() (p. 1382).

wxSound
This class represents a short sound (loaded from Windows WAV file), that can be stored in memory and played. Currently this class is implemented on Windows and Unix (and uses either Open Sound System (http://www.opensound.com/oss.html) or Simple DirectMedia Layer (http://www.libsdl.org/)). Derived from wxObject (p. 954) Include files <wx/sound.h>

wxSound::wxSound
wxSound() Default constructor.

1384


CHAPTER 7
wxSound(const wxString& fileName, bool isResource = false) Constructs a wave object from a file or resource. Call wxSound::IsOk (p. 1385) to determine whether this succeeded. Parameters fileName The filename or Windows resource. isResource true if fileName is a resource, false if it is a filename.

wxSound::~wxSound
~wxSound() Destroys the wxSound object.

wxSound::Create
bool Create(const wxString& fileName, bool isResource = false) Constructs a wave object from a file or resource. Parameters fileName The filename or Windows resource. isResource true if fileName is a resource, false if it is a filename. Return value true if the call was successful, false otherwise.

wxSound::IsOk
bool IsOk() const Returns true if the object contains a successfully loaded file or resource, false otherwise.

wxSound::IsPlaying

1385


CHAPTER 7
static bool IsPlaying() const Returns true if a sound is played at the moment.

wxSound::Play
bool Play(unsigned flags = wxSOUND_ASYNC) const static bool Play(const wxString& filename, unsigned flags = wxSOUND_ASYNC) Plays the sound file. If another sound is playing, it will be interrupted. Returns true on success, false otherwise. The possible values for flags are: wxSOUND_SYNC wxSOUND_ASYNC Play will block and wait until the sound is replayed. Sound is played asynchronously, Play returns immediately

wxSOUND_ASYNC | wxSOUND_LOOP Sound is played asynchronously and loops until another sound is played, wxSound::Stop (p. 1386) is called or the program terminates. The static form is shorthand for this code:
wxSound(filename).Play(flags);

wxSound::Stop
static void Stop() If a sound is played, this function stops it.

wxWindow
wxWindow is the base class for all windows and represents any visible objecto n screen. All controls, top level windows and so on are windows. Sizers and device contexts are not, however, as they don't appear on screen themselves. Please note that all children of the window will be deleted automatically by the destructor before the window itself is deleted which means that you don't have to worry about deleting them manually. Please see the window deletion overview (p. 1612) for more information. Also note that in this, and many others, wxWindows classes some GetXXX() methods may be overloaded (as, for example, GetSize (p. 1406) or GetClientSize (p. 1401)). In this case, the overloads are non-virtual because having multiple virtual functions with the

1386


CHAPTER 7
same name results in a virtual function name hiding at the derived class level (in English, this means that the derived class has to override all overloaded variants if it overrides any of them). To allow overriding them in the derived class, wxWindows uses a unique protected virtual DoGetXXX() method and all GetXXX() ones are forwarded to it, so overriding the former changes the behaviour of the latter. Derived from wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/window.h> Window styles The following styles can apply to all windows, although they will not always make sense for a particular window class or on all platforms. wxSIMPLE_BORDER wxDOUBLE_BORDER wxSUNKEN_BORDER wxRAISED_BORDER wxSTATIC_BORDER wxNO_BORDER Displays a thin border around the window. wxBORDER is the old name for this style. Displays a double border. Windows and Mac only. Displays a sunken border. Displays a raised border. Displays a border suitable for a static control. Windows only. Displays no border, overriding the default border style for the window.

The window is transparent, that is, it will not receive wxTRANSPARENT_WINDOW paint events. Windows only. wxTAB_TRAVERSAL wxWANTS_CHARS Use this to enable tab traversal for non-dialog windows. Use this to indicate that the window wants to get all char/key events for all keys - even for keys like TAB or ENTER which are usually used for dialog navigation and which wouldn't be generated without this style. If you need to use this style in order to get the arrows or etc., but would still like to have normal keyboard navigation take place, you should create and send a wxNavigationKeyEvent in response to the key events for Tab and Shift-Tab.

wxNO_FULL_REPAINT_ON_RESIZE Disables repainting the window completely when its size is changed - you will have to repaint the new window area manually if you use this style. Currently only has an effect for Windows.

1387


CHAPTER 7
wxVSCROLL wxHSCROLL wxALWAYS_SHOW_SB Use this style to enable a vertical scrollbar. Use this style to enable a horizontal scrollbar. If a window has scrollbars, disable them instead of hiding them when they are not needed (i.e. when the size of the window is big enough to not require the scrollbars to navigate it). This style is currently only implemented for wxMSW and wxUniversal and does nothing on the other platforms. Use this style to eliminate flicker caused by the background being repainted, then children being painted over them. Windows only.

wxCLIP_CHILDREN

wxFULL_REPAINT_ON_RESIZE Use this style to force a complete redraw of the window whenever it is resized instead of redrawing just the part of the window affected by resizing. Note that this was the behaviour by default before 2.5.1 release and that if you experience redraw problems with the code which previously used to work you may want to try this. See also window styles overview (p. 1611). Extra window styles The following are extra styles, set using wxWindow::SetExtraStyle (p. 1423). wxWS_EX_VALIDATE_RECURSIVELY By default, Validate/TransferDataTo/FromWindow() only work on direct children of the window (compatible behaviour). Set this flag to make them recursively descend into all subwindows. wxCommandEvents and the objects of the derived wxWS_EX_BLOCK_EVENTS classes are forwarded to the parent window and so on recursively by default. Using this flag for the given window allows to block this propagation at this window, i.e. prevent the events from being propagated further upwards. Dialogs have this flag on by default. wxWS_EX_TRANSIENT Don't use this window as an implicit parent for the other windows: this must be used with transient windows as otherwise there is the risk of creating a dialog/frame with this window as a parent which would lead to a crash if the parent is destroyed before the child.

wxWS_EX_PROCESS_IDLE This window should always process idle events, even if the mode set by wxIdleEvent::SetMode (p. 728) is wxIDLE_PROCESS_SPECIFIED. wxWS_EX_PROCESS_UI_UPDATES This window should always process UI update events, even if the mode set by

1388


CHAPTER 7
wxUpdateUIEvent::SetMode (p. 1354) is wxUPDATE_UI_PROCESS_SPECIFIED. See also Event handling overview (p. 1602)

wxWindow::wxWindow
wxWindow() Default constructor. wxWindow(wxWindow* parent, wxWindowID id, const wxPoint& pos = wxDefaultPosition, const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = wxPanelNameStr) Constructs a window, which can be a child of a frame, dialog or any other non-control window. Parameters parent Pointer to a parent window. id Window identifier. If -1, will automatically create an identifier. pos Window position. wxDefaultPosition is (-1, -1) which indicates that wxWindows should generate a default position for the window. If using the wxWindow class directly, supply an actual position. size Window size. wxDefaultSize is (-1, -1) which indicates that wxWindows should generate a default size for the window. If no suitable size can be found, the window will be sized to 20x20 pixels so that the window is visible but obviously not correctly sized. style Window style. For generic window styles, please see wxWindow (p. 1386). name Window name.

1389


CHAPTER 7 wxWindow::~wxWindow
~wxWindow() Destructor. Deletes all subwindows, then deletes itself. Instead of using the delete operator explicitly, you should normally use wxWindow::Destroy (p. 1395) so that wxWindows can delete a window only when it is safe to do so, in idle time. See also Window deletion overview (p. 1612), wxWindow::Destroy (p. 1395), wxCloseEvent (p. 139)

wxWindow::AddChild
virtual void AddChild(wxWindow* child) Adds a child window. This is called automatically by window creation functions so should not be required by the application programmer. Notice that this function is mostly internal to wxWindows and shouldn't be called by the user code. Parameters child Child window to add.

wxWindow::CaptureMouse
virtual void CaptureMouse() Directs all mouse input to this window. Call wxWindow::ReleaseMouse (p. 1416) to release the capture. Note that wxWindows maintains the stack of windows having captured the mouse and when the mouse is released the capture returns to the window which had had captured it previously and it is only really released if there were no previous window. In particular, this means that you must release the mouse as many times as you capture it. See also wxWindow::ReleaseMouse (p. 1416)

wxWindow::Center
void Center(int direction) A synonym for Centre (p. 1391).

1390


CHAPTER 7 wxWindow::CenterOnParent
void CenterOnParent(int direction) A synonym for CentreOnParent (p. 1391).

wxWindow::CenterOnScreen
void CenterOnScreen(int direction) A synonym for CentreOnScreen (p. 1392).

wxWindow::Centre
void Centre(int direction = wxBOTH) Centres the window. Parameters direction Specifies the direction for the centering. May be wxHORIZONTAL, wxVERTICAL or wxBOTH. It may also include wxCENTRE_ON_SCREEN flag if you want to center the window on the entire screen and not on its parent window. The flag wxCENTRE_FRAME is obsolete and should not be used any longer (it has no effect). Remarks If the window is a top level one (i.e. doesn't have a parent), it will be centered relative to the screen anyhow. See also wxWindow::Center (p. 1390)

wxWindow::CentreOnParent
void CentreOnParent(int direction = wxBOTH) Centres the window on its parent. This is a more readable synonym forCentre (p. 1391). Parameters direction Specifies the direction for the centering. May be wxHORIZONTAL, wxVERTICAL or wxBOTH.

1391


CHAPTER 7
Remarks This methods provides for a way to center top level windows over their parents instead of the entire screen. If there is no parent or if the window is not a top level window, then behaviour is the same aswxWindow::Centre (p. 1391). See also wxWindow::CentreOnScreen (p. 1391)

wxWindow::CentreOnScreen
void CentreOnScreen(int direction = wxBOTH) Centres the window on screen. This only works for top level windows - otherwise, the window will still be centered on its parent. Parameters direction Specifies the direction for the centering. May be wxHORIZONTAL, wxVERTICAL or wxBOTH. See also wxWindow::CentreOnParent (p. 1391)

wxWindow::ClearBackground
void ClearBackground() Clears the window by filling it with the current background colour. Does not cause an erase background event to be generated.

wxWindow::ClientToScreen
virtual void ClientToScreen(int* x, int* y) const wxPerl note: In wxPerl this method returns a 2-element list instead of modifying its parameters. virtual wxPoint ClientToScreen(const wxPoint& pt) const Converts to screen coordinates from coordinates relative to this window. x A pointer to a integer value for the x coordinate. Pass the client coordinate in, and a screen coordinate will be passed out.

1392


CHAPTER 7
y A pointer to a integer value for the y coordinate. Pass the client coordinate in, and a screen coordinate will be passed out. pt The client position for the second form of the function. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: ClientToScreen(point) ClientToScreenXY(x, y) Accepts and returns a wxPoint Returns a 2-tuple, (x, y)

wxWindow::Close
bool Close(bool force = false) This function simply generates a wxCloseEvent (p. 139) whose handler usually tries to close the window. It doesn't close the window itself, however. Parameters force false if the window's close handler should be able to veto the destruction of this window, true if it cannot. Remarks Close calls the close handler (p. 139) for the window, providing an opportunity for the window to choose whether to destroy the window. Usually it is only used with the top level windows (wxFrame and wxDialog classes) as the others are not supposed to have any special OnClose() logic. The close handler should check whether the window is being deleted forcibly, using wxCloseEvent::GetForce (p. 140), in which case it should destroy the window using wxWindow::Destroy (p. 1395). Note that calling Close does not guarantee that the window will be destroyed; but it provides a way to simulate a manual close of a window, which may or may not be implemented by destroying the window. The default implementation of wxDialog::OnCloseWindow does not necessarily delete the dialog, since it will simply simulate an wxID_CANCEL event which is handled by the appropriate button event handler and may do anything at all. To guarantee that the window will be destroyed, call wxWindow::Destroy (p. 1395) instead See also

1393


CHAPTER 7
Window deletion overview (p. 1612), wxWindow::Destroy (p. 1395), wxCloseEvent (p. 139)

wxWindow::ConvertDialogToPixels
wxPoint ConvertDialogToPixels(const wxPoint& pt) wxSize ConvertDialogToPixels(const wxSize& sz) Converts a point or size from dialog units to pixels. For the x dimension, the dialog units are multiplied by the average character width and then divided by 4. For the y dimension, the dialog units are multiplied by the average character height and then divided by 8. Remarks Dialog units are used for maintaining a dialog's proportions even if the font changes. You can also use these functions programmatically. A convenience macro is defined:
#define wxDLG_UNIT(parent, pt) parent->ConvertDialogToPixels(pt)

See also wxWindow::ConvertPixelsToDialog (p. 1394) wxPython note: In place of a single overloaded method name, wxPython implements the following methods: ConvertDialogPointToPixels(point) ConvertDialogSizeToPixels(size) Accepts and returns a wxPoint Accepts and returns a wxSize

Additionally, the following helper functions are defined: wxDLG_PNT(win, point) wxDLG_SZE(win, size) Converts a wxPoint from dialog units to pixels Converts a wxSize from dialog units to pixels

wxWindow::ConvertPixelsToDialog
wxPoint ConvertPixelsToDialog(const wxPoint& pt) wxSize ConvertPixelsToDialog(const wxSize& sz) Converts a point or size from pixels to dialog units.

1394


CHAPTER 7
For the x dimension, the pixels are multiplied by 4 and then divided by the average character width. For the y dimension, the pixels are multiplied by 8 and then divided by the average character height. Remarks Dialog units are used for maintaining a dialog's proportions even if the font changes. See also wxWindow::ConvertDialogToPixels (p. 1394) wxPython note: In place of a single overloaded method name, wxPythonimplements the following methods: ConvertDialogPointToPixels(point) ConvertDialogSizeToPixels(size) Accepts and returns a wxPoint Accepts and returns a wxSize

wxWindow::Destroy
virtual bool Destroy() Destroys the window safely. Use this function instead of the delete operator, since different window classes can be destroyed differently. Frames and dialogs are not destroyed immediately when this function is called -- they are added to a list of windows to be deleted on idle time, when all the window's events have been processed. This prevents problems with events being sent to non-existent windows. Return value true if the window has either been successfully deleted, or it has been added to the list of windows pending real deletion.

wxWindow::DestroyChildren
virtual void DestroyChildren() Destroys all children of a window. Called automatically by the destructor.

wxWindow::Disable
bool Disable() Disables the window, same as Enable(false) (p. 1396). Return value

1395


CHAPTER 7
Returns true if the window has been disabled, false if it had been already disabled before the call to this function.

wxWindow::DoUpdateWindowUI
virtual void DoUpdateWindowUI(wxUpdateUIEvent& event) Does the window-specific updating after processing the update event. This function is called by wxWindow::UpdateWindowUI (p. 1434) in order to check return values in the wxUpdateUIEvent (p. 1350) and act appropriately. For example, to allow frame and dialog title updating, wxWindows implements this function as follows:
// do the window-specific processing after processing the update event void wxTopLevelWindowBase::DoUpdateWindowUI(wxUpdateUIEvent& event) { if ( event.GetSetEnabled() ) Enable(event.GetEnabled()); if ( event.GetSetText() ) { if ( event.GetText() != GetTitle() ) SetTitle(event.GetText()); } }

wxWindow::DragAcceptFiles
virtual void DragAcceptFiles(bool accept) Enables or disables eligibility for drop file events (OnDropFiles). Parameters accept If true, the window is eligible for drop file events. If false, the window will not accept drop file events. Remarks Windows only.

wxWindow::Enable
virtual bool Enable(bool enable = true) Enable or disable the window for user input. Note that when a parent window is disabled, all of its children are disabled as well and they are reenabled again when the parent is. Parameters enable

1396


CHAPTER 7
If true, enables the window for input. If false, disables the window. Return value Returns true if the window has been enabled or disabled, false if nothing was done, i.e. if the window had already been in the specified state. See also wxWindow::IsEnabled (p. 1409), wxWindow::Disable (p. 1395)

wxWindow::FindFocus
static wxWindow* FindFocus() Finds the window or control which currently has the keyboard focus. Remarks Note that this is a static function, so it can be called without needing a wxWindow pointer. See also wxWindow::SetFocus (p. 1424)

wxWindow::FindWindow
wxWindow* FindWindow(long id) Find a child of this window, by identifier. wxWindow* FindWindow(const wxString& name) Find a child of this window, by name. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: FindWindowById(id) Accepts an integer Accepts a string

FindWindowByName(name)

wxWindow::FindWindowById
static wxWindow* FindWindowById(long id, wxWindow* parent = NULL) Find the first window with the given id. If parent is NULL, the search will start from all top-level frames and dialog boxes; if non-

1397


CHAPTER 7
NULL, the search will be limited to the given window hierarchy. The search is recursive in both cases. See also FindWindow (p. 1397)

wxWindow::FindWindowByName
static wxWindow* FindWindowByName(const wxString& name, wxWindow* parent = NULL) Find a window by its name (as given in a window constructor or Create function call). If parent is NULL, the search will start from all top-level frames and dialog boxes; if nonNULL, the search will be limited to the given window hierarchy. The search is recursive in both cases. If no window with such name is found, FindWindowByLabel (p. 1398) is called. See also FindWindow (p. 1397)

wxWindow::FindWindowByLabel
static wxWindow* FindWindowByLabel(const wxString& label, wxWindow* parent = NULL) Find a window by its label. Depending on the type of window, the label may be a window title or panel item label. If parent is NULL, the search will start from all top-level frames and dialog boxes; if non-NULL, the search will be limited to the given window hierarchy. The search is recursive in both cases. See also FindWindow (p. 1397)

wxWindow::Fit
virtual void Fit() Sizes the window so that it fits around its subwindows. This function won't do anything if there are no subwindows and will only really work correctly if the sizers are used for the subwindows layout. Also, if the window has exactly one subwindow it is better (faster and the result is more precise as Fit adds some margin to account for fuzziness of its calculations) to call
window >SetClientSize(child->GetSize()); -

instead of calling Fit.

1398


CHAPTER 7 wxWindow::FitInside
virtual void FitInside() Similar to Fit (p. 1398), but sizes the interior (virtual) size of a window. Mainly useful with scrolled windows to reset scrollbars after sizing changes that do not trigger a size event, and/or scrolled windows without an interior sizer. This function similarly won't do anything if there are no subwindows.

wxWindow::Freeze
virtual void Freeze() Freezes the window or, in other words, prevents any updates from taking place on screen, the window is not redrawn at all. Thaw (p. 1433) must be called to reenable window redrawing. This method is useful for visual appearance optimization (for example, it is a good idea to use it before inserting large amount of text into a wxTextCtrl under wxGTK) but is not implemented on all platforms nor for all controls so it is mostly just a hint to wxWindows and not a mandatory directive.

wxWindow::GetAcceleratorTable
wxAcceleratorTable* GetAcceleratorTable() const Gets the accelerator table for this window. See wxAcceleratorTable (p. 19).

wxWindow::GetAccessible
wxAccessibile* GetAccessible() Returns the accessible object for this window, if any. See also wxAccessible (p. 22).

wxWindow::GetAdjustedBestSize
wxSize GetAdjustedBestSize() const This method is similar to GetBestSize (p. 1400), except in one thing. GetBestSize should return the minimum untruncated size of the window, while this method will return the largest of BestSize and any user specified minimum size. ie. it is the minimum size the window should currently be drawn at, not the minimal size it can possibly tolerate.

wxWindow::GetBackgroundColour

1399


CHAPTER 7
virtual wxColour GetBackgroundColour() const Returns the background colour of the window. See also wxWindow::SetBackgroundColour (p. 1420), wxWindow::SetForegroundColour (p. 1424), wxWindow::GetForegroundColour (p. 1403)

wxWindow::GetBestSize
wxSize GetBestSize() const This functions returns the best acceptable minimal size for the window. For example, for a static control, it will be the minimal size such that the control label is not truncated. For windows containing subwindows (typicallywxPanel (p. 972)), the size returned by this function will be the same as the size the window would have had after callingFit (p. 1398).

wxWindow::GetCaret
wxCaret * GetCaret() const Returns the caret (p. 117) associated with the window.

wxWindow::GetCapture
static wxWindow * GetCapture() Returns the currently captured window. See also wxWindow::HasCapture (p. 1409), wxWindow::CaptureMouse (p. 1390), wxWindow::ReleaseMouse (p. 1416), wxMouseCaptureChangedEvent (p. 927)

wxWindow::GetCharHeight
virtual int GetCharHeight() const Returns the character height for this window.

wxWindow::GetCharWidth
virtual int GetCharWidth() const Returns the average character width for this window.

1400


CHAPTER 7 wxWindow::GetChildren
wxList& GetChildren() Returns a reference to the list of the window's children.

wxWindow::GetClientSize
void GetClientSize(int* width, int* height) const wxPerl note: In wxPerl this method takes no parameter and returns a 2-element list (width, height). wxSize GetClientSize() const This gets the size of the window 'client area' in pixels. The client area is the area which may be drawn on by the programmer, excluding title bar, border, scrollbars, etc. Parameters width Receives the client width in pixels. height Receives the client height in pixels. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: GetClientSizeTuple() GetClientSize() See also GetSize (p. 1406), GetVirtualSize (p. 1408) Returns a 2-tuple of (width, height) Returns a wxSize object

wxWindow::GetConstraints
wxLayoutConstraints* GetConstraints() const Returns a pointer to the window's layout constraints, or NULL if there are none.

wxWindow::GetContainingSizer
const wxSizer * GetContainingSizer() const Return the sizer that this window is a member of, if any, otherwiseNULL.

1401


CHAPTER 7 wxWindow::GetCursor
const wxCursor& GetCursor() const Return the cursor associated with this window. See also wxWindow::SetCursor (p. 1421)

wxWindow::GetDropTarget
wxDropTarget* GetDropTarget() const Returns the associated drop target, which may be NULL. See also wxWindow::SetDropTarget (p. 1422),Drag and drop overview (p. 1666)

wxWindow::GetEventHandler
wxEvtHandler* GetEventHandler() const Returns the event handler for this window. By default, the window is its own event handler. See also wxWindow::SetEventHandler (p. 1422), wxWindow::PushEventHandler (p. 1414), wxWindow::PopEventHandler (p. 1414), wxEvtHandler::ProcessEvent (p. 447), wxEvtHandler (p. 443)

wxWindow::GetExtraStyle
long GetExtraStyle() const Returns the extra style bits for the window.

wxWindow::GetFont
wxFont& GetFont() const Returns a reference to the font for this window. See also wxWindow::SetFont (p. 1424)

1402


CHAPTER 7 wxWindow::GetForegroundColour
virtual wxColour GetForegroundColour() Returns the foreground colour of the window. Remarks The interpretation of foreground colour is open to interpretation according to the window class; it may be the text colour or other colour, or it may not be used at all. See also wxWindow::SetForegroundColour (p. 1424), wxWindow::SetBackgroundColour (p. 1420), wxWindow::GetBackgroundColour (p. 1399)

wxWindow::GetGrandParent
wxWindow* GetGrandParent() const Returns the grandparent of a window, or NULL if there isn't one.

wxWindow::GetHandle
void* GetHandle() const Returns the platform-specific handle of the physical window. Cast it to an appropriate handle, such as HWND for Windows, Widget for Motif or GtkWidget for GTK. wxPython note: This method will return an integer in wxPython. wxPerl note: This method will return an integer in wxPerl.

wxWindow::GetHelpText
virtual wxString GetHelpText() const Gets the help text to be used as context-sensitive help for this window. Note that the text is actually stored by the current wxHelpProvider (p. 652) implementation, and not in the window object itself. See also SetHelpText (p. 1425), wxHelpProvider (p. 652)

wxWindow::GetId
int GetId() const

1403


CHAPTER 7
Returns the identifier of the window. Remarks Each window has an integer identifier. If the application has not provided one (or the default Id -1) an unique identifier with a negative value will be generated. See also wxWindow::SetId (p. 1425), Window identifiers (p. 1607)

wxWindow::GetLabel
virtual wxString GetLabel() const Generic way of getting a label from any window, for identification purposes. Remarks The interpretation of this function differs from class to class. For frames and dialogs, the value returned is the title. For buttons or static text controls, it is the button text. This function can be useful for meta-programs (such as testing tools or special-needs access programs) which need to identify windows by name.

wxWindow::GetName
virtual wxString GetName() const Returns the window's name. Remarks This name is not guaranteed to be unique; it is up to the programmer to supply an appropriate name in the window constructor or via wxWindow::SetName (p. 1425). See also wxWindow::SetName (p. 1425)

wxWindow::GetParent
virtual wxWindow* GetParent() const Returns the parent of the window, or NULL if there is no parent.

wxWindow::GetPosition
virtual void GetPosition(int* x, int* y) const

1404


CHAPTER 7
wxPoint GetPosition() const This gets the position of the window in pixels, relative to the parent window for the child windows or relative to the display origin for the top level windows. Parameters x Receives the x position of the window. y Receives the y position of the window. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: GetPosition() GetPositionTuple() Returns a wxPoint Returns a tuple (x, y)

wxPerl note: In wxPerl there are two methods instead of a single overloaded method: GetPosition() GetPositionXY() Returns a Wx::Point Returns a 2-element list ( x, y )

wxWindow::GetRect
virtual wxRect GetRect() const Returns the size and position of the window as a wxRect (p. 1042) object.

wxWindow::GetScrollThumb
virtual int GetScrollThumb(int orientation) Returns the built-in scrollbar thumb size. See also wxWindow::SetScrollbar (p. 1426)

wxWindow::GetScrollPos
virtual int GetScrollPos(int orientation) Returns the built-in scrollbar position.

1405


CHAPTER 7
See also See wxWindow::SetScrollbar (p. 1426)

wxWindow::GetScrollRange
virtual int GetScrollRange(int orientation) Returns the built-in scrollbar range. See also wxWindow::SetScrollbar (p. 1426)

wxWindow::GetSize
void GetSize(int* width, int* height) const wxSize GetSize() const This gets the size of the entire window in pixels, including title bar, border, scrollbars, etc. Parameters width Receives the window width. height Receives the window height. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: GetSize() GetSizeTuple() Returns a wxSize Returns a 2-tuple (width, height)

wxPerl note: In wxPerl there are two methods instead of a single overloaded method: GetSize() GetSizeWH() See also GetClientSize (p. 1401), GetVirtualSize (p. 1408) Returns a Wx::Size Returns a 2-element list ( width, height )

1406


CHAPTER 7 wxWindow::GetSizer
wxSizer * GetSizer() const Return the sizer associated with the window by a previous call toSetSizer() (p. 1430) or NULL.

wxWindow::GetTextExtent
virtual void GetTextExtent(const wxString& string, int* x, int* y, int* descent = NULL, int* externalLeading = NULL, const wxFont* font = NULL, bool use16 = false) const Gets the dimensions of the string as it would be drawn on the window with the currently selected font. Parameters string String whose extent is to be measured. x Return value for width. y Return value for height. descent Return value for descent (optional). externalLeading Return value for external leading (optional). font Font to use instead of the current window font (optional). use16 If true, string contains 16-bit characters. The default is false. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: GetTextExtent(string) Returns a 2-tuple, (width, height)

GetFullTextExtent(string, font=NULL)Returns a 4-tuple, (width, height, descent, externalLeading)

1407


CHAPTER 7
wxPerl note: In wxPerl this method takes only the string and optionally font parameters, and returns a 4-element list ( x, y, descent, externalLeading ).

wxWindow::GetTitle
virtual wxString GetTitle() Gets the window's title. Applicable only to frames and dialogs. See also wxWindow::SetTitle (p. 1430)

wxWindow::GetToolTip
wxToolTip* GetToolTip() const Get the associated tooltip or NULL if none.

wxWindow::GetUpdateRegion
virtual wxRegion GetUpdateRegion() const Returns the region specifying which parts of the window have been damaged. Should only be called within an wxPaintEvent (p. 967) handler. See also wxRegion (p. 1052), wxRegionIterator (p. 1057)

wxWindow::GetValidator
wxValidator* GetValidator() const Returns a pointer to the current validator for the window, or NULL if there is none.

wxWindow::GetVirtualSize
void GetVirtualSize(int* width, int* height) const wxSize GetVirtualSize() const This gets the virtual size of the window in pixels. Parameters width

1408


CHAPTER 7
Receives the window virtual width. height Receives the window virtual height. GetSize (p. 1406), GetClientSize (p. 1401)

wxWindow::GetWindowStyleFlag
long GetWindowStyleFlag() const Gets the window style that was passed to the constructor or Createmethod. GetWindowStyle() is another name for the same function.

wxWindow::HasCapture
virtual bool HasCapture() const Returns true if this window has the current mouse capture. See also wxWindow::CaptureMouse (p. 1390), wxWindow::ReleaseMouse (p. 1416), wxMouseCaptureChangedEvent (p. 927)

wxWindow::Hide
bool Hide() Equivalent to calling Show (p. 1432)(false).

wxWindow::InitDialog
void InitDialog() Sends an wxEVT_INIT_DIALOG event, whose handler usually transfers data to the dialog via validators.

wxWindow::IsEnabled
virtual bool IsEnabled() const Returns true if the window is enabled for input, false otherwise. See also wxWindow::Enable (p. 1396)

1409


CHAPTER 7 wxWindow::IsExposed
bool IsExposed(int x, int y) const bool IsExposed(wxPoint &pt) const bool IsExposed(int x, int y, int w, int h) const bool IsExposed(wxRect &rect) const Returns true if the given point or rectangle area has been exposed since the last repaint. Call this in an paint event handler to optimize redrawing by only redrawing those areas, which have been exposed. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: IsExposed(x,y, w=0,h=0) IsExposedPoint(pt) IsExposedRect(rect)

wxWindow::IsRetained
virtual bool IsRetained() const Returns true if the window is retained, false otherwise. Remarks Retained windows are only available on X platforms.

wxWindow::IsShown
virtual bool IsShown() const Returns true if the window is shown, false if it has been hidden.

wxWindow::IsTopLevel
bool IsTopLevel() const Returns true if the given window is a top-level one. Currently all frames and dialogs are considered to be top-level windows (even if they have a parent window).

wxWindow::Layout

1410


CHAPTER 7
void Layout() Invokes the constraint-based layout algorithm or the sizer-based algorithm for this window. See wxWindow::SetAutoLayout (p. 1419): when auto layout is on, this function gets called automatically when the window is resized.

wxWindow::LineDown
This is just a wrapper for ScrollLines() (p. 1418)(1).

wxWindow::LineUp
This is just a wrapper for ScrollLines() (p. 1418)(-1).

wxWindow::Lower
void Lower() Lowers the window to the bottom of the window hierarchy if it is a managed window (dialog or frame).

wxWindow::MakeModal
virtual void MakeModal(bool flag) Disables all other windows in the application so that the user can only interact with this window. Parameters flag If true, this call disables all other windows in the application so that the user can only interact with this window. If false, the effect is reversed.

wxWindow::Move
void Move(int x, int y) void Move(const wxPoint& pt) Moves the window to the given position. Parameters x

1411


CHAPTER 7
Required x position. y Required y position. pt wxPoint (p. 991) object representing the position. Remarks Implementations of SetSize can also implicitly implement the wxWindow::Move function, which is defined in the base wxWindow class as the call:
SetSize(x, y, -1, -1, wxSIZE_USE_EXISTING);

See also wxWindow::SetSize (p. 1427) wxPython note: In place of a single overloaded method name, wxPython implements the following methods: Move(point) MoveXY(x, y) Accepts a wxPoint Accepts a pair of integers

wxWindow::OnInternalIdle
virtual void OnInternalIdle() This virtual function is normally only used internally, but sometimes an application may need it to implement functionality that should not be disabled by an application defining an OnIdle handler in a derived class. This function may be used to do delayed painting, for example, and most implementations call wxWindow::UpdateWindowUI (p. 1434) in order to send update events to the window in idle time.

wxWindow::PageDown
This is just a wrapper for ScrollPages() (p. 1418)(1).

wxWindow::PageUp
This is just a wrapper for ScrollPages() (p. 1418)(-1).

1412


CHAPTER 7 wxWindow::PopEventHandler
wxEvtHandler* PopEventHandler(bool deleteHandler = false) const Removes and returns the top-most event handler on the event handler stack. Parameters deleteHandler If this is true, the handler will be deleted after it is removed. The default value is false. See also wxWindow::SetEventHandler (p. 1422), wxWindow::GetEventHandler (p. 1402), wxWindow::PushEventHandler (p. 1414), wxEvtHandler::ProcessEvent (p. 447), wxEvtHandler (p. 443)

wxWindow::PopupMenu
bool PopupMenu(wxMenu* menu, const wxPoint& pos) bool PopupMenu(wxMenu* menu, int x, int y) Pops up the given menu at the specified coordinates, relative to this window, and returns control when the user has dismissed the menu. If a menu item is selected, the corresponding menu event is generated and will be processed as usually. Parameters menu Menu to pop up. pos The position where the menu will appear. x Required x position for the menu to appear. y Required y position for the menu to appear. See also wxMenu (p. 885) Remarks Just before the menu is popped up, wxMenu::UpdateUI (p. 898) is called to ensure that

1413


CHAPTER 7
the menu items are in the correct state. The menu does not get deleted by the window. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: PopupMenu(menu, point) Specifies position with a wxPoint PopupMenuXY(menu, x, y) Specifies position with two integers (x, y)

wxWindow::PushEventHandler
void PushEventHandler(wxEvtHandler* handler) Pushes this event handler onto the event stack for the window. Parameters handler Specifies the handler to be pushed. Remarks An event handler is an object that is capable of processing the events sent to a window. By default, the window is its own event handler, but an application may wish to substitute another, for example to allow central implementation of event-handling for a variety of different window classes. wxWindow::PushEventHandler (p. 1414) allows an application to set up a chain of event handlers, where an event not handled by one event handler is handed to the next one in the chain. Use wxWindow::PopEventHandler (p. 1413) to remove the event handler. See also wxWindow::SetEventHandler (p. 1422), wxWindow::GetEventHandler (p. 1402), wxWindow::PopEventHandler (p. 1414), wxEvtHandler::ProcessEvent (p. 447), wxEvtHandler (p. 443)

wxWindow::Raise
void Raise() Raises the window to the top of the window hierarchy if it is a managed window (dialog or frame).

wxWindow::Refresh
virtual void Refresh(bool eraseBackground = true, const wxRect* rect = NULL)

1414


CHAPTER 7
Causes an event to be generated to repaint the window. Parameters eraseBackground If true, the background will be erased. rect If non-NULL, only the given rectangle will be treated as damaged. See also wxWindow::RefreshRect (p. 1415)

wxWindow::RefreshRect
void Refresh(const wxRect& rect) Redraws the contents of the given rectangle: the area inside it will be repainted. This is the same as Refresh (p. 1414) but has a nicer syntax.

wxWindow::RegisterHotKey
bool RegisterHotKey(int hotkeyId, int modifiers, int virtualKeyCode) Registers a system wide hotkey. Every time the user presses the hotkey registered here, this window will receive a hotkey event. It will receive the event even if the application is in the background and does not have the input focus because the user is working with some other application. Parameters hotkeyId Numeric identifier of the hotkey. For applications this must be between 0 and 0xBFFF. If this function is called from a shared DLL, it must be a system wide unique identifier between 0xC000 and 0xFFFF. This is a MSW specific detail. modifiers A bitwise combination of wxMOD_SHIFT, wxMOD_CONTROL, wxMOD_ALTor wxMOD_WIN specifying the modifier keys that have to be pressed along with the key. virtualKeyCode The virtual key code of the hotkey. Return value

1415


CHAPTER 7
true if the hotkey was registered successfully. false if some other application already registered a hotkey with this modifier/virtualKeyCode combination. Remarks Use EVT_HOTKEY(hotkeyId, fnc) in the event table to capture the event. This function is currently only implemented under MSW. See also wxWindow::UnregisterHotKey (p. 1434)

wxWindow::ReleaseMouse
virtual void ReleaseMouse() Releases mouse input captured with wxWindow::CaptureMouse (p. 1390). See also wxWindow::CaptureMouse (p. 1390), wxWindow::HasCapture (p. 1409), wxWindow::ReleaseMouse (p. 1416), wxMouseCaptureChangedEvent (p. 927)

wxWindow::RemoveChild
virtual void RemoveChild(wxWindow* child) Removes a child window. This is called automatically by window deletion functions so should not be required by the application programmer. Notice that this function is mostly internal to wxWindows and shouldn't be called by the user code. Parameters child Child window to remove.

wxWindow::RemoveEventHandler
bool RemoveEventHandler(wxEvtHandler *handler) Find the given handler in the windows event handler chain and remove (but not delete) it from it. Parameters handler The event handler to remove, must be non NULL and must be present in this

1416


CHAPTER 7
windows event handlers chain Return value Returns true if it was found and false otherwise (this also results in an assert failure so this function should only be called when the handler is supposed to be there). See also PushEventHandler (p. 1414), PopEventHandler (p. 1413)

wxWindow::Reparent
virtual bool Reparent(wxWindow* newParent) Reparents the window, i.e the window will be removed from its current parent window (e.g. a non-standard toolbar in a wxFrame) and then re-inserted into another. Available on Windows and GTK. Parameters newParent New parent.

wxWindow::ScreenToClient
virtual void ScreenToClient(int* x, int* y) const virtual wxPoint ScreenToClient(const wxPoint& pt) const Converts from screen to client window coordinates. Parameters x Stores the screen x coordinate and receives the client x coordinate. y Stores the screen x coordinate and receives the client x coordinate. pt The screen position for the second form of the function. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: ScreenToClient(point) ScreenToClientXY(x, y) Accepts and returns a wxPoint Returns a 2-tuple, (x, y)

1417


CHAPTER 7

wxWindow::ScrollLines
virtual bool ScrollLines(int lines) Scrolls the window by the given number of lines down (if lines is positive) or up. Return value Returns true if the window was scrolled, false if it was already on top/bottom and nothing was done. Remarks This function is currently only implemented under MSW and wxTextCtrl under wxGTK (it also works for wxScrolledWindow derived classes under all platforms). See also ScrollPages (p. 1418)

wxWindow::ScrollPages
virtual bool ScrollPages(int pages) Scrolls the window by the given number of pages down (if pages is positive) or up. Return value Returns true if the window was scrolled, false if it was already on top/bottom and nothing was done. Remarks This function is currently only implemented under MSW and wxTextCtrl under wxGTK (it also works for wxScrolledWindow derived classes under all platforms). See also ScrollLines (p. 1418)

wxWindow::ScrollWindow
virtual void ScrollWindow(int dx, int dy, const wxRect* rect = NULL) Physically scrolls the pixels in the window and move child windows accordingly. Parameters dx

1418


CHAPTER 7
Amount to scroll horizontally. dy Amount to scroll vertically. rect Rectangle to invalidate. If this is NULL, the whole window is invalidated. If you pass a rectangle corresponding to the area of the window exposed by the scroll, your painting handler can optimize painting by checking for the invalidated region. This parameter is ignored under GTK. Remarks Use this function to optimise your scrolling implementations, to minimise the area that must be redrawn. Note that it is rarely required to call this function from a user program.

wxWindow::SetAcceleratorTable
virtual void SetAcceleratorTable(const wxAcceleratorTable& accel) Sets the accelerator table for this window. See wxAcceleratorTable (p. 19).

wxWindow::SetAccessible
void SetAccessible(wxAccessibile* accessible) Sets the accessible for this window. Any existing accessible for this window will be deleted first, if not identical to accessible. See also wxAccessible (p. 22).

wxWindow::SetAutoLayout
void SetAutoLayout(bool autoLayout) Determines whether the wxWindow::Layout (p. 1410) function will be called automatically when the window is resized. It is called implicitly by wxWindow::SetSizer (p. 1430) but if you use wxWindow::SetConstraints (p. 1421) you should call it manually or otherwise the window layout won't be correctly updated when its size changes. Parameters autoLayout Set this to true if you wish the Layout function to be called from within wxWindow::OnSize functions. See also

1419


CHAPTER 7
wxWindow::SetConstraints (p. 1421)

wxWindow::SetBackgroundColour
virtual void SetBackgroundColour(const wxColour& colour) Sets the background colour of the window. Parameters colour The colour to be used as the background colour. Remarks The background colour is usually painted by the default wxEraseEvent (p. 438) event handler function under Windows and automatically under GTK. Note that setting the background colour does not cause an immediate refresh, so you may wish to call wxWindow::ClearBackground (p. 1392) or wxWindow::Refresh (p. 1414) after calling this function. Use this function with care under GTK+ as the new appearance of the window might not look equally well when used with "Themes", i.e GTK+'s ability to change its look as the user wishes with run-time loadable modules. See also wxWindow::GetBackgroundColour (p. 1399), wxWindow::SetForegroundColour (p. 1424), wxWindow::GetForegroundColour (p. 1403), wxWindow::ClearBackground (p. 1392), wxWindow::Refresh (p. 1414), wxEraseEvent (p. 438)

wxWindow::SetCaret
void SetCaret(wxCaret *caret) const Sets the caret (p. 117) associated with the window.

wxWindow::SetClientSize
virtual void SetClientSize(int width, int height) virtual void SetClientSize(const wxSize& size) This sets the size of the window client area in pixels. Using this function to size a window tends to be more device-independent than wxWindow::SetSize (p. 1427), since the application need not worry about what dimensions the border or title bar have when trying to fit the window around panel items, for example.

1420


CHAPTER 7
Parameters width The required client area width. height The required client area height. size The required client size. wxPython note: In place of a single overloaded method name, wxPython implements the following methods: SetClientSize(size) Accepts a wxSize

SetClientSizeWH(width, height)

wxWindow::SetContainingSizer
void SetContainingSizer(wxSizer* sizer) This normally does not need to be called by user code. It is called when a window is added to a sizer, and is used so the window can remove itself from the sizer when it is destroyed.

wxWindow::SetCursor
virtual void SetCursor(const wxCursor&cursor) Sets the window's cursor. Notice that the window cursor also sets it for the children of the window implicitly. The cursor may be wxNullCursor in which case the window cursor will be reset back to default. Parameters cursor Specifies the cursor that the window should normally display. See also ::wxSetCursor (p. 1501), wxCursor (p. 209)

wxWindow::SetConstraints 1421


CHAPTER 7
void SetConstraints(wxLayoutConstraints* constraints) Sets the window to have the given layout constraints. The window will then own the object, and will take care of its deletion. If an existing layout constraints object is already owned by the window, it will be deleted. Parameters constraints The constraints to set. Pass NULL to disassociate and delete the window's constraints. Remarks You must call wxWindow::SetAutoLayout (p. 1419) to tell a window to use the constraints automatically in OnSize; otherwise, you must override OnSize and call Layout() explicitly. When setting both a wxLayoutConstraints and a wxSizer (p. 1109), only the sizer will have effect.

wxWindow::SetDropTarget
void SetDropTarget(wxDropTarget* target) Associates a drop target with this window. If the window already has a drop target, it is deleted. See also wxWindow::GetDropTarget (p. 1402),Drag and drop overview (p. 1666)

wxWindow::SetEventHandler
void SetEventHandler(wxEvtHandler* handler) Sets the event handler for this window. Parameters handler Specifies the handler to be set. Remarks An event handler is an object that is capable of processing the events sent to a window. By default, the window is its own event handler, but an application may wish to substitute another, for example to allow central implementation of event-handling for a variety of different window classes. It is usually better to use wxWindow::PushEventHandler (p. 1414) since this sets up a

1422


CHAPTER 7
chain of event handlers, where an event not handled by one event handler is handed to the next one in the chain. See also wxWindow::GetEventHandler (p. 1402), wxWindow::PushEventHandler (p. 1414), wxWindow::PopEventHandler (p. 1414), wxEvtHandler::ProcessEvent (p. 447), wxEvtHandler (p. 443)

wxWindow::SetExtraStyle
void SetExtraStyle(long exStyle) Sets the extra style bits for the window. The currently defined extra style bits are: wxWS_EX_VALIDATE_RECURSIVELY TransferDataTo/FromWindow() and Validate() methods will recursively descend into all children of the window if it has this style flag set. wxWS_EX_BLOCK_EVENTS Normally, the command events are propagated upwards to the window parent recursively until a handler for them is found. Using this style allows to prevent them from being propagated beyond this window. Notice that wxDialog has this style on by default for the reasons explained in theevent processing overview (p. 1604). wxWS_EX_TRANSIENT This can be used to prevent a window from being used as an implicit parent for the dialogs which were created without a parent. It is useful for the windows which can disappear at any moment as creating children of such windows results in fatal problems.

wxFRAME_EX_CONTEXTHELP Under Windows, puts a query button on the caption. When pressed, Windows will go into a contextsensitive help mode and wxWindows will send a wxEVT_HELP event if the user clicked on an application window. This style cannot be used together with wxMAXIMIZE_BOX or wxMINIMIZE_BOX, so you should use the style ofwxDEFAULT_FRAME_STYLE & (wxMINIMIZE_BOX | wxMAXIMIZE_BOX) for the frames having this style (the dialogs don't have minimize nor maximize box by default) wxWS_EX_PROCESS_IDLE This window should always process idle events, even if the mode set by wxIdleEvent::SetMode (p. 728) is wxIDLE_PROCESS_SPECIFIED. wxWS_EX_PROCESS_UI_UPDATES This window should always process UI update events, even if the mode set by wxUpdateUIEvent::SetMode (p. 1354) is wxUPDATE_UI_PROCESS_SPECIFIED.

1423


CHAPTER 7 wxWindow::SetFocus
virtual void SetFocus() This sets the window to receive keyboard input. See also wxFocusEvent (p. 509)

wxWindow::SetFocusFromKbd
virtual void SetFocusFromKbd() This function is called by wxWindows keyboard navigation code when the user gives the focus to this window from keyboard (e.g. using TAB key). By default this method simply calls SetFocus (p. 1424) but can be overridden to do something in addition to this in the derived classes.

wxWindow::SetFont
void SetFont(const wxFont& font) Sets the font for this window. Parameters font Font to associate with this window. See also wxWindow::GetFont (p. 1402)

wxWindow::SetForegroundColour
virtual void SetForegroundColour(const wxColour& colour) Sets the foreground colour of the window. Parameters colour The colour to be used as the foreground colour. Remarks The interpretation of foreground colour is open to interpretation according to the window class; it may be the text colour or other colour, or it may not be used at all.

1424


CHAPTER 7
Note that when using this functions under GTK, you will disable the so called "themes", i.e. the user chosen appearance of windows and controls, including the themes of their parent windows. See also wxWindow::GetForegroundColour (p. 1403), wxWindow::SetBackgroundColour (p. 1420), wxWindow::GetBackgroundColour (p. 1399)

wxWindow::SetHelpText
virtual void SetHelpText(const wxString& helpText) Sets the help text to be used as context-sensitive help for this window. Note that the text is actually stored by the current wxHelpProvider (p. 652) implementation, and not in the window object itself. See also GetHelpText (p. 1403), wxHelpProvider (p. 652)

wxWindow::SetId
void SetId(int id) Sets the identifier of the window. Remarks Each window has an integer identifier. If the application has not provided one, an identifier will be generated. Normally, the identifier should be provided on creation and should not be modified subsequently. See also wxWindow::GetId (p. 1403), Window identifiers (p. 1607)

wxWindow::SetName
virtual void SetName(const wxString& name) Sets the window's name. Parameters name A name to set for the window. See also

1425


CHAPTER 7
wxWindow::GetName (p. 1404)

wxWindow::SetPalette
virtual void SetPalette(wxPalette* palette) Obsolete - use wxDC::SetPalette (p. 363) instead.

wxWindow::SetScrollbar
virtual void SetScrollbar(int orientation, int position, int thumbSize, int range, bool refresh = true) Sets the scrollbar properties of a built-in scrollbar. Parameters orientation Determines the scrollbar whose page size is to be set. May be wxHORIZONTAL or wxVERTICAL. position The position of the scrollbar in scroll units. thumbSize The size of the thumb, or visible portion of the scrollbar, in scroll units. range The maximum position of the scrollbar. refresh true to redraw the scrollbar, false otherwise. Remarks Let's say you wish to display 50 lines of text, using the same font. The window is sized so that you can only see 16 lines at a time. You would use:
SetScrollbar(wxVERTICAL, 0, 16, 50);

Note that with the window at this size, the thumb position can never go above 50 minus 16, or 34. You can determine how many lines are currently visible by dividing the current view size

1426


CHAPTER 7
by the character height in pixels. When defining your own scrollbar behaviour, you will always need to recalculate the scrollbar settings when the window size changes. You could therefore put your scrollbar calculations and SetScrollbar call into a function named AdjustScrollbars, which can be called initially and also from your wxSizeEvent (p. 1108) handler function. See also Scrolling overview (p. 1636), wxScrollBar (p. 1079), wxScrolledWindow (p. 1085)

wxWindow::SetScrollPos
virtual void SetScrollPos(int orientation, int pos, bool refresh = true) Sets the position of one of the built-in scrollbars. Parameters orientation Determines the scrollbar whose position is to be set. May be wxHORIZONTAL or wxVERTICAL. pos Position in scroll units. refresh true to redraw the scrollbar, false otherwise. Remarks This function does not directly affect the contents of the window: it is up to the application to take note of scrollbar attributes and redraw contents accordingly. See also wxWindow::SetScrollbar (p. 1426), wxWindow::GetScrollPos (p. 1427), wxWindow::GetScrollThumb (p. 1405), wxScrollBar (p. 1079), wxScrolledWindow (p. 1085)

wxWindow::SetSize
virtual void SetSize(int x, int y, int width, int height, int sizeFlags = wxSIZE_AUTO) virtual void SetSize(const wxRect& rect) Sets the size and position of the window in pixels. virtual void SetSize(int width, int height)

1427


CHAPTER 7
virtual void SetSize(const wxSize& size) Sets the size of the window in pixels. Parameters x Required x position in pixels, or -1 to indicate that the existing value should be used. y Required y position in pixels, or -1 to indicate that the existing value should be used. width Required width in pixels, or -1 to indicate that the existing value should be used. height Required height position in pixels, or -1 to indicate that the existing value should be used. size wxSize (p. 1106) object for setting the size. rect wxRect (p. 1042) object for setting the position and size. sizeFlags Indicates the interpretation of other parameters. It is a bit list of the following: wxSIZE_AUTO_WIDTH: a -1 width value is taken to indicate a wxWindowssupplied default width. wxSIZE_AUTO_HEIGHT: a -1 height value is taken to indicate a wxWindowssupplied default width. wxSIZE_AUTO: -1 size values are taken to indicate a wxWindows-supplied default size. wxSIZE_USE_EXISTING: existing dimensions should be used if -1 values are supplied. wxSIZE_ALLOW_MINUS_ONE: allow dimensions of -1 and less to be interpreted as real dimensions, not default values. Remarks The second form is a convenience for calling the first form with default x and y parameters, and must be used with non-default width and height values. The first form sets the position and optionally size, of the window. Parameters may be -1 to indicate either that a default should be supplied by wxWindows, or that the current

1428


CHAPTER 7
value of the dimension should be used. See also wxWindow::Move (p. 1411) wxPython note: In place of a single overloaded method name, wxPython implements the following methods: SetDimensions(x, y, width, height, sizeFlags=wxSIZE_AUTO) SetSize(size) SetPosition(point)

wxWindow::SetSizeHints
virtual void SetSizeHints(int minW=-1, int minH=-1, int maxW=-1, int maxH=-1, int incW=-1, int incH=-1) Allows specification of minimum and maximum window sizes, and window size increments. If a pair of values is not set (or set to -1), the default values will be used. Parameters minW Specifies the minimum width allowable. minH Specifies the minimum height allowable. maxW Specifies the maximum width allowable. maxH Specifies the maximum height allowable. incW Specifies the increment for sizing the width (Motif/Xt only). incH Specifies the increment for sizing the height (Motif/Xt only). Remarks If this function is called, the user will not be able to size the window outside the given bounds.

1429


CHAPTER 7
The resizing increments are only significant under Motif or Xt.

wxWindow::SetSizer
void SetSizer(wxSizer* sizer, bool deleteOld=true) Sets the window to have the given layout sizer. The window will then own the object, and will take care of its deletion. If an existing layout constraints object is already owned by the window, it will be deleted if the deleteOld parameter is true. Note that this function will also call SetAutoLayout (p. 1419) implicitly with trueparameter if the sizer is non-NULL and false otherwise. Parameters sizer The sizer to set. Pass NULL to disassociate and conditionally delete the window's sizer. See below. deleteOld If true (the default), this will delete any prexisting sizer. Pass false if you wish to handle deleting the old sizer yourself. Remarks SetSizer now enables and disables Layout automatically, but prior to wxWindows 2.3.3 the following applied: You must call wxWindow::SetAutoLayout (p. 1419) to tell a window to use the sizer automatically in OnSize; otherwise, you must override OnSize and call Layout() explicitly. When setting both a wxSizer and a wxLayoutConstraints (p. 784), only the sizer will have effect.

wxWindow::SetSizerAndFit
void SetSizerAndFit(wxSizer* sizer, bool deleteOld=true) The same as SetSizer (p. 1430), except it also sets the size hints for the window based on the sizer's minimum size.

wxWindow::SetTitle
virtual void SetTitle(const wxString& title) Sets the window's title. Applicable only to frames and dialogs. Parameters

1430


CHAPTER 7
title The window's title. See also wxWindow::GetTitle (p. 1408)

wxWindow::SetThemeEnabled
virtual void SetThemeEnabled(bool enable) This function tells a window if it should use the system's "theme" code to draw the windows' background instead if its own background drawing code. This does not always have any effect since the underlying platform obviously needs to support the notion of themes in user defined windows. One such platform is GTK+ where windows can have (very colourful) backgrounds defined by a user's selected theme. Dialogs, notebook pages and the status bar have this flag set to true by default so that the default look and feel is simulated best.

wxWindow::SetToolTip
void SetToolTip(const wxString& tip) void SetToolTip(wxToolTip* tip) Attach a tooltip to the window. See also: GetToolTip (p. 1408), wxToolTip (p. 1326)

wxWindow::SetValidator
virtual void SetValidator(const wxValidator& validator) Deletes the current validator (if any) and sets the window validator, having called wxValidator::Clone to create a new validator of this type.

wxWindow::SetVirtualSize
void SetVirtualSize(int width, int height) void SetVirtualSize(const wxSize& size) Sets the virtual size of the window in pixels.

wxWindow::SetVirtualSizeHints

1431


CHAPTER 7
virtual void SetVirtualSizeHints(int minW,int minH, int maxW=-1, int maxH=-1) Allows specification of minimum and maximum virtual window sizes. If a pair of values is not set (or set to -1), the default values will be used. Parameters minW Specifies the minimum width allowable. minH Specifies the minimum height allowable. maxW Specifies the maximum width allowable. maxH Specifies the maximum height allowable. Remarks If this function is called, the user will not be able to size the virtual area of the window outside the given bounds.

wxWindow::SetWindowStyle
void SetWindowStyle(long style) Identical to SetWindowStyleFlag (p. 1432).

wxWindow::SetWindowStyleFlag
virtual void SetWindowStyleFlag(long style) Sets the style of the window. Please note that some styles cannot be changed after the window creation and that Refresh() (p. 1414) might be called after changing the others for the change to take place immediately. See Window styles (p. 1611) for more information about flags. See also GetWindowStyleFlag (p. 1409)

wxWindow::Show
virtual bool Show(bool show = true)

1432


CHAPTER 7
Shows or hides the window. You may need to call Raise (p. 1414)for a top level window if you want to bring it to top, although this is not needed if Show() is called immediately after the frame creation. Parameters show If true displays the window. Otherwise, hides it. Return value true if the window has been shown or hidden or false if nothing was done because it already was in the requested state. See also wxWindow::IsShown (p. 1410)

wxWindow::Thaw
virtual void Thaw() Reenables window updating after a previous call toFreeze (p. 1399).

wxWindow::TransferDataFromWindow
virtual bool TransferDataFromWindow() Transfers values from child controls to data areas specified by their validators. Returnsfalse if a transfer failed. If the window has wxWS_EX_VALIDATE_RECURSIVELY extra style flag set, the method will also call TransferDataFromWindow() of all child windows. See also wxWindow::TransferDataToWindow (p. 1433), wxValidator (p. 1358), wxWindow::Validate (p. 1435)

wxWindow::TransferDataToWindow
virtual bool TransferDataToWindow() Transfers values to child controls from data areas specified by their validators. If the window has wxWS_EX_VALIDATE_RECURSIVELY extra style flag set, the method will also call TransferDataToWindow() of all child windows. Return value

1433


CHAPTER 7
Returns false if a transfer failed. See also wxWindow::TransferDataFromWindow (p. 1433), wxValidator (p. 1358), wxWindow::Validate (p. 1435)

wxWindow::UnregisterHotKey
bool UnregisterHotKey(int hotkeyId) Unregisters a system wide hotkey. Parameters hotkeyId Numeric identifier of the hotkey. Must be the same id that was passed to RegisterHotKey. Return value true if the hotkey was unregistered successfully, false if the id was invalid. Remarks This function is currently only implemented under MSW. See also wxWindow::RegisterHotKey (p. 1415)

wxWindow::Update
virtual void Update() Calling this method immediately repaints the invalidated area of the window while this would usually only happen when the flow of control returns to the event loop. Notice that this function doesn't refresh the window and does nothing if the window hadn't been already repainted. Use Refresh (p. 1414) first if you want to immediately redraw the window unconditionally.

wxWindow::UpdateWindowUI
virtual void UpdateWindowUI(long flags = wxUPDATE_UI_NONE) This function sends wxUpdateUIEvents (p. 1350) to the window. The particular implementation depends on the window; for example a wxToolBar will send an update UI event for each toolbar button, and a wxFrame will send an update UI event for each menubar menu item. You can call this function from your application to ensure that your

1434


CHAPTER 7
UI is up-to-date at this point (as far as your wxUpdateUIEvent handlers are concerned). This may be necessary if you have called wxUpdateUIEvent::SetMode (p. 1354) or wxUpdateUIEvent::SetUpdateInterval (p. 1355) to limit the overhead that wxWindows incurs by sending update UI events in idle time. flags should be a bitlist of one or more of the following values.
enum wxUpdateUI { wxUPDATE_UI_NONE wxUPDATE_UI_RECURSE descendants wxUPDATE_UI_FROMIDLE };

= 0x0000, // No particular value = 0x0001, // Call the function for = 0x0002 // Invoked from On(Internal)Idle

If you are calling this function from an OnInternalIdle or OnIdle function, make sure you pass the wxUPDATE_UI_FROMIDLE flag, since this tells the window to only update the UI elements that need to be updated in idle time. Some windows update their elements only when necessary, for example when a menu is about to be shown. The following is an example of how to call UpdateWindowUI from an idle function.
void MyWindow::OnInternalIdle() { if (wxUpdateUIEvent::CanUpdate(this)) UpdateWindowUI(wxUPDATE_UI_FROMIDLE); }

See also wxUpdateUIEvent (p. 1350), wxWindow::DoUpdateWindowUI (p. 1396), wxWindow::OnInternalIdle (p. 1412)

wxWindow::Validate
virtual bool Validate() Validates the current values of the child controls using their validators. If the window has wxWS_EX_VALIDATE_RECURSIVELY extra style flag set, the method will also call Validate() of all child windows. Return value Returns false if any of the validations failed. See also wxWindow::TransferDataFromWindow (p. 1433), wxWindow::TransferDataFromWindow (p. 1433), wxValidator (p. 1358)

wxWindow::WarpPointer
void WarpPointer(int x, int y)

1435


CHAPTER 7
Moves the pointer to the given position on the window. NB: This function is not supported under Mac because Apple Human Interface Guidelines forbid moving the mouse cursor programmatically. Parameters x The new x position for the cursor. y The new y position for the cursor.

wxWindowDC
A wxWindowDC must be constructed if an application wishes to paint on the whole area of a window (client and decorations). This should normally be constructed as a temporary stack object; don't store a wxWindowDC object. To draw on a window from inside OnPaint, construct a wxPaintDC (p. 966) object. To draw on the client area of a window from outside OnPaint, construct a wxClientDC (p. 133) object. To draw on the whole window including decorations, construct a wxWindowDC (p. 1436) object (Windows only). Derived from wxDC (p. 347) Include files <wx/dcclient.h> See also wxDC (p. 347), wxMemoryDC (p. 881), wxPaintDC (p. 966), wxClientDC (p. 133), wxScreenDC (p. 1072)

wxWindowDC::wxWindowDC
wxWindowDC(wxWindow* window) Constructor. Pass a pointer to the window on which you wish to paint.

1436


CHAPTER 7

wxWindowDisabler
This class disables all windows of the application (may be with the exception of one of them) in its constructor and enables them back in its destructor. This comes in handy when you want to indicate to the user that the application is currently busy and cannot respond to user input. Derived from None Include files <wx/utils.h> See also wxBusyCursor (p. 101)

wxWindowDisabler::wxWindowDisabler
wxWindowDisabler(wxWindow *winToSkip = NULL) Disables all top level windows of the applications with the exception of winToSkip if it is not NULL.

wxWindowDisabler::~wxWindowDisabler
~wxWindowDisabler() Reenables back the windows disabled by the constructor.

wxWizard
wxWizard is the central class for implementing 'wizard-like' dialogs. These dialogs are mostly familiar to Windows users and are nothing else but a sequence of 'pages' each of them displayed inside a dialog which has the buttons to pass to the next (and previous) pages. The wizards are typically used to decompose a complex dialog into several simple steps and are mainly useful to the novice users, hence it is important to keep them as simple as possible. To show a wizard dialog, you must first create an object of wxWizard class using either the non default constructor or a default one followed by call to Create (p. 1439) function. Then you should add all pages you want the wizard to show and call RunWizard (p. 1442). Finally, don't forget to call wizard->Destroy().

1437


CHAPTER 7
Derived from wxDialog (p. 367) wxPanel (p. 972) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/wizard.h> Event table macros To process input from a wizard dialog, use these event handler macros to direct input to member functions that take a wxWizardEvent (p. 1442) argument. For some events, Veto() (p. 954) can be called to prevent the event from happening. EVT_WIZARD_PAGE_CHANGED(id, func) The page has been just changed (this event can not be vetoed). EVT_WIZARD_PAGE_CHANGING(id, func) The page is being changed (this event can be vetoed). EVT_WIZARD_CANCEL(id, func) EVT_WIZARD_HELP(id, func) EVT_WIZARD_FINISHED(id, func) Extended styles Use the wxWindow::SetExtraStyle (p. 1423) function to set the following style. You will need to use two-step construction (use the default constructor, call SetExtraStyle, then call Create). wxWIZARD_EX_HELPBUTTON Shows a Help button using wxID_HELP. The user attempted to cancel the wizard (this event may also be vetoed). The wizard help button was pressed. The wizard finished button was pressed.

See also wxDialog (p. 367) for other extended styles. See also wxWizardEvent (p. 1442), wxWizardPage (p. 1444), wxWizard sample (p. 1570)

wxWizard::wxWizard
wxWizard() Default constructor. Use this if you wish to derive from wxWizard and then call Create (p.

1438


CHAPTER 7
1439), for example if you wish to set an extra style with wxWindow::SetExtraStyle (p. 1423) between the two calls. wxWizard(wxWindow* parent, int id = -1, const wxString& title = wxEmptyString, const wxBitmap& bitmap = wxNullBitmap, const wxPoint& pos = wxDefaultPosition, long style = wxDEFAULT_DIALOG_STYLE) Constructor which really creates the wizard -- if you use this constructor, you shouldn't call Create (p. 1439). Notice that unlike almost all other wxWindows classes, there is no size parameter in wxWizard constructor because the wizard will have a predefined default size by default. If you want to change this, you should use the GetPageAreaSizer (p. 1440) function. Parameters parent The parent window, may be NULL. id The id of the dialog, will usually be just -1. title The title of the dialog. bitmap The default bitmap used in the left side of the wizard. See also GetBitmap (p. 1445). pos The position of the dialog, it will be centered on the screen by default. style Window style is passed to wxDialog.

wxWizard::Create
bool Create(wxWindow* parent, int id = -1, const wxString& title = wxEmptyString, const wxBitmap& bitmap = wxNullBitmap, const wxPoint& pos = wxDefaultPosition, long style = wxDEFAULT_DIALOG_STYLE) Creates the wizard dialog. Must be called if the default constructor had been used to create the object. Notice that unlike almost all other wxWindows classes, there is no size parameter in wxWizard constructor because the wizard will have a predefined default size by default. If you want to change this, you should use the GetPageAreaSizer (p. 1440) function.

1439


CHAPTER 7
Parameters parent The parent window, may be NULL. id The id of the dialog, will usually be just -1. title The title of the dialog. bitmap The default bitmap used in the left side of the wizard. See also GetBitmap (p. 1445). pos The position of the dialog, it will be centered on the screen by default. style Window style is passed to wxDialog.

wxWizard::FitToPage
void FitToPage(const wxWizardPage* firstPage) This method is obsolete, useGetPageAreaSizer (p. 1440) instead. Sets the page size to be big enough for all the pages accessible via the given firstPage, i.e. this page, its next page and so on. This method may be called more than once and it will only change the page size if the size required by the new page is bigger than the previously set one. This is useful if the decision about which pages to show is taken during the run-time as in this case, the wizard won't be able to get to all pages starting from a single one and you should call Fit separately for the others.

wxWizard::GetCurrentPage
wxWizardPage* GetCurrentPage() const Get the current page while the wizard is running. NULL is returned if RunWizard() (p. 1442) is not being executed now.

wxWizard::GetPageAreaSizer

1440


CHAPTER 7
virtual wxSizer* GetPageAreaSizer() const Returns pointer to page area sizer. Wizard is laid out using sizers and page area sizer is the place holder for the pages. All pages are resized before being shown to match the wizard page area. Page area sizer has minimal size that is maximum of several values. First, all pages (or other objects) added to the sizer. Second, all pages reachable by repeatedly applying wxWizardPage::GetNext (p. 1445) to any page inserted into the sizer. Third, minimal size specified using SetPageSize (p. 1442) and FitToPage (p. 1440). Fourth, the total wizard height may be increased to accomodate the bitmap height. Fifth and finally, wizards are never smaller some built-in minimal size to avoid too small wizards. Caller can use wxSizer::SetMinSize (p. 1115) to enlarge it beyond minimal size. If wxRESIZE_BORDER was passed to constructor, user can resize wizard and consequently page area (but not make it smaller than the minimal size). It is recommended to add first page to page area sizer. For simple wizards, this will enlarge the wizard to fit biggest page. For non-linear wizards, first page of every separate chain should be added. Caller-specified size can be accomplished using wxSizer::SetMinSize (p. 1115). Adding pages to page area sizer affects default border width around page area that can be altered with SetBorder (p. 1442).

wxWizard::GetPageSize
wxSize GetPageSize() const Returns the size available for the pages.

wxWizard::HasNextPage
virtual bool HasNextPage(wxWizardPage *page) Return true if this page is not the last one in the wizard. The base class version implements this by calling page->GetNext (p. 1445) but this could be undesirable if, for example, the pages are created on demand only. See also HasPrevPage (p. 1441)

wxWizard::HasPrevPage
virtual bool HasPrevPage(wxWizardPage *page) Return true if this page is not the last one in the wizard. The base class version implements this by calling page->GetPrev (p. 1445) but this could be undesirable if, for example, the pages are created on demand only.

1441


CHAPTER 7
See also HasNextPage (p. 1441)

wxWizard::RunWizard
bool RunWizard(wxWizardPage* firstPage) Executes the wizard starting from the given page, returns true if it was successfully finished or false if user cancelled it. The firstPage can not be NULL.

wxWizard::SetPageSize
void SetPageSize(const wxSize& sizePage) This method is obsolete, useGetPageAreaSizer (p. 1440) instead. Sets the minimal size to be made available for the wizard pages. The wizard will take into account the size of the bitmap (if any) itself. Also, the wizard will never be smaller than the default size. The recommended way to use this function is to layout all wizard pages using the sizers (even though the wizard is not resizeable) and then use wxSizer::CalcMin (p. 1112) in a loop to calculate the maximum of minimal sizes of the pages and pass it to SetPageSize().

wxWizard::SetBorder
void SetBorder(int border) Sets width of border around page area. Default is zero. For backward compatibility, if there are no pages inGetPageAreaSizer (p. 1440), default is 5 pixels. If there is five point border around all controls in a page and border around page area is left zero, five point white space along all dialog borders will be added to control border to space page controls ten points from dialog border and non-page controls.

wxWizardEvent
wxWizardEvent class represents an event generated by thewizard (p. 1437): this event is first sent to the page itself and, if not processed there, goes up the window hierarchy as usual. Derived from wxNotifyEvent (p. 953) wxCommandEvent (p. 164) wxEvent (p. 439)

1442


CHAPTER 7
wxObject (p. 954) Include files <wx/wizard.h> Event table macros To process input from a wizard dialog, use these event handler macros to direct input to member functions that take a wxWizardEvent argument. EVT_WIZARD_PAGE_CHANGED(id, func) The page has been just changed (this event can not be vetoed). EVT_WIZARD_PAGE_CHANGING(id, func) The page is being changed (this event can be vetoed). EVT_WIZARD_CANCEL(id, func) EVT_WIZARD_HELP(id, func) EVT_WIZARD_FINISHED(id, func) See also wxWizard (p. 1437), wxWizard sample (p. 1570) The user attempted to cancel the wizard (this event may also be vetoed). The wizard help button was pressed. The wizard finished button was pressed.

wxWizardEvent::wxWizardEvent
wxWizardEvent(wxEventType type = wxEVT_NULL, int id = -1, bool direction = true) Constructor. It is not normally used by the user code as the objects of this type are constructed by wxWizard.

wxWizardEvent::GetDirection
bool GetDirection() const Return the direction in which the page is changing: for EVT_WIZARD_PAGE_CHANGING, return true if we're going forward or false otherwise and for EVT_WIZARD_PAGE_CHANGED return true if we came from the previous page and false if we returned from the next one.

wxWizardEvent::GetPage
wxWizardPage* GetPage() const

1443


CHAPTER 7
Returns the wxWizardPage (p. 1444) which was active when this event was generated.

wxWizardPage
wxWizardPage is one of the screens in wxWizard (p. 1437): it must know what are the following and preceding pages (which may be NULL for the first/last page). Except for this extra knowledge, wxWizardPage is just a panel, so the controls may be placed directly on it in the usual way. This class allows the programmer to decide the order of pages in the wizard dynamically (during run-time) and so provides maximal flexibility. Usually, however, the order of pages is known in advance in which case wxWizardPageSimple (p. 1445) class is enough and it is simpler to use. Virtual functions to override To use this class, you must override GetPrev (p. 1445) and GetNext (p. 1445) pure virtual functions (or you may use wxWizardPageSimple (p. 1445) instead). GetBitmap (p. 1445) can also be overridden, but this should be very rarely needed. Derived from wxPanel (p. 972) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/wizard.h> See also wxWizard (p. 1437), wxWizard sample (p. 1570)

wxWizardPage::wxWizardPage
wxWizardPage(wxWizard* parent, const wxBitmap& bitmap = wxNullBitmap, const wxChar *resource = NULL) Constructor accepts an optional bitmap which will be used for this page instead of the default one for this wizard (note that all bitmaps used should be of the same size). Notice that no other parameters are needed because the wizard will resize and reposition the page anyhow. Parameters parent

1444


CHAPTER 7
The parent wizard bitmap The page-specific bitmap if different from the global one resource Load the page from the specified resource if non NULL

wxWizardPage::GetPrev
wxWizardPage* GetPrev() const Get the page which should be shown when the user chooses the "Back"button: if NULL is returned, this button will be disabled. The first page of the wizard will usually return NULL from here, but the others will not. See also GetNext (p. 1445)

wxWizardPage::GetNext
wxWizardPage* GetNext() const Get the page which should be shown when the user chooses the "Next"button: if NULL is returned, this button will be disabled. The last page of the wizard will usually return NULL from here, but the others will not. See also GetPrev (p. 1445)

wxWizardPage::GetBitmap
wxBitmap GetBitmap() const This method is called by wxWizard to get the bitmap to display alongside the page. By default, m_bitmap member variable which was set in the constructor (p. 1444). If the bitmap was not explicitly set (i.e. if wxNullBitmap is returned), the default bitmap for the wizard should be used. The only cases when you would want to override this function is if the page bitmap depends dynamically on the user choices, i.e. almost never.

wxWizardPageSimple

1445


CHAPTER 7
wxWizardPageSimple is the simplest possible wxWizardPage (p. 1444) implementation: it just returns the pointers given to its constructor from GetNext() and GetPrev() functions. This makes it very easy to use the objects of this class in the wizards where the pages order is known statically - on the other hand, if this is not the case you must derive your own class from wxWizardPage (p. 1444) instead. Derived from wxWizardPage (p. 1444) wxPanel (p. 972) wxWindow (p. 1386) wxEvtHandler (p. 443) wxObject (p. 954) Include files <wx/wizard.h> See also wxWizard (p. 1437), wxWizard sample (p. 1570)

wxWizardPageSimple::wxWizardPageSimple
wxWizardPageSimple(wxWizard* parent = NULL, wxWizardPage* prev = NULL, wxWizardPage* next = NULL, const wxBitmap&bitmap = wxNullBitmap) Constructor takes the previous and next pages. They may be modified later bySetPrev() (p. 1446) or SetNext() (p. 1446).

wxWizardPageSimple::SetPrev
void SetPrev(wxWizardPage* prev) Sets the previous page.

wxWizardPageSimple::SetNext
void SetNext(wxWizardPage* next) Sets the next page.

wxWizardPageSimple::Chain
static void Chain(wxWizardPageSimple* first, wxWizardPageSimple* second)

1446


CHAPTER 7
A convenience function to make the pages follow each other. Example:
wxRadioboxPage *page3 = new wxRadioboxPage(wizard); wxValidationPage *page4 = new wxValidationPage(wizard); wxWizardPageSimple::Chain(page3, page4);

wxXmlResource
This is the main class for interacting with the XML-based resource system. The class holds XML resources from one or more .xml files, binary files or zip archive files. See XML-based resource system overview (p. 1627) for details. NOTE: XRC is not yet a part of the core wxWindows library, so please see the overview for how to compile and link it. Otherwise if you try to use it, you will get link errors. Derived from wxObject (p. 954) Include files <wx/xrc/xmlres.h> Data structures
enum wxXmlResourceFlags { wxXRC_USE_LOCALE = 1, wxXRC_NO_SUBCLASSING = 2 };

wxXmlResource::wxXmlResource
wxXmlResource(const wxString& filemask, int flags = wxXRC_USE_LOCALE) Constructor. filemask The XRC file, archive file, or wildcard specification that will be used to load all resource files inside a zip archive. flags wxXRC_USE_LOCALE: translatable strings will be translated via _(). wxXRC_NO_SUBCLASSING: subclass property of object nodes will be ignored

1447


CHAPTER 7
(useful for previews in XRC editors). wxXmlResource(int flags = wxXRC_USE_LOCALE) Constructor. flags wxXRC_USE_LOCALE: translatable strings will be translated via _(). wxXRC_NO_SUBCLASSING: subclass property of object nodes will be ignored (useful for previews in XRC editors).

wxXmlResource::~wxXmlResource
~wxXmlResource() Destructor.

wxXmlResource::AddHandler
void AddHandler(wxXmlResourceHandler* handler) Initializes only a specific handler (or custom handler). Convention says that the handler name is equal to the control's name plus 'XmlHandler', for example wxTextCtrlXmlHandler, wxHtmlWindowXmlHandler. The XML resource compiler (wxxrc) can create include file that contains initialization code for all controls used within the resource.

wxXmlResource::AttachUnknownControl
bool AttachUnknownControl(const wxString& name, wxWindow* control, wxWindow* parent = NULL) Attaches an unknown control to the given panel/window/dialog. Unknown controls are used in conjunction with <object class="unknown">.

wxXmlResource::ClearHandlers
void ClearHandlers() Removes all handlers.

wxXmlResource::CompareVersion
int CompareVersion(int major, int minor, int release, int revision) const Compares the XRC version to the argument. Returns -1 if the XRC version is less than

1448


CHAPTER 7
the argument, +1 if greater, and 0 if they equal.

wxXmlResource::CreateResFromNode
wxObject* CreateResFromNode(wxXmlNode* node, wxObject* parent, wxObject* instance = NULL) Creates a resource from information in the given node.

wxXmlResource::DoFindResource
wxXmlNode* DoFindResource(wxXmlNode* parent, const wxString& name, const wxString& classname, bool recursive) Helper function: finds a resource (calls UpdateResources) and returns a node containing it.

wxXmlResource::FindResource
wxXmlNode* FindResource(const wxString& name, const wxString& classname, bool recursive = false) Finds a resource (calls UpdateResources) and returns a node containing it.

wxXmlResource::Get
wxXmlResource* Get() Gets the global resources object or creates one if none exists.

wxXmlResource::GetFlags
int GetFlags() Returns flags, which may be a bitlist of wxXRC_USE_LOCALE and wxXRC_NO_SUBCLASSING.

wxXmlResource::GetVersion
long GetVersion() const Returns version information (a.b.c.d = d+ 256*c + 2562*b + 2563*a).

wxXmlResource::GetXRCID

1449


CHAPTER 7
int GetXRCID(const wxChar* str_id) Returns a numeric ID that is equivalent to the string ID used in an XML resource. To be used in event tables. The macro XRCID(name) is provided for convenience.

wxXmlResource::InitAllHandlers
void InitAllHandlers() Initializes handlers for all supported controls/windows. This will make the executable quite big because it forces linking against most of the wxWindows library.

wxXmlResource::Load
bool Load(const wxString& filemask) Loads resources from XML files that match given filemask. This method understands VFS (see filesys.h).

wxXmlResource::LoadBitmap
wxBitmap LoadBitmap(const wxString& name) Loads a bitmap resource from a file.

wxXmlResource::LoadDialog
wxDialog* LoadDialog(wxWindow* parent, const wxString& name) Loads a dialog. dlg points to a parent window (if any). bool LoadDialog(wxDialog* dlg, wxWindow* parent, const wxString& name) Loads a dialog. dlg points to parent window (if any). This form is used to finish creation of an already existing instance (the main reason for this is that you may want to use derived class with a new event table). Example:
MyDialog dlg; wxTheXmlResource->LoadDialog(&dlg, mainFrame, "my_dialog"); dlg->ShowModal();

wxXmlResource::LoadFrame
bool LoadFrame(wxFrame* frame, wxWindow* parent, const wxString& name)

1450


CHAPTER 7
Loads a frame.

wxXmlResource::LoadIcon
wxIcon LoadIcon(const wxString& name) Loads an icon resource from a file.

wxXmlResource::LoadMenu
wxMenu* LoadMenu(const wxString& name) Loads menu from resource. Returns NULL on failure.

wxXmlResource::LoadMenuBar
wxMenuBar* LoadMenuBar(wxWindow* parent, const wxString& name) Loads a menubar from resource. Returns NULL on failure. wxMenuBar* LoadMenuBar(const wxString& name) Loads a menubar from resource. Returns NULL on failure.

wxXmlResource::LoadPanel
wxPanel* LoadPanel(wxWindow* parent, const wxString& name) Loads a panel. panel points to parent window (if any). bool LoadPanel(wxPanel* panel, wxWindow* parent, const wxString& name) Loads a panel. panel points to parent window (if any). This form is used to finish creation of an already existing instance.

wxXmlResource::LoadToolBar
wxToolBar* LoadToolBar(wxWindow* parent, const wxString& name) Loads a toolbar.

wxXmlResource::Set
wxXmlResource* Set(wxXmlResource* res) Sets the global resources object and returns a pointer to the previous one (may be

1451


CHAPTER 7
NULL).

wxXmlResource::SetFlags
int SetFlags() Sets flags (bitlist of wxXRC_USE_LOCALE and wxXRC_NO_SUBCLASSING).

wxXmlResource::UpdateResources
void UpdateResources() Scans the resources list for unloaded files and loads them. Also reloads files that have been modified since the last load.

wxXmlResourceHandler
wxXmlResourceHandler is an abstract base class for resource handlers capable of creating a control from an XML node. See XML-based resource system overview (p. 1627) for details. NOTE: XRC is not yet a part of the core wxWindows library, so please see the overview for how to compile and link it. Otherwise if you try to use it, you will get link errors. Derived from wxObject (p. 954) Include files <wx/xrc/xmlres.h>

wxXmlResourceHandler::wxXmlResourceHandler
wxXmlResourceHandler() Default constructor.

wxXmlResourceHandler::~wxXmlResourceHandler
~wxXmlResourceHandler() Destructor.

1452


CHAPTER 7 wxXmlResourceHandler::AddStyle
void AddStyle(const wxString& name, int value) Add a style flag (e.g. wxMB_DOCKABLE) to the list of flags understood by this handler.

wxXmlResourceHandler::AddWindowStyles
void AddWindowStyles() Add styles common to all wxWindow-derived classes.

wxXmlResourceHandler::CanHandle
bool CanHandle(wxXmlNode* node) Returns true if it understands this node and can create a resource from it, false otherwise. Note You must not call any wxXmlResourceHandler methods except IsOfClass (p. 1456) from this method! The instance is not yet initialized with node data at the time CanHandle is called and it is only safe to operate on node directly or to call IsOfClass.

wxXmlResourceHandler::CreateChildren
void CreateChildren(wxObject* parent, bool this_hnd_only = false) Creates children.

wxXmlResourceHandler::CreateChildrenPrivately
void CreateChildrenPrivately(wxObject* parent, wxXmlNode* rootnode = NULL) Helper function.

wxXmlResourceHandler::CreateResFromNode
wxObject* CreateResFromNode(wxXmlNode* node, wxObject* parent, wxObject* instance = NULL) Creates a resource from a node.

wxXmlResourceHandler::CreateResource

1453


CHAPTER 7
wxObject* CreateResource(wxXmlNode* node, wxObject* parent, wxObject* instance) Creates an object (menu, dialog, control, ...) from an XML node. Should check for validity. parent is a higher-level object (usually window, dialog or panel) that is often necessary to create the resource. If instance is non-NULL it should not create a new instance via 'new' but should rather use this one, and call its Create method.

wxXmlResourceHandler::DoCreateResource
wxObject* DoCreateResource() Called from CreateResource after variables were filled.

wxXmlResourceHandler::GetBitmap
wxBitmap GetBitmap(const wxString& param = wxT("bitmap"), wxSize size = wxDefaultSize) Gets a bitmap.

wxXmlResourceHandler::GetBool
bool GetBool(const wxString& param, bool defaultv = false) Gets a bool flag (1, t, yes, on, true are true, everything else is false).

wxXmlResourceHandler::GetColour
wxColour GetColour(const wxString& param) Gets colour in HTML syntax (#RRGGBB).

wxXmlResourceHandler::GetCurFileSystem
wxFileSystem& GetCurFileSystem() Returns the current file system.

wxXmlResourceHandler::GetDimension
wxCoord GetDimension(const wxString& param, wxCoord defaultv = 0) Gets a dimension (may be in dialog units).

1454


CHAPTER 7 wxXmlResourceHandler::GetFont
wxFont GetFont(const wxString& param = wxT("font")) Gets a font.

wxXmlResourceHandler::GetID
int GetID() Returns the XRCID.

wxXmlResourceHandler::GetIcon
wxIcon GetIcon(const wxString& param = wxT("icon"), wxSize size = wxDefaultSize) Returns an icon.

wxXmlResourceHandler::GetLong
long GetLong(const wxString& param, long defaultv = 0) Gets the integer value from the parameter.

wxXmlResourceHandler::GetName
wxString GetName() Returns the resource name.

wxXmlResourceHandler::GetNodeContent
wxString GetNodeContent(wxXmlNode* node) Gets node content from wxXML_ENTITY_NODE.

wxXmlResourceHandler::GetParamNode
wxXmlNode* GetParamNode(const wxString& param) Finds the node or returns NULL.

wxXmlResourceHandler::GetParamValue
wxString GetParamValue(const wxString& param)

1455


CHAPTER 7
Finds the parameter value or returns the empty string.

wxXmlResourceHandler::GetPosition
wxPoint GetPosition(const wxString& param = wxT("pos")) Gets the position (may be in dialog units).

wxXmlResourceHandler::GetSize
wxSize GetSize(const wxString& param = wxT("size")) Gets the size (may be in dialog units).

wxXmlResourceHandler::GetStyle
int GetStyle(const wxString& param = wxT("style"), int defaults = 0) Gets style flags from text in form "flag | flag2| flag3 |..." Only understands flags added with AddStyle.

wxXmlResourceHandler::GetText
wxString GetText(const wxString& param) Gets text from param and does some conversions:    replaces \n, \r, \t by respective characters (according to C syntax) replaces $ by & and $$ by $ (needed for _File to &Filetranslation because of XML syntax) calls wxGetTranslations (unless disabled in wxXmlResource)

wxXmlResourceHandler::HasParam
bool HasParam(const wxString& param) Check to see if a parameter exists.

wxXmlResourceHandler::IsOfClass
bool IsOfClass(wxXmlNode* node, const wxString& classname) Convenience function. Returns true if the node has a property class equal to classname, e.g. <object class="wxDialog">.

1456


CHAPTER 7 wxXmlResourceHandler::SetParentResource
void SetParentResource(wxXmlResource* res) Sets the parent resource.

wxXmlResourceHandler::SetupWindow
void SetupWindow(wxWindow* wnd) Sets common window options.

wxZipInputStream
This class is input stream from ZIP archive. The archive must be local file (accessible via FILE*). It has all features including GetSize and seeking. Note If you need to enumerate files in ZIP archive, you can use wxFileSystem (p. 492) together with wxZipFSHandler (see the overview (p. 1601). Derived from wxInputStream (p. 762) Include files <wx/zipstrm.h>

wxZipInputStream::wxZipInputStream
wxZipInputStream(const wxString& archive, const wxString& file) Constructor. Parameters archive name of ZIP file file name of file stored in the archive

wxZlibInputStream
1457


CHAPTER 7
This filter stream decompresses a stream that is in zlib or gzip format. Note that reading the gzip format requires zlib version 1.2.0 greater. The stream is not seekable, SeekI() (p. 763) returns wxInvalidOffset. Also GetSize() (p. 1192) is not supported, it always returns 0. Derived from wxFilterInputStream (p. 501) Include files <wx/zstream.h> See also wxInputStream (p. 762), wxZlibOutputStream (p. 1458).

wxZlibInputStream::wxZlibInputStream
wxZlibInputStream(wxInputStream& stream, int flags = wxZLIB_ZLIB | wxZLIB_GZIP) The flags wxZLIB_ZLIB and wxZLIB_GZIP specify whether the input data is in zlib or gzip format. If both are used, bitwise ored, then zlib will autodetect the stream type, this is the default. If flags is zero, then the data is assumed to be a raw deflate stream without either zlib or gzip headers. The following symbols can be use for the flags:
// Flags enum { wxZLIB_NO_HEADER = 0, wxZLIB_ZLIB = 1, wxZLIB_GZIP = 2 1.2+ };

// raw deflate stream, no header or checksum // zlib header and checksum // gzip header and checksum, requires zlib

wxZlibOutputStream
This stream compresses all data written to it. The compressed output can be in zlib or gzip format. Note that writing the gzip format requires zlib version 1.2.0 greater. The stream is not seekable, SeekO() (p. 959) returns wxInvalidOffset. Derived from wxFilterOutputStream (p. 502) Include files

1458


CHAPTER 7
<wx/zstream.h> See also wxOutputStream (p. 958), wxZlibInputStream (p. 1457)

wxZlibOutputStream::wxZlibOutputStream
wxZlibOutputStream(wxOutputStream& stream, int level = -1, int flags = wxZLIB_ZLIB) Creates a new write-only compressed stream. level means level of compression. It is number between 0 and 9 (including these values) where 0 means no compression and 9 best but slowest compression. -1 is default value (currently equivalent to 6). The flags wxZLIB_ZLIB and wxZLIB_GZIP specify whether the output data will be in zlib or gzip format. wxZLIB_ZLIB is the default. If flags is zero, then a raw deflate stream is output without either zlib or gzip headers. The following symbols can be use for the compression level and flags:
// Compression level enum { wxZ_DEFAULT_COMPRESSION = -1, wxZ_NO_COMPRESSION = 0, wxZ_BEST_SPEED = 1, wxZ_BEST_COMPRESSION = 9 }; // Flags enum { wxZLIB_NO_HEADER = 0, wxZLIB_ZLIB = 1, wxZLIB_GZIP = 2 1.2+ };

// raw deflate stream, no header or checksum // zlib header and checksum // gzip header and checksum, requires zlib

1459


Chapter 8 Functions

The functions and macros defined in wxWindows are described here: you can either look up a function using the alphabetical listing of them or find it in the corresponding topic.

Alphabetical functions and macros list
CLASSINFO (p. 1515) copystring (p. 1484) DECLARE_ABSTRACT_CLASS (p. 1515) DECLARE_APP (p. 1516) DECLARE_CLASS (p. 1516) DECLARE_DYNAMIC_CLASS (p. 1516) IMPLEMENT_ABSTRACT_CLASS2 (p. 1517) IMPLEMENT_ABSTRACT_CLASS (p. 1517) IMPLEMENT_APP (p. 1517) IMPLEMENT_CLASS2 (p. 1518) IMPLEMENT_CLASS (p. 1518) IMPLEMENT_DYNAMIC_CLASS2 (p. 1518) IMPLEMENT_DYNAMIC_CLASS (p. 1518) ngettext (p. 1485) wxCONCAT (p. 1505) WXDEBUG_NEW (p. 1519) WXTRACELEVEL (p. 1526) WXTRACE (p. 1525) wxASSERT_MIN_BITSIZE (p. 1530) wxASSERT_MSG (p. 1530) wxASSERT (p. 1529) wxBITMAP (p. 1498) wxBeginBusyCursor (p. 1489) wxBell (p. 1489) wxCHECK (p. 1531) wxCHECK2_MSG (p. 1532) wxCHECK2 (p. 1532) wxCHECK_GCC_VERSION (p. 1465) wxCHECK_MSG (p. 1531) wxCHECK_RET (p. 1532) wxCHECK_VERSION (p. 1465) wxCHECK_W32API_VERSION (p. 1465) wxClientDisplayRect (p. 1499) wxClipboardOpen (p. 1503) wxCloseClipboard (p. 1504) wxColourDisplay (p. 1499) wxCOMPILE_TIME_ASSERT (p. 1530)

1460


CHAPTER 8
wxCOMPILE_TIME_ASSERT2 (p. 1531) wxConcatFiles (p. 1478) wxConstCast (p. 1519) wxCopyFile (p. 1478) wxCreateDynamicObject (p. 1519) wxCreateFileTipProvider (p. 1489) wxCRIT_SECT_DECLARE (p. 1473) wxCRIT_SECT_DECLARE_MEMBER (p. 1473) wxCRIT_SECT_LOCKER (p. 1473) wxCRITICAL_SECTION (p. 1473) wxDDECleanUp (p. 1507) wxDDEInitialize (p. 1508) wxDROP_ICON (p. 1499) wxDebugMsg (p. 1521) wxDirExists (p. 1475) wxDirSelector (p. 1490) wxDisplayDepth (p. 1499) wxDisplaySize (p. 1499) wxDisplaySizeMM (p. 1499) wxDos2UnixFilename (p. 1475) wxDynamicCastThis (p. 1520) wxDynamicCast (p. 1519) wxDYNLIB_FUNCTION (p. 1506) wxEmptyClipboard (p. 1504) wxEnableTopLevelWindows (p. 1508) wxEndBusyCursor (p. 1491) wxENTER_CRIT_SECT (p. 1474) wxEntry (p. 1466) wxEnumClipboardFormats (p. 1504) wxError (p. 1521) wxExecute (p. 1469) wxExit (p. 1471) wxEXPLICIT (p. 1506) wxFAIL_MSG (p. 1531) wxFAIL (p. 1531) wxFatalError (p. 1521) wxFileExists (p. 1476) wxFileModificationTime (p. 1476) wxFileNameFromPath (p. 1476) wxFileSelector (p. 1490) wxFindFirstFile (p. 1476) wxFindMenuItemId (p. 1508) wxFindNextFile (p. 1476) wxFindWindowAtPointer (p. 1509) wxFindWindowAtPoint (p. 1509) wxFindWindowByLabel (p. 1508) wxFindWindowByName (p. 1509) wxFinite (p. 1498) wxGetActiveWindow (p. 1509) wxGetApp (p. 1466) wxGetClipboardData (p. 1504)

1461


CHAPTER 8
wxGetClipboardFormatName (p. 1504) wxGetColourFromUser (p. 1491) wxGetCwd (p. 1478) wxGetDiskSpace (p. 1477) wxGetDisplayName (p. 1510) wxGetElapsedTime (p. 1527) wxGetEmailAddress (p. 1481) wxGetEnv (p. 1533) wxGetFontFromUser (p. 1492) wxGetFreeMemory (p. 1480) wxGetFullHostName (p. 1481) wxGetHomeDir (p. 1481) wxGetHostName (p. 1482) wxGetLocalTimeMillis (p. 1527) wxGetLocalTime (p. 1527) wxGetMousePosition (p. 1510) wxGetMultipleChoices (p. 1492) wxGetMultipleChoice (p. 1494) wxGetNumberFromUser (p. 1493) wxGetOSDirectory (p. 1477) wxGetOsDescription (p. 1482) wxGetOsVersion (p. 1483) wxGetPasswordFromUser (p. 1493) wxGetPrinterCommand (p. 1501) wxGetPrinterFile (p. 1501) wxGetPrinterMode (p. 1501) wxGetPrinterOptions (p. 1501) wxGetPrinterOrientation (p. 1501) wxGetPrinterPreviewCommand (p. 1502) wxGetPrinterScaling (p. 1502) wxGetPrinterTranslation (p. 1502) wxGetProcessId (p. 1472) wxGetResource (p. 1510) wxGetSingleChoiceData (p. 1495) wxGetSingleChoiceIndex (p. 1495) wxGetSingleChoice (p. 1494) wxGetTempFileName (p. 1478) wxGetTextFromUser (p. 1493) wxGetTopLevelParent (p. 1511) wxGetTranslation (p. 1485) wxGetUTCTime (p. 1528) wxGetUserHome (p. 1484) wxGetUserId (p. 1482) wxGetUserName (p. 1484) wxGetWorkingDirectory (p. 1478) wxGetenv (p. 1533) wxHandleFatalExceptions (p. 1467) wxICON (p. 1500) wxINTXX_SWAP_ALWAYS (p. 1514) wxINTXX_SWAP_ON_BE (p. 1514) wxINTXX_SWAP_ON_LE (p. 1514)

1462


CHAPTER 8
wxInitAllImageHandlers (p. 1467) wxInitialize (p. 1467) wxIsAbsolutePath (p. 1477) wxIsBusy (p. 1496) wxIsClipboardFormatAvailable (p. 1505) wxIsDebuggerRunning (p. 1532) wxIsEmpty (p. 1485) wxIsMainThread (p. 1474) wxIsNaN (p. 1498) wxIsWild (p. 1478) wxKill (p. 1471) wxLEAVE_CRIT_SECT (p. 1474) wxLoadUserResource (p. 1511) wxLogDebug (p. 1523) wxLogError (p. 1522) wxLogFatalError (p. 1522) wxLogMessage (p. 1522) wxLogStatus (p. 1523) wxLogSysError (p. 1523) wxLogTrace (p. 1523) wxLogVerbose (p. 1522) wxLogWarning (p. 1522) wxLL (p. 1506) wxLongLongFmtSpec (p. 1507) wxMakeMetafilePlaceable (p. 1500) wxMatchWild (p. 1479) wxMessageBox (p. 1496) wxMkdir (p. 1479) wxMutexGuiEnter (p. 1474) wxMutexGuiLeave (p. 1475) wxNewId (p. 1507) wxNow (p. 1528) wxOnAssert (p. 1529) wxOpenClipboard (p. 1505) wxPathOnly (p. 1477) wxPostDelete (p. 1511) wxPostEvent (p. 1512) wxRegisterClipboardFormat (p. 1505) wxRegisterId (p. 1507) wxRemoveFile (p. 1479) wxRenameFile (p. 1479) wxRmdir (p. 1479) wxSafeShowMessage (p. 1524) wxSafeYield (p. 1467) wxSetClipboardData (p. 1505) wxSetCursor (p. 1501) wxSetDisplayName (p. 1512) wxSetEnv (p. 1533) wxSetPrinterCommand (p. 1502) wxSetPrinterFile (p. 1502) wxSetPrinterMode (p. 1502)

1463


CHAPTER 8
wxSetPrinterOptions (p. 1502) wxSetPrinterOrientation (p. 1503) wxSetPrinterPreviewCommand (p. 1503) wxSetPrinterScaling (p. 1503) wxSetPrinterTranslation (p. 1503) wxSetWorkingDirectory (p. 1479) wxShell (p. 1472) wxShowTip (p. 1497) wxShutdown (p. 1472) wxSleep (p. 1528) wxSnprintf (p. 1487) wxSplitPath (p. 1479) wxStartTimer (p. 1528) wxStaticCast (p. 1520) wxStrcmp (p. 1486) wxStricmp (p. 1486) wxStringEq (p. 1486) wxStringMatch (p. 1486) wxStripMenuCodes (p. 1512) wxStrlen (p. 1486) wxSysErrorCode (p. 1525) wxSysErrorMsg (p. 1525) wxT (p. 1487) wxTraceLevel (p. 1526) wxTrace (p. 1526) wxTransferFileToStream (p. 1480) wxTransferStreamToFile (p. 1480) wxTrap (p. 1532) wxULL (p. 1513) wxUninitialize (p. 1468) wxUnix2DosFilename (p. 1477) wxUnsetEnv (p. 1533) wxUsleep (p. 1528) wxVsnprintf (p. 1488) wxWakeUpIdle (p. 1468) wxWriteResource (p. 1513) wxYield (p. 1468) _ (p. 1488) _T (p. 1488)

Version macros
The following constants are defined in wxWindows:    wxMAJOR_VERSION is the major version of wxWindows wxMINOR_VERSION is the minor version of wxWindows wxRELEASE_NUMBER is the release number

1464


CHAPTER 8
For example, the values or these constants for wxWindows 2.1.15 are 2, 1 and 15. Additionally, wxVERSION_STRING is a user-readable string containing the full wxWindows version and wxVERSION_NUMBER is a combination of the three version numbers above: for 2.1.15, it is 2115 and it is 2200 for wxWindows 2.2. Include files <wx/version.h> or <wx/defs.h>

wxCHECK_VERSION
bool wxCHECK_VERSION(major, minor, release) This is a macro which evaluates to true if the current wxWindows version is at least major.minor.release. For example, to test if the program is compiled with wxWindows 2.2 or higher, the following can be done:
wxString s; #if wxCHECK_VERSION(2, 2, 0) if ( s.StartsWith("foo") ) #else // replacement code for old version if ( strncmp(s, "foo", 3) == 0 ) #endif { ... }

wxCHECK_GCC_VERSION
bool wxCHECK_GCC_VERSION(major, minor, release) Returns 1 if the compiler being used to compile the code is GNU C++ compiler (g++) version major.minor.release or greater. Otherwise, and also if the compiler is not GNU C++ at all, returns 0.

wxCHECK_W32API_VERSION
bool wxCHECK_GCC_VERSION(major, minor, release) Returns 1 if the version of w32api headers used is major.minor.release or greater. Otherwise, and also if we are not compiling with mingw32/cygwin under Win32 at all, returns 0.

Application initialization and termination
The functions in this section are used on application startup/shutdown and also to control the behaviour of the main event loop of the GUI programs.

1465


CHAPTER 8 ::wxEntry
This initializes wxWindows in a platform-dependent way. Use this if you are not using the default wxWindows entry code (e.g. main or WinMain). For example, you can initialize wxWindows from an Microsoft Foundation Classes application using this function. void wxEntry(HANDLE hInstance, HANDLE hPrevInstance, const wxString& commandLine, int cmdShow, bool enterLoop = true) wxW indows initialization under Windows (non-DLL). If enterLoop is false, the function will return immediately after calling wxApp::OnInit. Otherwise, the wxWindows message loop will be entered. void wxEntry(HANDLE hInstance, HANDLE hPrevInstance, WORD wDataSegment, WORD wHeapSize, const wxString& commandLine) wxW indows initialization under Windows (for applications constructed as a DLL). int wxEntry(int argc, const wxString& *argv) wxW indows initialization under Unix. Remarks To clean up wxWindows, call wxApp::OnExit followed by the static function wxApp::CleanUp. For example, if exiting from an MFC application that also uses wxWindows:
int CTheApp::ExitInstance() { // OnExit isn't called by CleanUp so must be called explicitly. wxTheApp >OnExit(); wxApp::CleanUp(); return CWinApp::ExitInstance(); }

Include files <wx/app.h>

::wxGetApp
wxAppDerivedClass& wxGetApp() This function doesn't exist in wxWindows but it is created by using the IMPLEMENT_APP (p. 1517) macro. Thus, before using it anywhere but in the same module where this macro is used, you must make it available using DECLARE_APP (p. 1516). The advantage of using this function compared to directly using the global wxTheApp pointer is that the latter is of type wxApp * and so wouldn't allow you to access the functions specific to your application class but not present in wxApp while wxGetApp() returns the object of the right type.

1466


CHAPTER 8 ::wxHandleFatalExceptions
bool wxHandleFatalExceptions(bool doIt = true) If doIt is true, the fatal exceptions (also known as general protection faults under Windows or segmentation violations in the Unix world) will be caught and passed to wxApp::OnFatalException (p. 36). By default, i.e. before this function is called, they will be handled in the normal way which usually just means that the application will be terminated. Calling wxHandleFatalExceptions() with doIt equal to false will restore this default behaviour.

::wxInitAllImageHandlers
void wxInitAllImageHandlers() Initializes all available image handlers. For a list of available handlers, see wxImage (p. 728). See also wxImage (p. 728), wxImageHandler (p. 750) Include files <wx/image.h>

::wxInitialize
bool wxInitialize() This function is used in wxBase only and only if you don't createwxApp (p. 31) object at all. In this case you must call it from yourmain() function before calling any other wxWindows functions. If the function returns false the initialization could not be performed, in this case the library cannot be used andwxUninitialize (p. 1468) shouldn't be called neither. This function may be called several times butwxUninitialize (p. 1468) must be called for each successful call to this function. Include files <wx/app.h>

::wxSafeYield
bool wxSafeYield(wxWindow* win = NULL, bool onlyIfNeeded = false)

This function is similar to wxYield, except that it disables the user input to all program windows before calling wxYield and re-enables it again afterwards. If win is not NULL,

1467


CHAPTER 8
this window will remain enabled, allowing the implementation of some limited user interaction. Returns the result of the call to ::wxYield (p. 1468). Include files <wx/utils.h>

::wxUninitialize
void wxUninitialize() This function is for use in console (wxBase) programs only. It must be called once for each previous successful call to wxInitialize (p. 1467). Include files <wx/app.h>

::wxYield
bool wxYield() Calls wxApp::Yield (p. 41). This function is kept only for backwards compatibility. Please use the wxApp::Yield (p. 41) method instead in any new code. Include files <wx/app.h> or <wx/utils.h>

::wxWakeUpIdle
void wxWakeUpIdle() This functions wakes up the (internal and platform dependent) idle system, i.e. it will force the system to send an idle event even if the system currently is idle and thus would not send any idle event until after some other event would get sent. This is also useful for sending events between two threads and is used by the corresponding functions ::wxPostEvent (p. 1512) andwxEvtHandler::AddPendingEvent (p. 444). Include files <wx/event.h>

Process control functions

1468


CHAPTER 8
The functions in this section are used to launch or terminate the other processes.

::wxExecute
long wxExecute(const wxString& command, int sync = wxEXEC_ASYNC, wxProcess *callback = NULL) wxPerl note: In wxPerl this function is called Wx::ExecuteCommand long wxExecute(char **argv, int flags = wxEXEC_ASYNC, wxProcess *callback = NULL) wxPerl note: In wxPerl this function is called Wx::ExecuteArgs long wxExecute(const wxString& command, wxArrayString& output) wxPerl note: In wxPerl this function is called Wx::ExecuteStdout and it only takes the command argument, and returns a 2-element list ( status, output ), where output is an array reference. long wxExecute(const wxString& command, wxArrayString& output, wxArrayString& errors) wxPerl note: In wxPerl this function is called Wx::ExecuteStdoutStderr and it only takes the command argument, and returns a 3-element list ( status, output, errors ), whereoutput and errors are array references. Executes another program in Unix or Windows. The first form takes a command string, such as "emacs file.txt". The second form takes an array of values: a command, any number of arguments, terminated by NULL. The semantics of the third and fourth versions is different from the first two and is described in more details below. If flags parameter contains wxEXEC_ASYNC flag (the default), flow of control immediately returns. If it contains wxEXEC_SYNC, the current application waits until the other program has terminated. In the case of synchronous execution, the return value is the exit code of the process (which terminates by the moment the function returns) and will be-1 if the process couldn't be started and typically 0 if the process terminated successfully. Also, while waiting for the process to terminate, wxExecute will call wxYield (p. 1468). The caller should ensure that this can cause no recursion, in the simplest case by calling wxEnableTopLevelWindows(false) (p. 1508). For asynchronous execution, however, the return value is the process id and zero value indicates that the command could not be executed. As an added complication, the return value of -1 in this case indicates that we didn't launch a new process, but connected to the running one (this can only happen in case of using DDE under Windows for command execution). In particular, in this, and only this, case the calling code will not

1469


CHAPTER 8
get the notification about process termination. If callback isn't NULL and if execution is asynchronous,wxProcess::OnTerminate (p. 1023) will be called when the process finishes. Specifying this parameter also allows you to redirect the standard input and/or output of the process being launched by callingRedirect (p. 1024). If the child process IO is redirected, under Windows the process window is not shown by default (this avoids having to flush an unnecessary console for the processes which don't create any windows anyhow) but a wxEXEC_NOHIDE flag can be used to prevent this from happening, i.e. with this flag the child process window will be shown normally. Under Unix the flag wxEXEC_MAKE_GROUP_LEADER may be used to ensure that the new process is a group leader (this will create a new session if needed). Calling wxKill (p. 1471) with the argument of -pid where pid is the process ID of the new process will kill this process as well as all of its children (except those which have started their own session). Finally, you may use the third overloaded version of this function to execute a process (always synchronously) and capture its output in the arrayoutput. The fourth version adds the possibility to additionally capture the messages from standard error output in the errors array. NB: Currently wxExecute() can only be used from the main thread, calling this function from another thread will result in an assert failure in debug build and won't work. See also wxShell (p. 1472), wxProcess (p. 1019), Exec sample (p. 1565). Parameters command The command to execute and any parameters to pass to it as a single string. argv The command to execute should be the first element of this array, any additional ones are the command parameters and the array must be terminated with a NULL pointer. flags Combination of bit masks wxEXEC_ASYNC, wxEXEC_SYNC and wxEXEC_NOHIDE callback An optional pointer to wxProcess (p. 1019) Include files <wx/utils.h>

1470


CHAPTER 8 ::wxExit
void wxExit() Exits application after calling wxApp::OnExit (p. 36). Should only be used in an emergency: normally the top-level frame should be deleted (after deleting all other frames) to terminate the application. See wxCloseEvent (p. 139) and wxApp (p. 31). Include files <wx/app.h>

::wxKill
int wxKill(long pid, int sig = wxSIGTERM, wxKillError *rc = NULL) Equivalent to the Unix kill function: send the given signal sig to the process with PID pid. The valid signal values are
enum wxSignal { wxSIGNONE = 0, wxSIGHUP, wxSIGINT, wxSIGQUIT, wxSIGILL, wxSIGTRAP, wxSIGABRT, wxSIGEMT, wxSIGFPE, wxSIGKILL, wxSIGBUS, wxSIGSEGV, wxSIGSYS, wxSIGPIPE, wxSIGALRM, wxSIGTERM };

// verify if the process exists under Unix

// forcefully kill, dangerous!

// terminate the process gently

wxSIGNONE, wxSIGKILL and wxSIGTERM have the same meaning under both Unix and Windows but all the other signals are equivalent to wxSIGTERM under Windows. Returns 0 on success, -1 on failure. If rc parameter is not NULL, it will be filled with an element of wxKillError enum:
enum wxKillError { wxKILL_OK, wxKILL_BAD_SIGNAL, wxKILL_ACCESS_DENIED, wxKILL_NO_PROCESS, wxKILL_ERROR };

// // // // //

no error no such signal permission denied no such process another, unspecified error

See also wxProcess::Kill (p. 1022), wxProcess::Exists (p. 1022), Exec sample (p. 1565) Include files

1471


CHAPTER 8
<wx/utils.h>

::wxGetProcessId
unsigned long wxGetProcessId() Returns the number uniquely identifying the current process in the system. If an error occurs, 0 is returned. Include files <wx/utils.h>

::wxShell
bool wxShell(const wxString& command = NULL) Executes a command in an interactive shell window. If no command is specified, then just the shell is spawned. See also wxExecute (p. 1469), Exec sample (p. 1565). Include files <wx/utils.h>

::wxShutdown
bool wxShutdown(wxShutdownFlagsflags) This function shuts down or reboots the computer depending on the value of theflags. Please notice that doing this requires the corresponding access rights (superuser under Unix, SE_SHUTDOWN privelege under Windows NT) and that this function is only implemented under Unix and Win32. Parameters flags Either wxSHUTDOWN_POWEROFF or wxSHUTDOWN_REBOOT Returns true on success, false if an error occured. Include files <wx/utils.h>

1472


CHAPTER 8

Thread functions
The functions and macros here mainly exist to make it writing the code which may be compiled in multi thread build (wxUSE_THREADS = 1) as well as in single thread configuration (wxUSE_THREADS = 0). For example, a static variable must be protected against simultaneous access by multiple threads in the former configuration but in the latter the extra overhead of using the critical section is not needed. To solve this problem, the wxCRITICAL_SECTION (p. 1473) macro may be used to create and use the critical section only when needed. Include files <wx/thread.h> See also wxThread (p. 1284), wxMutex (p. 938), Multithreading overview (p. 1665)

wxCRIT_SECT_DECLARE
wxCRIT_SECT_DECLARE(cs) This macro declares a (static) critical section object named cs if wxUSE_THREADS is 1 and does nothing if it is 0.

wxCRIT_SECT_DECLARE_MEMBER
wxCRIT_SECT_DECLARE(cs) This macro declares a critical section object named cs if wxUSE_THREADS is 1 and does nothing if it is 0. As it doesn't include the static keyword (unlike wxCRIT_SECT_DECLARE (p. 1473)), it can be used to declare a class or struct member which explains its name.

wxCRIT_SECT_LOCKER
wxCRIT_SECT_LOCKER(name, cs) This macro creates a critical section lock (p. 207) object named name and associated with the critical section cs if wxUSE_THREADS is 1 and does nothing if it is 0.

wxCRITICAL_SECTION
wxCRITICAL_SECTION(name) This macro combines wxCRIT_SECT_DECLARE (p. 1473) and wxCRIT_SECT_LOCKER (p. 1473): it creates a static critical section object and also the

1473


CHAPTER 8
lock object associated with it. Because of this, it can be only used inside a function, not at global scope. For example:
int IncCount() { static int s_counter = 0; wxCRITICAL_SECTION(counter); return ++s_counter; }

(note that we suppose that the function is called the first time from the main thread so that the critical section object is initialized correctly by the time other threads start calling it, if this is not the case this approach can not be used and the critical section must be made a global instead).

wxENTER_CRIT_SECT
wxENTER_CRIT_SECT(wxCriticalSection& cs) This macro is equivalent to cs.Enter() (p. 207) if wxUSE_THREADS is 1 and does nothing if it is 0.

::wxIsMainThread
bool wxIsMainThread() Returns true if this thread is the main one. Always returns true ifwxUSE_THREADS is 0.

wxLEAVE_CRIT_SECT
wxLEAVE_CRIT_SECT(wxCriticalSection& cs) This macro is equivalent to cs.Leave() (p. 207) if wxUSE_THREADS is 1 and does nothing if it is 0.

::wxMutexGuiEnter
void wxMutexGuiEnter() This function must be called when any thread other than the main GUI thread wants to get access to the GUI library. This function will block the execution of the calling thread until the main thread (or any other thread holding the main GUI lock) leaves the GUI library and no other thread will enter the GUI library until the calling thread calls ::wxMutexGuiLeave() (p. 1475). Typically, these functions are used like this:
void MyThread::Foo(void)

1474


CHAPTER 8
{ // before doing any GUI calls we must ensure that this thread is the only // one doing it! wxMutexGuiEnter(); // Call GUI here: my_window->DrawSomething(); wxMutexGuiLeave(); }

Note that under GTK, no creation of top-level windows is allowed in any thread but the main one. This function is only defined on platforms which support preemptive threads.

::wxMutexGuiLeave
void wxMutexGuiLeave() See ::wxMutexGuiEnter() (p. 1474). This function is only defined on platforms which support preemptive threads.

File functions
Include files <wx/utils.h> See also wxPathList (p. 975) wxDir (p. 380) wxFile (p. 458) wxFileName (p. 475)

::wxDirExists
bool wxDirExists(const wxString& dirname) Returns true if the directory exists.

::wxDos2UnixFilename
void wxDos2UnixFilename(wxChar *s) Converts a DOS to a Unix filename by replacing backslashes with forward slashes.

1475


CHAPTER 8 ::wxFileExists
bool wxFileExists(const wxString& filename) Returns true if the file exists and is a plain file.

::wxFileModificationTime
time_t wxFileModificationTime(const wxString& filename) Returns time of last modification of given file.

::wxFileNameFromPath
wxString wxFileNameFromPath(const wxString& path) char * wxFileNameFromPath(char *path) NB: This function is obsolete, please usewxFileName::SplitPath (p. 489) instead. Returns the filename for a full path. The second form returns a pointer to temporary storage that should not be deallocated.

::wxFindFirstFile
wxString wxFindFirstFile(const char *spec, int flags = 0) This function does directory searching; returns the first file that matches the path spec, or the empty string. Use wxFindNextFile (p. 1476) to get the next matching file. Neither will report the current directory "." or the parent directory "..". spec may contain wildcards. flags may be wxDIR for restricting the query to directories, wxFILE for files or zero for either. For example:
wxString f = wxFindFirstFile("/home/project/*.*"); while ( !f.IsEmpty() ) { ... f = wxFindNextFile(); }

::wxFindNextFile
wxString wxFindNextFile() Returns the next file that matches the path passed to wxFindFirstFile (p. 1476).

1476


CHAPTER 8
See wxFindFirstFile (p. 1476) for an example.

::wxGetDiskSpace
bool wxGetDiskSpace(const wxString& path, wxLongLong *total = NULL, wxLongLong *free = NULL) This function returns the total number of bytes and number of free bytes on the disk containing the directory path (it should exist). Bothtotal and free parameters may be NULL if the corresponding information is not needed. Returns true on success, false if an error occured (for example, the directory doesn't exist). Portability This function is implemented for Win16 (only for drives less than 2Gb), Win32, Mac OS and generic Unix provided the system has statfs() function. This function first appeared in wxWindows 2.3.2.

::wxGetOSDirectory
wxString wxGetOSDirectory() Returns the Windows directory under Windows; on other platforms returns the empty string.

::wxIsAbsolutePath
bool wxIsAbsolutePath(const wxString& filename) Returns true if the argument is an absolute filename, i.e. with a slash or drive name at the beginning.

::wxPathOnly
wxString wxPathOnly(const wxString& path) Returns the directory part of the filename.

::wxUnix2DosFilename
void wxUnix2DosFilename(const wxString& s) Converts a Unix to a DOS filename by replacing forward slashes with backslashes.

1477


CHAPTER 8 ::wxConcatFiles
bool wxConcatFiles(const wxString& file1, const wxString& file2,const wxString& file3) Concatenates file1 and file2 to file3, returning true if successful.

::wxCopyFile
bool wxCopyFile(const wxString& file1, const wxString& file2, bool overwrite = true) Copies file1 to file2, returning true if successful. Ifoverwrite parameter is true (default), the destination file is overwritten if it exists, but if overwrite is false, the functions fails in this case.

::wxGetCwd
wxString wxGetCwd() Returns a string containing the current (or working) directory.

::wxGetWorkingDirectory
wxString wxGetWorkingDirectory(char *buf=NULL, int sz=1000) NB: This function is obsolete: use wxGetCwd (p. 1478) instead. Copies the current working directory into the buffer if supplied, or copies the working directory into new storage (which you must delete yourself) if the buffer is NULL. sz is the size of the buffer if supplied.

::wxGetTempFileName
char * wxGetTempFileName(const wxString& prefix, char *buf=NULL) bool wxGetTempFileName(const wxString& prefix, wxString& buf) NB: These functions are obsolete, please use wxFileName::CreateTempFileName (p. 480) instead.

::wxIsWild
bool wxIsWild(const wxString& pattern) Returns true if the pattern contains wildcards. See wxMatchWild (p. 1479).

1478


CHAPTER 8 ::wxMatchWild
bool wxMatchWild(const wxString& pattern, const wxString& text, bool dot_special) Returns true if the pattern matches the text; if dot_special is true, filenames beginning with a dot are not matched with wildcard characters. See wxIsWild (p. 1478).

::wxMkdir
bool wxMkdir(const wxString& dir, int perm = 0777) Makes the directory dir, returning true if successful. perm is the access mask for the directory for the systems on which it is supported (Unix) and doesn't have effect for the other ones.

::wxRemoveFile
bool wxRemoveFile(const wxString& file) Removes file, returning true if successful.

::wxRenameFile
bool wxRenameFile(const wxString& file1, const wxString& file2) Renames file1 to file2, returning true if successful.

::wxRmdir
bool wxRmdir(const wxString& dir, int flags=0) Removes the directory dir, returning true if successful. Does not work under VMS. The flags parameter is reserved for future use.

::wxSetWorkingDirectory
bool wxSetWorkingDirectory(const wxString& dir) Sets the current working directory, returning true if the operation succeeded. Under MS Windows, the current drive is also changed if dir contains a drive specification.

::wxSplitPath
void wxSplitPath(const char * fullname, wxString * path, wxString * name, wxString

1479


CHAPTER 8
* ext) NB: This function is obsolete, please usewxFileName::SplitPath (p. 489) instead. This function splits a full file name into components: the path (including possible disk/drive specification under Windows), the base name and the extension. Any of the output parameters (path, name or ext) may be NULL if you are not interested in the value of a particular component. wxSplitPath() will correctly handle filenames with both DOS and Unix path separators under Windows, however it will not consider backslashes as path separators under Unix (where backslash is a valid character in a filename). On entry, fullname should be non-NULL (it may be empty though). On return, path contains the file path (without the trailing separator), namecontains the file name and ext contains the file extension without leading dot. All three of them may be empty if the corresponding component is. The old contents of the strings pointed to by these parameters will be overwritten in any case (if the pointers are not NULL).

::wxTransferFileToStream
bool wxTransferFileToStream(const wxString& filename, ostream& stream) Copies the given file to stream. Useful when converting an old application to use streams (within the document/view framework, for example). Include files <wx/docview.h>

::wxTransferStreamToFile
bool wxTransferStreamToFile(istream& stream const wxString& filename) Copies the given stream to the file filename. Useful when converting an old application to use streams (within the document/view framework, for example). Include files <wx/docview.h>

Network, user and OS functions
The functions in this section are used to retrieve information about the current computer and/or user characteristics.

::wxGetFreeMemory

1480


CHAPTER 8
long wxGetFreeMemory() Returns the amount of free memory in bytes under environments which support it, and -1 if not supported. Currently, it is supported only under Windows, Linux and Solaris. Include files <wx/utils.h>

::wxGetFullHostName
wxString wxGetFullHostName() Returns the FQDN (fully qualified domain host name) or an empty string on error. See also wxGetHostName (p. 1482) Include files <wx/utils.h>

::wxGetEmailAddress
bool wxGetEmailAddress(const wxString& buf, int sz) Copies the user's email address into the supplied buffer, by concatenating the values returned by wxGetFullHostName (p. 1481) and wxGetUserId (p. 1482). Returns true if successful, false otherwise. Include files <wx/utils.h>

::wxGetHomeDir
wxString wxGetHomeDir() Return the (current) user's home directory. See also wxGetUserHome (p. 1484) Include files <wx/utils.h>

1481


CHAPTER 8 ::wxGetHostName
wxString wxGetHostName() bool wxGetHostName(char * buf, int sz) Copies the current host machine's name into the supplied buffer. Please note that the returned name is not fully qualified, i.e. it does not include the domain name. Under Windows or NT, this function first looks in the environment variable SYSTEM_NAME; if this is not found, the entry HostName in the wxWindows section of the WIN.INI file is tried. The first variant of this function returns the hostname if successful or an empty string otherwise. The second (deprecated) function returns true if successful, false otherwise. See also wxGetFullHostName (p. 1481) Include files <wx/utils.h>

::wxGetUserId
wxString wxGetUserId() bool wxGetUserId(char * buf, int sz) This function returns the "user id" also known as "login name" under Unix i.e. something like "jsmith". It uniquely identifies the current user (on this system). Under Windows or NT, this function first looks in the environment variables USER and LOGNAME; if neither of these is found, the entry UserId in the wxWindows section of the WIN.INI file is tried. The first variant of this function returns the login name if successful or an empty string otherwise. The second (deprecated) function returns true if successful, false otherwise. See also wxGetUserName (p. 1484) Include files <wx/utils.h>

::wxGetOsDescription
wxString wxGetOsDescription()

1482


CHAPTER 8
Returns the string containing the description of the current platform in a user-readable form. For example, this function may return strings likeWindows NT Version 4.0 or Linux 2.2.2 i386. See also ::wxGetOsVersion (p. 1483) Include files <wx/utils.h>

::wxGetOsVersion
int wxGetOsVersion(int *major = NULL, int *minor = NULL) Gets operating system version information. Platform Mac OS Return types Return value is wxMAC when compiled with CodeWarrior under Mac OS 8.x/9.x and Mac OS X, wxMAC_DARWIN when compiled with the Apple Developer Tools under Mac OS X. Both major and minor have to be looked at as hexadecimal numbers. So System 10.2.4 returns 0x10, resp 16 for major and 0x24, resp 36 for minor. GTK Motif OS/2 Windows 3.1 Windows NT/2000 Windows 98 Windows 95 Win32s (Windows 3.1) Return value is wxGTK, For GTK 1.0, major is 1, minor is 0. Return value is wxMOTIF_X, major is X version, minor is X revision. Return value is wxOS2_PM. Return value is wxWINDOWS, major is 3, minor is 1. Return value is wxWINDOWS_NT, version is returned in major and minor Return value is wxWIN95, major is 4, minor is 1 or greater. Return value is wxWIN95, major is 4, minor is 0. Return value is wxWIN32S, major is 3, minor is 1.

1483


CHAPTER 8
Watcom C++ 386 supervisor mode (Windows 3.1) Return value is wxWIN386, major is 3, minor is 1. See also ::wxGetOsDescription (p. 1482) Include files <wx/utils.h>

::wxGetUserHome
const wxChar * wxGetUserHome(const wxString& user = "") Returns the home directory for the given user. If the username is empty (default value), this function behaves likewxGetHomeDir (p. 1481). Include files <wx/utils.h>

::wxGetUserName
wxString wxGetUserName() bool wxGetUserName(char * buf, int sz) This function returns the full user name (something like "Mr. John Smith"). Under Windows or NT, this function looks for the entry UserName in the wxWindows section of the WIN.INI file. If PenWindows is running, the entry Current in the section User of the PENWIN.INI file is used. The first variant of this function returns the user name if successful or an empty string otherwise. The second (deprecated) function returns trueif successful, false otherwise. See also wxGetUserId (p. 1482) Include files <wx/utils.h>

String functions
::copystring 1484


CHAPTER 8
char * copystring(const char *s) Makes a copy of the string s using the C++ new operator, so it can be deleted with the delete operator. This function is deprecated, use wxString (p. 1200) class instead.

ngettext
const wxChar * ngettext(const char *str, const char *strPlural, size_t n) This macro expands into a call to plural form version ofwxGetTranslation (p. 1485) function, so it marks the message for the extraction by xgettext just aswxTRANSLATE (p. 1487) does, but also returns the translation of the string for the current locale during execution, either singular or plural form depending on the value of n. See also _ (p. 1488)

::wxGetTranslation
const char * wxGetTranslation(const char * str) const char * wxGetTranslation(const char * str, const char * strPlural, size_t n) This function returns the translation of string str in the currentlocale (p. 828). If the string is not found in any of the loaded message catalogs (see internationalization overview (p. 1589)), the original string is returned. In debug build, an error message is logged -- this should help to find the strings which were not yet translated. As this function is used very often, an alternative (and also common in Unix world) syntax is provided: the _() (p. 1488) macro is defined to do the same thing as wxGetTranslation. The second form is used when retrieving translation of string that has different singular and plural form in English or different plural forms in some other language. It takes two extra arguments: strparameter must contain the singular form of the string to be converted. It is also used as the key for the search in the catalog. The strPlural parameter is the plural form (in English). The parameter n is used to determine the plural form. If no message catalog is found str is returned if 'n == 1', otherwise strPlural. The ngettext (p. 1485) macro is defined to do the same thing. See GNU gettext manual (http://www.gnu.org/manual/gettext/html_chapter/gettext_10.html#S EC150) for additional information on plural forms handling.

::wxIsEmpty
bool wxIsEmpty(const char * p) Returns true if the pointer is either NULL or points to an empty string, false otherwise.

1485


CHAPTER 8 ::wxStrcmp
int wxStrcmp(const char *p1, const char *p2) Returns a negative value, 0, or positive value if p1 is less than, equal to or greater than p2. The comparison is case-sensitive. This function complements the standard C function stricmp() which performs caseinsensitive comparison.

::wxStricmp
int wxStricmp(const char *p1, const char *p2) Returns a negative value, 0, or positive value if p1 is less than, equal to or greater than p2. The comparison is case-insensitive. This function complements the standard C function strcmp() which performs casesensitive comparison.

::wxStringMatch
bool wxStringMatch(const wxString& s1, const wxString& s2, bool subString = true, bool exact = false) NB: This function is obsolete, use wxString::Find (p. 1210) instead. Returns true if the substring s1 is found within s2, ignoring case if exact is false. If subString is false, no substring matching is done.

::wxStringEq
bool wxStringEq(const wxString& s1, const wxString& s2) NB: This function is obsolete, use wxString (p. 1200) instead. A macro defined as:
#define wxStringEq(s1, s2) (s1 && s2 && (strcmp(s1, s2) == 0))

::wxStrlen
size_t wxStrlen(const char * p) This is a safe version of standard function strlen(): it does exactly the same thing (i.e. returns the length of the string) except that it returns 0 ifp is the NULL pointer.

1486


CHAPTER 8 ::wxSnprintf
int wxSnprintf(wxChar *buf, size_t len, const wxChar *format, ...) This function replaces the dangerous standard function sprintf() and is like snprintf() available on some platforms. The only difference with sprintf() is that an additional argument - buffer size - is taken and the buffer is never overflowed. Returns the number of characters copied to the buffer or -1 if there is not enough space. See also wxVsnprintf (p. 1488), wxString::Printf (p. 1215)

wxT
wxChar wxT(char ch) const wxChar * wxT(const char *s) wxT() is a macro which can be used with character and string literals (in other words, 'x' or "foo") to automatically convert them to Unicode in Unicode build configuration. Please see the Unicode overview (p. 1583) for more information.
This macro is simply returns the value passed to it without changes in ASCII build. In fact, its definition is:#ifdef UNICODE #define wxT(x) L ## x #else // !Unicode #define wxT(x) x #endif

wxTRANSLATE
const wxChar * wxTRANSLATE(const char *s) This macro doesn't do anything in the program code -- it simply expands to the value of its argument (expand in Unicode build where it is equivalent to wxT (p. 1487) which makes it unnecessary to use both wxTRANSLATE and wxT with the same string which would be really unreadable). However it does have a purpose and it is to mark the literal strings for the extraction into the message catalog created by xgettext program. Usually this is achieved using _() (p. 1488) but that macro not only marks the string for extraction but also expands into wxGetTranslation (p. 1485) function call which means that it cannot be used in some situations, notably for the static arrays initialization. Here is an example which should make it more clear: suppose that you have a static array of strings containing the weekday names and which have to be translated (note that it is a bad example, really, aswxDateTime (p. 236) already can be used to get the localized week day names already). If you write
static const wxChar * const weekdays[] = { _("Mon"), ..., _("Sun") }; ...

1487


CHAPTER 8
// use weekdays[n] as usual

the code wouldn't compile because the function calls are forbidden in the array initializer. So instead you should do
static const wxChar * const weekdays[] = { wxTRANSLATE("Mon"), ..., wxTRANSLATE("Sun") }; ... // use wxGetTranslation(weekdays[n])

here. Note that although the code would compile if you simply omit wxTRANSLATE() in the above, it wouldn't work as expected because there would be no translations for the weekday names in the program message catalog and wxGetTranslation wouldn't find them.

::wxVsnprintf
int wxVsnprintf(wxChar *buf, size_t len, const wxChar *format, va_list argPtr) The same as wxSnprintf (p. 1487) but takes a va_list argument instead of arbitrary number of parameters. See also wxSnprintf (p. 1487), wxString::PrintfV (p. 1215)

_
const wxChar * _(const char *s) This macro expands into a call to wxGetTranslation (p. 1485) function, so it marks the message for the extraction by xgettext just aswxTRANSLATE (p. 1487) does, but also returns the translation of the string for the current locale during execution. Don't confuse this macro with _T() (p. 1488)! See also ngettext (p. 1485)

_T
wxChar _T(char ch) const wxChar * _T(const wxChar ch) This macro is exactly the same as wxT (p. 1487) and is defined in wxWindows simply because it may be more intuitive for Windows programmers as the standard Win32 headers also define it (as well as yet another name for the same macro which is

1488


CHAPTER 8
_TEXT()). Don't confuse this macro with _() (p. 1488)!

Dialog functions
Below are a number of convenience functions for getting input from the user or displaying messages. Note that in these functions the last three parameters are optional. However, it is recommended to pass a parent frame parameter, or (in MS Windows or Motif) the wrong window frame may be brought to the front when the dialog box is popped up.

::wxBeginBusyCursor
void wxBeginBusyCursor(wxCursor *cursor = wxHOURGLASS_CURSOR) Changes the cursor to the given cursor for all windows in the application. Use wxEndBusyCursor (p. 1491) to revert the cursor back to its previous state. These two calls can be nested, and a counter ensures that only the outer calls take effect. See also wxIsBusy (p. 1496), wxBusyCursor (p. 101). Include files <wx/utils.h>

::wxBell
void wxBell() Ring the system bell. Include files <wx/utils.h>

::wxCreateFileTipProvider
wxTipProvider * wxCreateFileTipProvider(const wxString& filename, size_t currentTip) This function creates a wxTipProvider (p. 1304) which may be used with wxShowTip (p. 1497). filename The name of the file containing the tips, one per line currentTip

1489


CHAPTER 8
The index of the first tip to show - normally this index is remembered between the 2 program runs. See also Tips overview (p. 1663) Include files <wx/tipdlg.h>

::wxDirSelector
wxString wxDirSelector(const wxString& message = wxDirSelectorPromptStr, const wxString& default_path = "", long style = 0, const wxPoint& pos = wxDefaultPosition, wxWindow *parent = NULL) Pops up a directory selector dialog. The arguments have the same meaning as those of wxDirDialog::wxDirDialog(). The message is displayed at the top, and the default_path, if specified, is set as the initial selection. The application must check for an empty return value (if the user pressed Cancel). For example:
const wxString& dir = wxDirSelector("Choose a folder"); if ( !dir.empty() ) { ... }

Include files <wx/dirdlg.h>

::wxFileSelector
wxString wxFileSelector(const wxString& message, const wxString& default_path = "", const wxString& default_filename = "", const wxString& default_extension = "", const wxString& wildcard = "*.*'', int flags = 0, wxWindow *parent = "", int x = -1, int y = -1) Pops up a file selector box. In Windows, this is the common file selector dialog. In X, this is a file selector box with the same functionality. The path and filename are distinct elements of a full file pathname. If path is empty, the current directory will be used. If filename is empty, no default filename will be supplied. The wildcard determines what files are displayed in the file selector, and file extension supplies a type extension for the required filename. Flags may be a combination of wxOPEN, wxSAVE, wxOVERWRITE_PROMPT, wxHIDE_READONLY, wxFILE_MUST_EXIST, wxMULTIPLE or 0.

1490


CHAPTER 8
Both the Unix and Windows versions implement a wildcard filter. Typing a filename containing wildcards (*, ?) in the filename text item, and clicking on Ok, will result in only those files matching the pattern being displayed. The wildcard may be a specification for multiple types of file with a description for each, such as:
"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"

The application must check for an empty return value (the user pressed Cancel). For example:
wxString filename = wxFileSelector("Choose a file to open"); if ( !filename.empty() ) { // work with the file ... } //else: cancelled by user

Include files <wx/filedlg.h>

::wxEndBusyCursor
void wxEndBusyCursor() Changes the cursor back to the original cursor, for all windows in the application. Use with wxBeginBusyCursor (p. 1489). See also wxIsBusy (p. 1496), wxBusyCursor (p. 101). Include files <wx/utils.h>

::wxGetColourFromUser
wxColour wxGetColourFromUser(wxWindow *parent, const wxColour& colInit) Shows the colour selection dialog and returns the colour selected by user or invalid colour (use wxColour::Ok (p. 152) to test whether a colour is valid) if the dialog was cancelled. Parameters parent The parent window for the colour selection dialog colInit If given, this will be the colour initially selected in the dialog.

1491


CHAPTER 8
Include files <wx/colordlg.h>

::wxGetFontFromUser
wxFont wxGetFontFromUser(wxWindow *parent, const wxFont& fontInit) Shows the font selection dialog and returns the font selected by user or invalid font (use wxFont::Ok (p. 515) to test whether a font is valid) if the dialog was cancelled. Parameters parent The parent window for the font selection dialog fontInit If given, this will be the font initially selected in the dialog. Include files <wx/fontdlg.h>

::wxGetMultipleChoices
size_t wxGetMultipleChoices( wxArrayInt& selections, const wxString& message, const wxString& caption, const wxArrayString& aChoices, wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) size_t wxGetMultipleChoices( wxArrayInt& selections, const wxString& message, const wxString& caption, int n, const wxString& choices[], wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) Pops up a dialog box containing a message, OK/Cancel buttons and a multiple-selection listbox. The user may choose an arbitrary (including 0) number of items in the listbox whose indices will be returned inselection array. The initial contents of this array will be used to select the items when the dialog is shown.

1492


CHAPTER 8
You may pass the list of strings to choose from either using choiceswhich is an array of n strings for the listbox or by using a singleaChoices parameter of type wxArrayString (p. 53). If centre is true, the message text (which may include new line characters) is centred; if false, the message is left-justified. Include files <wx/choicdlg.h> wxPerl note: In wxPerl there is just an array reference in place of nand choices, and no selections parameter; the function returns an array containing the user selections.

::wxGetNumberFromUser
long wxGetNumberFromUser( const wxString& message, const wxString& prompt, const wxString& caption, long value, long min = 0, long max = 100, wxWindow *parent = NULL, const wxPoint& pos = wxDefaultPosition) Shows a dialog asking the user for numeric input. The dialogs title is set tocaption, it contains a (possibly) multiline message above the single line prompt and the zone for entering the number. The number entered must be in the range min..max (both of which should be positive) and value is the initial value of it. If the user enters an invalid value or cancels the dialog, the function will return -1. Dialog is centered on its parent unless an explicit position is given inpos. Include files <wx/textdlg.h>

::wxGetPasswordFromUser
wxString wxGetTextFromUser(const wxString& message, const wxString& caption = "Input text", const wxString& default_value = "", wxWindow *parent = NULL) Similar to wxGetTextFromUser (p. 1493) but the text entered in the dialog is not shown on screen but replaced with stars. This is intended to be used for entering passwords as the function name implies. Include files <wx/textdlg.h>

::wxGetTextFromUser

1493


CHAPTER 8
wxString wxGetTextFromUser(const wxString& message, const wxString& caption = "Input text", const wxString& default_value = "", wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true) Pop up a dialog box with title set to caption, message, and a default_value. The user may type in text and press OK to return this text, or press Cancel to return the empty string. If centre is true, the message text (which may include new line characters) is centred; if false, the message is left-justified. Include files <wx/textdlg.h>

::wxGetMultipleChoice
int wxGetMultipleChoice(const wxString& message, const wxString& caption, int n, const wxString& choices[], int nsel, int *selection, wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) Pops up a dialog box containing a message, OK/Cancel buttons and a multiple-selection listbox. The user may choose one or more item(s) and press OK or Cancel. The number of initially selected choices, and array of the selected indices, are passed in; this array will contain the user selections on exit, with the function returning the number of selections. selection must be as big as the number of choices, in case all are selected. If Cancel is pressed, -1 is returned. choices is an array of n strings for the listbox. If centre is true, the message text (which may include new line characters) is centred; if false, the message is left-justified. Include files <wx/choicdlg.h>

::wxGetSingleChoice
wxString wxGetSingleChoice(const wxString& message, const wxString& caption, const wxArrayString& aChoices, wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200)

1494


CHAPTER 8
wxString wxGetSingleChoice(const wxString& message, const wxString& caption, int n, const wxString& choices[], wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) Pops up a dialog box containing a message, OK/Cancel buttons and a single-selection listbox. The user may choose an item and press OK to return a string or Cancel to return the empty string. UsewxGetSingleChoiceIndex (p. 1495) if empty string is a valid choice and if you want to be able to detect pressing Cancel reliably. You may pass the list of strings to choose from either using choiceswhich is an array of n strings for the listbox or by using a singleaChoices parameter of type wxArrayString (p. 53). If centre is true, the message text (which may include new line characters) is centred; if false, the message is left-justified. Include files <wx/choicdlg.h> wxPerl note: In wxPerl there is just an array reference in place of nand choices.

::wxGetSingleChoiceIndex
int wxGetSingleChoiceIndex(const wxString& message, const wxString& caption, const wxArrayString& aChoices, wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) int wxGetSingleChoiceIndex(const wxString& message, const wxString& caption, int n, const wxString& choices[], wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) As wxGetSingleChoice but returns the index representing the selected string. If the user pressed cancel, -1 is returned. Include files <wx/choicdlg.h> wxPerl note: In wxPerl there is just an array reference in place of nand choices.

::wxGetSingleChoiceData

1495


CHAPTER 8
wxString wxGetSingleChoiceData(const wxString& message, const wxString& caption, const wxArrayString& aChoices, const wxString& client_data[], wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) wxString wxGetSingleChoiceData(const wxString& message, const wxString& caption, int n, const wxString& choices[], const wxString& client_data[], wxWindow *parent = NULL, int x = -1, int y = -1, bool centre = true, int width=150, int height=200) As wxGetSingleChoice but takes an array of client data pointers corresponding to the strings, and returns one of these pointers or NULL if Cancel was pressed. The client_data array must have the same number of elements as choices or aChoices! Include files <wx/choicdlg.h> wxPerl note: In wxPerl there is just an array reference in place of nand choices, and the client data array must have the same length as the choices array.

::wxIsBusy
bool wxIsBusy() Returns true if between two wxBeginBusyCursor (p. 1489) and wxEndBusyCursor (p. 1491) calls. See also wxBusyCursor (p. 101). Include files <wx/utils.h>

::wxMessageBox
int wxMessageBox(const wxString& message, const wxString& caption = "Message", int style = wxOK, wxWindow *parent = NULL, int x = -1, int y = -1) General purpose message dialog. style may be a bit list of the following identifiers: wxYES_NO Puts Yes and No buttons on the message box. May be combined with wxCANCEL.

1496


CHAPTER 8
wxCANCEL wxOK wxICON_EXCLAMATION wxICON_HAND wxICON_ERROR wxICON_QUESTION wxICON_INFORMATION Puts a Cancel button on the message box. May be combined with wxYES_NO or wxOK. Puts an Ok button on the message box. May be combined with wxCANCEL. Displays an exclamation mark symbol. Displays an error symbol. Displays an error symbol - the same as wxICON_HAND. Displays a question mark symbol. Displays an information symbol.

The return value is one of: wxYES, wxNO, wxCANCEL, wxOK. For example:
... int answer = wxMessageBox("Quit program?", "Confirm", wxYES_NO | wxCANCEL, main_frame); if (answer == wxYES) main_frame->Close(); ...

message may contain newline characters, in which case the message will be split into separate lines, to cater for large messages. Include files <wx/msgdlg.h>

::wxShowTip
bool wxShowTip(wxWindow *parent, wxTipProvider *tipProvider, bool showAtStartup = tr u e ) This function shows a "startup tip" to the user. The return value is the state of the "Show tips at startup'' checkbox. parent The parent window for the modal dialog tipProvider An object which is used to get the text of the tips. It may be created with the wxCreateFileTipProvider (p. 1489) function. showAtStartup Should be true if startup tips are shown, false otherwise. This is used as the initial

1497


CHAPTER 8
value for "Show tips at startup" checkbox which is shown in the tips dialog. See also Tips overview (p. 1663) Include files <wx/tipdlg.h>

Math functions
Include files <wx/math.h>

wxFinite
int wxFinite(double x) Returns a non-zero value if x is neither infinite or NaN (not a number), returns 0 otherwise.

wxIsNaN
bool wxIsNaN(double x) Returns a non-zero value if x is NaN (not a number), returns 0 otherwise.

GDI functions
The following are relevant to the GDI (Graphics Device Interface). Include files <wx/gdicmn.h>

wxBITMAP
wxBITMAP(bitmapName) This macro loads a bitmap from either application resources (on the platforms for which they exist, i.e. Windows and OS2) or from an XPM file. It allows to avoid using #ifdefs when creating bitmaps. See also

1498


CHAPTER 8
Bitmaps and icons overview (p. 1638),wxICON (p. 1500) Include files <wx/gdicmn.h>

::wxClientDisplayRect
void wxClientDisplayRect(int *x, int *y,int *width, int *height) wxRect wxGetClientDisplayRect() Returns the dimensions of the work area on the display. On Windows this means the area not covered by the taskbar, etc. Other platforms are currently defaulting to the whole display until a way is found to provide this info for all window managers, etc.

::wxColourDisplay
bool wxColourDisplay() Returns true if the display is colour, false otherwise.

::wxDisplayDepth
int wxDisplayDepth() Returns the depth of the display (a value of 1 denotes a monochrome display).

::wxDisplaySize
void wxDisplaySize(int *width, int *height) wxSize wxGetDisplaySize() Returns the display size in pixels.

::wxDisplaySizeMM
void wxDisplaySizeMM(int *width, int *height) wxSize wxGetDisplaySizeMM() Returns the display size in millimeters.

::wxDROP_ICON

1499


CHAPTER 8
wxIconOrCursor wxDROP_ICON(const char *name) This macro creates either a cursor (MSW) or an icon (elsewhere) with the given name. Under MSW, the cursor is loaded from the resource file and the icon is loaded from XPM file under other platforms. This macro should be used withwxDropSource constructor (p. 428). Include files <wx/dnd.h>

wxICON
wxICON(iconName) This macro loads an icon from either application resources (on the platforms for which they exist, i.e. Windows and OS2) or from an XPM file. It allows to avoid using #ifdefs when creating icons. See also Bitmaps and icons overview (p. 1638),wxBITMAP (p. 1498) Include files <wx/gdicmn.h>

::wxMakeMetafilePlaceable
bool wxMakeMetafilePlaceable(const wxString& filename, int minX, int minY, int maxX, int maxY, float scale=1.0) Given a filename for an existing, valid metafile (as constructed using wxMetafileDC (p. 917)) makes it into a placeable metafile by prepending a header containing the given bounding box. The bounding box may be obtained from a device context after drawing into it, using the functions wxDC::MinX, wxDC::MinY, wxDC::MaxX and wxDC::MaxY. In addition to adding the placeable metafile header, this function adds the equivalent of the following code to the start of the metafile data:
SetMapMode(dc, MM_ANISOTROPIC); SetWindowOrg(dc, minX, minY); SetWindowExt(dc, maxX - minX, maxY - minY);

This simulates the wxMM_TEXT mapping mode, which wxWindows assumes. Placeable metafiles may be imported by many Windows applications, and can be used in RTF (Rich Text Format) files. scale allows the specification of scale for the metafile. This function is only available under Windows.

1500


CHAPTER 8 ::wxSetCursor
void wxSetCursor(wxCursor *cursor) Globally sets the cursor; only has an effect in Windows and GTK. See also wxCursor (p. 209), wxWindow::SetCursor (p. 1421).

Printer settings
NB: These routines are obsolete and should no longer be used! The following functions are used to control PostScript printing. Under Windows, PostScript output can only be sent to a file. Include files <wx/dcps.h>

::wxGetPrinterCommand
wxString wxGetPrinterCommand() Gets the printer command used to print a file. The default is lpr.

::wxGetPrinterFile
wxString wxGetPrinterFile() Gets the PostScript output filename.

::wxGetPrinterMode
int wxGetPrinterMode() Gets the printing mode controlling where output is sent (PS_PREVIEW, PS_FILE or PS_PRINTER). The default is PS_PREVIEW.

::wxGetPrinterOptions
wxString wxGetPrinterOptions() Gets the additional options for the print command (e.g. specific printer). The default is nothing.

::wxGetPrinterOrientation

1501


CHAPTER 8
int wxGetPrinterOrientation() Gets the orientation (PS_PORTRAIT or PS_LANDSCAPE). The default is PS_PORTRAIT.

::wxGetPrinterPreviewCommand
wxString wxGetPrinterPreviewCommand() Gets the command used to view a PostScript file. The default depends on the platform.

::wxGetPrinterScaling
void wxGetPrinterScaling(float *x, float *y) Gets the scaling factor for PostScript output. The default is 1.0, 1.0.

::wxGetPrinterTranslation
void wxGetPrinterTranslation(float *x, float *y) Gets the translation (from the top left corner) for PostScript output. The default is 0.0, 0.0.

::wxSetPrinterCommand
void wxSetPrinterCommand(const wxString& command) Sets the printer command used to print a file. The default is lpr.

::wxSetPrinterFile
void wxSetPrinterFile(const wxString& filename) Sets the PostScript output filename.

::wxSetPrinterMode
void wxSetPrinterMode(int mode) Sets the printing mode controlling where output is sent (PS_PREVIEW, PS_FILE or PS_PRINTER). The default is PS_PREVIEW.

::wxSetPrinterOptions

1502


CHAPTER 8
void wxSetPrinterOptions(const wxString& options) Sets the additional options for the print command (e.g. specific printer). The default is nothing.

::wxSetPrinterOrientation
void wxSetPrinterOrientation(int orientation) Sets the orientation (PS_PORTRAIT or PS_LANDSCAPE). The default is PS_PORTRAIT.

::wxSetPrinterPreviewCommand
void wxSetPrinterPreviewCommand(const wxString& command) Sets the command used to view a PostScript file. The default depends on the platform.

::wxSetPrinterScaling
void wxSetPrinterScaling(float x, float y) Sets the scaling factor for PostScript output. The default is 1.0, 1.0.

::wxSetPrinterTranslation
void wxSetPrinterTranslation(float x, float y) Sets the translation (from the top left corner) for PostScript output. The default is 0.0, 0.0.

Clipboard functions
These clipboard functions are implemented for Windows only. The use of these functions is deprecated and the code is no longer maintained. Use the wxClipboard (p. 136)class instead. Include files <wx/clipbrd.h>

::wxClipboardOpen
bool wxClipboardOpen() Returns true if this application has already opened the clipboard.

1503


CHAPTER 8 ::wxCloseClipboard
bool wxCloseClipboard() Closes the clipboard to allow other applications to use it.

::wxEmptyClipboard
bool wxEmptyClipboard() Empties the clipboard.

::wxEnumClipboardFormats
int wxEnumClipboardFormats(intdataFormat) Enumerates the formats found in a list of available formats that belong to the clipboard. Each call to this function specifies a known available format; the function returns the format that appears next in the list. dataFormat specifies a known format. If this parameter is zero, the function returns the first format in the list. The return value specifies the next known clipboard data format if the function is successful. It is zero if the dataFormat parameter specifies the last format in the list of available formats, or if the clipboard is not open. Before it enumerates the formats function, an application must open the clipboard by using the wxOpenClipboard function.

::wxGetClipboardData
wxObject * wxGetClipboardData(intdataFormat) Gets data from the clipboard. dataFormat may be one of:   wxCF_TEXT or wxCF_OEMTEXT: returns a pointer to new memory containing a null-terminated text string. wxCF_BITMAP: returns a new wxBitmap.

The clipboard must have previously been opened for this call to succeed.

::wxGetClipboardFormatName
bool wxGetClipboardFormatName(intdataFormat, const wxString& formatName, intmaxCount)

1504


CHAPTER 8
Gets the name of a registered clipboard format, and puts it into the buffer formatName which is of maximum length maxCount. dataFormat must not specify a predefined clipboard format.

::wxIsClipboardFormatAvailable
bool wxIsClipboardFormatAvailable(intdataFormat) Returns true if the given data format is available on the clipboard.

::wxOpenClipboard
bool wxOpenClipboard() Opens the clipboard for passing data to it or getting data from it.

::wxRegisterClipboardFormat
int wxRegisterClipboardFormat(const wxString& formatName) Registers the clipboard data format name and returns an identifier.

::wxSetClipboardData
bool wxSetClipboardData(intdataFormat, wxObject *data, intwidth, intheight) Passes data to the clipboard. dataFormat may be one of:     wxCF_TEXT or wxCF_OEMTEXT: data is a null-terminated text string. wxCF_BITMAP: data is a wxBitmap. wxCF_DIB: data is a wxBitmap. The bitmap is converted to a DIB (device independent bitmap). wxCF_METAFILE: data is a wxMetafile. width and height are used to give recommended dimensions.

The clipboard must have previously been opened for this call to succeed.

Miscellaneous functions
wxCONCAT

1505


CHAPTER 8
wxCONCAT(x, y) This macro returns the concatenation of two tokens x and y.

wxDYNLIB_FUNCTION
wxDYNLIB_FUNCTION(type, name, dynlib) When loading a function from a DLL you always have to cast the returned void * pointer to the correct type and, even more annoyingly, you have to repeat this type twice if you want to declare and define a function pointer all in one line This macro makes this slightly less painful by allowing you to specify the type only once, as the first parameter, and creating a variable of this type named after the function but with pfn prefix and initialized with the function name from the wxDynamicLibrary (p. 433) dynlib. Parameters type the type of the function name the name of the function to load, not a string (without quotes, it is quoted automatically by the macro) dynlib the library to load the function from

wxEXPLICIT
wxEXPLICIT is a macro which expands to the C++ explicit keyword if the compiler supports it or nothing otherwise. Thus, it can be used even in the code which might have to be compiled with an old compiler without support for this language feature but still take advantage of it when it is available.

wxLL
wxLongLong_t wxLL(number) This macro is defined for the platforms with a native 64 bit integer type and allows to define 64 bit compile time constants:
#ifdef wxLongLong_t wxLongLong_t ll = wxLL(0x1234567890abcdef); #endif

Include files

1506


CHAPTER 8
<wx/longlong.h> See also wxULL (p. 1513), wxLongLong (p. 857)

wxLongLongFmtSpec
This macro is defined to contain the printf() format specifier using which 64 bit integer numbers (i.e. those of type wxLongLong_t) can be printed. Example of using it:
#ifdef wxLongLong_t wxLongLong_t ll = wxLL(0x1234567890abcdef); printf("Long long = %" wxLongLongFmtSpec "x\n", ll); #endif

See also wxLL (p. 1506) Include files <wx/longlong.h>

::wxNewId
long wxNewId() Generates an integer identifier unique to this run of the program. Include files <wx/utils.h>

::wxRegisterId
void wxRegisterId(long id) Ensures that ids subsequently generated by NewId do not clash with the given id. Include files <wx/utils.h>

::wxDDECleanUp
void wxDDECleanUp() Called when wxWindows exits, to clean up the DDE system. This no longer needs to be called by the application.

1507


CHAPTER 8
See also wxDDEInitialize (p. 1508). Include files <wx/dde.h>

::wxDDEInitialize
void wxDDEInitialize() Initializes the DDE system. May be called multiple times without harm. This no longer needs to be called by the application: it will be called by wxWindows if necessary. See also wxDDEServer (p. 1101), wxDDEClient (p. 131), wxDDEConnection (p. 191), wxDDECleanUp (p. 1507). Include files <wx/dde.h>

::wxEnableTopLevelWindows
void wxEnableTopLevelWindow(bool enable = true) This function enables or disables all top level windows. It is used by::wxSafeYield (p. 1467). Include files <wx/utils.h>

::wxFindMenuItemId
int wxFindMenuItemId(wxFrame *frame, const wxString& menuString, const wxString& itemString) Find a menu item identifier associated with the given frame's menu bar. Include files <wx/utils.h>

::wxFindWindowByLabel
wxWindow * wxFindWindowByLabel(const wxString& label, wxWindow *parent=NULL)

1508


CHAPTER 8
NB: This function is obsolete, please usewxWindow::FindWindowByLabel (p. 1398) instead. Find a window by its label. Depending on the type of window, the label may be a window title or panel item label. If parent is NULL, the search will start from all top-level frames and dialog boxes; if non-NULL, the search will be limited to the given window hierarchy. The search is recursive in both cases. Include files <wx/utils.h>

::wxFindWindowByName
wxWindow * wxFindWindowByName(const wxString& name, wxWindow *parent=NULL) NB: This function is obsolete, please usewxWindow::FindWindowByName (p. 1398) instead. Find a window by its name (as given in a window constructor or Create function call). If parent is NULL, the search will start from all top-level frames and dialog boxes; if nonNULL, the search will be limited to the given window hierarchy. The search is recursive in both cases. If no such named window is found, wxFindWindowByLabel is called. Include files <wx/utils.h>

::wxFindWindowAtPoint
wxWindow * wxFindWindowAtPoint(const wxPoint& pt) Find the deepest window at the given mouse position in screen coordinates, returning the window if found, or NULL if not.

::wxFindWindowAtPointer
wxWindow * wxFindWindowAtPointer(wxPoint& pt) Find the deepest window at the mouse pointer position, returning the window and current pointer position in screen coordinates.

::wxGetActiveWindow
wxWindow * wxGetActiveWindow()

1509


CHAPTER 8
Gets the currently active window (Windows only). Include files <wx/windows.h>

::wxGetDisplayName
wxString wxGetDisplayName() Under X only, returns the current display name. See also wxSetDisplayName (p. 1512). Include files <wx/utils.h>

::wxGetMousePosition
wxPoint wxGetMousePosition() Returns the mouse position in screen coordinates. Include files <wx/utils.h>

::wxGetResource
bool wxGetResource(const wxString& section, const wxString& entry, const wxString& *value, const wxString& file = NULL) bool wxGetResource(const wxString& section, const wxString& entry, float *value, const wxString& file = NULL) bool wxGetResource(const wxString& section, const wxString& entry, long *value, const wxString& file = NULL) bool wxGetResource(const wxString& section, const wxString& entry, int *value, const wxString& file = NULL) Gets a resource value from the resource database (for example, WIN.INI, or .Xdefaults). If file is NULL, WIN.INI or .Xdefaults is used, otherwise the specified file is used. Under X, if an application class (wxApp::GetClassName) has been defined, it is appended to the string /usr/lib/X11/app-defaults/ to try to find an applications default file when merging all resource databases. The reason for passing the result in an argument is that it can be convenient to define a default value, which gets overridden if the value exists in the resource file. It saves a separate test for that resource's existence, and it also allows the overloading of the

1510


CHAPTER 8
function for different types. See also wxWriteResource (p. 1513), wxConfigBase (p. 177). Include files <wx/utils.h>

::wxGetTopLevelParent
wxWindow * wxGetTopLevelParent(wxWindow *win) Returns the first top level parent of the given window, or in other words, the frame or dialog containing it, or NULL. Include files <wx/window.h>

::wxLoadUserResource
wxString wxLoadUserResource(const wxString& resourceName, const wxString& resourceType="TEXT") Loads a user-defined Windows resource as a string. If the resource is found, the function creates a new character array and copies the data into it. A pointer to this data is returned. If unsuccessful, NULL is returned. The resource must be defined in the .rc file using the following syntax:
myResource TEXT file.ext

where file.ext is a file that the resource compiler can find. This function is available under Windows only. Include files <wx/utils.h>

::wxPostDelete
void wxPostDelete(wxObject *object) Tells the system to delete the specified object when all other events have been processed. In some environments, it is necessary to use this instead of deleting a frame directly with the delete operator, because some GUIs will still send events to a deleted window. Now obsolete: use wxWindow::Close (p. 1393) instead.

1511


CHAPTER 8
Include files <wx/utils.h>

::wxPostEvent
void wxPostEvent(wxEvtHandler *dest, wxEvent& event) In a GUI application, this function posts event to the specified destobject using wxEvtHandler::AddPendingEvent (p. 444). Otherwise, it dispatches event immediately usingwxEvtHandler::ProcessEvent (p. 447). See the respective documentation for details (and caveats). Include files <wx/app.h>

::wxSetDisplayName
void wxSetDisplayName(const wxString& displayName) Under X only, sets the current display name. This is the X host and display name such as "colonsay:0.0", and the function indicates which display should be used for creating windows from this point on. Setting the display within an application allows multiple displays to be used. See also wxGetDisplayName (p. 1510). Include files <wx/utils.h>

::wxStripMenuCodes
wxString wxStripMenuCodes(const wxString& in) void wxStripMenuCodes(char *in, char *out) NB: This function is obsolete, please usewxMenuItem::GetLabelFromText (p. 911) instead. Strips any menu codes from in and places the result in out (or returns the new string, in the first form). Menu codes include & (mark the next character with an underline as a keyboard shortkey in Windows and Motif) and \t (tab in Windows). Include files <wx/utils.h>

1512


CHAPTER 8 wxULL
wxLongLong_t wxULL(number) This macro is defined for the platforms with a native 64 bit integer type and allows to define unsigned 64 bit compile time constants:
#ifdef wxLongLong_t unsigned wxLongLong_t ll = wxULL(0x1234567890abcdef); #endif

Include files <wx/longlong.h> See also wxLL (p. 1506), wxLongLong (p. 857)

::wxWriteResource
bool wxWriteResource(const wxString& section, const wxString& entry, const wxString& value, const wxString& file = NULL) bool wxWriteResource(const wxString& section, const wxString& entry, float value, const wxString& file = NULL) bool wxWriteResource(const wxString& section, const wxString& entry, long value, const wxString& file = NULL) bool wxWriteResource(const wxString& section, const wxString& entry, int value, const wxString& file = NULL) Writes a resource value into the resource database (for example, WIN.INI, or .Xdefaults). If file is NULL, WIN.INI or .Xdefaults is used, otherwise the specified file is used. Under X, the resource databases are cached until the internal function wxFlushResources is called automatically on exit, when all updated resource databases are written to their files. Note that it is considered bad manners to write to the .Xdefaults file under Unix, although the WIN.INI file is fair game under Windows. See also wxGetResource (p. 1510), wxConfigBase (p. 177). Include files <wx/utils.h>

Byte order macros

1513


CHAPTER 8
The endian-ness issues (that is the difference between big-endian and little-endian architectures) are important for the portable programs working with the external binary data (for example, data files or data coming from network) which is usually in some fixed, platform-independent format. The macros are helpful for transforming the data to the correct format.

wxINTXX_SWAP_ALWAYS
wxInt32 wxINT32_SWAP_ALWAYS(wxInt32 value) wxUint32 wxUINT32_SWAP_ALWAYS(wxUint32 value) wxInt16 wxINT16_SWAP_ALWAYS(wxInt16 value) wxUint16 wxUINT16_SWAP_ALWAYS(wxUint16 value) These macros will swap the bytes of the value variable from little endian to big endian or vice versa unconditionally, i.e. independently of the current platform.

wxINTXX_SWAP_ON_BE
wxInt32 wxINT32_SWAP_ON_BE(wxInt32 value) wxUint32 wxUINT32_SWAP_ON_BE(wxUint32 value) wxInt16 wxINT16_SWAP_ON_BE(wxInt16 value) wxUint16 wxUINT16_SWAP_ON_BE(wxUint16 value) This macro will swap the bytes of the value variable from little endian to big endian or vice versa if the program is compiled on a big-endian architecture (such as Sun work stations). If the program has been compiled on a little-endian architecture, the value will be unchanged. Use these macros to read data from and write data to a file that stores data in littleendian (for example Intel i386) format.

wxINTXX_SWAP_ON_LE
wxInt32 wxINT32_SWAP_ON_LE(wxInt32 value) wxUint32 wxUINT32_SWAP_ON_LE(wxUint32 value) wxInt16 wxINT16_SWAP_ON_LE(wxInt16 value) wxUint16 wxUINT16_SWAP_ON_LE(wxUint16 value) This macro will swap the bytes of the value variable from little endian to big endian or vice versa if the program is compiled on a little-endian architecture (such as Intel PCs). If the program has been compiled on a big-endian architecture, the value will be

1514


CHAPTER 8
unchanged. Use these macros to read data from and write data to a file that stores data in big-endian format.

RTTI functions
wxWindows uses its own RTTI ("run-time type identification") system which predates the current standard C++ RTTI and so is kept for backwards compatibility reasons but also because it allows some things which the standard RTTI doesn't directly support (such as creating a class from its name). The standard C++ RTTI can be used in the user code without any problems and in general you shouldn't need to use the functions and the macros in this section unless you are thinking of modifying or adding any wxWindows classes. See also RTTI overview (p. 1572)

CLASSINFO
wxClassInfo * CLASSINFO(className) Returns a pointer to the wxClassInfo object associated with this class. Include files <wx/object.h>

DECLARE_ABSTRACT_CLASS
DECLARE_ABSTRACT_CLASS(className) Used inside a class declaration to declare that the class should be made known to the class hierarchy, but objects of this class cannot be created dynamically. The same as DECLARE_CLASS. Example:
class wxCommand: public wxObject { DECLARE_ABSTRACT_CLASS(wxCommand) private: ... public: ... };

Include files

1515


CHAPTER 8
<wx/object.h>

DECLARE_APP
DECLARE_APP(className) This is used in headers to create a forward declaration of the wxGetApp (p. 1466) function implemented by IMPLEMENT_APP (p. 1517). It creates the declaration className& wxGetApp(void). Example:
DECLARE_APP(MyApp)

Include files <wx/app.h>

DECLARE_CLASS
DECLARE_CLASS(className) Used inside a class declaration to declare that the class should be made known to the class hierarchy, but objects of this class cannot be created dynamically. The same as DECLARE_ABSTRACT_CLASS. Include files <wx/object.h>

DECLARE_DYNAMIC_CLASS
DECLARE_DYNAMIC_CLASS(className) Used inside a class declaration to declare that the objects of this class should be dynamically creatable from run-time type information. Example:
class wxFrame: public wxWindow { DECLARE_DYNAMIC_CLASS(wxFrame) private: const wxString& frameTitle; public: ... };

Include files <wx/object.h>

1516


CHAPTER 8 IMPLEMENT_ABSTRACT_CLASS
IMPLEMENT_ABSTRACT_CLASS(className, baseClassName) Used in a C++ implementation file to complete the declaration of a class that has runtime type information. The same as IMPLEMENT_CLASS. Example:
IMPLEMENT_ABSTRACT_CLASS(wxCommand, wxObject) wxCommand::wxCommand(void) { ... }

Include files <wx/object.h>

IMPLEMENT_ABSTRACT_CLASS2
IMPLEMENT_ABSTRACT_CLASS2(className, baseClassName1, baseClassName2) Used in a C++ implementation file to complete the declaration of a class that has runtime type information and two base classes. The same as IMPLEMENT_CLASS2. Include files <wx/object.h>

IMPLEMENT_APP
IMPLEMENT_APP(className) This is used in the application class implementation file to make the application class known to wxWindows for dynamic construction. You use this instead of Old form:
MyApp myApp;

New form:
IMPLEMENT_APP(MyApp)

See also DECLARE_APP (p. 1516). Include files <wx/app.h>

1517


CHAPTER 8 IMPLEMENT_CLASS
IMPLEMENT_CLASS(className, baseClassName) Used in a C++ implementation file to complete the declaration of a class that has runtime type information. The same as IMPLEMENT_ABSTRACT_CLASS. Include files <wx/object.h>

IMPLEMENT_CLASS2
IMPLEMENT_CLASS2(className, baseClassName1, baseClassName2) Used in a C++ implementation file to complete the declaration of a class that has runtime type information and two base classes. The same as IMPLEMENT_ABSTRACT_CLASS2. Include files <wx/object.h>

IMPLEMENT_DYNAMIC_CLASS
IMPLEMENT_DYNAMIC_CLASS(className, baseClassName) Used in a C++ implementation file to complete the declaration of a class that has runtime type information, and whose instances can be created dynamically. Example:
IMPLEMENT_DYNAMIC_CLASS(wxFrame, wxWindow) wxFrame::wxFrame(void) { ... }

Include files <wx/object.h>

IMPLEMENT_DYNAMIC_CLASS2
IMPLEMENT_DYNAMIC_CLASS2(className, baseClassName1, baseClassName2) Used in a C++ implementation file to complete the declaration of a class that has runtime type information, and whose instances can be created dynamically. Use this for classes derived from two base classes. Include files

1518


CHAPTER 8
<wx/object.h>

wxConstCast
classname * wxConstCast(ptr, classname) This macro expands into const_cast<classname *>(ptr) if the compiler supports const_cast or into an old, C-style cast, otherwise. See also wxDynamicCast (p. 1519) wxStaticCast (p. 1520)

::wxCreateDynamicObject
wxObject * wxCreateDynamicObject(const wxString& className) Creates and returns an object of the given class, if the class has been registered with the dynamic class system using DECLARE... and IMPLEMENT... macros.

WXDEBUG_NEW
WXDEBUG_NEW(arg) This is defined in debug mode to be call the redefined new operator with filename and line number arguments. The definition is:
#define WXDEBUG_NEW new(__FILE__,__LINE__)

In non-debug mode, this is defined as the normal new operator. Include files <wx/object.h>

wxDynamicCast
classname * wxDynamicCast(ptr, classname) This macro returns the pointer ptr cast to the type classname * if the pointer is of this type (the check is done during the run-time) orNULL otherwise. Usage of this macro is preferred over obsoleted wxObject::IsKindOf() function. The ptr argument may be NULL, in which case NULL will be returned. Example:
wxWindow *win = wxWindow::FindFocus(); wxTextCtrl *text = wxDynamicCast(win, wxTextCtrl);

1519


CHAPTER 8
if ( text ) { // a text control has the focus... } else { // no window has the focus or it is not a text control }

See also RTTI overview (p. 1572) wxDynamicCastThis (p. 1520) wxConstCast (p. 1519) wxStatiicCast (p. 1520)

wxDynamicCastThis
classname * wxDynamicCastThis(classname) This macro is equivalent to wxDynamicCast(this, classname) but the latter provokes spurious compilation warnings from some compilers (because it tests whether this pointer is non NULL which is always true), so this macro should be used to avoid them. See also wxDynamicCast (p. 1519)

wxStaticCast
classname * wxStaticCast(ptr, classname) This macro checks that the cast is valid in debug mode (an assert failure will result if wxDynamicCast(ptr, classname) == NULL) and then returns the result of executing an equivalent of static_cast<classname *>(ptr). wxDynamicCast (p. 1519) wxConstCast (p. 1519)

Log functions
These functions provide a variety of logging functions: see Log classes overview (p. 1595) for further information. The functions use (implicitly) the currently active log target, so their descriptions here may not apply if the log target is not the standard one (installed by wxWindows in the beginning of the program). Include files <wx/log.h>

1520


CHAPTER 8 ::wxDebugMsg
void wxDebugMsg(const wxString& fmt, ...) NB: This function is now obsolete, replaced by Log functions (p. 1520) and wxLogDebug (p. 1523) in particular. Display a debugging message; under Windows, this will appear on the debugger command window, and under Unix, it will be written to standard error. The syntax is identical to printf: pass a format string and a variable list of arguments. Tip: under Windows, if your application crashes before the message appears in the debugging window, put a wxYield call after each wxDebugMsg call. wxDebugMsg seems to be broken under WIN32s (at least for Watcom C++): preformat your messages and use OutputDebugString instead. Include files <wx/utils.h>

::wxError
void wxError(const wxString& msg, const wxString& title = "wxWindows Internal Error") NB: This function is now obsolete, please use wxLogError (p. 1522)instead. Displays msg and continues. This writes to standard error under Unix, and pops up a message box under Windows. Used for internal wxWindows errors. See also wxFatalError (p. 1521). Include files <wx/utils.h>

::wxFatalError
void wxFatalError(const wxString& msg, const wxString& title = "wxWindows Fatal Error") NB: This function is now obsolete, please usewxLogFatalError (p. 1522) instead. Displays msg and exits. This writes to standard error under Unix, and pops up a message box under Windows. Used for fatal internal wxWindows errors. See also wxError (p. 1521). Include files <wx/utils.h>

1521


CHAPTER 8 ::wxLogError
void wxLogError(const char *formatString, ...) void wxVLogError(const char *formatString, va_list argPtr) The functions to use for error messages, i.e. the messages that must be shown to the user. The default processing is to pop up a message box to inform the user about it.

::wxLogFatalError
void wxLogFatalError(const char *formatString, ...) void wxVLogFatalError(const char *formatString, va_list argPtr) Like wxLogError (p. 1522), but also terminates the program with the exit code 3. Using abort() standard function also terminates the program with this exit code.

::wxLogWarning
void wxLogWarning(const char *formatString, ...) void wxVLogWarning(const char *formatString, va_list argPtr) For warnings - they are also normally shown to the user, but don't interrupt the program work.

::wxLogMessage
void wxLogMessage(const char *formatString, ...) void wxVLogMessage(const char *formatString, va_list argPtr) For all normal, informational messages. They also appear in a message box by default (but it can be changed). Notice that the standard behaviour is to not show informational messages if there are any errors later - the logic being that the later error messages make the informational messages preceding them meaningless.

::wxLogVerbose
void wxLogVerbose(const char *formatString, ...) void wxVLogVerbose(const char *formatString, va_list argPtr) For verbose output. Normally, it is suppressed, but might be activated if the user wishes to know more details about the program progress (another, but possibly confusing name for the same function is wxLogInfo).

1522


CHAPTER 8 ::wxLogStatus
void wxLogStatus(wxFrame *frame, const char *formatString, ...) void wxVLogStatus(wxFrame *frame, const char *formatString, va_list argPtr) void wxLogStatus(const char *formatString, ...) void wxVLogStatus(const char *formatString, va_list argPtr) Messages logged by these functions will appear in the statusbar of the frame or of the top level application window by default (i.e. when using the second version of the functions). If the target frame doesn't have a statusbar, the message will be lost.

::wxLogSysError
void wxLogSysError(const char *formatString, ...) void wxVLogSysError(const char *formatString, va_list argPtr) Mostly used by wxWindows itself, but might be handy for logging errors after system call (API function) failure. It logs the specified message text as well as the last system error code (errno or ::GetLastError() depending on the platform) and the corresponding error message. The second form of this function takes the error code explicitly as the first argument. See also wxSysErrorCode (p. 1525),wxSysErrorMsg (p. 1525)

::wxLogDebug
void wxLogDebug(const char *formatString, ...) void wxVLogDebug(const char *formatString, va_list argPtr) The right functions for debug output. They only do something in debug mode (when the preprocessor symbol __WXDEBUG__ is defined) and expand to nothing in release mode (otherwise).

::wxLogTrace
void wxLogTrace(const char *formatString, ...) void wxVLogTrace(const char *formatString, va_list argPtr) void wxLogTrace(const char *mask, const char *formatString, ...)

1523


CHAPTER 8
void wxVLogTrace(const char *mask, const char *formatString, va_list argPtr) void wxLogTrace(wxTraceMask mask, const char *formatString, ...) void wxVLogTrace(wxTraceMask mask, const char *formatString, va_list argPtr) As wxLogDebug, trace functions only do something in debug build and expand to nothing in the release one. The reason for making it a separate function from it is that usually there are a lot of trace messages, so it might make sense to separate them from other debug messages. The trace messages also usually can be separated into different categories and the second and third versions of this function only log the message if themask which it has is currently enabled in wxLog (p. 843). This allows to selectively trace only some operations and not others by changing the value of the trace mask (possible during the run-time). For the second function (taking a string mask), the message is logged only if the mask has been previously enabled by the call toAddTraceMask (p. 846) or by settingWXTRACE environment variable (p. 1700). The predefined string trace masks used by wxWindows are:      wxTRACE_MemAlloc: trace memory allocation (new/delete) wxTRACE_Messages: trace window messages/X callbacks wxTRACE_ResAlloc: trace GDI resource allocation wxTRACE_RefCount: trace various ref counting operations wxTRACE_OleCalls: trace OLE method calls (Win32 only)

The third version of the function only logs the message if all the bit corresponding to the mask are set in the wxLog trace mask which can be set by SetTraceMask (p. 849). This version is less flexible than the previous one because it doesn't allow defining the user trace masks easily - this is why it is deprecated in favour of using string trace masks.      wxTraceMemAlloc: trace memory allocation (new/delete) wxTraceMessages: trace window messages/X callbacks wxTraceResAlloc: trace GDI resource allocation wxTraceRefCount: trace various ref counting operations wxTraceOleCalls: trace OLE method calls (Win32 only)

::wxSafeShowMessage
void wxSafeShowMessage(const wxString& title, const wxString& text) This function shows a message to the user in a safe way and should be safe to call even before the application has been initialized or if it is currently in some other strange state

1524


CHAPTER 8
(for example, about to crash). Under Windows this function shows a message box using a native dialog instead ofwxMessageBox (p. 1496) (which might be unsafe to call), elsewhere it simply prints the message to the standard output using the title as prefix. Parameters title The title of the message box shown to the user or the prefix of the message string text The text to show to the user See also wxLogFatalError (p. 1522) Include files <wx/log.h>

::wxSysErrorCode
unsigned long wxSysErrorCode() Returns the error code from the last system call. This function useserrno on Unix platforms and GetLastError under Win32. See also wxSysErrorMsg (p. 1525),wxLogSysError (p. 1523)

::wxSysErrorMsg
const wxChar * wxSysErrorMsg(unsigned long errCode = 0) Returns the error message corresponding to the given system error code. IferrCode is 0 (default), the last error code (as returned bywxSysErrorCode (p. 1525)) is used. See also wxSysErrorCode (p. 1525),wxLogSysError (p. 1523)

WXTRACE
Include files <wx/object.h> WXTRACE(formatString, ...)

1525


CHAPTER 8
NB: This macro is now obsolete, replaced by Log functions (p. 1520). Calls wxTrace with printf-style variable argument syntax. Output is directed to the current output stream (see wxDebugContext (p. 1599)). Include files <wx/memory.h>

WXTRACELEVEL
WXTRACELEVEL(level, formatString, ...) NB: This function is now obsolete, replaced by Log functions (p. 1520). Calls wxTraceLevel with printf-style variable argument syntax. Output is directed to the current output stream (see wxDebugContext (p. 1599)). The first argument should be the level at which this information is appropriate. It will only be output if the level returned by wxDebugContext::GetLevel is equal to or greater than this value. Include files <wx/memory.h>

::wxTrace
void wxTrace(const wxString& fmt, ...) NB: This function is now obsolete, replaced by Log functions (p. 1520). Takes printf-style variable argument syntax. Output is directed to the current output stream (see wxDebugContext (p. 1599)). Include files <wx/memory.h>

::wxTraceLevel
void wxTraceLevel(int level, const wxString& fmt, ...) NB: This function is now obsolete, replaced by Log functions (p. 1520). Takes printf-style variable argument syntax. Output is directed to the current output stream (see wxDebugContext (p. 1599)). The first argument should be the level at which this information is appropriate. It will only be output if the level returned by wxDebugContext::GetLevel is equal to or greater than this value. Include files <wx/memory.h>

1526


CHAPTER 8

Time functions
The functions in this section deal with getting the current time and starting/stopping the global timers. Please note that the timer functions are deprecated because they work with one global timer only andwxTimer (p. 1294) and/or wxStopWatch (p. 1190) classes should be used instead. For retrieving the current time, you may also usewxDateTime::Now (p. 246) orwxDateTime::UNow (p. 247) methods.

::wxGetElapsedTime
long wxGetElapsedTime(bool resetTimer = true) Gets the time in milliseconds since the last ::wxStartTimer (p. 1528). If resetTimer is true (the default), the timer is reset to zero by this call. See also wxTimer (p. 1294). Include files <wx/timer.h>

::wxGetLocalTime
long wxGetLocalTime() Returns the number of seconds since local time 00:00:00 Jan 1st 1970. See also wxDateTime::Now (p. 246) Include files <wx/timer.h>

::wxGetLocalTimeMillis
wxLongLong wxGetLocalTimeMillis() Returns the number of milliseconds since local time 00:00:00 Jan 1st 1970. See also wxDateTime::Now (p. 246), wxLongLong (p. 857) Include files <wx/timer.h>

1527


CHAPTER 8 ::wxGetUTCTime
long wxGetUTCTime() Returns the number of seconds since GMT 00:00:00 Jan 1st 1970. See also wxDateTime::Now (p. 246) Include files <wx/timer.h>

::wxNow
wxString wxNow() Returns a string representing the current date and time. Include files <wx/utils.h>

::wxSleep
void wxSleep(int secs) Sleeps for the specified number of seconds. Include files <wx/utils.h>

::wxStartTimer
void wxStartTimer() Starts a stopwatch; use ::wxGetElapsedTime (p. 1527) to get the elapsed time. See also wxTimer (p. 1294). Include files <wx/timer.h>

::wxUsleep
void wxUsleep(unsigned long milliseconds)

1528


CHAPTER 8
Sleeps for the specified number of milliseconds. Notice that usage of this function is encouraged instead of calling usleep(3) directly because the standard usleep() function is not MT safe. Include files <wx/utils.h>

Debugging macros and functions
Useful macros and functions for error checking and defensive programming. wxWindows defines three families of the assert-like macros: the wxASSERT and wxFAIL macros only do anything if __WXDEBUG__ is defined (in other words, in the debug build) but disappear completely in the release build. On the other hand, the wxCHECK macros stay event in release builds but a check failure doesn't generate any user-visible effects then. Finally, the compile time assertions don't happen during the run-time but result in the compilation error messages if the condition they check fail. Include files <wx/debug.h>

::wxOnAssert
void wxOnAssert(const char *fileName, int lineNumber, const char *cond, const char *msg = NULL) This function is called whenever one of debugging macros fails (i.e. condition is false in an assertion). It is only defined in the debug mode, in release builds the wxCHECK (p. 1531) failures don't result in anything. To override the default behaviour in the debug builds which is to show the user a dialog asking whether he wants to abort the program, continue or continue ignoring any subsequent assert failures, you may overridewxApp::OnAssert (p. 34) which is called by this function if the global application object exists.

wxASSERT
wxASSERT(condition) Assert macro. An error message will be generated if the condition is false in debug mode, but nothing will be done in the release build. Please note that the condition in wxASSERT() should have no side effects because it will not be executed in release mode at all. See also wxASSERT_MSG (p. 1530),

1529


CHAPTER 8
wxCOMPILE_TIME_ASSERT (p. 1530)

wxASSERT_MIN_BITSIZE
wxASSERT_MIN_BITSIZE(type, size) This macro results in acompile time assertion failure (p. 1530) if the size of the given type type is less than size bits. You may use it like this, for example:
// we rely on the int being able to hold values up to 2^32 wxASSERT_MIN_BITSIZE(int, 32); // can't work with the platforms using UTF-8 for wchar_t wxASSERT_MIN_BITSIZE(wchar_t, 16);

wxASSERT_MSG
wxASSERT_MSG(condition, msg) Assert macro with message. An error message will be generated if the condition is false. See also wxASSERT (p. 1529), wxCOMPILE_TIME_ASSERT (p. 1530)

wxCOMPILE_TIME_ASSERT
wxCOMPILE_TIME_ASSERT(condition, msg) Using wxCOMPILE_TIME_ASSERT results in a compilation error if the specified condition is false. The compiler error message should include the msg identifier - please note that it must be a valid C++ identifier and not a string unlike in the other cases. This macro is mostly useful for testing the expressions involving thesizeof operator as they can't be tested by the preprocessor but it is sometimes desirable to test them at the compile time. Note that this macro internally declares a struct whose name it tries to make unique by using the __LINE__ in it but it may still not work if you use it on the same line in two different source files. In this case you may either change the line in which either of them appears on or use thewxCOMPILE_TIME_ASSERT2 (p. 1531) macro. Also note that Microsoft Visual C++ has a bug which results in compiler errors if you use this macro with "Program Database For Edit And Continue'' (/ZI) option, so you shouldn't use it ("Program Database'' (/Zi) is ok though) for the code making use of this macro. See also

1530


CHAPTER 8
wxASSERT_MSG (p. 1530), wxASSERT_MIN_BITSIZE (p. 1530)

wxCOMPILE_TIME_ASSERT2
wxCOMPILE_TIME_ASSERT(condition, msg, name) This macro is identical to wxCOMPILE_TIME_ASSERT2 (p. 1531)except that it allows you to specify a unique name for the struct internally defined by this macro to avoid getting the compilation errors described above (p. 1530).

wxFAIL
wxFAIL() Will always generate an assert error if this code is reached (in debug mode). See also: wxFAIL_MSG (p. 1531)

wxFAIL_MSG
wxFAIL_MSG(msg) Will always generate an assert error with specified message if this code is reached (in debug mode). This macro is useful for marking unreachable" code areas, for example it may be used in the "default:" branch of a switch statement if all possible cases are processed above. See also wxFAIL (p. 1531)

wxCHECK
wxCHECK(condition, retValue) Checks that the condition is true, returns with the given return value if not (FAILs in debug mode). This check is done even in release mode.

wxCHECK_MSG
wxCHECK_MSG(condition, retValue, msg) Checks that the condition is true, returns with the given return value if not (FAILs in debug mode). This check is done even in release mode. This macro may be only used in non void functions, see alsowxCHECK_RET (p. 1532).

1531


CHAPTER 8 wxCHECK_RET
wxCHECK_RET(condition, msg) Checks that the condition is true, and returns if not (FAILs with given error message in debug mode). This check is done even in release mode. This macro should be used in void functions instead ofwxCHECK_MSG (p. 1531).

wxCHECK2
wxCHECK2(condition, operation) Checks that the condition is true and wxFAIL (p. 1531) and executeoperation if it is not. This is a generalisation ofwxCHECK (p. 1531) and may be used when something else than just returning from the function must be done when the condition is false. This check is done even in release mode.

wxCHECK2_MSG
wxCHECK2(condition, operation, msg) This is the same as wxCHECK2 (p. 1532), butwxFAIL_MSG (p. 1531) with the specified msg is called instead of wxFAIL() if the condition is false.

::wxTrap
void wxTrap() In debug mode (when __WXDEBUG__ is defined) this function generates a debugger exception meaning that the control is passed to the debugger if one is attached to the process. Otherwise the program just terminates abnormally. In release mode this function does nothing. Include files <wx/debug.h>

::wxIsDebuggerRunning
bool wxIsDebuggerRunning() Returns true if the program is running under debugger, false otherwise. Please note that this function is currently only implemented for Mac builds using CodeWarrior and always returns false elsewhere.

1532


CHAPTER 8

Environment access functions
The functions in this section allow to access (get) or change value of environment variables in a portable way. They are currently implemented under Win32 and POSIXlike systems (Unix). Include files <wx/utils.h>

wxGetenv
wxChar * wxGetEnv(const wxString& var) This is a macro defined as getenv() or its wide char version in Unicode mode. Note that under Win32 it may not return correct value for the variables set with wxSetEnv (p. 1533), use wxGetEnv (p. 1533) function instead.

wxGetEnv
bool wxGetEnv(const wxString& var, wxString *value) Returns the current value of the environment variable var in value.value may be NULL if you just want to know if the variable exists and are not interested in its value. Returns true if the variable exists, false otherwise.

wxSetEnv
bool wxSetEnv(const wxString& var, const wxChar *value) Sets the value of the environment variable var (adding it if necessary) to value. Returns true on success.

wxUnsetEnv
bool wxUnsetEnv(const wxString& var) Removes the variable var from the environment.wxGetEnv (p. 1533) will return NULL after the call to this function. Returns true on success.

1533


Chapter 9 Constants

This chapter describes the constants defined by wxWindows.

Preprocesser symbols defined by wxWindows
Here is the list of preprocessor symbols used in the wxWindows source grouped by category (and sorted by alphabetical order inside each category).

GUI system
__WINDOWS__ __WIN16__ __WIN32__ __WIN95__ __WXBASE__ __WXWINCE__ __WXGTK__ __WXGTK12__ __WXGTK20__ __WXMOTIF__ __WXMOTIF20__ __WXMAC__ any Windows, yom may also use __WXMSW__ Win16 API (not supported since wxWindows 2.6) Win32 API Windows 95 or NT 4.0 and above system (not NT 3.5x) Only wxBase, no GUI features Windows CE GTK+ GTK+ 1.2 or higher GTK+ 2.0 or higher Motif Motif 2.0 or higher Mac OS whether Classic (Mac OS 8/9 TARGET_CARBON == 0) or Carbon (including Mac OS X TARGET_CARBON == 1) SciTech Soft MGL (__WXUNIVERSAL__ will be also defined) Any Windows Identical to __WXPM__

__WXMGL__ __WXMSW__ __WXOS2__

1534


CHAPTER 9
__WXPM__ __WXSTUBS__ __WXXT__ __WXX11__ __WXWINE__ __WXUNIVERSAL__ OS/2 native Presentation Manager Stubbed version ('template' wxWin implementation) Xt; mutually exclusive with WX_MOTIF, not implemented in wxWindows 2.x wxX11 (__WXUNIVERSAL__ will be also defined) WINE (i.e. WIN32 on Unix) wxUniversal port, always defined in addition to one of the symbols above so this should be tested first. any X11-based GUI toolkit except GTK+

__X__

In fact, they should better all start with __WX instead of __ only, so please start any new defines with __WX.

Operating systems
__APPLE__ __AIX__ __BSD__ __CYGWIN__ __DARWIN__ any Mac OS version AIX Any *BSD system Cygwin: Unix on Win32 Mac OS X using the BSD Unix C library (as opposed to using the Metrowerks MSL C/C++ library) DG-UX DOS (used with wxMGL only) FreeBSD HP-UX (Unix) GNU Hurd Linux Mach-O Architecture (Mac OS X only builds) OSF/1 IRIX

__DATA_GENERAL__ __DOS_GENERAL__ __FREEBSD__ __HPUX__ __GNU__ __LINUX__ __MACH__ __OSF__ __SGI__

1535


CHAPTER 9
__SOLARIS__ __SUN__ __SUNOS__ __SVR4__ __SYSV__ __ULTRIX__ __UNIX__ __UNIX_LIKE__ __VMS__ __WINDOWS__ Solaris Any Sun Sun OS SystemV R4 SystemV generic Ultrix any Unix Unix, BeOS or VMS VMS any Windows

Hardware architectures
Note that not all of these symbols are always defined, it depends on the compiler used. __ALPHA__ __INTEL__ __POWERPC__ DEC Alpha architecture Intel i386 or compatible Motorola Power PC

Compilers
__BORLANDC__ __DJGPP__ __DIGITALMARS__ __GNUG__ __GNUWIN32__ __MINGW32__ __MWERKS__ __SUNCC__ __SYMANTECC__ Borland C++. The value of the macro corresponds to the compiler version: 500 is 5.0. DJGPP Digital Mars Gnu C++ on any platform, see also wxCHECK_GCC_VERSION (p. 1465) Gnu-Win32 compiler, see also wxCHECK_W32API_VERSION (p. 1465) MinGW CodeWarrior MetroWerks compiler Sun CC Symantec C++

1536


CHAPTER 9
__VISAGECPP__ __VISUALC__ IBM Visual Age (OS/2) Microsoft Visual C++. The value of this macro corresponds to the compiler version: 1020 for 4.2 (the first supported version), 1100 for 5.0, 1200 for 6.0 and so on AIX compiler Watcom C++. The value of this macro corresponds to the compiler version, 1100 is 11.0 and 1200 is OpenWatcom. Windows CE version

__XLC__ __WATCOMC__

_WIN32_WCE

Miscellaneous
__WXWINDOWS__ __WXDEBUG__ wxUSE_XXX always defined in wxWindows applications, see also wxCHECK_VERSION (p. 1465) defined in debug mode, undefined in release mode if defined as 1, feature XXX is active (the symbols of this form are always defined, use #if and not #ifdef to test for them) this particular feature test macro is defined to 1when compiling or using the library with the GUI features activated, if it is defined as 0, only wxBase is available. only used by wxWindows internally (defined as 1 when building wxBase code, either as a standalone library or as part of the monolithic wxWindows library, defined as 0 when building GUI library only)

wxUSE_GUI

wxUSE_BASE

Standard event identifiers
wxWindows defines a special identifier value wxID_ANY which is used in the following two situations:   when creating a new window you may specify wxID_ANY to let wxWindows assign an unused identifier to it automatically when installing an event handler using either the event table macros or wxEvtHandler::Connect (p. 444), you may use it to indicate that you want to handle the events coming from any control, regardless of its identifier

1537


CHAPTER 9
wxWindows also defines a few standard command identifiers which may be used by the user code and also are sometimes used by wxWindows itself. These reserved identifiers are all in the range between wxID_LOWEST and wxID_HIGHEST and, accordingly, the user code should avoid defining its own constants in this range.
wxID_LOWEST = 4999, wxID_OPEN, wxID_CLOSE, wxID_NEW, wxID_SAVE, wxID_SAVEAS, wxID_REVERT, wxID_EXIT, wxID_UNDO, wxID_REDO, wxID_HELP, wxID_PRINT, wxID_PRINT_SETUP, wxID_PREVIEW, wxID_ABOUT, wxID_HELP_CONTENTS, wxID_HELP_COMMANDS, wxID_HELP_PROCEDURES, wxID_HELP_CONTEXT, wxID_CLOSE_ALL, wxID_CUT = 5030, wxID_COPY, wxID_PASTE, wxID_CLEAR, wxID_FIND, wxID_DUPLICATE, wxID_SELECTALL, wxID_FILE1 = 5050, wxID_FILE2, wxID_FILE3, wxID_FILE4, wxID_FILE5, wxID_FILE6, wxID_FILE7, wxID_FILE8, wxID_FILE9, // Standard button IDs wxID_OK = 5100, wxID_CANCEL, wxID_APPLY, wxID_YES, wxID_NO, wxID_STATIC, wxID_FORWARD, wxID_BACKWARD, wxID_DEFAULT, wxID_MORE, wxID_SETUP, wxID_RESET, wxID_CONTEXT_HELP, wxID_YESTOALL, wxID_NOTOALL, wxID_ABORT, wxID_RETRY, wxID_IGNORE, // System menu IDs (used by wxUniv): wxID_SYSTEM_MENU = 5200, wxID_CLOSE_FRAME, wxID_MOVE_FRAME, wxID_RESIZE_FRAME,

1538


CHAPTER 9
wxID_MAXIMIZE_FRAME, wxID_ICONIZE_FRAME, wxID_RESTORE_FRAME, // IDs used by generic file dialog (13 consecutive starting from this value) wxID_FILEDLGG = 5900, wxID_HIGHEST = 5999

Keycodes
Keypresses are represented by an enumerated type, wxKeyCode. The possible values are the ASCII character codes, plus the following:
WXK_BACK WXK_TAB WXK_RETURN WXK_ESCAPE WXK_SPACE WXK_DELETE = = = = = = 8 9 13 27 32 127

WXK_STRT A = 300 WXK_LBUTTON WXK_RBUTTON WXK_CANCEL WXK_MBUTTON WXK_CLEAR WXK_SHIFT WXK_CONTROL WXK_MENU WXK_PAUSE WXK_CAPITAL WXK_PRIOR WXK_NEXT WXK_END WXK_HOME WXK_LEFT WXK_UP WXK_RIGHT WXK_DOWN WXK_SELECT WXK_PRINT WXK_EXECUTE WXK_SNAPSHOT WXK_INSERT WXK_HELP WXK_NUMPAD0 WXK_NUMPAD1 WXK_NUMPAD2 WXK_NUMPAD3 WXK_NUMPAD4 WXK_NUMPAD5 WXK_NUMPAD6 WXK_NUMPAD7 WXK_NUMPAD8 WXK_NUMPAD9 WXK_MULTIPLY WXK_ADD WXK_SEPARATOR WXK_SUBTRACT WXK_DECIMAL WXK_DIVIDE WXK_F1 WXK_F2 WXK_F3 WXK_F4

1539


CHAPTER 9
WXK_F5 WXK_F6 WXK_F7 WXK_F8 WXK_F9 WXK_F10 WXK_F11 WXK_F12 WXK_F13 WXK_F14 WXK_F15 WXK_F16 WXK_F17 WXK_F18 WXK_F19 WXK_F20 WXK_F21 WXK_F22 WXK_F23 WXK_F24 WXK_NUMLOCK WXK_SCROLL WXK_PAGEUP, WXK_PAGEDOWN, WXK_NUMPAD_SPACE, WXK_NUMPAD_TAB, WXK_NUMPAD_ENTER, WXK_NUMPAD_F1, WXK_NUMPAD_F2, WXK_NUMPAD_F3, WXK_NUMPAD_F4, WXK_NUMPAD_HOME, WXK_NUMPAD_LEFT, WXK_NUMPAD_UP, WXK_NUMPAD_RIGHT, WXK_NUMPAD_DOWN, WXK_NUMPAD_PRIOR, WXK_NUMPAD_PAGEUP, WXK_NUMPAD_NEXT, WXK_NUMPAD_PAGEDOWN, WXK_NUMPAD_END, WXK_NUMPAD_BEGIN, WXK_NUMPAD_INSERT, WXK_NUMPAD_DELETE, WXK_NUMPAD_EQUAL, WXK_NUMPAD_MULTIPLY, WXK_NUMPAD_ADD, WXK_NUMPAD_SEPARATOR, WXK_NUMPAD_SUBTRACT, WXK_NUMPAD_DECIMAL, WXK_NUMPAD_IVIDE, D // the following key codes are only generated under Windows currently WXK_WINDOWS_LEFT, WXK_WINDOWS_RIGHT, WXK_WINDOWS_MENU

1540


Chapter 10 Classes by category
A classification of wxWindows classes by category.

Managed windows
There are several types of window that are directly controlled by the window manager (such as MS Windows, or the Motif Window Manager). Frames may contain windows, and dialog boxes may directly contain controls. wxDialog (p. 367) wxFrame (p. 530) wxMDIChildFrame (p. 869) wxMDIParentFrame (p. 874) wxMiniFrame (p. 922) wxSplashScreen (p. 1162) wxTipWindow (p. 1305) wxWizard (p. 1437) See also Common dialogs. Dialog box Normal frame MDI child frame MDI parent frame A frame with a small title bar Splash screen class Shows text in a small window A wizard dialog

Miscellaneous windows
The following are a variety of classes that are derived from wxWindow. wxPanel (p. 972) wxScrolledWindow (p. 1085) wxGrid (p. 569) wxSplitterWindow (p. 1166) wxStatusBar (p. 1185) wxToolBar (p. 1309) wxNotebook (p. 943) wxListbook (p. 792) wxPlotWindow (p. 987) A window whose colour changes according to current user settings Window with automatically managed scrollbars A grid (table) window Window which can be split vertically or horizontally Implements the status bar on a frame Toolbar class Notebook class Similar to notebook but using list control A class to display data.

1541


CHAPTER 10
wxSashWindow (p. 1068) wxSashLayoutWindow (p. 1065) wxVScrolledWindow (p. 1379) wxWizardPage (p. 1444) wxWizardPageSimple (p. 1445) Window with four optional sashes that can be dragged Window that can be involved in an IDE-like layout arrangement As wxScrolledWindow but supports lines of variable height A base class for the page in wizard dialog. A page in wizard dialog.

Common dialogs
Overview (p. 1647) Common dialogs are ready-made dialog classes which are frequently used in an application. wxDialog (p. 367) wxColourDialog (p. 156) wxDirDialog (p. 384) wxFileDialog (p. 466) wxFindReplaceDialog (p. 505) wxMultipleChoiceDialog (p. 938) wxSingleChoiceDialog (p. 1102) wxTextEntryDialog (p. 1269) wxFontDialog (p. 522) wxPageSetupDialog (p. 960) wxPrintDialog (p. 1002) wxPageSetupDialog (p. 960) wxMessageDialog (p. 914) wxWizard (p. 1437) Base class for common dialogs Colour chooser dialog Directory selector dialog File selector dialog Text search/replace dialog Dialog to get one or more selections from a list Dialog to get a single selection from a list and return the string Dialog to get a single line of text from the user Font chooser dialog Standard page setup dialog Standard print dialog Standard page setup dialog Simple message box dialog A wizard dialog.

Controls
Typically, these are small windows which provide interaction with the user. Controls that are not static can have validators (p. 1358) associated with them. wxControl (p. 198) The base class for controls

1542


CHAPTER 10
wxButton (p. 103) wxBitmapButton (p. 80) wxToggleButton (p. 1307) wxCalendarCtrl (p. 108) wxCheckBox (p. 120) wxCheckListBox (p. 124) wxChoice (p. 127) wxComboBox (p. 158) wxGauge (p. 551) wxGenericDirCtrl (p. 560) wxHtmlListBox (p. 683) wxStaticBox (p. 1178) wxListBox (p. 793) wxListCtrl (p. 799) wxListView (p. 825) wxTabCtrl (p. 1234) wxTextCtrl (p. 1248) wxTreeCtrl (p. 1327) wxScrollBar (p. 1079) wxSpinButton (p. 1154) wxSpinCtrl (p. 1158) wxStaticText (p. 1183) wxStaticBitmap (p. 1176) wxRadioBox (p. 1033) wxRadioButton (p. 1039) Push button control, displaying text Push button control, displaying a bitmap A button which stays pressed when clicked by user. Date picker control Checkbox control A listbox with a checkbox to the left of each item Choice control (a combobox without the editable area) A choice with an editable area A control to represent a varying quantity, such as time remaining A control for displaying a directory tree A listbox showing HTML content A static, or group box for visually grouping related controls A list of strings for single or multiple selection A control for displaying lists of strings and/or icons, plus a multicolumn report view A simpler interface (faade for wxListCtrl in report mode Manages several tabs Single or multiline text editing control Tree (hierarchy) control Scrollbar control A spin or 'up-down' control A spin control - i.e. spin button and text control One or more lines of non-editable text A control to display a bitmap A group of radio buttons A round button to be used with others in a mutually exclusive way

1543


CHAPTER 10
wxSlider (p. 1121) wxVListBox (p. 1373) A slider that can be dragged by the user A listbox supporting variable height rows

Menus
wxMenu (p. 885) wxMenuBar (p. 898) wxMenuItem (p. 909) Displays a series of menu items for selection Contains a series of menus for use with a frame Represents a single menu item

Window layout
There are two different systems for laying out windows (and dialogs in particular). One is based upon so-called sizers and it requires less typing, thinking and calculating and will in almost all cases produce dialogs looking equally well on all platforms, the other is based on so-called constraints and is deprecated, though still available. Sizer overview (p. 1620) describes sizer-based layout. These are the classes relevant to sizer-based layout. wxSizer (p. 1109) wxGridSizer (p. 633) wxFlexGridSizer (p. 506) wxGridBagSizer (p. 609) wxBoxSizer (p. 89) wxStaticBoxSizer (p. 1180) wxNotebookSizer (p. 952) Abstract base class A sizer for laying out windows in a grid with all fields having the same size A sizer for laying out windows in a flexible grid Another grid sizer that lets you specify the cell an item is in, and items can span rows and/or columns. A sizer for laying out windows in a row or column Same as wxBoxSizer, but with a surrounding static box Sizer to use with the wxNotebook control

Constraints overview (p. 1616) describes constraints-based layout. These are the classes relevant to constraints-based window layout. wxIndividualLayoutConstraint (p. 758) wxLayoutConstraints (p. 784) Represents a single constraint dimension

Represents the constraints for a window class

Device contexts
Overview (p. 1641) Device contexts are surfaces that may be drawn on, and provide an abstraction that allows parameterisation of your drawing code by passing different device contexts.

1544


CHAPTER 10
wxBufferedDC (p. 98) wxBufferedPaintDC (p. 99) wxClientDC (p. 133) wxPaintDC (p. 966) wxWindowDC (p. 1436) wxScreenDC (p. 1072) wxDC (p. 347) wxMemoryDC (p. 881) wxMetafileDC (p. 917) wxMirrorDC (p. 924) wxPostScriptDC (p. 991) wxPrinterDC (p. 1010) A helper device context for double buffered drawing. A helper device context for double buffered drawing inside OnPaint. A device context to access the client area outside OnPaint events A device context to access the client area inside OnPaint events A device context to access the non-client area A device context to access the entire screen The device context base class A device context for drawing into bitmaps A device context for drawing into metafiles A proxy device context allowing for simple mirroring. A device context for drawing into PostScript files A device context for drawing to printers

Graphics device interface
Bitmaps overview (p. 1638) These classes are related to drawing on device contexts and windows. wxColour (p. 150) wxDCClipper (p. 367) wxBitmap (p. 67) wxBrush (p. 90) wxBrushList (p. 96) wxCursor (p. 209) wxFont (p. 510) wxFontList (p. 525) wxIcon (p. 716) wxImage (p. 728) Represents the red, blue and green elements of a colour Wraps the operations of setting and destroying the clipping region Represents a bitmap Used for filling areas on a device context The list of previously-created brushes A small, transparent bitmap representing the cursor Represents fonts The list of previously-created fonts A small, transparent bitmap for assigning to frames and drawing on device contexts A platform-independent image class

1545


CHAPTER 10
wxImageList (p. 754) wxMask (p. 860) wxPen (p. 976) wxPenList (p. 983) wxPalette (p. 968) wxRegion (p. 1052) wxRendererNative (p. 1059) A list of images, used with some controls Represents a mask to be used with a bitmap for transparent drawing Used for drawing lines on a device context The list of previously-created pens Represents a table of indices into RGB values Represents a simple or complex region on a window or device context Abstracts high-level drawing primitives

Events
Overview (p. 1602) An event object contains information about a specific event. Event handlers (usually member functions) have a single, event argument. wxActivateEvent (p. 29) wxCalendarEvent (p. 117) A window or application activation event Used with wxCalendarCtrl (p. 108)

wxCalculateLayoutEvent (p. 107) Used to calculate window layout wxCloseEvent (p. 139) wxCommandEvent (p. 164) wxDialUpEvent (p. 376) wxDropFilesEvent (p. 425) wxEraseEvent (p. 438) wxEvent (p. 439) wxFindDialogEvent (p. 502) wxFocusEvent (p. 509) wxKeyEvent (p. 777) wxIconizeEvent (p. 725) wxIdleEvent (p. 726) wxInitDialogEvent (p. 761) wxJoystickEvent (p. 774) wxListEvent (p. 818) A close window or end session event An event from a variety of standard controls Event send by wxDialUpManager (p. 377) A drop files event An erase background event The event base class Event sent bywxFindReplaceDialog (p. 505) A window focus event A keypress event An iconize/restore event An idle event A dialog initialisation event A joystick event A list control event

1546


CHAPTER 10
wxMaximizeEvent (p. 862) wxMenuEvent (p. 907) A maximize event A menu event A mouse capture changed event

wxMouseCaptureChangedEvent (p. 927) wxMouseEvent (p. 928) wxMoveEvent (p. 937) wxNotebookEvent (p. 950) wxNotifyEvent (p. 953) wxPaintEvent (p. 967) wxProcessEvent (p. 1024)

A mouse event A move event A notebook control event A notification event, which can be vetoed A paint event A process ending event

wxQueryLayoutInfoEvent (p. 1030) Used to query layout information wxScrollEvent (p. 1094) wxScrollWinEvent (p. 1097) wxSizeEvent (p. 1108) wxSocketEvent (p. 1150) wxSpinEvent (p. 1161) A scroll event from sliders, stand-alone scrollbars and spin buttons A scroll event from scrolled windows A size event A socket event An event from wxSpinButton (p. 1154) A system colour change event

wxSysColourChangedEvent (p. 1227) wxTabEvent (p. 1239) wxTreeEvent (p. 1345) wxUpdateUIEvent (p. 1350) wxWizardEvent (p. 1442)

A tab control event A tree control event A user interface update event A wizard event

Validators
Overview (p. 1614) These are the window validators, used for filtering and validating user input. wxValidator (p. 1358) wxTextValidator (p. 1281) wxGenericValidator (p. 564) Base validator class Text control validator class Generic control validator class

Data structures
These are the data structure classes supported by wxWindows.

1547


CHAPTER 10
wxCmdLineParser (p. 141) wxDateSpan (p. 230) wxDateTime (p. 236) wxHashMap (p. 637) wxHashTable (p. 642) wxList (p. 786) wxLongLong (p. 857) wxNode (p. 942) wxObject (p. 954) wxPathList (p. 975) wxPoint (p. 991) wxRect (p. 1042) wxRegEx (p. 1049) wxRegion (p. 1052) wxString (p. 1200) wxStringList (p. 1223) wxStringTokenizer (p. 1225) wxRealPoint (p. 1041) wxSize (p. 1106) wxTimeSpan (p. 1298) wxVariant (p. 1360) Command line parser class A logical time interval. A class for date/time manipulations A simple hash map implementation A simple hash table implementation (deprecated, use wxHashMap) A simple linked list implementation A portable 64 bit integer type Represents a node in the wxList implementation The root class for most wxWindows classes A class to help search multiple paths Representation of a point A class representing a rectangle Regular expression support A class representing a region A string class A class representing a list of strings A class for interpreting a string as a list of tokens or words Representation of a point using floating point numbers Representation of a size A time interval. A class for storing arbitrary types that may change at run-time

Run-time class information system
Overview (p. 1572) wxWindows supports run-time manipulation of class information, and dynamic creation of objects given class names. wxClassInfo (p. 130) wxObject (p. 954) Holds run-time class information Root class for classes with run-time information

1548


CHAPTER 10
RTTI macros (p. 1515) Macros for manipulating run-time information

Logging features
Overview (p. 1595) wxWindows provides several classes and functions for message logging. Please see the wxLog overview (p. 1595) for more details. wxLog (p. 843) wxLogStderr (p. 854) wxLogStream (p. 854) wxLogTextCtrl (p. 855) wxLogWindow (p. 855) wxLogGui (p. 851) wxLogNull (p. 852) wxLogChain (p. 850) wxLogPassThrough (p. 853) The base log class Log messages to a C STDIO stream Log messages to a C++ iostream Log messages to a wxTextCtrl (p. 1248) Log messages to a log frame Default log target for GUI programs Temporarily suppress message logging Allows to chain two log targets Allows to filter the log messages

wxStreamToTextRedirector (p. 1198) Allows to redirect output sent to cout to a wxTextCtrl (p. 1248) Log functions (p. 1520) Error and warning logging functions

Debugging features
Overview (p. 1598) wxWindows supports some aspects of debugging an application through classes, functions and macros. wxDebugContext (p. 341) Debugging macros (p. 1529) WXDEBUG_NEW (p. 1519) Provides memory-checking facilities Debug macros for assertion and checking Use this macro to give further debugging information

Networking classes
wxWindows provides its own classes for socket based networking. wxDialUpManager (p. 377) wxIPV4address (p. 766) wxIPaddress (p. 764) Provides functions to check the status of network connection and to establish one Represents an Internet address Represents an Internet address

1549


CHAPTER 10
wxSocketBase (p. 1131) wxSocketClient (p. 1148) wxSocketServer (p. 1152) wxSocketEvent (p. 1150) wxFTP (p. 545) wxHTTP (p. 715) wxURL (p. 1355) Represents a socket base object Represents a socket client Represents a socket server A socket event FTP protocol class HTTP protocol class Represents a Universal Resource Locator

Interprocess communication
Overview (p. 1688) wxWindows provides simple interprocess communications facilities based on Windows DDE, but available on most platforms using TCP. wxClient (p. 131) wxConnection (p. 191) wxServer (p. 1101) Represents a client Represents the connection between a client and a server Represents a server

Document/view framework
Overview (p. 1651) wxWindows supports a document/view framework which provides housekeeping for a document-centric application. wxDocument (p. 413) wxView (p. 1369) wxDocTemplate (p. 408) wxDocManager (p. 394) wxDocChildFrame (p. 392) wxDocParentFrame (p. 406) Represents a document Represents a view Manages the relationship between a document class and a view class Manages the documents and views in an application A child frame for showing a document view A parent frame to contain views

Printing framework
Overview (p. 1664) A printing and previewing framework is implemented to make it relatively straightforward to provide document printing facilities.

1550


CHAPTER 10
wxPreviewFrame (p. 995) wxPreviewCanvas (p. 992) wxPreviewControlBar (p. 993) wxPrintDialog (p. 1002) wxPageSetupDialog (p. 960) wxPrinter (p. 1007) wxPrinterDC (p. 1010) wxPrintout (p. 1010) wxPrintPreview (p. 1014) wxPrintData (p. 996) wxPrintDialogData (p. 1003) Frame for displaying a print preview Canvas for displaying a print preview Standard control bar for a print preview Standard print dialog Standard page setup dialog Class representing the printer Printer device context Class representing a particular printout Class representing a print preview Represents information about the document being printed Represents information about the print dialog

wxPageSetupDialogData (p. 961) Represents information about the page setup dialog

Drag and drop and clipboard classes
Drag and drop and clipboard overview (p. 1666) wxDataObject (p. 222) wxDataFormat (p. 217) wxTextDataObject (p. 1266) wxFileDataObject (p. 1266) wxBitmapDataObject (p. 84) wxCustomDataObject (p. 215) wxClipboard (p. 136) wxDropTarget (p. 429) wxFileDropTarget (p. 470) wxTextDropTarget (p. 1268) wxDropSource (p. 427) Data object class Represents a data format Text data object class File data object class Bitmap data object class Custom data object class Clipboard class Drop target class File drop target class Text drop target class Drop source class

File related classes
wxWindows has several small classes to work with disk files, see file classes overview (p. 1593) for more details.

1551


CHAPTER 10
wxFileName (p. 475) wxDir (p. 380) wxDirTraverser (p. 386) wxFile (p. 458) wxFFile (p. 451) wxTempFile (p. 1242) wxTextFile (p. 1271) Operations with the file name and attributes Class for enumerating files/subdirectories. Class used together with wxDir for recursively enumerating the files/subdirectories Low-level file input/output class. Another low-level file input/output class. Class to safely replace an existing file Class for working with text files as with arrays of lines

Stream classes
wxWindows has its own set of stream classes, as an alternative to often buggy standard stream libraries, and to provide enhanced functionality. wxStreamBase (p. 1191) wxStreamBuffer (p. 1193) wxInputStream (p. 762) wxOutputStream (p. 958) Stream base class Stream buffer class Input stream class Output stream class

wxCountingOutputStream (p. 205) Stream class for querying what size a stream would have. wxFilterInputStream (p. 501) wxFilterOutputStream (p. 502) wxBufferedInputStream (p. 100) Filtered input stream class Filtered output stream class Buffered input stream class

wxBufferedOutputStream (p. 100) Buffered output stream class wxMemoryInputStream (p. 884) Memory input stream class

wxMemoryOutputStream (p. 884) Memory output stream class wxDataInputStream (p. 219) wxDataOutputStream (p. 228) wxTextInputStream (p. 1276) wxTextOutputStream (p. 1280) wxFileInputStream (p. 474) wxFileOutputStream (p. 490) Platform-independent binary data input stream class Platform-independent binary data output stream class Platform-independent text data input stream class Platform-independent text data output stream class File input stream class File output stream class

1552


CHAPTER 10
wxFFileInputStream (p. 456) wxFFileOutputStream (p. 457) wxZlibInputStream (p. 1457) wxZlibOutputStream (p. 1458) wxZipInputStream (p. 1457) wxSocketInputStream (p. 1151) Another file input stream class Another file output stream class Zlib (compression) input stream class Zlib (compression) output stream class Input stream for reading from ZIP archives Socket input stream class

wxSocketOutputStream (p. 1152) Socket output stream class

Threading classes
Multithreading overview (p. 1665) wxWindows provides a set of classes to make use of the native thread capabilities of the various platforms. wxThread (p. 1284) wxThreadHelper (p. 1291) wxMutex (p. 938) wxMutexLocker (p. 941) wxCriticalSection (p. 206) wxCriticalSectionLocker (p. 207) wxCondition (p. 173) wxSemaphore (p. 1098) Thread class Manages background threads easily Mutex class Mutex locker utility class Critical section class Critical section locker utility class Condition class Semaphore class

HTML classes
wxWindows provides a set of classes to display text in HTML format. These class include a help system based on the HTML widget. wxHtmlHelpController (p. 672) wxHtmlWindow (p. 699) wxHtmlEasyPrinting (p. 668) wxHtmlPrintout (p. 690) wxHtmlParser (p. 685) wxHtmlTagHandler (p. 696) wxHtmlWinParser (p. 708) HTML help controller class HTML window class Simple class for printing HTML Generic HTML wxPrintout class Generic HTML parser class HTML tag handler, pluginable into wxHtmlParser HTML parser class for wxHtmlWindow

1553


CHAPTER 10
wxHtmlWinTagHandler (p. 714) HTML tag handler, pluginable into wxHtmlWinParser

Virtual file system classes
wxWindows provides a set of classes that implement an extensible virtual file system, used internally by the HTML classes. wxFSFile (p. 543) wxFileSystem (p. 492) wxFileSystemHandler (p. 494) Represents a file in the virtual file system Main interface for the virtual file system Class used to announce file system type

XML-based resource system classes
XML-based resource system overview (p. 1627) Resources allow your application to create controls and other user interface elements from specifications stored in an XML format. wxXmlResource (p. 1447) The main class for working with resources.

wxXmlResourceHandler (p. 1452) The base class for XML resource handlers.

Online help
wxHelpController (p. 644) wxHtmlHelpController (p. 672) wxContextHelp (p. 195) wxContextHelpButton (p. 196) wxHelpProvider (p. 652) wxSimpleHelpProvider (p. 1102) Family of classes for controlling help windows HTML help controller class Class to put application into context-sensitive help mode Button class for putting application into contextsensitive help mode Abstract class for context-sensitive help provision Class for simple context-sensitive help provision

wxHelpControllerHelpProvider (p. 649) Class for context-sensitive help provision via a help controller wxToolTip (p. 1326) Class implementing tooltips

Database classes
Database classes overview (p. 1668) wxWindows provides a set of classes for accessing Microsoft's ODBC (Open Database Connectivity) product, donated by Remstar. This is known as wxODBC. wxDb (p. 263) wxDbTable (p. 301) ODBC database connection Provides access to a database table

1554


CHAPTER 10
wxDbInf (p. 300) wxDbTableInf (p. 336) wxDbColDef (p. 292) wxDbColInf (p. 293) wxDbColDataPtr (p. 292) wxDbColFor (p. 293) wxDbConnectInf (p. 294) wxDbIdxDef (p. 300)

Miscellaneous
wxApp (p. 31) wxCaret (p. 117) wxCmdLineParser (p. 141) wxConfig (p. 177) wxDllLoader (p. 390) wxLayoutAlgorithm (p. 781) wxProcess (p. 1019) wxTimer (p. 1294) wxStopWatch (p. 1190) wxMimeTypesManager (p. 918) wxSystemSettings (p. 1229) wxSystemOptions (p. 1228) wxAcceleratorTable (p. 19) wxAutomationObject (p. 63) wxFontMapper (p. 526) wxEncodingConverter (p. 435) wxCalendarDateAttr (p. 114) wxQuantize (p. 1029) Application class A caret (cursor) object Command line parser class Classes for configuration reading/writing (using either INI files or registry) Class to work with shared libraries. An alternative window layout facility Process class Timer class Stop watch class MIME-types manager class System settings class for obtaining various global parameters System options class for run-time configuration Accelerator table OLE automation class Font mapping, finding suitable font for given encoding Encoding conversions Used with wxCalendarCtrl (p. 108) Class to perform quantization, or colour reduction

1555


CHAPTER 10
wxSingleInstanceChecker (p. 1104) Check that only single program instance is running

1556


Chapter 11 Topic overviews
This chapter contains a selection of topic overviews, first things first:

Notes on using the reference
In the descriptions of the wxWindows classes and their member functions, note that descriptions of inherited member functions are not duplicated in derived classes unless their behaviour is different. So in using a class such as wxScrolledWindow, be aware that wxWindow functions may be relevant. Note also that arguments with default values may be omitted from a function call, for brevity. Size and position arguments may usually be given a value of -1 (the default), in which case wxWindows will choose a suitable value. Most strings are returned as wxString objects. However, for remaining char * return values, the strings are allocated and deallocated by wxWindows. Therefore, return values should always be copied for long-term use, especially since the same buffer is often used by wxWindows. The member functions are given in alphabetical order except for constructors and destructors which appear first.

Writing a wxWindows application: a rough guide
To set a wxWindows application going, you will need to derive a wxApp (p. 31) class and override wxApp::OnInit (p. 36). An application must have a top-level wxFrame (p. 530) or wxDialog (p. 367) window. Each frame may contain one or more instances of classes such as wxPanel (p. 972), wxSplitterWindow (p. 1166) or other windows and controls. A frame can have a wxMenuBar (p. 898), a wxToolBar (p. 1309), a status line, and a wxIcon (p. 716) for when the frame is iconized. A wxPanel (p. 972) is used to place controls (classes derived from wxControl (p. 198)) which are used for user interaction. Examples of controls are wxButton (p. 103), wxCheckBox (p. 120), wxChoice (p. 127), wxListBox (p. 793), wxRadioBox (p. 1033), wxSlider (p. 1121). Instances of wxDialog (p. 367) can also be used for controls and they have the advantage of not requiring a separate frame. Instead of creating a dialog box and populating it with items, it is possible to choose one of the convenient common dialog classes, such as wxMessageDialog (p. 914) and wxFileDialog (p. 466).

1557


CHAPTER 11
You never draw directly onto a window - you use a device context (DC). wxDC (p. 347) is the base for wxClientDC (p. 133), wxPaintDC (p. 966), wxMemoryDC (p. 881), wxPostScriptDC (p. 991), wxMemoryDC (p. 881), wxMetafileDC (p. 917) and wxPrinterDC (p. 1010). If your drawing functions have wxDC as a parameter, you can pass any of these DCs to the function, and thus use the same code to draw to several different devices. You can draw using the member functions of wxDC, such as wxDC::DrawLine (p. 353) and wxDC::DrawText (p. 355). Control colour on a window (wxColour (p. 150)) with brushes (wxBrush (p. 90)) and pens (wxPen (p. 976)). To intercept events, you add a DECLARE_EVENT_TABLE macro to the window class declaration, and put a BEGIN_EVENT_TABLE ... END_EVENT_TABLE block in the implementation file. Between these macros, you add event macros which map the event (such as a mouse click) to a member function. These might override predefined event handlers such as for wxKeyEvent (p. 777) and wxMouseEvent (p. 928). Most modern applications will have an on-line, hypertext help system; for this, you need wxHelp and the wxHelpController (p. 644) class to control wxHelp. GUI applications aren't all graphical wizardry. List and hash table needs are catered for by wxList (p. 786), wxStringList (p. 1223) and wxHashMap (p. 637). You will undoubtedly need some platform-independent file functions (p. 1475), and you may find it handy to maintain and search a list of paths using wxPathList (p. 975). There's a miscellany (p. 1505) of operating system and other functions. See also Classes by Category (p. 1541) for a list of classes.

wxWindows Hello World sample
As many people have requested a mini-sample to be published here so that some quick judgment concerning syntax and basic principles can be made, you can now look at wxWindows' "Hello World": You have to include wxWindows' header files, of course. This can be done on a file by file basis (such as #include "wx/window.h") or using one global include (#include "wx/wx.h"). This is also useful on platforms which support precompiled headers such as all major compilers on the Windows platform.
// // file name: hworld.cpp // // purpose: wxWindows "Hello world" // // For compilers that support precompilation, includes "wx/wx.h". #include "wx/wxprec.h" #ifdef __BORLANDC__ #pragma hdrstop #endif #ifndef WX_PRECOMP #include "wx/wx.h" #endif

Practically every app should define a new class derived from wxApp. By overriding

1558


CHAPTER 11
wxApp's OnInit() the program can be initialized, e.g. by creating a new main window.
class MyApp: public wxApp { virtual bool OnInit(); };

The main window is created by deriving a class from wxFrame and giving it a menu and a status bar in its constructor. Also, any class that wishes to respond to any "event" (such as mouse clicks or messages from the menu or a button) must declare an event table using the macro below. Finally, the way to react to such events must be done in "handlers". In our sample, we react to two menu items, one for "Quit" and one for displaying an "About" window. These handlers should not be virtual.
class MyFrame: public wxFrame { public: MyFrame(const wxString& title, const wxPoint& pos, const wxSize& size); void OnQuit(wxCommandEvent& event); void OnAbout(wxCommandEvent& event); private: DECLARE_EVENT_TABLE() };

In order to be able to react to a menu command, it must be given a unique identifier such as a const or an enum.
enum { ID_Quit = 1, ID_About, };

We then proceed to actually implement an event table in which the events are routed to their respective handler functions in the class MyFrame. There are predefined macros for routing all common events, ranging from the selection of a list box entry to a resize event when a user resizes a window on the screen. If -1 is given as the ID, the given handler will be invoked for any event of the specified type, so that you could add just one entry in the event table for all menu commands or all button commands etc. The origin of the event can still be distinguished in the event handler as the (only) parameter in an event handler is a reference to a wxEvent object, which holds various information about the event (such as the ID of and a pointer to the class, which emitted the event).
BEGIN_EVENT_TABLE(MyFrame, wxFrame) EVT_MENU(ID_Quit, MyFrame::OnQuit) EVT_MENU(ID_About, MyFrame::OnAbout) END_EVENT_TABLE()

As in all programs there must be a "main" function. Under wxWindows main is implemented using this macro, which creates an application instance and starts the program.
IMPLEMENT_APP(MyApp)

As mentioned above, wxApp::OnInit() is called upon startup and should be used to initialize the program, maybe showing a "splash screen" and creating the main window

1559


CHAPTER 11
(or several). The frame should get a title bar text ("Hello World") and a position and startup size. One frame can also be declared to be the top window. Returning true indicates a successful initialization.
bool MyApp::OnInit() { MyFrame *frame = new MyFrame( "Hello World", wxPoint(50,50), wxSize(450,340) ); frame->Show( true ); SetTopWindow( frame ); return true; }

In the constructor of the main window (or later on) we create a menu with two menu items as well as a status bar to be shown at the bottom of the main window. Both have to be "announced" to the frame with respective calls.
MyFrame::MyFrame(const wxString& title, const wxPoint& pos, const wxSize& size) : wxFrame((wxFrame *)NULL, -1, title, pos, size) { wxMenu *menuFile = new wxMenu; menuFile->Append( ID_About, "&About..." ); menuFile->AppendSeparator(); menuFile->Append( ID_Quit, "E&xit" ); wxMenuBar *menuBar = new wxMenuBar; menuBar->Append( menuFile, "&File" ); SetMenuBar( menuBar ); CreateStatusBar(); SetStatusText( "Welcome to wxWindows!" ); }

Here are the actual event handlers. MyFrame::OnQuit() closes the main window by calling Close(). The parameter true indicates that other windows have no veto power such as after asking "Do you really want to close?". If there is no other main window left, the application will quit.
void MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event)) { Close( true ); }

MyFrame::OnAbout() will display a small window with some text in it. In this case a typical "About" window with information about the program.
void MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event)) { wxMessageBox( "This is a wxWindows' Hello world sample", "About Hello World", wxOK | wxICON_INFORMATION ); }

wxWindows samples
Probably the best way to learn wxWindows is by reading the source of some 50+ samples provided with it. Many aspects of wxWindows programming can be learnt from them, but sometimes it is not simple to just choose the right sample to look at. This

1560


CHAPTER 11
overview aims at describing what each sample does/demonstrates to make it easier to find the relevant one if a simple grep through all sources didn't help. They also provide some notes about using the samples and what features of wxWindows are they supposed to test. There are currently more than 50 different samples as part of wxWindows and this list is not complete. You should start your tour of wxWindows with the minimal sample (p. 1561) which is the wxWindows version of "Hello, world!". It shows the basic structure of wxWindows program and is the most commented sample of all - looking at its source code is recommended. The next most useful sample is probably the controls (p. 1562) one which shows many of wxWindows standard controls, such as buttons, listboxes, checkboxes, comboboxes etc. Other, more complicated controls, have their own samples. In this category you may find the following samples showing the corresponding controls: wxCalendarCtrl (p. 1561) wxListCtrl (p. 1566) wxTreeCtrl (p. 1570) wxGrid (p. 1565) Calendar a.k.a. date picker control List view control Tree view control Grid control

Finally, it might be helpful to do a search in the entire sample directory if you can't find the sample you showing the control you are interested in by name. Most of wxWindows classes, occur in at least one of the samples.

Minimal sample
The minimal sample is what most people will know under the term Hello World, i.e. a minimal program that doesn't demonstrate anything apart from what is needed to write a program that will display a "hello" dialog. This is usually a good starting point for learning how to use wxWindows.

Art provider sample
The artprov sample shows how you can customize the look of standard wxWindows dialogs by replacing default bitmaps/icons with your own versions. It also shows how you can use wxArtProvider to get stock bitmaps for use in your application.

Calendar sample
This font shows the calendar control (p. 108) in action. It shows how to configure the control (see the different options in the calendar menu) and also how to process the notifications from it.

1561


CHAPTER 11 Checklist sample
This sample demonstrates the use of the wxCheckListBox (p. 124)class intercepting check, select and double click events. It also tests the use of various methods modifying the control, such as by deleting items from it or inserting new once (these functions are actually implemented in the parent class wxListBox (p. 793) so the sample tests that class as well). The layout of the dialog is created using a wxBoxSizer (p. 89)demonstrating a simple dynamic layout.

Config sample
This sample demonstrates the wxConfig (p. 177) classes in a platform independent way, i.e. it uses text based files to store a given configuration under Unix and uses the Registry under Windows. See wxConfig overview (p. 1600) for the descriptions of all features of this class.

Controls sample
The controls sample is the main test program for most simple controls used in wxWindows. The sample tests their basic functionality, events, placement, modification in terms of colour and font as well as the possibility to change the controls programmatically, such as adding item to a list box etc. Apart from that, the sample uses a wxNotebook (p. 943) and tests most features of this special control (using bitmap in the tabs, using wxSizers (p. 1109) and constraints (p. 784) within notebook pages, advancing pages programmatically and vetoing a page change by intercepting the wxNotebookEvent (p. 950). The various controls tested are listed here: wxButton (p. 103) wxBitmapButton (p. 80) wxCheckBox (p. 120) wxChoice (p. 127) wxComboBox (p. 158) wxGauge (p. 551) wxStaticBox (p. 1178) wxListBox (p. 793) wxSpinCtrl Push button control, displaying text Push button control, displaying a bitmap Checkbox control Choice control (a combobox without the editable area) A choice with an editable area A control to represent a varying quantity, such as time remaining A static, or group box for visually grouping related controls A list of strings for single or multiple selection A spin ctrl with a text field and a 'up-down' control

1562


CHAPTER 11
wxSpinButton (p. 1154) wxStaticText (p. 1183) wxStaticBitmap (p. 1176) wxRadioBox (p. 1033) wxRadioButton (p. 1039) wxSlider (p. 1121) A spin or 'up-down' control One or more lines of non-editable text A control to display a bitmap A group of radio buttons A round button to be used with others in a mutually exclusive way A slider that can be dragged by the user

Database sample
The database sample is a small test program showing how to use the ODBC classes written by Remstar Intl. Obviously, this sample requires a database with ODBC support to be correctly installed on your system.

Dialogs sample
This sample shows how to use the common dialogs available from wxWindows. These dialogs are described in details in the Common dialogs overview (p. 1647).

Dialup sample
This sample shows wxDialUpManager (p. 377) class. It displays in the status bar the information gathered through its interface: in particular, the current connection status (online or offline) and whether the connection is permanent (in which case a string 'LAN' appears in the third status bar field - but note that you may have be on a LAN not connected to the Internet, in which case you will not see this) or not. Using the menu entries, you may also dial or hang up the line if you have a modem attached and (this only makes sense for Windows) list the available connections.

DnD sample
This sample shows both clipboard and drag and drop in action. It is quite non trivial and may be safely used as a basis for implementing the clipboard and drag and drop operations in a real-life program. When you run the sample, its screen is split in several parts. On the top, there are two listboxes which show the standard derivations of wxDropTarget (p. 429): wxTextDropTarget (p. 1268) and wxFileDropTarget (p. 470). The middle of the sample window is taken by the log window which shows what is going on (of course, this only works in debug builds) and may be helpful to see the sequence of steps of data transfer.

1563


CHAPTER 11
Finally, the last part is used for dragging text from it to either one of the listboxes (only one will accept it) or another application. The last functionality available from the main frame is to paste a bitmap from the clipboard (or, in the case of Windows version, also a metafile) - it will be shown in a new frame. So far, everything we mentioned was implemented with minimal amount of code using standard wxWindows classes. The more advanced features are demonstrated if you create a shape frame from the main frame menu. A shape is a geometric object which has a position, size and color. It models some application-specific data in this sample. A shape object supports its own private wxDataFormat (p. 217) which means that you may cut and paste it or drag and drop (between one and the same or different shapes) from one sample instance to another (or the same). However, chances are that no other program supports this format and so shapes can also be rendered as bitmaps which allows them to be pasted/dropped in many other applications (and, under Windows, also as metafiles which are supported by most of Windows programs as well - try Write/Wordpad, for example). Take a look at DnDShapeDataObject class to see how you may use wxDataObject (p. 222) to achieve this.

Dynamic sample
This sample is a very small sample that demonstrates the use of thewxEvtHandler::Connect (p. 444) method. This method should be used whenever it is not known at compile time, which control will receive which event or which controls are actually going to be in a dialog or frame. This is most typically the case for any scripting language that would work as a wrapper for wxWindows or programs where forms or similar datagrams can be created by the uses. See also the event sample (p. 1564)

Event sample
The event sample demonstrates various features of the wxWindows events. It shows using dynamic events and connecting/disconnecting the event handlers during the run time and also using PushEventHandler() (p. 1414) andPopEventHandler() (p. 1413). It replaces the old dynamic sample.

Except(ions) sample
This very simple sample shows how to use C++ exceptions in wxWindows programs, i.e. where to catch the exception which may be thrown by the program code. It doesn't do anything very exciting by itself, you need to study its code to understand what goes on. You need to build the library with wxUSE_EXCEPTIONS being set to 1and compile your code with the C++ exceptions support to be able to build this sample.

1564


CHAPTER 11 Exec sample
The exec sample demonstrates the wxExecute (p. 1469) and wxShell (p. 1472) functions. Both of them are used to execute the external programs and the sample shows how to do this synchronously (waiting until the program terminates) or asynchronously (notification will come later). It also shows how to capture the output of the child process in both synchronous and asynchronous cases and how to kill the processes with wxProcess::Kill (p. 1022) and test for their existence with wxProcess::Exists (p. 1022).

Font sample
The font sample demonstrates wxFont (p. 510), wxFontEnumerator (p. 523) and wxFontMapper (p. 526) classes. It allows you to see the fonts available (to wxWindows) on the computer and shows all characters of the chosen font as well.

Grid sample
TODO.

HTML samples
Eight HTML samples (you can find them in directory samples/html) cover all features of HTML sub-library. Test demonstrates how to create wxHtmlWindow (p. 699) and also shows most of supported HTML tags. Widget shows how you can embed ordinary controls or windows within HTML page. It also nicely explains how to write new tag handlers and extend the library to work with unsupported tags. About may give you an idea how to write good-looking about boxes. Zip demonstrates use of virtual file systems in wxHTML. The zip archives handler (ships with wxWindows) allows you to access HTML pages stored in compressed archive as if they were ordinary files. Virtual is yet another virtual file systems demo. This one generates pages at run-time. You may find it useful if you need to display some reports in your application. Printing explains use of wxHtmlEasyPrinting (p. 668) class which serves as as-simpleas-possible interface for printing HTML documents without much work. In fact, only few function calls are sufficient. Help and Helpview are variations on displaying HTML help (compatible with MS HTML Help Workshop). Help shows how to embed wxHtmlHelpController (p. 672) in your application while Helpview is simple tool that only pops up help window and displays

1565


CHAPTER 11
help books given at command line.

Image sample
The image sample demonstrates the use of the wxImage (p. 728) class and shows how to download images in a variety of formats, currently PNG, GIF, TIFF, JPEG, BMP, PNM and PCX. The top of the sample shows to rectangles, one of which is drawn directly in the window, the other one is drawn into a wxBitmap (p. 67), converted to a wxImage, saved as a PNG image and then reloaded from the PNG file again so that conversions between wxImage and wxBitmap as well as loading and save PNG files are tested. At the bottom of the main frame is a test for using a monochrome bitmap by drawing into a wxMemoryDC (p. 881). The bitmap is then drawn specifying the foreground and background colours with wxDC::SetTextForeground (p. 366) and wxDC::SetTextBackground (p. 366) (on the left). The bitmap is then converted to a wxImage and the foreground colour (black) is replaced with red using wxImage::Replace (p. 745).

Internat(ionalization) sample
The not very clearly named internat sample demonstrates the wxWindows internatationalization (i18n for short from now on) features. To be more precise, it only shows localization support, i.e. support for translating the program messages in another language while true i18n would also involve changing the other aspects of the programs behaviour. More information about this sample can be found in the readme.txt file in its directory. Please see also i18n overview (p. 1589).

Layout sample
The layout sample demonstrates the two different layout systems offered by wxWindows. When starting the program, you will see a frame with some controls and some graphics. The controls will change their size whenever you resize the entire frame and the exact behaviour of the size changes is determined using the wxLayoutConstraints (p. 784) class. See also the overview (p. 1616) and the wxIndividualLayoutConstraint (p. 758) class for further information. The menu in this sample offers two more tests, one showing how to use a wxBoxSizer (p. 89) in a simple dialog and the other one showing how to use sizers in connection with a wxNotebook (p. 943) class. See also wxNotebookSizer (p. 952) and wxSizer (p. 1109).

Listctrl sample
This sample shows wxListCtrl (p. 799) control. Different modes supported by the control (list, icons, small icons, report) may be chosen from the menu.

1566


CHAPTER 11
The sample also provides some timings for adding/deleting/sorting a lot of (several thousands) items into the control.

Notebook sample
This samples shows two controls at once: although initially it was written to demonstrate wxNotebook (p. 943) only, it can now be also used to see wxListbook (p. 792) in action. To switch between the two controls you need to manually change TEST_LISTBOOK definition in the file notebook.h and rebuild the sample.

Render sample
This sample shows how to replace the default wxWindows renderer (p. 1059) and also how to write a shared library (DLL) implementing a renderer and load and unload it during the run-time.

Rotate sample
This is a simple example which demonstrates how to rotate an image with the wxImage::Rotate (p. 746) method. The rotation can be done without interpolation (left mouse button) which will be faster, or with interpolation (right mouse button) which is slower but gives better results.

Scroll subwindow sample
This sample demonstrates the use of the wxScrolledWindow (p. 1085) class including placing subwindows into it and drawing simple graphics. It uses the SetTargetWindow (p. 1094) method and thus the effect of scrolling does not show in the scrolled window itself, but in one of its subwindows. Additionally, this samples demonstrates how to optimize drawing operations in wxWindows, in particular using the wxWindow::IsExposed (p. 1410) method with the aim to prevent unnecessary drawing in the window and thus reducing or removing flicker on screen.

Sockets sample
The sockets sample demonstrates how to use the communication facilities provided by wxSocket (p. 1131). There are two different applications in this sample: a server, which is implemented using a wxSocketServer (p. 1152) object, and a client, which is implemented as a wxSocketClient (p. 1148). The server binds to the local address, using TCP port number 3000, sets up an event handler to be notified of incoming connection requests (wxSOCKET_CONNECTION events), and stands there, waiting for clients (listening in the socket parlance). For each accepted connection, a new wxSocketBase (p. 1131) object is created. These socket

1567


CHAPTER 11
objects are independent from the server that created them, so they set up their own event handler, and then request to be notified of wxSOCKET_INPUT (incoming data) or wxSOCKET_LOST (connection closed at the remote end) events. In the sample, the event handler is the same for all connections; to find out which socket the event is addressed to, the GetSocket (p. 1151) function is used. Although it might take some time to get used to the event-oriented system upon which wxSocket is built, the benefits are many. See, for example, that the server application, while being single-threaded (and of course without using fork() or ugly select() loops) can handle an arbitrary number of connections. The client starts up unconnected, so you can use the Connect... option to specify the address of the server you are going to connect to (the TCP port number is hard-coded as 3000). Once connected, a number of tests are possible. Currently, three tests are implemented. They show how to use the basic IO calls in wxSocketBase (p. 1131), such as Read (p. 1142), Write (p. 1146), ReadMsg (p. 1143) and WriteMsg (p. 1147), and how to set up the correct IO flags depending on what you are going to do. See the comments in the code for more information. Note that because both clients and connection objects in the server set up an event handler to catch wxSOCKET_LOST events, each one is immediately notified if the other end closes the connection. There is also an URL test which shows how to use the wxURL (p. 1355) class to fetch data from a given URL. The sockets sample is work in progress. Some things to do:     More tests for basic socket functionality. More tests for protocol classes (wxProtocol and its descendants). Tests for the recently added (and still in alpha stage) datagram sockets. New samples which actually do something useful (suggestions accepted).

Sound sample
The sound sample shows how to use wxSound (p. 1384) for simple audio output (e.g. notifications).

Statbar sample
This sample shows how to create and use wxStatusBar. Although most of the samples have a statusbar, they usually only create a default one and only do it once. Here you can see how to recreate the statusbar (with possibly different number of fields) and how to use it to show icons/bitmaps and/or put arbitrary controls into it.

Text sample

1568


CHAPTER 11
This sample demonstrates four features: firstly the use and many variants of the wxTextCtrl (p. 1248) class (single line, multi line, read only, password, ignoring TAB, ignoring ENTER). Secondly it shows how to intercept a wxKeyEvent (p. 777) in both the raw form using the EVT_KEY_UP and EVT_KEY_DOWN macros and the higher level from using the EVT_CHAR macro. All characters will be logged in a log window at the bottom of the main window. By pressing some of the function keys, you can test some actions in the text ctrl as well as get statistics on the text ctrls, which is useful for testing if these statistics actually are correct. Thirdly, on platforms which support it, the sample will offer to copy text to the wxClipboard (p. 136) and to paste text from it. The GTK version will use the so called PRIMARY SELECTION, which is the pseudo clipboard under X and best known from pasting text to the XTerm program. Last not least: some of the text controls have tooltips and the sample also shows how tooltips can be centrally disabled and their latency controlled.

Thread sample
This sample demonstrates the use of threads in connection with GUI programs. There are two fundamentally different ways to use threads in GUI programs and either way has to take care of the fact that the GUI library itself usually is not multi-threading safe, i.e. that it might crash if two threads try to access the GUI class simultaneously. One way to prevent that is have a normal GUI program in the main thread and some worker threads which work in the background. In order to make communication between the main thread and the worker threads possible, wxWindows offers the wxPostEvent (p. 1512) function and this sample makes use of this function. The other way to use a so called Mutex (such as those offered in the wxMutex (p. 938) class) that prevent threads from accessing the GUI classes as long as any other thread accesses them. For this, wxWindows has the wxMutexGuiEnter (p. 1474) and wxMutexGuiLeave (p. 1475) functions, both of which are used and tested in the sample as well. See also Multithreading overview (p. 1665) and wxThread (p. 1284).

Toolbar sample
The toolbar sample shows the wxToolBar (p. 1309) class in action. The following things are demonstrated:   Creating the toolbar using wxToolBar::AddTool (p. 1313) and wxToolBar::AddControl (p. 1313): see MyApp::InitToolbar in the sample. Using EVT_UPDATE_UI handler for automatically enabling/disabling toolbar buttons without having to explicitly call EnableTool. This is done in MyFrame::OnUpdateCopyAndCut.

1569


CHAPTER 11
 Using wxToolBar::DeleteTool (p. 1315) and wxToolBar::InsertTool (p. 1320) to dynamically update the toolbar.

Some buttons in the main toolbar are check buttons, i.e. they stay checked when pressed. On the platforms which support it, the sample also add a combobox to the toolbar showing how you can use arbitrary controls and not only buttons in it. If you toggle another toolbar in the sample (using Ctrl-A) you will also see the radio toolbar buttons in action: the first three buttons form a radio group, that is checking any of them automatically unchecks the previously checked one.

Treectrl sample
This sample demonstrates using wxTreeCtrl (p. 1327) class. Here you may see how to process various notification messages sent by this control and also when they occur (by looking at the messages in the text control in the bottom part of the frame). Adding, inserting and deleting items and branches from the tree as well as sorting (in default alphabetical order as well as in custom one) is demonstrated here as well - try the corresponding menu entries.

Wizard sample
This sample shows so-called wizard dialog (implemented using wxWizard (p. 1437) and related classes). It shows almost all features supported:  Using bitmaps with the wizard and changing them depending on the page shown (notice that wxValidationPage in the sample has a different image from the other ones) Using TransferDataFromWindow (p. 1433) to verify that the data entered is correct before passing to the next page (done in wxValidationPage which forces the user to check a checkbox before continuing). Using more elaborated techniques to allow returning to the previous page, but not continuing to the next one or vice versa (in wxRadioboxPage) This (wxRadioboxPage) page also shows how the page may process Cancel button itself instead of relying on the wizard parent to do it. Normally, the order of the pages in the wizard is known at compile-time, but sometimes it depends on the user choices: wxCheckboxPage shows how to dynamically decide which page to display next (see also wxWizardPage (p. 1444))



  

wxApp overview
Classes: wxApp (p. 31)

1570


CHAPTER 11
A wxWindows application does not have a main procedure; the equivalent is the OnInit (p. 36) member defined for a class derived from wxApp. OnInit will usually create a top window as a bare minimum. Unlike in earlier versions of wxWindows, OnInit does not return a frame. Instead it returns a boolean value which indicates whether processing should continue (true) or not (false). You call wxApp::SetTopWindow (p. 40) to let wxWindows know about the top window. Note that the program's command line arguments, represented by argc and argv, are available from within wxApp member functions. An application closes by destroying all windows. Because all frames must be destroyed for the application to exit, it is advisable to use parent frames wherever possible when creating new frames, so that deleting the top level frame will automatically delete child frames. The alternative is to explicitly delete child frames in the top-level frame's wxCloseEvent (p. 139) handler. In emergencies the wxExit (p. 1471) function can be called to kill the application however normally the applications shuts down automatically, see below (p. 1571). An example of defining an application follows:
class DerivedApp : public wxApp { public: virtual bool OnInit(); }; IMPLEMENT_APP(DerivedApp) bool DerivedApp::OnInit() { wxFrame *the_frame = new wxFrame(NULL, ID_MYFRAME, argv[0]); ... the_frame->Show(true); SetTopWindow(the_frame); return true; }

Note the use of IMPLEMENT_APP(appClass), which allows wxWindows to dynamically create an instance of the application object at the appropriate point in wxWindows initialization. Previous versions of wxWindows used to rely on the creation of a global application object, but this is no longer recommended, because required global initialization may not have been performed at application object construction time. You can also use DECLARE_APP(appClass) in a header file to declare the wxGetApp function which returns a reference to the application object. Otherwise you can only use the global wxTheApp pointer which is of type wxApp *.

Application shutdown
The application normally shuts down when the last of its top level windows is closed. This is normally the expected behaviour and means that it is enough to call Close() (p. 1393) in response to the "Exit" menu command if your program has a single top level

1571


CHAPTER 11
window. If this behaviour is not desirable wxApp::SetExitOnFrameDelete (p. 40) can be called to change it. Note that starting from wxWindows 2.3.3 such logic doesn't apply for the windows shown before the program enters the main loop: in other words, you can safely show a dialog from wxApp::OnInit (p. 36) and not be afraid that your application terminates when this dialog -- which is the last top level window for the moment -- is closed. Another aspect of the application shutdown is the OnExit (p. 36) which is called when the application exits but before wxWindows cleans up its internal structures. Your should delete all wxWindows object that your created by the time OnExit finishes. In particular, do not destroy them from application class' destructor! For example, this code may crash:
class MyApp : public wxApp { public: wxCHMHelpController m_helpCtrl; ... };

The reason for that is that m_helpCtrl is a member object and is thus destroyed from MyApp destructor. But MyApp object is deleted after wxWindows structures that wxCHMHelpController depends on were uninitialized! The solution is to destroy HelpCtrl in OnExit:
class MyApp : public wxApp { public: wxCHMHelpController *m_helpCtrl; ... }; bool MyApp::OnInit() { ... m_helpCtrl = new wxCHMHelpController; ... } int MyApp::OnExit() { delete m_helpCtrl; return 0; }

Run time class information overview
Classes: wxObject (p. 954), wxClassInfo (p. 130). One of the failings of C++ used to be that no run-time information was provided about a class and its position in the inheritance hierarchy. Another, which still persists, is that instances of a class cannot be created just by knowing the name of a class, which makes facilities such as persistent storage hard to implement. Most C++ GUI frameworks overcome these limitations by means of a set of macros and functions and wxWindows is no exception. As it originated before the addition of RTTI to

1572


CHAPTER 11
the standard C++ and as support for it still missing from some (albeit old) compilers, wxWindows doesn't (yet) use it, but provides its own macro-based RTTI system. In the future, the standard C++ RTTI will be used though and you're encouraged to use whenever possible wxDynamicCast() (p. 1519) macro which, for the implementations that support it, is defined just as dynamic_cast<> and uses wxWindows RTTI for all the others. This macro is limited to wxWindows classes only and only works with pointers (unlike the real dynamic_cast<> which also accepts references). Each class that you wish to be known the type system should have a macro such as DECLARE_DYNAMIC_CLASS just inside the class declaration. The macro IMPLEMENT_DYNAMIC_CLASS should be in the implementation file. Note that these are entirely optional; use them if you wish to check object types, or create instances of classes using the class name. However, it is good to get into the habit of adding these macros for all classes. Variations on these macros (p. 1515) are used for multiple inheritance, and abstract classes that cannot be instantiated dynamically or otherwise. DECLARE_DYNAMIC_CLASS inserts a static wxClassInfo declaration into the class, initialized by IMPLEMENT_DYNAMIC_CLASS. When initialized, the wxClassInfo object inserts itself into a linked list (accessed through wxClassInfo::first and wxClassInfo::next pointers). The linked list is fully created by the time all global initialisation is done. IMPLEMENT_DYNAMIC_CLASS is a macro that not only initialises the static wxClassInfo member, but defines a global function capable of creating a dynamic object of the class in question. A pointer to this function is stored in wxClassInfo, and is used when an object should be created dynamically. wxObject::IsKindOf (p. 956) uses the linked list of wxClassInfo. It takes a wxClassInfo argument, so use CLASSINFO(className) to return an appropriate wxClassInfo pointer to use in this function. The function wxCreateDynamicObject (p. 1519) can be used to construct a new object of a given type, by supplying a string name. If you have a pointer to the wxClassInfo object instead, then you can simply call wxClassInfo::CreateObject.

wxClassInfo
Run time class information overview (p. 1572) Class: wxClassInfo (p. 130) This class stores meta-information about classes. An application may use macros such as DECLARE_DYNAMIC_CLASS and IMPLEMENT_DYNAMIC_CLASS to record runtime information about a class, including:    its position in the inheritance hierarchy; the base class name(s) (up to two base classes are permitted); a string representation of the class name;

1573


CHAPTER 11
 a function that can be called to construct an instance of this class.

The DECLARE_... macros declare a static wxClassInfo variable in a class, which is initialized by macros of the form IMPLEMENT_... in the implementation C++ file. Classes whose instances may be constructed dynamically are given a global constructor function which returns a new object. You can get the wxClassInfo for a class by using the CLASSINFO macro, e.g. CLASSINFO(wxFrame). You can get the wxClassInfo for an object using wxObject::GetClassInfo. See also wxObject (p. 954) and wxCreateDynamicObject (p. 1519).

Example
In a header file frame.h:
class wxFrame : public wxWindow { DECLARE_DYNAMIC_CLASS(wxFrame) private: wxString m_title; public: ... };

In a C++ file frame.cpp:
IMPLEMENT_DYNAMIC_CLASS(wxFrame, wxWindow) wxFrame::wxFrame() { ... }

wxString overview
Classes: wxString (p. 1200), wxArrayString (p. 53), wxStringTokenizer (p. 1225)

Introduction
wxString is a class which represents a character string of arbitrary length (limited by MAX_INT which is usually 2147483647 on 32 bit machines) and containing arbitrary characters. The ASCII NUL character is allowed, but be aware that in the current string implementation some methods might not work correctly in this case. wxString works with both ASCII (traditional, 7 or 8 bit, characters) as well as Unicode (wide characters) strings. This class has all the standard operations you can expect to find in a string class: dynamic memory management (string extends to accommodate new characters),

1574


CHAPTER 11
construction from other strings, C strings and characters, assignment operators, access to individual characters, string concatenation and comparison, substring extraction, case conversion, trimming and padding (with spaces), searching and replacing and both Clike Printf() (p. 1215) and stream-like insertion functions as well as much more - see wxString (p. 1200) for a list of all functions.

Comparison of wxString to other string classes
The advantages of using a special string class instead of working directly with C strings are so obvious that there is a huge number of such classes available. The most important advantage is the need to always remember to allocate/free memory for C strings; working with fixed size buffers almost inevitably leads to buffer overflows. At last, C++ has a standard string class (std::string). So why the need for wxString? There are several advantages: 1. Efficiency This class was made to be as efficient as possible: both in terms of size (each wxString objects takes exactly the same space as a char * pointer, sing reference counting (p. 1577)) and speed. It also provides performance statistics gathering code (p. 1578) which may be enabled to fine tune the memory allocation strategy for your particular application - and the gain might be quite big. Compatibility This class tries to combine almost full compatibility with the old wxWindows 1.xx wxString class, some reminiscence to MFC CString class and 90% of the functionality of std::string class. Rich set of functions Some of the functions present in wxString are very useful but don't exist in most of other string classes: for example, AfterFirst (p. 1208), BeforeLast (p. 1208), operator<< (p. 1220) or Printf (p. 1215). Of course, all the standard string operations are supported as well. Unicode wxString is Unicode friendly: it allows to easily convert to and from ANSI and Unicode strings in any build mode (see the Unicode overview (p. 1583) for more details) and maps to eitherstring or wstring transparently depending on the current mode. Used by wxWindows And, of course, this class is used everywhere inside wxWindows so there is no performance loss which would result from conversions of objects of any other string class (including std::string) to wxString internally by wxWindows.

2.

3.

4.

5.

However, there are several problems as well. The most important one is probably that there are often several functions to do exactly the same thing: for example, to get the length of the string either one of length(), Len() (p. 1213) or Length() (p. 1213) may be used. The first function, as almost all the other functions in lowercase, is std::string compatible. The second one is "native" wxString version and the last one is wxWindows 1.xx way. So the question is: which one is better to use? And the answer is that: The usage of std::string compatible functions is strongly advised! It will both make your code more familiar to other C++ programmers (who are supposed to have

1575


CHAPTER 11
knowledge of std::string but not of wxString), let you reuse the same code in both wxWindows and other programs (by just typedefing wxString as std::string when used outside wxWindows) and by staying compatible with future versions of wxWindows which will probably start using std::string sooner or later too. In the situations where there is no corresponding std::string function, please try to use the new wxString methods and not the old wxWindows 1.xx variants which are deprecated and may disappear in future versions.

Some advice about using wxString
Probably the main trap with using this class is the implicit conversion operator to const char *. It is advised that you use c_str() (p. 1208)instead to clearly indicate when the conversion is done. Specifically, the danger of this implicit conversion may be seen in the following code fragment:
// this function converts the input string to uppercase, output it to the screen // and returns the result const char *SayHELLO(const wxString& input) { wxString output = input.Upper(); printf("Hello, %s!\n", output); return output; }

There are two nasty bugs in these three lines. First of them is in the call to the printf() function. Although the implicit conversion to C strings is applied automatically by the compiler in the case of
puts(output);

because the argument of puts() is known to be of the type const char *, this is not done for printf() which is a function with variable number of arguments (and whose arguments are of unknown types). So this call may do anything at all (including displaying the correct string on screen), although the most likely result is a program crash. The solution is to use c_str() (p. 1208): just replace this line with
printf("Hello, %s!\n", output.c_str());

The second bug is that returning output doesn't work. The implicit cast is used again, so the code compiles, but as it returns a pointer to a buffer belonging to a local variable which is deleted as soon as the function exits, its contents is totally arbitrary. The solution to this problem is also easy: just make the function return wxString instead of a C string. This leads us to the following general advice: all functions taking string arguments should take const wxString& (this makes assignment to the strings inside the function faster because of reference counting (p. 1577)) and all functions returning strings should return wxString - this makes it safe to return local variables.

1576


CHAPTER 11 Other string related functions and classes
As most programs use character strings, the standard C library provides quite a few functions to work with them. Unfortunately, some of them have rather counter-intuitive behaviour (like strncpy() which doesn't always terminate the resulting string with a NULL) and are in general not very safe (passing NULL to them will probably lead to program crash). Moreover, some very useful functions are not standard at all. This is why in addition to all wxString functions, there are also a few global string functions which try to correct these problems: wxIsEmpty() (p. 1485) verifies whether the string is empty (returning true for NULL pointers), wxStrlen() (p. 1486) also handles NULLs correctly and returns 0 for them and wxStricmp() (p. 1486) is just a platform-independent version of case-insensitive string comparison function known either as stricmp() or strcasecmp() on different platforms. The <wx/string.h> header also defines wxSnprintf (p. 1487) and wxVsnprintf (p. 1488) functions which should be used instead of the inherently dangerous standard sprintf() and which use snprintf() instead which does buffer size checks whenever possible. Of course, you may also use wxString::Printf (p. 1215) which is also safe. There is another class which might be useful when working with wxString: wxStringTokenizer (p. 1225). It is helpful when a string must be broken into tokens and replaces the standard C library strtok() function. And the very last string-related class is wxArrayString (p. 53): it is just a version of the "template" dynamic array class which is specialized to work with strings. Please note that this class is specially optimized (using its knowledge of the internal structure of wxString) for storing strings and so it is vastly better from a performance point of view than a wxObjectArray of wxStrings.

Reference counting and why you shouldn't care about it
wxString objects use a technique known as copy on write (COW). This means that when a string is assigned to another, no copying really takes place: only the reference count on the shared string data is incremented and both strings share the same data. But as soon as one of the two (or more) strings is modified, the data has to be copied because the changes to one of the strings shouldn't be seen in the others. As data copying only happens when the string is written to, this is known as COW. What is important to understand is that all this happens absolutely transparently to the class users and that whether a string is shared or not is not seen from the outside of the class - in any case, the result of any operation on it is the same. Probably the unique case when you might want to think about reference counting is when a string character is taken from a string which is not a constant (or a constant reference). In this case, due to C++ rules, the "read-only" operator[] (which is the same as GetChar() (p. 1211)) cannot be chosen and the "read/write" operator[] (the same as GetWritableChar() (p. 1211)) is used instead. As the call to this operator may modify the string, its data is unshared (COW is done) and so if the string was really shared there is some performance loss (both in terms of speed and memory consumption). In the rare

1577


CHAPTER 11
cases when this may be important, you might prefer using GetChar() (p. 1211) instead of the array subscript operator for this reasons. Please note that at() (p. 1204) method has the same problem as the subscript operator in this situation and so using it is not really better. Also note that if all string arguments to your functions are passed as const wxString& (see the section Some advice (p. 1576)) this situation will almost never arise because for constant references the correct operator is called automatically.

Tuning wxString for your application
Note: this section is strictly about performance issues and is absolutely not necessary to read for using wxString class. Please skip it unless you feel familiar with profilers and relative tools. If you do read it, please also read the preceding section about reference counting (p. 1577). For the performance reasons wxString doesn't allocate exactly the amount of memory needed for each string. Instead, it adds a small amount of space to each allocated block which allows it to not reallocate memory (a relatively expensive operation) too often as when, for example, a string is constructed by subsequently adding one character at a time to it, as for example in:
// delete all vowels from the string wxString DeletellVowels(const wxString& original) A { wxString result; size_t len = original.length(); for ( size_t n = 0; n < len; n++ ) { if ( strchr("aeuio", tolower(original[n])) == NULL ) result += original[n]; } return result; }

This is quite a common situation and not allocating extra memory at all would lead to very bad performance in this case because there would be as many memory (re)allocations as there are consonants in the original string. Allocating too much extra memory would help to improve the speed in this situation, but due to a great number of wxString objects typically used in a program would also increase the memory consumption too much. The very best solution in precisely this case would be to use Alloc() (p. 1207) function to preallocate, for example, len bytes from the beginning - this will lead to exactly one memory allocation being performed (because the result is at most as long as the original string). However, using Alloc() is tedious and so wxString tries to do its best. The default algorithm assumes that memory allocation is done in granularity of at least 16 bytes (which is the case on almost all of wide-spread platforms) and so nothing is lost if the amount of memory to allocate is rounded up to the next multiple of 16. Like this, no memory is lost and 15 iterations from 16 in the example above won't allocate memory but use the already allocated pool. The default approach is quite conservative. Allocating more memory may bring important

1578


CHAPTER 11
performance benefits for programs using (relatively) few very long strings. The amount of memory allocated is configured by the setting of EXTRA_ALLOC in the file string.cpp during compilation (be sure to understand why its default value is what it is before modifying it!). You may try setting it to greater amount (say twice nLen) or to 0 (to see performance degradation which will follow) and analyse the impact of it on your program. If you do it, you will probably find it helpful to also define WXSTRING_STATISTICS symbol which tells the wxString class to collect performance statistics and to show them on stderr on program termination. This will show you the average length of strings your program manipulates, their average initial length and also the percent of times when memory wasn't reallocated when string concatenation was done but the already preallocated memory was used (this value should be about 98% for the default allocation policy, if it is less than 90% you should really consider fine tuning wxString for your application). It goes without saying that a profiler should be used to measure the precise difference the change to EXTRA_ALLOC makes to your program.

Date and time classes overview
Classes: wxDateTime (p. 236), wxDateSpan (p. 230), wxTimeSpan (p. 1298), wxCalendarCtrl (p. 108)

Introduction
wxWindows provides a set of powerful classes to work with dates and times. Some of the supported features of wxDateTime (p. 236) class are: Wide range The range of supported dates goes from about 4714 B.C. to some 480 million years in the future. Not using floating point calculations anywhere ensures that the date calculations don't suffer from rounding errors. Not only all usual calculations with dates are supported, but also more exotic week and year day calculations, work day testing, standard astronomical functions, conversion to and from strings in either strict or free format. Objects of wxDateTime are small (8 bytes) and working with them is fast

Precision

Many features

Efficiency

All date/time classes at a glance
There are 3 main classes declared in <wx/datetime.h>: except wxDateTime (p. 236) itself which represents an absolute moment in time, there are also two classes -

1579


CHAPTER 11
wxTimeSpan (p. 1298) and wxDateSpan (p. 230) which represent the intervals of time. There are also helper classes which are used together with wxDateTime: wxDateTimeHolidayAuthority (p. 262) which is used to determine whether a given date is a holiday or not and wxDateTimeWorkDays (p. 262) which is a derivation of this class for which (only) Saturdays and Sundays are the holidays. See more about these classes in the discussion of the holidays (p. 1582). Finally, in other parts of this manual you may find mentions of wxDate and wxTime classes. These classes (p. 1583) are obsolete and superseded by wxDateTime.

wxDateTime characteristics
wxDateTime (p. 236) stores the time as a signed number of milliseconds since the Epoch which is fixed, by convention, to Jan 1, 1970 - however this is not visible to the class users (in particular, dates prior to the Epoch are handled just as well (or as bad) as the dates after it). But it does mean that the best resolution which can be achieved with this class is 1 millisecond. The size of wxDateTime object is 8 bytes because it is represented as a 64 bit integer. The resulting range of supported dates is thus approximatively 580 million years, but due to the current limitations in the Gregorian calendar support, only dates from Nov 24, 4714BC are supported (this is subject to change if there is sufficient interest in doing it). Finally, the internal representation is time zone independent (always in GMT) and the time zones only come into play when a date is broken into year/month/day components. See more about timezones (p. 1581) below. Currently, the only supported calendar is Gregorian one (which is used even for the dates prior to the historic introduction of this calendar which was first done on Oct 15, 1582 but is, generally speaking, country, and even region, dependent). Future versions will probably have Julian calendar support as well and support for other calendars (Maya, Hebrew, Chinese...) is not ruled out.

Difference between wxDateSpan and wxTimeSpan
While there is only one logical way to represent an absolute moment in the time (and hence only one wxDateTime class), there are at least two methods to describe a time interval. First, there is the direct and self-explaining way implemented by wxTimeSpan (p. 1298): it is just a difference in milliseconds between two moments in time. Adding or subtracting such an interval to wxDateTime is always well-defined and is a fast operation. But in the daily life other, calendar-dependent time interval specifications are used. For example, 'one month later' is commonly used. However, it is clear that this is not the same as wxTimeSpan of 60*60*24*31 seconds because 'one month later' Feb 15 is Mar 15 and not Mar 17 or Mar 16 (depending on whether the year is leap or not). This is why there is another class for representing such intervals called wxDateSpan (p.

1580


CHAPTER 11
230). It handles these sort of operations in the most natural way possible, but note that manipulating with intervals of this kind is not always well-defined. Consider, for example, Jan 31 + '1 month': this will give Feb 28 (or 29), i.e. the last day of February and not the non-existent Feb 31. Of course, this is what is usually wanted, but you still might be surprised to notice that now subtracting back the same interval from Feb 28 will result in Jan 28 and not Jan 31 we started with! So, unless you plan to implement some kind of natural language parsing in the program, you should probably use wxTimeSpan instead of wxDateSpan (which is also more efficient). However, wxDateSpan may be very useful in situations when you do need to understand what 'in a month' means (of course, it is just wxDateTime::Now() + wxDateSpan::Month()).

Date arithmetics
Many different operations may be performed with the dates, however not all of them make sense. For example, multiplying a date by a number is an invalid operation, even though multiplying either of the time span classes by a number is perfectly valid. Here is what can be done: Addition a wxTimeSpan or wxDateSpan can be added to wxDateTime resulting in a new wxDateTime object and also 2 objects of the same span class can be added together giving another object of the same class. the same types of operations as above are allowed and, additionally, a difference between two wxDateTime objects can be taken and this will yield wxTimeSpan. a wxTimeSpan or wxDateSpan object can be multiplied by an integer number resulting in an object of the same type. a wxTimeSpan or wxDateSpan object may finally be negated giving an interval of the same magnitude but of opposite time direction.

Subtraction

Multiplication

Unary minus

For all these operations there are corresponding global (overloaded) operators and also member functions which are synonyms for them: Add(), Subtract() and Multiply(). Unary minus as well as composite assignment operations (like +=) are only implemented as members and Neg() is the synonym for unary minus.

Time zone considerations
Although the time is always stored internally in GMT, you will usually work in the local time zone. Because of this, all wxDateTime constructors and setters which take the broken down date assume that these values are for the local time zone. Thus,

1581


CHAPTER 11
wxDateTime(1, wxDateTime::Jan, 1970) will not correspond to the wxDateTime Epoch unless you happen to live in the UK. All methods returning the date components (year, month, day, hour, minute, second...) will also return the correct values for the local time zone by default, so, generally, doing the natural things will lead to natural and correct results. If you only want to do this, you may safely skip the rest of this section. However, if you want to work with different time zones, you should read it to the end. In this (rare) case, you are still limited to the local time zone when constructing wxDateTime objects, i.e. there is no way to construct a wxDateTime corresponding to the given date in, say, Pacific Standard Time. To do it, you will need to call ToTimezone (p. 262) or MakeTimezone (p. 262) methods to adjust the date for the target time zone. There are also special versions of these functions ToGMT (p. 262) and MakeGMT (p. 262) for the most common case - when the date should be constructed in GMT. You also can just retrieve the value for some time zone without converting the object to it first. For this you may pass TimeZone argument to any of the methods which are affected by the time zone (all methods getting date components and the date formatting ones, for example). In particular, the Format() family of methods accepts a TimeZone parameter and this allows to simply print time in any time zone. To see how to do it, the last issue to address is how to construct a TimeZone object which must be passed to all these methods. First of all, you may construct it manually by specifying the time zone offset in seconds from GMT, but usually you will just use one of the symbolic time zone names (p. 236) and let the conversion constructor do the job. I.e. you would just write
wxDateTime dt(...whatever...); printf("The time is %s in local time zone", dt.FormatTime().c_str()); printf("The time is %s in GMT", dt.FormatTime(wxDateTime::GMT).c_str());

Daylight saving time (DST)
DST (a.k.a. 'summer time') handling is always a delicate task which is better left to the operating system which is supposed to be configured by the administrator to behave correctly. Unfortunately, when doing calculations with date outside of the range supported by the standard library, we are forced to deal with these issues ourselves. Several functions are provided to calculate the beginning and end of DST in the given year and to determine whether it is in effect at the given moment or not, but they should not be considered as absolutely correct because, first of all, they only work more or less correctly for only a handful of countries (any information about other ones appreciated!) and even for them the rules may perfectly well change in the future. The time zone handling methods (p. 1581) use these functions too, so they are subject to the same limitations.

wxDateTime and Holidays

1582


CHAPTER 11
TODO.

Compatibility
The old classes for date/time manipulations ported from wxWindows version 1.xx are still included but are reimplemented in terms of wxDateTime. However, using them is strongly discouraged because they have a few quirks/bugs and were not 'Y2K' compatible.

Unicode support in wxWindows
This section briefly describes the state of the Unicode support in wxWindows. Read it if you want to know more about how to write programs able to work with characters from languages other than English.

What is Unicode?
Starting with release 2.1 wxWindows has support for compiling in Unicode mode on the platforms which support it. Unicode is a standard for character encoding which addresses the shortcomings of the previous, 8 bit standards, by using at least 16 (and possibly 32) bits for encoding each character. This allows to have at least 65536 characters (what is called the BMP, or basic multilingual plane) and possible 2^32 of them instead of the usual 256 and is sufficient to encode all of the world languages at once. More details about Unicode may be found at www.unicode.org. As this solution is obviously preferable to the previous ones (think of incompatible encodings for the same language, locale chaos and so on), many modern operating systems support it. The probably first example is Windows NT which uses only Unicode internally since its very first version. Writing internationalized programs is much easier with Unicode and, as the support for it improves, it should become more and more so. Moreover, in the Windows NT/2000 case, even the program which uses only standard ASCII can profit from using Unicode because they will work more efficiently - there will be no need for the system to convert all strings the program uses to/from Unicode each time a system call is made.

Unicode and ANSI modes
As not all platforms supported by wxWindows support Unicode (fully) yet, in many cases it is unwise to write a program which can only work in Unicode environment. A better solution is to write programs in such way that they may be compiled either in ANSI (traditional) mode or in the Unicode one. This can be achieved quite simply by using the means provided by wxWindows. Basically, there are only a few things to watch out for:  Character type (char or wchar_t)

1583


CHAPTER 11
   Literal strings (i.e. "Hello, world!" or '*') String functions (strlen(), strcpy(), ...) Special preprocessor tokens (__FILE__, __DATE__ and __TIME__)

Let's look at them in order. First of all, each character in an Unicode program takes 2 bytes instead of usual one, so another type should be used to store the characters (char only holds 1 byte usually). This type is called wchar_t which stands for widecharacter type. Also, the string and character constants should be encoded using wide characters (wchar_t type) which typically take 2 or 4 bytes instead of char which only takes one. This is achieved by using the standard C (and C++) way: just put the letter 'L' after any string constant and it becomes a long constant, i.e. a wide character one. To make things a bit more readable, you are also allowed to prefix the constant with 'L'instead of putting it after it. Of course, the usual standard C functions don't work with wchar_tstrings, so another set of functions exists which do the same thing but acceptwchar_t * instead of char *. For example, a function to get the length of a wide-character string is called wcslen() (compare with strlen() - you see that the only difference is that the "str" prefix standing for "string" has been replaced with "wcs" standing for "wide-character string"). And finally, the standard preprocessor tokens enumerated above expand to ANSI strings but it is more likely that Unicode strings are wanted in the Unicode build. wxWindows provides the macros __TFILE__, __TDATE__ and __TTIME__ which behave exactly as the standard ones except that they produce ANSI strings in ANSI build and Unicode ones in the Unicode build. To summarize, here is a brief example of how a program which can be compiled in both ANSI and Unicode modes could look like:
#ifdef __UNICODE__ wchar_t wch = L'*'; const wchar_t *ws = L"Hello, world!"; int len = wcslen(ws); wprintf(L"Compiled at %s\n", __TDATE__); #else // ANSI char ch = '*'; const char *s = "Hello, world!"; int len = strlen(s); printf("Compiled at %s\n", __DATE__); #endif // Unicode/ANSI

Of course, it would be nearly impossibly to write such programs if it had to be done this way (try to imagine the number of #ifdef UNICODE an average program would have had!). Luckily, there is another way - see the next section.

Unicode support in wxWindows
In wxWindows, the code fragment from above should be written instead:

1584


CHAPTER 11
wxChar ch = wxT('*'); wxString s = wxT("Hello, world!"); int len = s.Len();

What happens here? First of all, you see that there are no more #ifdefs at all. Instead, we define some types and macros which behave differently in the Unicode and ANSI builds and allows us to avoid using conditional compilation in the program itself. We have a wxChar type which maps either on char or wchar_t depending on the mode in which program is being compiled. There is no need for a separate type for strings though, because the standard wxString (p. 1200) supports Unicode, i.e. it stores either ANSI or Unicode strings depending on the compile mode. Finally, there is a special wxT() (p. 1487) macro which should enclose all literal strings in the program. As it is easy to see comparing the last fragment with the one above, this macro expands to nothing in the (usual) ANSI mode and prefixes 'L' to its argument in the Unicode mode. The important conclusion is that if you use wxChar instead of char, avoid using C style strings and use wxString instead and don't forget to enclose all string literals inside wxT() (p. 1487) macro, your program automatically becomes (almost) Unicode compliant! Just let us state once again the rules:   Always use wxChar instead of char Always enclose literal string constants in wxT() (p. 1487) macro unless they're already converted to the right representation (another standard wxWindows macro _() (p. 1488) does it, for example, so there is no need for wxT() in this case) or you intend to pass the constant directly to an external function which doesn't accept wide-character strings. Use wxString instead of C style strings.



Unicode and the outside world
We have seen that it was easy to write Unicode programs using wxWindows types and macros, but it has been also mentioned that it isn't quite enough. Although everything works fine inside the program, things can get nasty when it tries to communicate with the outside world which, sadly, often expects ANSI strings (a notable exception is the entire Win32 API which accepts either Unicode or ANSI strings and which thus makes it unnecessary to ever perform any conversions in the program). GTK 2.0 only accepts UTF-8 strings. To get a ANSI string from a wxString, you may use the mb_str() function which always returns an ANSI string (independently of the mode - while the usual c_str() (p. 1208) returns a pointer to the internal representation which is either ASCII or Unicode). More rarely used, but still useful, is wc_str() function which always returns the Unicode string.

Unicode-related compilation settings 1585


CHAPTER 11
You should define wxUSE_UNICODE to 1 to compile your program in Unicode mode. Note that it currently only works in Win32 and GTK 2.0 and that some parts of wxWindows are not Unicode-compliant yet (ODBC classes, for example). If you compile your program in ANSI mode you can still define wxUSE_WCHAR_T to get some limited support for wchar_t type. This will allow your program to perform conversions between Unicode strings and ANSI ones (using wxMBConv classes (p. 1586)) and construct wxString objects from Unicode strings (presumably read from some external file or elsewhere).

wxMBConv classes overview
Classes: wxMBConv (p. 863), wxMBConvLibc, wxMBConvUTF7 (p. 866), wxMBConvUTF8 (p. 867), wxCSConv (p. 208),wxMBConvUTF16 (p. 868), wxMBConvUTF32 (p. 869) The wxMBConv classes in wxWindows enables an Unicode-aware application to easily convert between Unicode and the variety of 8-bit encoding systems still in use.

Background: The need for conversion
As programs are becoming more and more globalized, and users exchange documents across country boundaries as never before, applications increasingly need to take into account all the different character sets in use around the world. It is no longer enough to just depend on the default byte-sized character set that computers have traditionally used. A few years ago, a solution was proposed: the Unicode standard. Able to contain the complete set of characters in use in one unified global coding system, it would resolve the character set problems once and for all. But it hasn't happened yet, and the migration towards Unicode has created new challenges, resulting in "compatibility encodings" such as UTF-8. A large number of systems out there still depends on the old 8-bit encodings, hampered by the huge amounts of legacy code still widely deployed. Even sending Unicode data from one Unicode-aware system to another may need encoding to an 8-bit multibyte encoding (UTF-7 or UTF-8 is typically used for this purpose), to pass unhindered through any traditional transport channels.

Background: The wxString class
If you have compiled wxWindows in Unicode mode, the wxChar type will become identical to wchar_t rather than char, and a wxString stores wxChars. Hence, all wxString manipulation in your application will then operate on Unicode strings, and almost as easily as working with ordinary char strings (you just need to remember to use the wxT() macro to encapsulate any string literals). But often, your environment doesn't want Unicode strings. You could be sending data

1586


CHAPTER 11
over a network, or processing a text file for some other application. You need a way to quickly convert your easily-handled Unicode data to and from a traditional 8-bitencoding. And this is what the wxMBConv classes do.

wxMBConv classes
The base class for all these conversions is the wxMBConv class (which itself implements standard libc locale conversion). Derived classes include wxMBConvLibc, several different wxMBConvUTFxxx classes, and wxCSConv, which implement different kinds of conversions. You can also derive your own class for your own custom encoding and use it, should you need it. All you need to do is override the MB2WC and WC2MB methods.

wxMBConv objects
Several of the wxWindows-provided wxMBConv classes have predefined instances (wxConvLibc, wxConvFile, wxConvUTF7, wxConvUTF8, wxConvLocal). You can use these predefined objects directly, or you can instantiate your own objects. A variable, wxConvCurrent, points to the conversion object that the user interface is supposed to use, in the case that the user interface is not Unicode-based (like with GTK+ 1.2). By default, it points to wxConvLibc or wxConvLocal, depending on which works best on the current platform.

wxCSConv
The wxCSConv class is special because when it is instantiated, you can tell it which character set it should use, which makes it meaningful to keep many instances of them around, each with a different character set (or you can create a wxCSConv instance on the fly). The predefined wxCSConv instance, wxConvLocal, is preset to use the default user character set, but you should rarely need to use it directly, it is better to go through wxConvCurrent.

Converting strings
Once you have chosen which object you want to use to convert your text, here is how you would use them with wxString. These examples all assume that you are using a Unicode build of wxWindows, although they will still compile in a non-Unicode build (they just won't convert anything). Example 1: Constructing a wxString from input in current encoding.
wxString str(input_data, *wxConvCurrent);

Example 2: Input in UTF-8 encoding.
wxString str(input_data, wxConvUTF8);

1587


CHAPTER 11

Example 3: Input in KOI8-R. Construction of wxCSConv instance on the fly.
wxString str(input_data, wxCSConv(wxT("koi8-r")));

Example 4: Printing a wxString to stdout in UTF-8 encoding.
puts(str.mb_str(wxConvUTF8));

Example 5: Printing a wxString to stdout in custom encoding. Using preconstructed wxCSConv instance.
wxCSConv cust(user_encoding); printf("Data: %s\n", (const char*) str.mb_str(cust));

Note: Since mb_str() returns a temporary wxCharBuffer to hold the result of the conversion, you need to explicitly cast it to const char* if you use it in a vararg context (like with printf).

Converting buffers
If you have specialized needs, or just don't want to use wxString, you can also use the conversion methods of the conversion objects directly. This can even be useful if you need to do conversion in a non-Unicode build of wxWindows; converting a string from UTF-8 to the current encoding should be possible by doing this:
wxString str(wxConvUTF8.cMB2WC(input_data), *wxConvCurrent);

Here, cMB2WC of the UTF8 object returns a wxWCharBuffer containing a Unicode string. The wxString constructor then converts it back to an 8-bit character set using the passed conversion object, *wxConvCurrent. (In a Unicode build of wxWindows, the constructor ignores the passed conversion object and retains the Unicode data.) This could also be done by first making a wxString of the original data:
wxString input_str(input_data); wxString str(input_str.wc_str(wxConvUTF8), *wxConvCurrent);

To print a wxChar buffer to a non-Unicode stdout:
printf("Data: %s\n", (const char*) wxConvCurrent->cWX2MB(unicode_data));

If you need to do more complex processing on the converted data, you may want to store the temporary buffer in a local variable:
const wxWX2MBbuf tmp_buf = wxConvCurrent->cWX2MB(unicode_data); const char *tmp_str = (const char*) tmp_buf; printf("Data: %s\n", tmp_str); process_data(tmp_str);

If a conversion had taken place in cWX2MB (i.e. in a Unicode build), the buffer will be deallocated as soon as tmp_buf goes out of scope. (The macro wxWX2MBbuf reflects the correct return value of cWX2MB (either char* or wxCharBuffer), except for the const.)

1588


CHAPTER 11

Internationalization
Although internationalization of an application (i18n for short) involves far more than just translating its text messages to another message -- date, time and currency formats need changing too, some languages are written left to right and others right to left, character encoding may differ and many other things may need changing too -- it is a necessary first step. wxWindows provides facilities for message translation with its wxLocale (p. 828) class and is itself fully translated into several languages. Please consult wxWindows home page for the most up-to-date translations - and if you translate it into one of the languages not done yet, your translations would be gratefully accepted for inclusion into the future versions of the library! The wxWindows approach to i18n closely follows GNU gettext package. wxWindows uses the message catalogs which are binary compatible with gettext catalogs and this allows to use all of the programs in this package to work with them. But note that no additional libraries are needed during the run-time, however, so you have only the message catalogs to distribute and nothing else. During program development you will need the gettext package for working with message catalogs. Warning: gettext versions < 0.10 are known to be buggy, so you should find a later version of it! There are two kinds of message catalogs: source catalogs which are text files with extension .po and binary catalogs which are created from the source ones with msgfmt program (part of gettext package) and have the extension .mo. Only the binary files are needed during program execution. The program i18n involves several steps: 1. 2. Translating the strings in the program text using wxGetTranslation (p. 1485) or equivalently the _() (p. 1488) and ngettext (p. 1485) macros. Extracting the strings to be translated from the program: this uses the work done in the previous step because xgettext program used for string extraction recognises the standard _() as well as (using its -k option) our wxGetTranslation and extracts all strings inside the calls to these functions. Alternatively, you may use -a option to extract all the strings, but it will usually result in many strings being found which don't have to be translated at all. This will create a text message catalog -- a .po file. Translating the strings extracted in the previous step to other language(s). It involves editing the .po file. Compiling the .po file into .mo file to be used by the program. Setting the appropriate locale in your program to use the strings for the given language: see wxLocale (p. 828).

3. 4. 5.

See also the GNU gettext documentation linked from docs/html/index.htm in your wxWindows distribution. See also Writing non-English applications (p. 1590). It focuses on handling charsets related problems.

1589


CHAPTER 11
Finally, take a look at the i18n sample (p. 1566) which shows to you how all this looks in practice.

Writing non-English applications
This article describes how to write applications that communicate with user in language other than English. Unfortunately many languages use different charsets under Unix and Windows (and other platforms, to make situation even more complicated). These charsets usually differ in so many characters it is impossible to use same texts under all platforms. wxWindows library provides mechanism that helps you avoid distributing many identical, only differently encoded, packages with your application (e.g. help files and menu items in iso8859-13 and windows-1257). Thanks to this mechanism you can, for example, distribute only iso8859-13 data and it will be handled transparently under all systems. Please read Internationalization (p. 1589) which describes the locales concept. In the following text, wherever iso8859-2 and windows-1250 are used, any encodings are meant and any encodings may be substituted there. Locales The best way to ensure correctly displayed texts in a GUI across platforms is to use locales. Write your in-code messages in English or without diacritics and put real messages into the message catalog (see Internationalization (p. 1589)). A standard .po file begins with a header like this:
# SOME DESCRIPTIVE TITLE. # Copyright (C) YEAR Free Software Foundation, Inc. # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR. # msgid "" msgstr "" "Project-Id-Version: PACKAGE VERSION\n" "POT-Creation-Date: 1999-02-19 16:03+0100\n" "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n" "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n" "Language-Team: LANGUAGE <LL@li.org>\n" "MIME-Version: 1.0\n" "Content-Type: text/plain; charset=CHARSET\n" "Content-Transfer-Encoding: ENCODING\n"

Note this particular line:
"Content-Type: text/plain; charset=CHARSET\n"

It specifies the charset used by the catalog. All strings in the catalog are encoded using this charset. You have to fill in proper charset information. Your .po file may look like this after doing so:
# SOME DESCRIPTIVE TITLE. # Copyright (C) YEAR Free Software Foundation, Inc. # FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.

1590


CHAPTER 11
# msgid "" msgstr "" "Project-Id-Version: PACKAGE VERSION\n" "POT-Creation-Date: 1999-02-19 16:03+0100\n" "PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n" "Last-Translator: FULL NAME <EMAIL@ADDRESS>\n" "Language-Team: LANGUAGE <LL@li.org>\n" "MIME-Versin: 1.0 \n" o "Content-Type: text/plain; charset=iso8859-2\n" "Content-Transfer-Encoding: 8bit\n"

(Make sure that the header is not marked as fuzzy.) wxWindows is able to use this catalog under any supported platform (although iso8859-2 is a Unix encoding and is normally not understood by Windows). How is this done? When you tell the wxLocale class to load a message catalog that contains correct header, it checks the charset. The catalog is then converted to the charset used (seewxLocale::GetSystemEncoding (p. 841) andwxLocale::GetSystemEncodingName (p. 841)) by user's operating system. This is default behaviour of thewxLocale (p. 828) class; you can disable it by not passingwxLOCALE_CONV_ENCODING to wxLocale::Init (p. 842). Font mapping You can use wxMBConv classes (p. 1586) and wxFontMapper (p. 526) to display text:
if (!wxFontMapper::Get()->IsEncodingAvailable(enc, facename)) { wxFontEncoding alternative; if (wxFontMapper::Get()->GetAltForEncoding(enc, &alternative, facename, false)) { wxCSConv convFrom(wxFontMapper::Get()->GetEncodingName(enc)); wxCSConv convTo(wxFontMapper::Get()->GetEncodingName(alternative)); text = wxString(text.mb_str(convFrom), convTo); } else ...failure (or we may try iso8859-1/7bit ASCII)... } ...display text...

Converting data You may want to store all program data (created documents etc.) in the same encoding, let's say utf-8. You can usewxCSConv (p. 208) class to convert data to encoding used by the system your application is running on (seewxLocale::GetSystemEncoding (p. 841)). Help files If you're using wxHtmlHelpController (p. 672) there is no problem at all. You must only make sure that all the HTML files contain the META tag, e.g.
<meta http equiv="Content-Type" content="text/html; charset=iso8859-2"> -

and that the hhp project file contains one additional line in the OPTIONSsection:
Charset=iso88592 -

1591


CHAPTER 11
This additional entry tells the HTML help controller what encoding is used in contents and index tables.

Container classes overview
Classes: wxList (p. 786), wxArray (p. 42) wxWindows uses itself several container classes including doubly-linked lists and dynamic arrays (i.e. arrays which expand automatically when they become full). For both historical and portability reasons wxWindows does not use STL which provides the standard implementation of many container classes in C++. First of all, wxWindows has existed since well before STL was written, and secondly we don't believe that today compilers can deal really well with all of STL classes (this is especially true for some less common platforms). Of course, the compilers are evolving quite rapidly and hopefully their progress will allow to base future versions of wxWindows on STL - but this is not yet the case. wxWindows container classes don't pretend to be as powerful or full as STL ones, but they are quite useful and may be compiled with absolutely any C++ compiler. They're used internally by wxWindows, but may, of course, be used in your programs as well if you wish. The list classes in wxWindows are doubly-linked lists which may either own the objects they contain (meaning that the list deletes the object when it is removed from the list or the list itself is destroyed) or just store the pointers depending on whether you called or not wxList::DeleteContents (p. 789) method. Dynamic arrays resemble C arrays but with two important differences: they provide runtime range checking in debug builds and they expand automatically the allocated memory when there is no more space for new items. They come in two sorts: the "plain" arrays which store either built-in types such as "char", "int" or "bool" or the pointers to arbitrary objects, or "object arrays" which own the object pointers to which they store. For the same portability reasons, the container classes implementation in wxWindows does not use templates, but is rather based on C preprocessor i.e. is done with the macros: WX_DECLARE_LIST and WX_DEFINE_LIST for the linked lists and WX_DECLARE_ARRAY, WX_DECLARE_OBJARRAY and WX_DEFINE_OBJARRAY for the dynamic arrays. The "DECLARE" macro declares a new container class containing the elements of given type and is needed for all three types of container classes: lists, arrays and objarrays. The "DEFINE" classes must be inserted in your program in a place where the full declaration of container element class is in scope (i.e. not just forward declaration), otherwise destructors of the container elements will not be called! As array classes never delete the items they contain anyhow, there is no WX_DEFINE_ARRAY macro for them. Examples of usage of these macros may be found in wxList (p. 786) and wxArray (p. 42) documentation. Finally, wxWindows predefines several commonly used container classes. wxList is defined for compatibility with previous versions as a list containing wxObjects and wxStringList as a list of C-style strings (char *), both of these classes are deprecated and

1592


CHAPTER 11
should not be used in new programs. The following array classes are defined: wxArrayInt, wxArrayLong, wxArrayPtrVoid and wxArrayString. The first three store elements of corresponding types, but wxArrayString is somewhat special: it is an optimized version of wxArray which uses its knowledge about wxString (p. 1200) reference counting schema.

File classes and functions overview
Classes: wxFile (p. 458), wxDir (p. 380), wxTempFile (p. 1242), wxTextFile (p. 1271) Functions: see file functions (p. 1475). wxWindows provides some functions and classes to facilitate working with files. As usual, the accent is put on cross-platform features which explains, for example, the wxTextFile (p. 1271) class which may be used to convert between different types of text files (DOS/Unix/Mac). wxFile may be used for low-level IO. It contains all the usual functions to work with files (opening/closing, reading/writing, seeking, and so on) but compared with using standard C functions, has error checking (in case of an error a message is logged using wxLog (p. 843) facilities) and closes the file automatically in the destructor which may be quite convenient. wxTempFile is a very small file designed to make replacing the files contents safer - see its documentation (p. 1242) for more details. wxTextFile is a general purpose class for working with small text files on line by line basis. It is especially well suited for working with configuration files and program source files. It can be also used to work with files with "non native" line termination characters and write them as "native" files if needed (in fact, the files may be written in any format). wxDir is a helper class for enumerating the files or subdirectories of a directory. It may be used to enumerate all files, only files satisfying the given template mask or only nonhidden files.

wxStreams overview
Classes: wxStreamBase (p. 1191), wxStreamBuffer (p. 1193), wxInputStream (p. 762), wxOutputStream (p. 958), wxFilterInputStream (p. 501), wxFilterOutputStream (p. 502) Purpose of wxStream We had troubles with standard C++ streams on several platforms: they react quite well in most cases, but in the multi-threaded case, for example, they have many problems. Some Borland Compilers refuse to work at all with them and using iostreams on Linux makes writing programs, that are binary compatible across different Linux distributions, impossible. Therefore, wxStreams have been added to wxWindows because an application should compile and run on all supported platforms and we don't want users to depend on

1593


CHAPTER 11
release X.XX of libg++ or some other compiler to run the program. wxStreams is divided in two main parts: 1. 2. the core: wxStreamBase, wxStreamBuffer, wxInputStream, wxOutputStream, wxFilterIn/OutputStream the "IO" classes: wxSocketIn/OutputStream, wxDataIn/OutputStream, wxFileIn/OutputStream, ...

wxStreamBase is the base definition of a stream. It defines, for example, the API of OnSysRead, OnSysWrite, OnSysSeek and OnSysTell. These functions are really implemented by the "IO" classes. wxInputStream and wxOutputStream inherit from it. wxStreamBuffer is a cache manager for wxStreamBase (it manages a stream buffer linked to a stream). One stream can have multiple stream buffers but one stream have always one autoinitialized stream buffer. wxInputStream is the base class for read-only streams. It implements Read, SeekI (I for Input), and all read or IO generic related functions. wxOutputStream does the same thing but it is for write-only streams. wxFilterIn/OutputStream is the base class definition for stream filtering. Stream filtering means a stream which does no syscall but filters data which are passed to it and then pass them to another stream. For example, wxZLibInputStream is an inline stream decompressor. The "IO" classes implements the specific parts of the stream. This could be nothing in the case of wxMemoryIn/OutputStream which bases itself on wxStreamBuffer. This could also be a simple link to the a true syscall (for example read(...), write(...)). Generic usage: an example Usage is simple. We can take the example of wxFileInputStream and here is some sample code:
... // The constructor initializes the stream buffer and open the file descriptor // associted to the name of the file. a wxFileInputStream in_stream("the_file_to_be_read"); // Ok, read some bytes ... nb_datas is expressed in bytes. in_stream.Read(data, nb_datas); if (in_stream.LastError() != wxSTREAM_NOERROR) { // Oh oh, something bad happens. // For a complete list, look into the documentation at wxStreamBase. } // You can also inline all like this. if (in_stream.Read(data, nb_datas).LastError() != wxSTREAM_NOERROR) { // Do something. } // You can also get the last number of bytes REALLY put into the buffer. size_t really_read = in_stream.LastRead(); // Ok, moves to the beginning of the stream. SeekI returns the last position // in the stream counted from the beginning.

1594


CHAPTER 11
off_t old_position = in_stream.SeekI(0, wxFromBeginning); // What is my current position ? off_t position = in_stream.TellI(); // wxFileInputStream will close the file descriptor on the destruction.

Compatibility with C++ streams As I said previously, we could add a filter stream so it takes an istream argument and builds a wxInputStream from it: I don't think it should be difficult to implement it and it may be available in the fix of wxWindows 2.0.

wxLog classes overview
Classes: wxLog (p. 843), wxLogStderr (p. 854), wxLogStream (p. 854), wxLogTextCtrl (p. 855), wxLogWindow (p. 855), wxLogGui (p. 851), wxLogNull (p. 852), wxLogChain (p. 850), wxLogPassThrough (p. 853), wxStreamToTextRedirector (p. 1198) This is a general overview of logging classes provided by wxWindows. The word logging here has a broad sense, including all of the program output, not only non interactive messages. The logging facilities included in wxWindows provide the base wxLog class which defines the standard interface for a log target as well as several standard implementations of it and a family of functions to use with them. First of all, no knowledge of wxLog classes is needed to use them. For this, you should only know about wxLogXXX() functions. All of them have the same syntax as printf() or vprintf() , i.e. they take the format string as the first argument and respectively a variable number of arguments or a variable argument list pointer. Here are all of them:  wxLogFatalError which is like wxLogError, but also terminates the program with the exit code 3 (using abort() standard function). Unlike for all the other logging functions, this function can't be overridden by a log target. wxLogError is the function to use for error messages, i.e. the messages that must be shown to the user. The default processing is to pop up a message box to inform the user about it. wxLogWarning for warnings - they are also normally shown to the user, but don't interrupt the program work. wxLogMessage is for all normal, informational messages. They also appear in a message box by default (but it can be changed, see below). Notice that the standard behaviour is to not show informational messages if there are any errors later - the logic being that the later error messages make the informational



 

1595


CHAPTER 11
messages preceding them meaningless.  wxLogVerbose is for verbose output. Normally, it is suppressed, but might be activated if the user wishes to know more details about the program progress (another, but possibly confusing name for the same function is wxLogInfo). wxLogStatus is for status messages - they will go into the status bar of the active or specified (as the first argument) wxFrame (p. 530) if it has one. wxLogSysError is mostly used by wxWindows itself, but might be handy for logging errors after system call (API function) failure. It logs the specified message text as well as the last system error code (errno or ::GetLastError() depending on the platform) and the corresponding error message. The second form of this function takes the error code explicitly as the first argument. wxLogDebug is the right function for debug output. It only does anything at all in the debug mode (when the preprocessor symbol__WXDEBUG__ is defined) and expands to nothing in release mode (otherwise).Tip: under Windows, you must either run the program under debugger or use a 3rd party program such as DbgView (http://www.sysinternals.com) to actually see the debug output. wxLogTrace as wxLogDebug only does something in debug build. The reason for making it a separate function from it is that usually there are a lot of trace messages, so it might make sense to separate them from other debug messages which would be flooded in them. Moreover, the second version of this function takes a trace mask as the first argument which allows to further restrict the amount of messages generated.

 





The usage of these functions should be fairly straightforward, however it may be asked why not use the other logging facilities, such as C standard stdio functions or C++ streams. The short answer is that they're all very good generic mechanisms, but are not really adapted for wxWindows, while the log classes are. Some of advantages in using wxWindows log functions are:  Portability It is a common practice to use printf()statements or cout/cerr C++ streams for writing out some (debug or otherwise) information. Although it works just fine under Unix, these messages go strictly nowhere under Windows where the stdout of GUI programs is not assigned to anything. Thus, you might view wxLogMessage() as a simple substitute for printf().
You can also redirect the wxLogXXX calls to cout by just writing: *logger=new wxLogStream(&cout); wxLog::SetActiveTarget(logger); wxLog

Finally, there is also a possibility to redirect the output sent to cout to a wxTextCtrl (p. 1248) by using the wxStreamToTextRedirector (p. 1198) class.  Flexibility The output of wxLog functions can be redirected or suppressed entirely based on their importance, which is either impossible or difficult to do with traditional methods. For example, only error messages, or only error messages and warnings might be logged, filtering out all informational

1596


CHAPTER 11
messages.  Completeness Usually, an error message should be presented to the user when some operation fails. Let's take a quite simple but common case of a file error: suppose that you're writing your data file on disk and there is not enough space. The actual error might have been detected inside wxWindows code (say, in wxFile::Write), so the calling function doesn't really know the exact reason of the failure, it only knows that the data file couldn't be written to the disk. However, as wxWindows uses wxLogError() in this situation, the exact error code (and the corresponding error message) will be given to the user together with "high level" message about data file writing error.

After having enumerated all the functions which are normally used to log the messages, and why would you want to use them we now describe how all this works. wxWindows has the notion of a log target: it is just a class deriving from wxLog (p. 843). As such, it implements the virtual functions of the base class which are called when a message is logged. Only one log target is active at any moment, this is the one used by wxLogXXX()functions. The normal usage of a log object (i.e. object of a class derived from wxLog) is to install it as the active target with a call to SetActiveTarget() and it will be used automatically by all subsequent calls to wxLogXXX() functions. To create a new log target class you only need to derive it from wxLog and implement one (or both) of DoLog() and DoLogString() in it. The second one is enough if you're happy with the standard wxLog message formatting (prepending "Error:" or "Warning:", timestamping &c) but just want to send the messages somewhere else. The first one may be overridden to do whatever you want but you have to distinguish between the different message types yourself. There are some predefined classes deriving from wxLog and which might be helpful to see how you can create a new log target class and, of course, may also be used without any change. There are:    wxLogStderr This class logs messages to a FILE *, using stderr by default as its name suggests. wxLogStream This class has the same functionality as wxLogStderr, but uses ostream and cerr instead of FILE * and stderr. wxLogGui This is the standard log target for wxWindows applications (it is used by default if you don't do anything) and provides the most reasonable handling of all types of messages for given platform. wxLogWindow This log target provides a "log console" which collects all messages generated by the application and also passes them to the previous active log target. The log window frame has a menu allowing user to clear the log, close it completely or save all messages to file. wxLogNull The last log class is quite particular: it doesn't do anything. The objects of this class may be instantiated to (temporarily) suppress output of wxLogXXX() functions. As an example, trying to open a non-existing file will usually provoke an error message, but if for some reasons it is unwanted, just





1597


CHAPTER 11
use this construction:
wxFile file; // wxFile.Open() normally complains if file can't be opened, we don't want it { wxLogNull logNo; if ( !file.Open("bar") ) ... process error ourselves ... } // ~wxLogNull called, old log sink restored wxLogMessage("..."); // ok

The log targets can also be combined: for example you may wish to redirect the messages somewhere else (for example, to a log file) but also process them as normally. For this the wxLogChain (p. 850) and wxLogPassThrough (p. 853) can be used.

Debugging overview
Classes, functions and macros: wxDebugContext (p. 341), wxObject (p. 954), wxLog (p. 843), Log functions (p. 1520), Debug macros (p. 1529) Various classes, functions and macros are provided in wxWindows to help you debug your application. Most of these are only available if you compile both wxWindows, your application and all libraries that use wxWindows with the __WXDEBUG__ symbol defined. You can also test the __WXDEBUG__ symbol in your own applications to execute code that should be active only in debug mode. wxDebugContext wxDebugContext (p. 341) is a class that never gets instantiated, but ties together various static functions and variables. It allows you to dump all objects to that stream, write statistics about object allocation, and check memory for errors. It is good practice to define a wxObject::Dump (p. 955) member function for each class you derive from a wxWindows class, so that wxDebugContext::Dump (p. 341) can call it and give valuable information about the state of the application. If you have difficulty tracking down a memory leak, recompile in debugging mode and call wxDebugContext::Dump (p. 341) and wxDebugContext::PrintStatistics (p. 343) at appropriate places. They will tell you what objects have not yet been deleted, and what kinds of object they are. In fact, in debug mode wxWindows will automatically detect memory leaks when your application is about to exit, and if there are any leaks, will give you information about the problem. (How much information depends on the operating system and compiler -- some systems don't allow all memory logging to be enabled). See the memcheck sample for example of usage. For wxDebugContext to do its work, the new and delete operators for wxObject have been redefined to store extra information about dynamically allocated objects (but not statically declared objects). This slows down a debugging version of an application, but can find difficult-to-detect memory leaks (objects are not deallocated), overwrites (writing

1598


CHAPTER 11
past the end of your object) and underwrites (writing to memory in front of the object). If debugging mode is on and the symbols wxUSE_GLOBAL_MEMORY_OPERATORS and wxUSE_DEBUG_NEW_ALWAYS are set to 1 in setup.h, 'new' is defined to be:
#define new new(__FILE__,__LINE__)

All occurrences of 'new' in wxWindows and your own application will use the overridden form of the operator with two extra arguments. This means that the debugging output (and error messages reporting memory problems) will tell you what file and on what line you allocated the object. Unfortunately not all compilers allow this definition to work properly, but most do. Debug macros You should also use debug macros (p. 1529) as part of a 'defensive programming' strategy, scattering wxASSERTs liberally to test for problems in your code as early as possible. Forward thinking will save a surprising amount of time in the long run. wxASSERT (p. 1529) is used to pop up an error message box when a condition is not true. You can also use wxASSERT_MSG (p. 1530) to supply your own helpful error message. For example:
void MyClass::MyFunction(wxObject* object) { wxASSERT_MSG( (object != NULL), "object should not be NULL in MyFunction!" ); ... };

The message box allows you to continue execution or abort the program. If you are running the application inside a debugger, you will be able to see exactly where the problem was. Logging functions You can use the wxLogDebug (p. 1523) and wxLogTrace (p. 1523) functions to output debugging information in debug mode; it will do nothing for non-debugging code.

wxDebugContext overview
Debugging overview (p. 1598) Class: wxDebugContext (p. 341) wxDebugContext is a class for performing various debugging and memory tracing operations. This class has only static data and function members, and there should be no instances. Probably the most useful members are SetFile (for directing output to a file, instead of the default standard error or debugger output); Dump (for dumping the dynamically

1599


CHAPTER 11
allocated objects) and PrintStatistics (for dumping information about allocation of objects). You can also call Check to check memory blocks for integrity. Here's an example of use. The SetCheckpoint ensures that only the allocations done after the checkpoint will be dumped.
wxDebugContext::SetCheckpoint(); wxDebugContext::SetFile("c:\\temp\\debug.log"); wxString *thing = new wxString; char *ordinaryNonObject = new char[1000]; wxDebugContext::Dump(); wxDebugContext::PrintStatistics();

You can use wxDebugContext if __WXDEBUG__ is defined, or you can use it at any other time (if wxUSE_DEBUG_CONTEXT is set to 1 in setup.h). It is not disabled in nondebug mode because you may not wish to recompile wxWindows and your entire application just to make use of the error logging facility. Note: wxDebugContext::SetFile has a problem at present, so use the default stream instead. Eventually the logging will be done through the wxLog facilities instead.

wxConfig classes overview
Classes: wxConfig (p. 177) This overview briefly describes what the config classes are and what they are for. All the details about how to use them may be found in the description of the wxConfigBase (p. 177) class and the documentation of the file, registry and INI file based implementations mentions all the features/limitations specific to each one of these versions. The config classes provide a way to store some application configuration information. They were especially designed for this usage and, although may probably be used for many other things as well, should be limited to it. It means that this information should be: 1. 2. 3. Typed, i.e. strings or numbers for the moment. You can not store binary data, for example. Small. For instance, it is not recommended to use the Windows registry for amounts of data more than a couple of kilobytes. Not performance critical, neither from speed nor from a memory consumption point of view.

On the other hand, the features provided make them very useful for storing all kinds of small to medium volumes of hierarchically-organized, heterogeneous data. In short, this is a place where you can conveniently stuff all your data (numbers and strings) organizing it in a tree where you use the filesystem-like paths to specify the location of a piece of data. In particular, these classes were designed to be as easy to use as possible.

1600


CHAPTER 11
From another point of view, they provide an interface which hides the differences between the Windows registry and the standard Unix text format configuration files. Other (future) implementations of wxConfigBase might also understand GTK resource files or their analogues on the KDE side. In any case, each implementation of wxConfigBase does its best to make the data look the same way everywhere. Due to the limitations of the underlying physical storage as in the case of wxIniConfig, it may not implement 100% of the base class functionality. There are groups of entries and the entries themselves. Each entry contains either a string or a number (or a boolean value; support for other types of data such as dates or timestamps is planned) and is identified by the full path to it: something like /MyApp/UserPreferences/Colors/Foreground. The previous elements in the path are the group names, and each name may contain an arbitrary number of entries and subgroups. The path components are always separated with a slash, even though some implementations use the backslash internally. Further details (including how to read/write these entries) may be found in the documentation for wxConfigBase (p. 177).

wxFileSystem
The wxHTML library uses a virtual file systems mechanism similar to the one used in Midnight Commander, Dos Navigator, FAR or almost any modern file manager. It allows the user to access data stored in archives as if they were ordinary files. On-the-fly generated files that exist only in memory are also supported. Classes Three classes are used in order to provide virtual file systems mechanism:    The wxFSFile (p. 543) class provides information about opened file (name, input stream, mime type and anchor). The wxFileSystem (p. 492) class is the interface. Its main methods are ChangePathTo() and OpenFile(). This class is most often used by the end user. The wxFileSystemHandler (p. 494) is the core of virtual file systems mechanism. You can derive your own handler and pass it to of the VFS mechanism. You can derive your own handler and pass it to wxFileSystem's AddHandler() method. In the new handler you only need to override the OpenFile() and CanOpen() methods.

Locations Locations (aka filenames aka addresses) are constructed from four parts:   protocol - handler can recognize if it is able to open a file by checking its protocol. Examples are "http", "file" or "ftp". right location - is the name of file within the protocol. In "http://www.wxwindows.org/index.html" the right location is "//www.wxwindows.org/index.html".

1601


CHAPTER 11
  anchor - an anchor is optional and is usually not present. In "index.htm#chapter2" the anchor is "chapter2". left location - this is usually an empty string. It is used by 'local' protocols such as ZIP. See Combined Protocols paragraph for details.

Combined Protocols The left location precedes the protocol in the URL string. It is not used by global protocols like HTTP but it becomes handy when nesting protocols - for example you may want to access files in a ZIP archive: file:archives/cpp_doc.zip#zip:reference/fopen.htm#syntax In this example, the protocol is "zip", right location is "reference/fopen.htm", anchor is "syntax" and left location is "file:archives/cpp_doc.zip". There are two protocols used in this example: "zip" and "file". File Systems Included in wxHTML The following virtual file system handlers are part of wxWindows so far: wxInternetFSHandler wxZipFSHandler A handler for accessing documents via HTTP or FTP protocols. Include file is <wx/fs_inet.h>. A handler for ZIP archives. Include file is <wx/fs_zip.h>. URL is in form "archive.zip#zip:filename". This handler allows you to access data stored in memory (such as bitmaps) as if they were regular files. See wxMemoryFSHandler documentation (p. 882) for details. Include file is <wx/fs_mem.h>. URL is prefixed with memory:, e.g. "memory:myfile.htm"

wxMemoryFSHandler

In addition, wxFileSystem itself can access local files. Initializing file system handlers Use wxFileSystem::AddHandler (p. 492) to initialize a handler, for example:
#include <wx/fs_mem.h> ... bool MyApp::OnInit() { wxFileSystem::AddHandler(new wxMemoryFSHandler); ... }

Event handling overview

1602


CHAPTER 11
Classes: wxEvtHandler (p. 443), wxWindow (p. 1386), wxEvent (p. 439)

Introduction
Before version 2.0 of wxWindows, events were handled by the application either by supplying callback functions, or by overriding virtual member functions such as OnSize. From wxWindows 2.0, event tables are used instead, with a few exceptions. An event table is placed in an implementation file to tell wxWindows how to map events to member functions. These member functions are not virtual functions, but they are all similar in form: they take a single wxEvent-derived argument, and have a void return type. Here's an example of an event table.
BEGIN_EVENT_TABLE(MyFrame, wxFrame) EVT_MENU (wxID_EXIT, MyFrame::OnExit) EVT_MENU (DO_TEST, MyFrame::DoTest) EVT_SIZE ( MyFrame::OnSize) EVT_BUTTON (BUTTON1, MyFrame::OnButton1) END_EVENT_TABLE()

The first two entries map menu commands to two different member functions. The EVT_SIZE macro doesn't need a window identifier, since normally you are only interested in the current window's size events. The EVT_BUTTON macro demonstrates that the originating event does not have to come from the window class implementing the event table -- if the event source is a button within a panel within a frame, this will still work, because event tables are searched up through the hierarchy of windows for the command events. In this case, the button's event table will be searched, then the parent panel's, then the frame's. As mentioned before, the member functions that handle events do not have to be virtual. Indeed, the member functions should not be virtual as the event handler ignores that the functions are virtual, i.e. overriding a virtual member function in a derived class will not have any effect. These member functions take an event argument, and the class of event differs according to the type of event and the class of the originating window. For size events, wxSizeEvent (p. 1108) is used. For menu commands and most control commands (such as button presses), wxCommandEvent (p. 164) is used. When controls get more complicated, then specific event classes are used, such as wxTreeEvent (p. 1345) for events from wxTreeCtrl (p. 1327) windows. As well as the event table in the implementation file, there must also be a DECLARE_EVENT_TABLE macro somewhere in the class declaration. For example:
class MyFrame : public wxFrame { public: ... void OnExit(wxCommandEvent& event); void OnSize(wxSizeEvent& event); protected: int ... m_count;

1603


CHAPTER 11

DECLARE_EVENT_TABLE() };

Note that this macro may occur in any section of the class (public, protected or private) but that it is probably better to insert it at the end, as shown, because this macro implicitly changes the access to protected which may be quite unexpected if there is anything following it. Finally, if you don't like using macros for static initialization of the event tables you may also use wxEvtHandler::Connect (p. 444) to connect the events to the handlers dynamically, during run-time. See theevent sample (p. 1564) for an example of doing it.

How events are processed
When an event is received from the windowing system, wxWindows calls wxEvtHandler::ProcessEvent (p. 447) on the first event handler object belonging to the window generating the event. It may be noted that wxWindows' event processing system implements something very close to virtual methods in normal C++, i.e. it is possible to alter the behaviour of a class by overriding its event handling functions. In many cases this works even for changing the behaviour of native controls. For example it is possible to filter out a number of key events sent by the system to a native text control by overriding wxTextCtrl and defining a handler for key events using EVT_KEY_DOWN. This would indeed prevent any key events from being sent to the native control - which might not be what is desired. In this case the event handler function has to call Skip() so as to indicate that the search for the event handler should continue. To summarize, instead of explicitly calling the base class version as you would have done with C++ virtual functions (i.e. wxTextCtrl::OnChar()), you should instead call Skip (p. 443). In practice, this would look like this if the derived text control only accepts 'a' to 'z' and 'A' to 'Z':
void MyTextCtrl::OnChar(wxKeyEvent& event) { if ( isalpha( event.KeyCode() ) ) { // key code is within legal range. we call event.Skip() so the // event can be processed either in the base wxWindows class // or the native control. event.Skip(); } else { // illegal key hit. we don't call event.Skip() so the // event is not processed anywhere else. wxBell(); } }

The normal order of event table searching by ProcessEvent is as follows:

1604


CHAPTER 11
1. 2. 3. If the object is disabled (via a call to wxEvtHandler::SetEvtHandlerEnabled (p. 450)) the function skips to step (6). If the object is a wxWindow, ProcessEvent is recursively called on the window's wxValidator (p. 1358). If this returns true, the function exits. SearchEventTable is called for this event handler. If this fails, the base class table is tried, and so on until no more tables exist or an appropriate function was found, in which case the function exits. The search is applied down the entire chain of event handlers (usually the chain has a length of one). If this succeeds, the function exits. If the object is a wxWindow and the event is set to set to propagate (in the library only wxCommandEvent based events are set to propagate), ProcessEvent is recursively applied to the parent window's event handler. If this returns true, the function exits. Finally, ProcessEvent is called on the wxApp object.

4. 5.

6.

Pay close attention to Step 5. People often overlook or get confused by this powerful feature of the wxWindows event processing system. To put it a different way, events set to propagate (See: wxEvent::ShouldPropagate (p. 443)) (most likely derived either directly or indirectly from wxCommandEvent) will travel up the containment hierarchy from child to parent until the maximal propagation level is reached or an event handler is found that doesn't call event.Skip() (p. 443). Finally, there is another additional complication (which, in fact, simplifies life of wxWindows programmers significantly): when propagating the command events upwards to the parent window, the event propagation stops when it reaches the parent dialog, if any. This means that you don't risk to get unexpected events from the dialog controls (which might be left unprocessed by the dialog itself because it doesn't care about them) when a modal dialog is popped up. The events do propagate beyond the frames, however. The rationale for this choice is that there are only a few frames in a typical application and their parent-child relation are well understood by the programmer while it may be very difficult, if not impossible, to track down all the dialogs which may be popped up in a complex program (remember that some are created automatically by wxWindows). If you need to specify a different behaviour for some reason, you can use SetExtraStyle(wxWS_EX_BLOCK_EVENTS) (p. 1423) explicitly to prevent the events from being propagated beyond the given window or unset this flag for the dialogs which have it on by default. Typically events that deal with a window as a window (size, motion, paint, mouse, keyboard, etc.) are sent only to the window. Events that have a higher level of meaning and/or are generated by the window itself, (button click, menu select, tree expand, etc.) are command events and are sent up to the parent to see if it is interested in the event. Note that your application may wish to override ProcessEvent to redirect processing of events. This is done in the document/view framework, for example, to allow event handlers to be defined in the document or view. To test for command events (which will probably be the only events you wish to redirect), you may use wxEvent::IsCommandEvent (p. 442) for efficiency, instead of using the slower run-time type system.

1605


CHAPTER 11
As mentioned above, only command events are recursively applied to the parents event handler in the libary itself. As this quite often causes confusion for users, here is a list of system events which will NOT get sent to the parent's event handler: wxEvent (p. 439) wxActivateEvent (p. 29) wxCloseEvent (p. 139) wxEraseEvent (p. 438) wxFocusEvent (p. 509) wxKeyEvent (p. 777) wxIdleEvent (p. 726) wxInitDialogEvent (p. 761) wxJoystickEvent (p. 774) wxMenuEvent (p. 907) wxMouseEvent (p. 928) wxMoveEvent (p. 937) wxPaintEvent (p. 967) wxQueryLayoutInfoEvent (p. 1030) wxSizeEvent (p. 1108) wxScrollWinEvent (p. 1097) wxSysColourChangedEvent (p. 1227) wxUpdateUIEvent (p. 1350) The event base class A window or application activation event A close window or end session event An erase background event A window focus event A keypress event An idle event A dialog initialisation event A joystick event A menu event A mouse event A move event A paint event Used to query layout information A size event A scroll event sent by a scrolled window (not a scroll bar) A system colour change event A user interface update event

In some cases, it might be desired by the programmer to get a certain number of system events in a parent window, for example all key events sent to, but not used by, the native controls in a dialog. In this case, a special event handler will have to be written that will override ProcessEvent() in order to pass all events (or any selection of them) to the parent window.

Pluggable event handlers
In fact, you don't have to derive a new class from a window class if you don't want to. You can derive a new class from wxEvtHandler instead, defining the appropriate event table, and then call wxWindow::SetEventHandler (p. 1422) (or, preferably, wxWindow::PushEventHandler (p. 1414)) to make this event handler the object that responds to events. This way, you can avoid a lot of class derivation, and use the same

1606


CHAPTER 11
event handler object to handle events from instances of different classes. If you ever have to call a window's event handler manually, use the GetEventHandler function to retrieve the window's event handler and use that to call the member function. By default, GetEventHandler returns a pointer to the window itself unless an application has redirected event handling using SetEventHandler or PushEventHandler. One use of PushEventHandler is to temporarily or permanently change the behaviour of the GUI. For example, you might want to invoke a dialog editor in your application that changes aspects of dialog boxes. You can grab all the input for an existing dialog box, and edit it 'in situ', before restoring its behaviour to normal. So even if the application has derived new classes to customize behaviour, your utility can indulge in a spot of bodysnatching. It could be a useful technique for on-line tutorials, too, where you take a user through a serious of steps and don't want them to diverge from the lesson. Here, you can examine the events coming from buttons and windows, and if acceptable, pass them through to the original event handler. Use PushEventHandler/PopEventHandler to form a chain of event handlers, where each handler processes a different range of events independently from the other handlers.

Window identifiers
Window identifiers are integers, and are used to uniquely determine window identity in the event system (though you can use it for other purposes). In fact, identifiers do not need to be unique across your entire application just so long as they are unique within a particular context you're interested in, such as a frame and its children. You may use the wxID_OK identifier, for example, on any number of dialogs so long as you don't have several within the same dialog. If you pass wxID_ANY to a window constructor, an identifier will be generated for you automatically by wxWindows. This is useful when you don't care about the exact identifier either because you're not going to process the events from the control being created at all or because you process the events from all controls in one place (in which case you should specify wxID_ANY in the event table or wxEvtHandler::Connect (p. 444) call as well. The automatically generated identifiers are always negative and so will never conflict with the user-specified identifiers which must be always positive. The following standard identifiers are supplied. You can use wxID_HIGHEST to determine the number above which it is safe to define your own identifiers. Or, you can use identifiers below wxID_LOWEST.
#define wxID_ANY #define wxID_LOWEST #define #define #define #define #define #define #define #define #define #define #define #define wxID_OPEN wxID_CLOSE wxID_NEW wxID_SAVE wxID_SAVEAS wxID_REVERT wxID_EXIT wxID_UNDO wxID_REDO wxID_HELP wxID_PRINT wxID_PRINT_SETUP -1 4999 5000 5001 5002 5003 5004 5005 5006 5007 5008 5009 5010 5011

1607


CHAPTER 11
#define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define #define wxID_PREVIEW wxID_ABOUT wxID_HELP_CONTENTS wxID_HELP_COMMANDS wxID_HELP_PROCEDURES wxID_HELP_CONTEXT wxID_CUT wxID_COPY wxID_PASTE wxID_CLEAR wxID_FIND wxID_DUPLICATE wxID_SELECTALL wxID_DELETE wxID_REPLACE wxID_REPLACE_ALL wxID_PROPERTIES wxID_VIEW_DETAILS wxID_VIEW_LARGEICONS wxID_VIEW_SMALLICONS wxID_VIEW_LIST wxID_VIEW_SORTDATE wxID_VIEW_SORTNAME wxID_VIW_SORTSIZE E wxID_VIEW_SORTTYPE wxID_FILE1 wxID_FILE2 wxID_FILE3 wxID_FILE4 wxID_FILE5 wxID_FILE6 wxID_FILE7 wxID_FILE8 wxID_FILE9 wxID_OK wxID_CANCEL wxID_APPLY wxID_YES wxID_NO wxID_STATIC 5012 5013 5014 5015 5016 5017 5030 5031 5032 5033 5034 5035 5036 5037 5038 5039 5040 5041 5042 5043 5044 5045 5046 5047 5048 5050 5051 5052 5053 5054 5055 5056 5057 5058 5100 5101 5102 5103 5104 5105 5999

#define wxID_HIGHEST

Event macros summary
Generic event table macros EVT_CUSTOM(event, id, func) Allows you to add a custom event table entry by specifying the event identifier (such as wxEVT_SIZE), the window identifier, and a member function to call.

EVT_CUSTOM_RANGE(event, id1, id2, func) The same as EVT_CUSTOM, but responds to a range of window identifiers. EVT_COMMAND(id, event, func) The same as EVT_CUSTOM, but expects a member function with a wxCommandEvent argument.

1608


CHAPTER 11
EVT_COMMAND_RANGE(id1, id2, event, func) The same as EVT_CUSTOM_RANGE, but expects a member function with a wxCommandEvent argument. Macros listed by event class The documentation for specific event macros is organised by event class. Please refer to these sections for details. wxActivateEvent (p. 29) The EVT_ACTIVATE and EVT_ACTIVATE_APP macros intercept activation and deactivation events. A range of commonly-used control events. The EVT_CLOSE macro handles window closure called via wxWindow::Close (p. 1393). The EVT_DROP_FILES macros handles file drop events. The EVT_ERASE_BACKGROUND macro is used to handle window erase requests. The EVT_SET_FOCUS and EVT_KILL_FOCUS macros are used to handle keyboard focus events. EVT_CHAR, EVT_KEY_DOWN and EVT_KEY_UP macros handle keyboard input for any window. The EVT_IDLE macro handle application idle events (to process background tasks, for example). The EVT_INIT_DIALOG macro is used to handle dialog initialisation. These macros handle wxListCtrl (p. 799) events. These macros handle special menu events (not menu commands). Mouse event macros can handle either individual mouse events or all mouse events. The EVT_MOVE macro is used to handle

wxCommandEvent (p. 164) wxCloseEvent (p. 139)

wxDropFilesEvent (p. 425) wxEraseEvent (p. 438)

wxFocusEvent (p. 509)

wxKeyEvent (p. 777)

wxIdleEvent (p. 726)

wxInitDialogEvent (p. 761) wxListEvent (p. 818) wxMenuEvent (p. 907) wxMouseEvent (p. 928)

wxMoveEvent (p. 937)

1609


CHAPTER 11
a window move. wxPaintEvent (p. 967) wxScrollEvent (p. 1094) The EVT_PAINT macro is used to handle window paint requests. These macros are used to handle scroll events from wxScrollBar (p. 1079), wxSlider (p. 1121),and wxSpinButton (p. 1154). The EVT_SIZE macro is used to handle a window resize. The EVT_SPLITTER_SASH_POS_CHANGE D, EVT_SPLITTER_UNSPLIT and EVT_SPLITTER_DCLICK macros are used to handle the various splitter window events. The EVT_SYS_COLOUR_CHANGED macro is used to handle events informing the application that the user has changed the system colours (Windows only). These macros handle wxTreeCtrl (p. 1327) events. The EVT_UPDATE_UI macro is used to handle user interface update pseudoevents, which are generated to give the application the chance to update the visual state of menus, toolbars and controls.

wxSizeEvent (p. 1108) wxSplitterEvent (p. 1164)

wxSysColourChangedEvent (p. 1227)

wxTreeEvent (p. 1345) wxUpdateUIEvent (p. 1350)

C++ exceptions overview
Introduction
wxWindows had been started long before the exceptions were introduced in C++ so it is not very surprizing that it is not built around using them as some more modern C++ libraries are. For instance, the library doesn't throw exceptions to signal about the errors. Moreover, up to (and including) the version 2.4 of wxWindows, even using the exceptions in the user code was dangerous because the library code wasn't exceptionsafe and so an exception propagating through it could result in memory and/or resource leaks, and also not very convenient. Starting from the version 2.5.1 wxWindows becomes more exception-friendly. It still doesn't use the exceptions by itself but it should be now safe to use the exceptions in the user code and the library tries to help you with this. Please note that making the library

1610


CHAPTER 11
exception-safe is still work in progress.

Strategies for exceptions handling
There are several choice for using the exceptions in wxWindows programs. First of all, you may not use them at all. As stated above, the library doesn't throw any exceptions by itself and so you don't have to worry about exceptions at all unless your own code throws them. This is, of course, the simplest solution but may be not the best one to deal with all possible errors. Another strategy is to use exceptions only to signal truly fatal errors. In this case you probably don't expect to recover from them and the default behaviour -- to simply terminate the program -- may be appropriate. If it is not, you may override OnUnhandledException() (p. 38) in your wxApp-derived class to perform any clean up tasks. Note, however, that any information about the exact exception type is lost when this function is called, so if you need you should override OnRun() (p. 38) and add a try/catch clause around the call of the base class version. This would allow you to catch any exceptions generated during the execution of the main event loop. To deal with the exceptions which may arise during the program startup and/or shutdown you should insert try/catch clauses in OnInit() (p. 36) and/or OnExit() (p. 36) as well. Finally, you may also want to continue running even when certain exceptions occur. If all of your exceptions may happen only in the event handlers of a single class (or only in the classes derived from it), you may centralize your exception handling code in ProcessEvent (p. 447) method of this class. If this is impractical, you may also consider overriding the wxApp::HandleEvent() (p. 41) which allows you to handle all the exceptions thrown by any event handler.

Technicalities
To use any kind of exception support in the library you need to build it with wxUSE_EXCEPTIONS set to 1. This should be the case by default but if it isn't, you should edit the include/wx/msw/setup.h file under Windows or run configure with --enable-exceptions argument under Unix. On the other hand, if you do not plan to use exceptions, setting this flag to 0 or using -disable-exceptions could result in a leaner and slightly faster library. As for any other library feature, there is a sample (p. 1564) showing how to use it. Please look at its sources for further information.

Window styles
Window styles are used to specify alternative behaviour and appearances for windows, when they are created. The symbols are defined in such as way that they can be combined in a 'bit-list' using the C++ bitwise-or operator. For example:
wxCAPTION | wxMINIMIZE_BOX | wxMAXIMIZE_BOX | wxTHICK_FRAME

1611


CHAPTER 11
For the window styles specific to each window class, please see the documentation for the window. Most windows can use the generic styles listed for wxWindow (p. 1386) in addition to their own styles.

Window deletion overview
Classes: wxCloseEvent (p. 139), wxWindow (p. 1386) Window deletion can be a confusing subject, so this overview is provided to help make it clear when and how you delete windows, or respond to user requests to close windows. What is the sequence of events in a window deletion? When the user clicks on the system close button or system close command, in a frame or a dialog, wxWindows calls wxWindow::Close (p. 1393). This in turn generates an EVT_CLOSE event: see wxCloseEvent (p. 139). It is the duty of the application to define a suitable event handler, and decide whether or not to destroy the window. If the application is for some reason forcing the application to close (wxCloseEvent::CanVeto (p. 140) returns false), the window should always be destroyed, otherwise there is the option to ignore the request, or maybe wait until the user has answered a question before deciding whether it is safe to close. The handler for EVT_CLOSE should signal to the calling code if it does not destroy the window, by calling wxCloseEvent::Veto (p. 141). Calling this provides useful information to the calling code. The wxCloseEvent handler should only call wxWindow::Destroy (p. 1395) to delete the window, and not use the delete operator. This is because for some window classes, wxWindows delays actual deletion of the window until all events have been processed, since otherwise there is the danger that events will be sent to a non-existent window. As reinforced in the next section, calling Close does not guarantee that the window will be destroyed. Call wxWindow::Destroy (p. 1395) if you want to be certain that the window is destroyed. How can the application close a window itself? Your application can either use wxWindow::Close (p. 1393) event just as the framework does, or it can call wxWindow::Destroy (p. 1395) directly. If using Close(), you can pass a true argument to this function to tell the event handler that we definitely want to delete the frame and it cannot be vetoed. The advantage of using Close instead of Destroy is that it will call any clean-up code defined by the EVT_CLOSE handler; for example it may close a document contained in a window after first asking the user whether the work should be saved. Close can be vetoed by this process (return false), whereas Destroy definitely destroys the window. What is the default behaviour? The default close event handler for wxDialog simulates a Cancel command, generating a wxID_CANCEL event. Since the handler for this cancel event might itself call Close, there is a check for infinite looping. The default handler for wxID_CANCEL hides the

1612


CHAPTER 11
dialog (if modeless) or calls EndModal(wxID_CANCEL) (if modal). In other words, by default, the dialog is not destroyed (it might have been created on the stack, so the assumption of dynamic creation cannot be made). The default close event handler for wxFrame destroys the frame using Destroy().What should I do when the user calls up Exit from a menu? You can simply call wxWindow::Close (p. 1393) on the frame. This will invoke your own close event handler which may destroy the frame. You can do checking to see if your application can be safely exited at this point, either from within your close event handler, or from within your exit menu command handler. For example, you may wish to check that all files have been saved. Give the user a chance to save and quit, to not save but quit anyway, or to cancel the exit command altogether. What should I do to upgrade my 1.xx OnClose to 2.0? In wxWindows 1.xx, the OnClose function did not actually delete 'this', but signaled to the calling function (either Close, or the wxWindows framework) to delete or not delete the window. To update your code, you should provide an event table entry in your frame or dialog, using the EVT_CLOSE macro. The event handler function might look like this:
void MyFrame::OnCloseWindow(wxCloseEvent& event) { if (MyDataHasBeenModified()) { wxMessageDialog* dialog = new wxMessageDialog(this, "Save changed data?", "My app", wxYES_NO|wxCANCEL); int ans = dialog->ShowModal(); dialog->Destroy(); switch (ans) { case wxID_YES: // Save, then destroy, quitting app SaveMyData(); this->Destroy(); break; case wxID_NO: // Don't save; just destroy, quitting app this->Destroy(); break; case wxID_CANCEL: // Do nothing - so don't quit app. default: if (!event.CanVeto()) // Test if we can veto this deletion this->Destroy(); // If not, destroy the window anyway. else event.Veto(); // Notify the calling code that we didn't delete the frame. break; } } }

How do I exit the application gracefully? A wxWindows application automatically exits when the designated top window, or the last frame or dialog, is destroyed. Put any application-wide cleanup code in wxApp::OnExit (p. 36) (this is a virtual function, not an event handler).

1613


CHAPTER 11
Do child windows get deleted automatically? Yes, child windows are deleted from within the parent destructor. This includes any children that are themselves frames or dialogs, so you may wish to close these child frame or dialog windows explicitly from within the parent close handler. What about other kinds of window? So far we've been talking about 'managed' windows, i.e. frames and dialogs. Windows with parents, such as controls, don't have delayed destruction and don't usually have close event handlers, though you can implement them if you wish. For consistency, continue to use the wxWindow::Destroy (p. 1395) function instead of the delete operator when deleting these kinds of windows explicitly.

wxDialog overview
Classes: wxDialog (p. 367) A dialog box is similar to a panel, in that it is a window which can be used for placing controls, with the following exceptions: 1. 2. 3. A surrounding frame is implicitly created. Extra functionality is automatically given to the dialog box, such as tabbing between items (currently Windows only). If the dialog box is modal, the calling program is blocked until the dialog box is dismissed.

Under Windows 3, modal dialogs have to be emulated using modeless dialogs and a message loop. This is because Windows 3 expects the contents of a modal dialog to be loaded from a resource file or created on receipt of a dialog initialization message. This is too restrictive for wxWindows, where any window may be created and displayed before its contents are created. For a set of dialog convenience functions, including file selection, see Dialog functions (p. 1489). See also wxPanel (p. 972) and wxWindow (p. 1386) for inherited member functions. Validation of data in controls is covered in Validator overview (p. 1614).

wxValidator overview
Classes: wxValidator (p. 1358), wxTextValidator (p. 1281), wxGenericValidator (p. 564) The aim of the validator concept is to make dialogs very much easier to write. A validator is an object that can be plugged into a control (such as a wxTextCtrl), and mediates between C++ data and the control, transferring the data in either direction and validating it. It also is able to intercept events generated by the control, providing filtering behaviour without the need to derive a new control class.

1614


CHAPTER 11
You can use a stock validator, such as wxTextValidator (p. 1281) (which does text control data transfer, validation and filtering) and wxGenericValidator (p. 564) (which does data transfer for a range of controls); or you can write your own. Example Here is an example of wxTextValidator usage.
wxTextCtrl *txt1 = new wxTextCtrl(this, -1, wxT(""), wxPoint(10, 10), wxSize(100, 80), 0, wxTextValidator(wxFILTER_ALPHA, &g_data.m_string));

In this example, the text validator object provides the following functionality: 1. 2. 3. It transfers the value of g_data.m_string (a wxString variable) to the wxTextCtrl when the dialog is initialised. It transfers the wxTextCtrl data back to this variable when the dialog is dismissed. It filters input characters so that only alphabetic characters are allowed.

The validation and filtering of input is accomplished in two ways. When a character is input, wxTextValidator checks the character against the allowed filter flag (wxFILTER_ALPHA in this case). If the character is inappropriate, it is vetoed (does not appear) and a warning beep sounds. The second type of validation is performed when the dialog is about to be dismissed, so if the default string contained invalid characters already, a dialog box is shown giving the error, and the dialog is not dismissed. Anatomy of a validator A programmer creating a new validator class should provide the following functionality. A validator constructor is responsible for allowing the programmer to specify the kind of validation required, and perhaps a pointer to a C++ variable that is used for storing the data for the control. If such a variable address is not supplied by the user, then the validator should store the data internally. The wxValidator::Validate (p. 1360) member function should return true if the data in the control (not the C++ variable) is valid. It should also show an appropriate message if data was not valid. The wxValidator::TransferToWindow (p. 1359) member function should transfer the data from the validator or associated C++ variable to the control. The wxValidator::TransferFromWindow (p. 1359) member function should transfer the data from the control to the validator or associated C++ variable. There should be a copy constructor, and a wxValidator::Clone (p. 1359) function which returns a copy of the validator object. This is important because validators are passed by reference to window constructors, and must therefore be cloned internally. You can optionally define event handlers for the validator, to implement filtering. These handlers will capture events before the control itself does.

1615


CHAPTER 11
For an example implementation, see the valtext.h and valtext.cpp files in the wxWindows library. How validators interact with dialogs For validators to work correctly, validator functions must be called at the right times during dialog initialisation and dismissal. When a wxDialog::Show (p. 375) is called (for a modeless dialog) or wxDialog::ShowModal (p. 375) is called (for a modal dialog), the function wxWindow::InitDialog (p. 1409) is automatically called. This in turn sends an initialisation event to the dialog. The default handler for the wxEVT_INIT_DIALOG event is defined in the wxWindow class to simply call the function wxWindow::TransferDataToWindow (p. 1433). This function finds all the validators in the window's children and calls the TransferToWindow function for each. Thus, data is transferred from C++ variables to the dialog just as the dialog is being shown. If you are using a window or panel instead of a dialog, you will need to call wxWindow::InitDialog (p. 1409) explicitly before showing the window. When the user clicks on a button, for example the OK button, the application should first call wxWindow::Validate (p. 1435), which returns false if any of the child window validators failed to validate the window data. The button handler should return immediately if validation failed. Secondly, the application should call wxWindow::TransferDataFromWindow (p. 1433) and return if this failed. It is then safe to end the dialog by calling EndModal (if modal) or Show (if modeless). In fact, wxDialog contains a default command event handler for the wxID_OK button. It goes like this:
void wxDialog::OnOK(wxCommandEvent& event) { if ( Validate() && TransferDataFromWindow() ) { if ( IsModal() ) EndModal(wxID_OK); else { SetReturnCode(wxID_OK); this->Show(false); } } }

So if using validators and a normal OK button, you may not even need to write any code for handling dialog dismissal. If you load your dialog from a resource file, you will need to iterate through the controls setting validators, since validators can't be specified in a dialog resource.

Constraints overview
Classes: wxLayoutConstraints (p. 784), wxIndividualLayoutConstraint (p. 758). Note: constraints are now deprecated and you should use sizers (p. 1620) instead.

1616


CHAPTER 11
Objects of class wxLayoutConstraint can be associated with a window to define the way it is laid out, with respect to its siblings or the parent. The class consists of the following eight constraints of class wxIndividualLayoutConstraint, some or all of which should be accessed directly to set the appropriate constraints.         left: represents the left hand edge of the window right: represents the right hand edge of the window top: represents the top edge of the window bottom: represents the bottom edge of the window width: represents the width of the window height: represents the height of the window centreX: represents the horizontal centre point of the window centreY: represents the vertical centre point of the window

The constraints are initially set to have the relationship wxUnconstrained, which means that their values should be calculated by looking at known constraints. To calculate the position and size of the control, the layout algorithm needs to know exactly 4 constraints (as it has 4 numbers to calculate from them), so you should always set exactly 4 of the constraints from the above table. If you want the controls height or width to have the default value, you may use a special value for the constraint: wxAsIs. If the constraint is wxAsIs, the dimension will not be changed which is useful for the dialog controls which often have the default size (e.g. the buttons whose size is determined by their label). The constrains calculation is done in wxWindow::Layout (p. 1410) function which evaluates constraints. To call it you can either callwxWindow::SetAutoLayout (p. 1419) if the parent window is a frame, panel or a dialog to tell default OnSize handlers to call Layout automatically whenever the window size changes, or override OnSize and call Layout yourself (note that you do have to call Layout (p. 1410) yourself if the parent window is not a frame, panel or dialog).

Constraint layout: more detail
By default, windows do not have a wxLayoutConstraints object. In this case, much layout must be done explicitly, by performing calculations in OnSize members, except for the case of frames that have exactly one subwindow (not counting toolbar and statusbar which are also positioned by the frame automatically), where wxFrame::OnSize takes care of resizing the child to always fill the frame. To avoid the need for these rather awkward calculations, the user can create a wxLayoutConstraints object and associate it with a window with wxWindow::SetConstraints. This object contains a constraint for each of the window

1617


CHAPTER 11
edges, two for the centre point, and two for the window size. By setting some or all of these constraints appropriately, the user can achieve quite complex layout by defining relationships between windows. In wxWindows, each window can be constrained relative to either its siblings on the same window, or the parent. The layout algorithm therefore operates in a top-down manner, finding the correct layout for the children of a window, then the layout for the grandchildren, and so on. Note that this differs markedly from native Motif layout, where constraints can ripple upwards and can eventually change the frame window or dialog box size. We assume in wxWindows that the user is always 'boss' and specifies the size of the outer window, to which subwindows must conform. Obviously, this might be a limitation in some circumstances, but it suffices for most situations, and the simplification avoids some of the nightmarish problems associated with programming Motif. When the user sets constraints, many of the constraints for windows edges and dimensions remain unconstrained. For a given window, the wxWindow::Layout algorithm first resets all constraints in all children to have unknown edge or dimension values, and then iterates through the constraints, evaluating them. For unconstrained edges and dimensions, it tries to find the value using known relationships that always hold. For example, an unconstrained width may be calculated from the left and right edges, if both are currently known. For edges and dimensions with user-supplied constraints, these constraints are evaluated if the inputs of the constraint are known. The algorithm stops when all child edges and dimension are known (success), or there are unknown edges or dimensions but there has been no change in this cycle (failure). It then sets all the window positions and sizes according to the values it has found. Because the algorithm is iterative, the order in which constraints are considered is irrelevant, however you may reduce the number of iterations (and thus speed up the layout calculations) by creating the controls in such order that as many constraints as possible can be calculated during the first iteration. For example, if you have 2 buttons which you'd like to position in the lower right corner, it is slightly more efficient to first create the second button and specify that its right border IsSameAs(parent, wxRight) and then create the first one by specifying that it should be LeftOf() the second one than to do in a more natural left-to-right order.

Window layout examples Example 1: subwindow layout
This example specifies a panel and a window side by side, with a text subwindow below it.
frame->panel = new wxPanel(frame, -1, wxPoint(0, 0), wxSize(1000, 500), 0); frame->scrollWindow = new MyScrolledWindow(frame, -1, wxPoint(0, 0), wxSize(400, 400), wxRETAINED); frame->text_window = new MyTextWindow(frame, -1, wxPoint(0, 250), wxSize(400, 250)); // Set constraints for panel subwindow wxLayoutConstraints *c1 = new wxLayoutConstraints;

1618


CHAPTER 11
c1->left.SameAs c1->top.SameAs c1->right.PercentOf c1->height.PercentOf (frame, (frame, (frame, (frame, wxLeft); wxTop); wxWidth, 50); wxHeight, 50);

frame->panel->SetConstraints(c1); // Set constraints for scrollWindow subwindow wxLayoutConstraints *c2 = new wxLayoutConstraints; c2->left.SameAs c2->top.SameAs c2->right.SameAs c2->height.PercentOf (frame->panel, wxRight); (frame, wxTop); (frame, wxRight); (frame, wxHeight, 50);

frame->scrollWindow->SetConstraints(c2); // Set constraints for text subwindow wxLayoutConstraints *c3 = new wxLayoutConstraints; c3->left.SameAs (frame, wxLeft); c3->top.Below (frame->panel); c3->right.SameAs (frame, wxRight); c3->bottom.SameAs (frame, wxBottom); frame->text_window->SetConstraints(c3);

Example 2: panel item layout
This example sizes a button width to 80 percent of the panel width, and centres it horizontally. A listbox and multitext item are placed below it. The listbox takes up 40 percent of the panel width, and the multitext item takes up the remainder of the width. Margins of 5 pixels are used.
// Create some panel items wxButton *btn1 = new wxButton(frame->panel, -1, "A button") ; wxLayoutConstraints *b1 = new wxLayoutConstraints; b1->centreX.SameAs (frame->panel, wxCentreX); b1->top.SameAs (frame->panel, wxTop, 5); b1->width.PercentOf (frame->panel, wxWidth, 80); b1->height.PercentOf (frame->panel, wxHeight, 10); btn1->SetConstraints(b1); wxListBox *list = new wxListBox(frame->panel, -1, "A list", wxPoint( 1, -1), wxSize(200, 100)); wxLayoutConstraints *b2 = new wxLayoutConstraints; b2->top.Below (btn1, 5); b2->left.SameAs (frame->panel, wxLeft, 5); b2->width.PercentOf (frame->panel, wxWidth, 40); b2->bottom.SameAs (frame->panel, wxBottom, 5); list->SetConstraints(b2); wxTextCtrl *mtext = new wxTextCtrl(frame->panel, -1, "Multiline text", "Some text", wxPoint(-1, -1), wxSize(150, 100), wxTE_MULTILINE); wxLayoutConstraints *b3 = new wxLayoutConstraints; b3->top.Below (btn1, 5); b3->left.RightOf (list, 5); b3->right.SameAs (frame->panel, wxRight, 5); b3->bottom.SameAs (frame->panel, wxBottom, 5); mtext->SetConstraints(b3);

1619


CHAPTER 11

Sizer overview
Classes: wxSizer (p. 1109), wxGridSizer (p. 633), wxFlexGridSizer (p. 506), wxBoxSizer (p. 89), wxStaticBoxSizer (p. 1180), wxNotebookSizer (p. 952),CreateButtonSizer (p. 1627) Sizers, as represented by the wxSizer class and its descendants in the wxWindows class hierarchy, have become the method of choice to define the layout of controls in dialogs in wxWindows because of their ability to create visually appealing dialogs independent of the platform, taking into account the differences in size and style of the individual controls. Unlike the original wxWindows Dialog Editor, editors such as wxDesigner, DialogBlocks, wxrcedit, XRCed and wxWorkshop create dialogs based exclusively on sizers, practically forcing the user to create platform independent layouts without compromises. The next section describes and shows what can be done with sizers. The following sections briefly describe how to program with individual sizer classes. For information about the new wxWindows resource system, which can describe sizerbased dialogs, see the XML-based resource system overview (p. 1627).

The idea behind sizers
The layout algorithm used by sizers in wxWindows is closely related to layout systems in other GUI toolkits, such as Java's AWT, the GTK toolkit or the Qt toolkit. It is based upon the idea of individual subwindows reporting their minimal required size and their ability to get stretched if the size of the parent window has changed. This will most often mean that the programmer does not set the start-up size of a dialog, the dialog will rather be assigned a sizer and this sizer will be queried about the recommended size. This sizer in turn will query its children (which can be normal windows, empty space or other sizers) so that a hierarchy of sizers can be constructed. Note that wxSizer does not derive from wxWindow and thus does not interfere with tab ordering and requires very few resources compared to a real window on screen. What makes sizers so well fitted for use in wxWindows is the fact that every control reports its own minimal size and the algorithm can handle differences in font sizes or different window (dialog item) sizes on different platforms without problems. For example, if the standard font as well as the overall design of Linux/GTK widgets requires more space than on Windows, the initial dialog size will automatically be bigger on Linux/GTK than on Windows. There are currently five different kinds of sizers available in wxWindows. Each represents either a certain way to lay out dialog items in a dialog or it fulfils a special task such as wrapping a static box around a dialog item (or another sizer). These sizers will be discussed one by one in the text below. For more detailed information on how to use sizers programmatically, please refer to the section Programming with Sizers (p. 1624).

Common features
All sizers are containers, that is, they are used to lay out one dialog item (or several

1620


CHAPTER 11
dialog items), which they contain. Such items are sometimes referred to as the children of the sizer. Independent of how the individual sizers lay out their children, all children have certain features in common: A minimal size: This minimal size is usually identical to the initial size of the controls and may either be set explicitly in the wxSize field of the control constructor or may be calculated by wxWindows, typically by setting the height and/or the width of the item to 1. Note that only some controls can calculate their size (such as a checkbox) whereas others (such as a listbox) don't have any natural width or height and thus require an explicit size. Some controls can calculate their height, but not their width (e.g. a single line text control):

A border: The border is just empty space and is used to separate dialog items in a dialog. This border can either be all around, or at any combination of sides such as only above and below the control. The thickness of this border must be set explicitly, typically 5 points. The following samples show dialogs with only one dialog item (a button) and a border of 0, 5, and 10 pixels around the button:

1621


CHAPTER 11

An alignment: Often, a dialog item is given more space than its minimal size plus its border. Depending on what flags are used for the respective dialog item, the dialog item can be made to fill out the available space entirely, i.e. it will grow to a size larger than the minimal size, or it will be moved to either the centre of the available space or to either side of the space. The following sample shows a listbox and three buttons in a horizontal box sizer; one button is centred, one is aligned at the top, one is aligned at the bottom:

A stretch factor: If a sizer contains more than one child and it is offered more space than its children and their borders need, the question arises how to distribute the surplus space among the children. For this purpose, a stretch factor may be assigned to each child, where the default value of 0 indicates that the child will not get more space than its requested minimum size. A value of more than zero is interpreted in relation to the sum of all stretch factors in the children of the respective sizer, i.e. if two children get a stretch factor of 1, they will get half the extra space each independent of whether one control has a minimal sizer inferior to the other or not. The following sample shows a dialog with three buttons, the first one has a stretch factor of 1 and thus gets stretched, whereas the other two buttons have a stretch factor of zero and keep their initial width:

Within wxDesigner, this stretch factor gets set from the Option menu.

Hiding controls using sizers
You can hide controls contained in sizers the same way you would hide any control, using the wxWindow::Show (p. 1432) method. However, wxSizer also offers a separate method which can tell the sizer not to consider that control in its size calculations. To hide a window using the sizer, call wxSizer::Show (p. 1116). You must then call Layout on the sizer to force an update.

1622


CHAPTER 11
This is useful when hiding parts of the interface, since you can avoid removing the controls from the sizer and having to add them back later. Note: This is supported only by wxBoxSizer and wxFlexGridSizer. wxBoxSizer wxBoxSizer (p. 89) can lay out its children either vertically or horizontally, depending on what flag is being used in its constructor. When using a vertical sizer, each child can be centered, aligned to the right or aligned to the left. Correspondingly, when using a horizontal sizer, each child can be centered, aligned at the bottom or aligned at the top. The stretch factor described in the last paragraph is used for the main orientation, i.e. when using a horizontal box sizer, the stretch factor determines how much the child can be stretched horizontally. The following sample shows the same dialog as in the last sample, only the box sizer is a vertical box sizer now:

wxStaticBoxSizer wxStaticBoxSixer (p. 1180) is the same as a wxBoxSizer, but surrounded by a static box. Here is a sample:

wxGridSizer wxGridSizer (p. 633) is a two-dimensional sizer. All children are given the same size, which is the minimal size required by the biggest child, in this case the text control in the left bottom border. Either the number of columns or the number or rows is fixed and the grid sizer will grow in the respectively other orientation if new children are added:

1623


CHAPTER 11

For programming information, see wxGridSizer (p. 633). wxFlexGridSizer Another two-dimensional sizer derived from wxGridSizer. The width of each column and the height of each row are calculated individually according the minimal requirements from the respectively biggest child. Additionally, columns and rows can be declared to be stretchable if the sizer is assigned a size different from that which it requested. The following sample shows the same dialog as the one above, but using a flex grid sizer:

wxNotebookSizer wxNotebookSizer (p. 952) can be used with notebooks. It calculates the size of each notebook page and sets the size of the notebook to the size of the biggest page plus some extra space required for the notebook tabs and decorations.

Programming with wxBoxSizer
The basic idea behind a wxBoxSizer (p. 89) is that windows will most often be laid out in rather simple basic geometry, typically in a row or a column or several hierarchies of either. As an example, we will construct a dialog that will contain a text field at the top and two buttons at the bottom. This can be seen as a top-hierarchy column with the text at the top and buttons at the bottom and a low-hierarchy row with an OK button to the left and a Cancel button to the right. In many cases (particularly dialogs under Unix and normal

1624


CHAPTER 11
frames) the main window will be resizable by the user and this change of size will have to get propagated to its children. In our case, we want the text area to grow with the dialog, whereas the button shall have a fixed size. In addition, there will be a thin border around all controls to make the dialog look nice and - to make matter worse - the buttons shall be centred as the width of the dialog changes. It is the unique feature of a box sizer, that it can grow in both directions (height and width) but can distribute its growth in the main direction (horizontal for a row) unevenly among its children. In our example case, the vertical sizer is supposed to propagate all its height changes to only the text area, not to the button area. This is determined by the proportion parameter when adding a window (or another sizer) to a sizer. It is interpreted as a weight factor, i.e. it can be zero, indicating that the window may not be resized at all, or above zero. If several windows have a value above zero, the value is interpreted relative to the sum of all weight factors of the sizer, so when adding two windows with a value of 1, they will both get resized equally much and each half as much as the sizer owning them. Then what do we do when a column sizer changes its width? This behaviour is controlled by flags (the second parameter of the Add() function): Zero or no flag indicates that the window will preserve it is original size, wxGROW flag (same as wxEXPAND) forces the window to grow with the sizer, and wxSHAPED flag tells the window to change it is size proportionally, preserving original aspect ratio. When wxGROW flag is not used, the item can be aligned within available space. wxALIGN_LEFT, wxALIGN_TOP, wxALIGN_RIGHT, wxALIGN_BOTTOM, wxALIGN_CENTER_HORIZONTAL and wxALIGN_CENTER_VERTICAL do what they say. wxALIGN_CENTRE (same as wxALIGN_CENTER) is defined as (wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL). Default alignment is wxALIGN_LEFT | wxALIGN_TOP. As mentioned above, any window belonging to a sizer may have border, and it can be specified which of the four sides may have this border, using the wxTOP, wxLEFT, wxRIGHT and wxBOTTOM constants or wxALL for all directions (and you may also use wxNORTH, wxWEST etc instead). These flags can be used in combination with the alignment flags above as the second parameter of the Add() method using the binary or operator |. The sizer of the border also must be made known, and it is the third parameter in the Add() method. This means, that the entire behaviour of a sizer and its children can be controlled by the three parameters of the Add() method.
// we want to get a dialog that is stretchable because it // has a text ctrl at the top and two buttons at the bottom MyDialog::MyDialog(wxFrame *parent, wxWindowID id, const wxString &title ) : wxDialog(parent, id, title, wxDefaultPosition, wxDefaultSize, wxDEFAULT_DIALOG_STYLE | wxRESIZE_BORDER) { wxBoxSizer *topsizer = new wxBoxSizer( wxVERTICAL ); // create text ctrl with minimal size 100x60 topsizer >Add( new wxTextCtrl( this, -1, "My text.", wxDefaultPosition, wxSize(100,60), wxTE_MULTILINE), 1, // make vertically stretchable wxEXPAND | // make horizontally stretchable wxALL, // and make border all around 10 ); // set border width to 10 wxBoxSizer *button_sizer = new wxBoxSizer( wxHORIZONTAL ); button_sizer->Add( new wxButton( this, wxID_OK, "OK" ),

1625


CHAPTER 11
0, // make horizontally unstretchable wxALL, // make border all around (implicit top alignment) 10 ); // set border width to 10 button_sizer->Add( new wxButton( this, wxID_CANCEL, "Cancel" ), 0, // make horizontally unstretchable wxALL, // make border all around (implicit top alignment) 10 ); // set border width to 10 topsizer >Add( button_sizer, 0, // make vertically unstretchable wxALIGN_CENTER ); // no border and centre horizontally SetSizer( topsizer ); // use the sizer for layout // set size hints to honour minimum

topsizer >SetSizeHints( this ); size }

Programming with wxGridSizer
wxGridSizer (p. 633) is a sizer which lays out its children in a two-dimensional table with all table fields having the same size, i.e. the width of each field is the width of the widest child, the height of each field is the height of the tallest child.

Programming with wxFlexGridSizer
wxFlexGridSizer (p. 506) is a sizer which lays out its children in a two-dimensional table with all table fields in one row having the same height and all fields in one column having the same width, but all rows or all columns are not necessarily the same height or width as in the wxGridSizer (p. 633).

Programming with wxNotebookSizer
wxNotebookSizer (p. 952) is a specialized sizer to make sizers work in connection with using notebooks. This sizer is different from any other sizer as you must not add any children to it - instead, it queries the notebook class itself. The only thing this sizer does is to determine the size of the biggest page of the notebook and report an adjusted minimal size to a more toplevel sizer. In order to query the size of notebook page, this page needs to have its own sizer, otherwise the wxNotebookSizer will ignore it. Notebook pages get their sizer by assigning one to them using wxWindow::SetSizer (p. 1430) and setting the auto-layout option to true using wxWindow::SetAutoLayout (p. 1419). Here is one example showing how to add a notebook page that the notebook sizer is aware of:
wxNotebook *notebook = new wxNotebook( &dialog, -1 ); wxNotebookSizer *nbs = new wxNotebookSizer( notebook ); // Add panel as notebook page wxPanel *panel = new wxPanel( notebook, -1 ); notebook->AddPage( panel, "My Notebook Page" ); wxBoxSizer *panelsizer = new wxBoxSizer( wxVERTICAL );

1626


CHAPTER 11
// Add controls to panel and panelsizer here... panel->SetAutoLayout( true ); panel->SetSizer( panelsizer );

Programming with wxStaticBoxSizer
wxStaticBoxSizer (p. 1180) is a sizer derived from wxBoxSizer but adds a static box around the sizer. Note that this static box has to be created separately.

CreateButtonSizer
As a convenience, CreateButtonSizer ( long flags ) can be used to create a standard button sizer in which standard buttons are displayed. The following flags can be passed to this function:
wxYES_NO // Add Yes/No subpanel wxYES // return wxID_YES wxNO // return wxID_NO wxNO_DEFAULT // make the wxNO button the default, otherwise wxYES or wxOK button will be default wxOK // return wxID_OK wxCANCEL // return wxID_CANCEL wxHELP // return wxID_HELP wxFORWARD wxBACKWARD wxSETUP wxMORE // // // // return return return return wxID_FORWARD wxID_BACKWARD wxID_SETUP wxID_MORE

XML-based resource system overview
Classes: wxXmlResource (p. 1447), wxXmlResourceHandler (p. 1452) IMPORTANT NOTE: XRC is not yet a part of the core wxWindows library, so please see the next section for how to compile and link it. Otherwise if you try to use it, you will get link errors. The XML-based resource system, known as XRC, allows user interface elements such as dialogs, menu bars and toolbars, to be stored in text files and loaded into the application at run-time. XRC files can also be compiled into binary XRS files or C++ code (the former makes it possible to store all resources in since file and the latter is useful when you want to embed the resources into the executable). There are several advantages to using XRC resources.   Recompiling and linking an application is not necessary if the resources change. If you use a dialog designers that generates C++ code, it can be hard to reintegrate this into existing C++ code. Separation of resources and code is a more elegant solution.

1627


CHAPTER 11
   You can choose between different alternative resource files at run time, if necessary. The XRC format uses sizers for flexibility, allowing dialogs to be resizable and highly portable. The XRC format is a wxWindows standard, and can be generated or postprocessed by any program that understands it. As it is based on the XML standard, existing XML editors can be used for simple editing purposes.

XRC was written by Vaclav Slavik.

Compiling and using XRC
XRC can be found under the 'contrib' hierarchy, in the following directories:
contrib/src/xrc contrib/include/wx/xrc contrib/samples/xrc contrib/utils/wxrc contrib/utils/wxrcedit ; ; ; ; ; XRC XRC XRC XRC XRC source headers sample resource compiler editor (in progress)

To compile XRC:  Under Windows using VC++, open the contrib/src/xrc/XrcVC.dsw project and compile. Also compile contrib/utils/wxrc using wxBase if you wish to compile resource files. Under Unix, XRC should be configured when you configured wxWindows. Make XRC by changing directory to contrib/src/xrc and type 'make'. Similarly compile contrib/utils/wxrc using wxBase if you wish to compile resource files. Note: there is currently a problem with the wxWindows build system that means that only the static version of library can be built at present.



To use XRC:   Under Windows using VC++, link with wxxrc[d].lib. Under Unix, link with libwxxrc[d].a.

XRC concepts
These are the typical steps for using XRC files in your application.    Include the appropriate headers: normally "wx/xrc/xmlres.h" will suffice; If you are going to use XRS files (p. 1629), install wxFileSystem ZIP handler first with wxFileSystem::AddHandler(new wxZipFSHandler); call wxXmlResource::Get()->InitAllHandlers() from your wxApp::OnInit function, and then call wxXmlResource::Get()>Load("myfile.xrc") to load the resource file;

1628


CHAPTER 11
 to create a dialog from a resource, create it using the default constructor, and then load using for example wxXmlResource::Get()->LoadDialog(&dlg, this, "dlg1"); set up event tables as usual but use the XRCID(str) macro to translate from XRC string names to a suitable integer identifier, for example EVT_MENU(XRCID("quit"), MyFrame::OnQuit).



To create an XRC file, you can use one of the following methods.     Create the file by hand; use wxDesigner (http://www.roebling.de), a commercial dialog designer/RAD tool; use DialogBlocks (http://www.anthemion.co.uk/dialogblocks), a commercial dialog editor; use XRCed (http://xrced.sf.net), a wxPython-based dialog editor that you can find in the wxPython/tools subdirectory of the wxWindows CVS archive; use Glade (http://wxglade.sf.net), a GUI designer written in wxPython. At the moment it can generate Python, C++ and XRC; use wxrcedit (utils/contrib/wxrcedit) (under development); convert WIN32 RC files to XRC with the tool in contrib/utils/convertrc.

  

A complete list of third-party tools that write to XRC can be found at www.wxwindows.org/lnk_tool.htm (http://www.wxwindows.org/lnk_tool.in). It is highly recommended that you use a resource editing tool, since it's fiddly writing XRC files by hand. You can use wxXmlResource::Load (p. 1450) in a number of ways. You can pass an XRC file (XML-based text resource file) or a zip-compressed file (p. 1629) (extension ZIP or XRS) containing other XRC. You can also use embedded C++ resources (p. 1630)

Using binary resource files
To compile binary resource files, use the command-line wxrc utility. It takes one or more file parameters (the input XRC files) and the following switches and options:     -h (--help): show a help message -v (--verbose): show verbose logging information -c (--cpp-code): write C++ source rather than a XRS file -e (--extra-cpp-code): if used together with -c, generates C++ header file

1629


CHAPTER 11
containing class definitions for the windows defined by the XRC file (see special subsection)      -u (--uncompressed): do not compress XML files (C++ only) -g (--gettext): output .po catalog (to stdout, or a file if -o is used) -n (--function) <name>: specify C++ function name (use with -c) -o (--output) <filename>: specify the output file, such as resource.xrs or resource.cpp -l (--list-of-handlers) <filename>: output a list of necessary handlers to this file
For example: % wxrc resource.wrc % wxrc resource.wrc -o resource.wrs % wxrc resource.wrc -v -c -o resource.cpp

Note XRS file is esentially a renamed ZIP archive which means that you can manipulate it with standard ZIP tools. Note that if you are using XRS files, you have to initialize wxFileSystem (p. 492) ZIP handler first! It is a simple thing to do:
#include <wx/filesys.h> #include <wx/fs_zip.h> ... wxFileSystem::AddHandler(new wxZipFSHandler);

Using embedded resources
It is sometimes useful to embed resources in the executable itself instead of loading external file (e.g. when your app is small and consists only of one exe file). XRC provides means to convert resources into regular C++ file that can be compiled and included in the executable. Use the -c switch towxrc utility to produce C++ file with embedded resources. This file will contain a function called InitXmlResource (unless you override this with a command line switch). Use it to load the resource:
extern void InitXMLResource(); // defined in generated file ... wxXmlResource::Get()->InitAllHandlers(); InitXmlResource(); ...

XRC C++ sample
This is the C++ source file (xrcdemo.cpp) for the XRC sample.
#include "wx/wx.h" #include "wx/image.h" #include "wx/xrc/xmlres.h" // the application icon

1630


CHAPTER 11
#if defined(__WXGTK__) || defined(__WXMOTIF__) || defined(__WXMAC__) #include "rc/appicon.xpm" #endif // --------------------------------------------------------------------------// private classes // --------------------------------------------------------------------------// Define a new application type, each program should derive a class from wxApp class MyApp : public wxApp { public: // override base class virtuals // ---------------------------// this one is called on application startup and is a good place for the app // initialization (doing it here and not in the ctor allows to have an error // return: if OnInit() returns false, the application terminates) virtual bool OnInit(); }; // Define a new frame type: this is going to be our main frame class MyFrame : public wxFrame { public: // ctor(s) MyFrame(const wxString& title, const wxPoint& pos, const wxSize& size); // event handlers (these functions should _not_ be virtual) void OnQuit(wxCommandEvent& event); void OnAbout(wxCommandEvent& event); void OnDlg1(wxCommandEvent& event); void OnDlg2(wxCommandEvent& event); private: // any class wishing to process wxWindows events must use this macro DECLARE_EVENT_TABLE() }; // --------------------------------------------------------------------------// event tables and other macros for wxWindows // --------------------------------------------------------------------------BEGIN_EVENT_TABLE(MyFrame, wxFrame) EVT_MENU(XRCID("menu_quit"), MyFrame::OnQuit) EVT_MENU(XRCID("menu_about"), MyFrame::OnAbout) EVT_MENU(XRCID("menu_dlg1"), MyFrame::OnDlg1) EVT_MENU(XRCID("menu_dlg2"), MyFrame::OnDlg2) END_EVENT_TABLE() IMPLEMENT_APP(MyApp) // --------------------------------------------------------------------------// the application class // --------------------------------------------------------------------------// 'Main program' equivalent: the program execution "starts" here bool MyApp::OnInit() { wxImage::AddHandler(new wxGIFHandler); wxXmlResource::Get()->InitAllHandlers(); wxXmlResource::Get()->Load("rc/resource.xrc");

1631


CHAPTER 11

MyFrame *frame = new MyFrame("XML resources demo", wxPoint(50, 50), wxSize(450, 340)); frame->Show(true); return true; } // --------------------------------------------------------------------------// main frame // --------------------------------------------------------------------------// frame constructor MyFrame::MyFrame(const wxString& title, const wxPoint& pos, const wxSize& size) : wxFrame((wxFrame *)NULL, -1, title, pos, size) { SetIcon(wxICON(appicon)); SetMenuBar(wxXmlResource::Get()->LoadMenuBar("mainmenu")); SetToolBar(wxXmlResource::Get()->LoadToolBar(this, "toolbar")); } // event handlers void MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event)) { // true is to force the frame to close Close(true); } void MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event)) { wxString msg; msg.Printf( _T("This is the about dialog of XML resources demo.\n") _T("Welcome to %s"), wxVERSION_STRING); wxMessageBox(msg, "About XML resources demo", wxOK | wxICON_INFORMATION, this); } void MyFrae::OnDlg1(wxCommandEvent& WXUNUSED(event)) m { wxDialog dlg; wxXmlResource::Get()->LoadDialog(&dlg, this, "dlg1"); dlg.ShowModal(); } void MyFrame::OnDlg2(wxCommandEvent& WXUNUSED(event)) { wxDialog dlg; wxXmlResource::Get()->LoadDialog(&dlg, this, "dlg2"); dlg.ShowModal(); }

XRC resource file sample
This is the XML file (resource.xrc) for the XRC sample.
<?xml version="1.0"?> <resource version="2.3.0.1"> <object class="wxMenuBar" name="mainmenu"> <style>wxMB_DOCKABLE</style> <object class="wxMenu" name="menu_file"> <label>_File</label> <style>wxMENU_TEAROFF</style> <object class="wxMenuItem" name="menu_about"> <label>_About...</label>

1632


CHAPTER 11
<bitmap>filesave.gif</bitmap> </object> <object class="separator"/> <object class="wxMenuItem" name="menu_dlg1"> <label>Dialog 1</label> </object> <object class="wxMenuItem" name="menu_dlg2"> <label>Dialog 2</label> </object> <object class="separator"/> <object class="wxMenuItem" name="menu_quit"> <label>E_xit\tAlt-X</label> </object> </object> </object> <object class="wxToolBar" name="toolbar"> <style>wxTB_FLAT|wxTB_DOCKABLE</style> <margins>2,2</margins> <object class="tool" name="menu_open"> <bitmap>fileopen.gif</bitmap> <tooltip>Open catalog</tooltip> </object> <object class="tool" name="menu_save"> <bitmap>filesave.gif</bitmap> <tooltip>Save catalog</tooltip> </object> <object class="tool" name="menu_update"> <bitmap>update.gif</bitmap> <tooltip>Update catalog - synchronize it with sources</tooltip> </object> <separator/> <object class="tool" name="menu_quotes"> <bitmap>quotes.gif</bitmap> <toggle>1</toggle> <tooltip>Display quotes around the string?</tooltip> </object> <object class="separator"/> <object class="tool" name="menu_fuzzy"> <bitmap>fuzzy.gif</bitmap> <tooltip>Toggled if selected string is fuzzy translation</tooltip> <toggle>1</toggle> </object> </object> <object class="wxDialog" name="dlg1"> <object class="wxBoxSizer"> <object class="sizeritem"> <object class="wxBitmapButton"> <bitmap>fuzzy.gif</bitmap> <focus>fileopen.gif</focus> </object> </object> <object class="sizeritem"> <object class="wxPanel"> <object class="wxStaticText"> <label>fdgdfgdfgdfg</label> </object> <style>wxSUNKEN_BORDER</style> </object> <flag>wxALIGN_CENTER</flag> </object> <object class="sizeritem"> <object class="wxButton"> <label>Buttonek</label> </object> <border10d</border> > <flag>wxALL</flag> </object> <object class="sizeritem"> <object class="wxHtmlWindow"> <htmlcode>&lt;h1&gt;Hi,&lt;/h1&gt;man</htmlcode> <size>100,45d</size> </object>

1633


CHAPTER 11
</object> <object class="sizeritem"> <object class="wxNotebook"> <object class="notebookpage"> <object class="wxPanel"> <object class="wxBoxSizer"> <object class="sizeritem"> <object class="wxHtmlWindow"> <htmlcode>Hello, we are inside a &lt;u&gt;NOTEBOOK&lt;/u&gt;...</htmlcode> <size>50,50d</size> </object> <option>1</option> </object> </object> </object> <label>Page</label> </object> <object class="notebookpage"> <object class="wxPanel"> <object class="wxBoxSizer"> <object class="sizeritem"> <object class="wxHtmlWindow"> <htmlcode>Hello, we are inside a &lt;u&gt;NOTEBOOK&lt;/u&gt;...</htmlcode> <size>50,50d</size> </object> </object> </object> </object> <label>Page 2</label> </object> <usenotebooksizer>1</usenotebooksizer> </object> <flag>wxEXPAND</flag> </object> <orient>wxVERTICAL</orient> </object> </object> <object class="wxDialog" name="dlg2"> <object class="wxBoxSizer"> <orient>wxVERTICAL</orient> <object class="sizeritem" name="dfgdfg"> <object class="wxTextCtrl"> <size>200,200d</size> <style>wxTE_MULTILINE|wxSUNKEN_BORDER</style> <value>Hello, this is an ordinary multiline\n textctrl....</value> </object> <option>1</option> <flag>wxEXPAND|wxALL</flag> <border>10</border> </object> <object class="sizeritem"> <object class="wxBoxSizer"> <object class="sizeritem"> <object class="wxButton" name="wxID_OK"> <label>Ok</label> <default>1</default> </object> </object> <object class="sizeritem"> <object class="wxButton" name="wxID_CANCEL"> <label>Cancel</label> </object> <border>10</border> <flag>wxLEFT</flag> </object> </object> <flag>wxLEFT|wxRIGHT|wxBOTTOM|wxALIGN_RIGHT</flag> <border>10</border> </object>

1634


CHAPTER 11
</object> <title>Second testing dialog</title> </object> </resource>

XRC file format
Please see Technical Note 14 (docs/tech/tn0014.txt) in your wxWindows distribution.

C++ header file generation
Using the -e switch together with -c, a C++ header file is written containing class definitions for the GUI windows defined in the XRC file. This code generation can make it easier to use XRC and automate program development. The classes can be used as basis for development, freeing the programmer from dealing with most of the XRC specifities (e.g. XRCCTRL). For each top level window defined in the XRC file a C++ class definition is generated, containing as class members the named widgets of the window. A default constructor for each class is also generated. Inside the constructor all XRC loading is done and all class members representing widgets are initialized. A simple example will help understand how the scheme works. Suppose you have a XRC file defining a top level window TestWnd_Base, which subclasses wxFrame (any other class like wxDialog will do also), and has subwidgets wxTextCtrl A and wxButton B. The XRC file and corresponding class definition in the header file will be something like:
<?xml version="1.0"?> <resource version="2.3.0.1"> <object class="wxFrame" name="TestWnd_Base"> <size>-1,-1</size> <title>Test</title> <object class="wxBoxSizer"> <orient>wxHORIZONTAL</orient> <object class="sizeritem"> <object class="wxTextCtrl" name="A"> <label>Test label</label> </object> </object> <object class="sizeritem"> <object class="wxButton" name="B"> <label>Test button</label> </object> </object> </object> </object> </resource> class TestWnd_Base : public wxFrame { protected: wxTextCtrl* A; wxButton* B; private: void InitWidgetsFromXRC(){ wxXmlResource::Get()->LoadObject(this,NULL,"TestWnd","wxFrame"); A = XRCCTRL(*this,"A",wxTextCtrl);

1635


CHAPTER 11
B = XRCCTRL(*this,"B",wxButton); } public: TestWnd::TestWnd(){ InitWidgetsFromXRC(); } };

The generated window class can be used as basis for the full window class. The class members which represent widgets may be accessed by name instead of usingXRCCTRL every time you wish to reference them (note that they are protected class members), though you must still use XRCID to refer to widget ids in the event table. Example:
#include "resource.h" class TestWnd : public TestWnd_Base { public: TestWnd(){ // A, B already initialised at this point A->SetValue("Updated in TestWnd::TestWnd"); B->SetValue("Nice :)"); } void OnBPressed(wxEvent& event){ Close(); } DECLARE_EVENT_TABLE(); }; BEGIN_EVENT_TABLE(TestWnd,TestWnd_Base) EVT_BUTTON(XRCID("B"),TestWnd::OnBPressed) END_EVENT_TABLE()

Adding new resource handlers
Coming soon.

Scrolling overview
Classes: wxWindow (p. 1386), wxScrolledWindow (p. 1085), wxIcon (p. 716), wxScrollBar (p. 1079). Scrollbars come in various guises in wxWindows. All windows have the potential to show a vertical scrollbar and/or a horizontal scrollbar: it is a basic capability of a window. However, in practice, not all windows do make use of scrollbars, such as a single-line wxTextCtrl. Because any class derived from wxWindow (p. 1386) may have scrollbars, there are functions to manipulate the scrollbars and event handlers to intercept scroll events. But just because a window generates a scroll event, doesn't mean that the window necessarily handles it and physically scrolls the window. The base class wxWindow in fact doesn't have any default functionality to handle scroll events. If you created a wxWindow object with scrollbars, and then clicked on the scrollbars, nothing at all would happen. This is deliberate, because the interpretation of scroll events varies from one

1636


CHAPTER 11
window class to another. wxScrolledWindow (p. 1085) (formerly wxCanvas) is an example of a window that adds functionality to make scrolling really work. It assumes that scrolling happens in consistent units, not different-sized jumps, and that page size is represented by the visible portion of the window. It is suited to drawing applications, but perhaps not so suitable for a sophisticated editor in which the amount scrolled may vary according to the size of text on a given line. For this, you would derive from wxWindow and implement scrolling yourself. wxGrid (p. 569) is an example of a class that implements its own scrolling, largely because columns and rows can vary in size. The scrollbar model The function wxWindow::SetScrollbar (p. 1426) gives a clue about the way a scrollbar is modeled. This function takes the following arguments: orientation position visible range refresh Which scrollbar: wxVERTICAL or wxHORIZONTAL. The position of the scrollbar in scroll units. The size of the visible portion of the scrollbar, in scroll units. The maximum position of the scrollbar. Whether the scrollbar should be repainted.

orientation determines whether we're talking about the built-in horizontal or vertical scrollbar. position is simply the position of the 'thumb' (the bit you drag to scroll around). It is given in scroll units, and so is relative to the total range of the scrollbar. visible gives the number of scroll units that represents the portion of the window currently visible. Normally, a scrollbar is capable of indicating this visually by showing a different length of thumb. range is the maximum value of the scrollbar, where zero is the start position. You choose the units that suit you, so if you wanted to display text that has 100 lines, you would set this to 100. Note that this doesn't have to correspond to the number of pixels scrolled - it is up to you how you actually show the contents of the window. refresh just indicates whether the scrollbar should be repainted immediately or not. An example Let's say you wish to display 50 lines of text, using the same font. The window is sized so that you can only see 16 lines at a time. You would use:
SetScrollbar(wxVERTICAL, 0, 16, 50);

Note that with the window at this size, the thumb position can never go above 50 minus

1637


CHAPTER 11
16, or 34. You can determine how many lines are currently visible by dividing the current view size by the character height in pixels. When defining your own scrollbar behaviour, you will always need to recalculate the scrollbar settings when the window size changes. You could therefore put your scrollbar calculations and SetScrollbar call into a function named AdjustScrollbars, which can be called initially and also from your wxSizeEvent (p. 1108) handler function.

Bitmaps and icons overview
Classes: wxBitmap (p. 67), wxBitmapHandler (p. 85), wxIcon (p. 716), wxCursor (p. 209). The wxBitmap class encapsulates the concept of a platform-dependent bitmap, either monochrome or colour. Platform-specific methods for creating a wxBitmap object from an existing file are catered for, and this is an occasion where conditional compilation will sometimes be required. A bitmap created dynamically or loaded from a file can be selected into a memory device context (instance of wxMemoryDC (p. 881)). This enables the bitmap to be copied to a window or memory device context using wxDC::Blit (p. 348), or to be used as a drawing surface. The wxToolBarSimple class is implemented using bitmaps, and the toolbar demo shows one of the toolbar bitmaps being used for drawing a miniature version of the graphic which appears on the main window. See wxMemoryDC (p. 881) for an example of drawing onto a bitmap. All wxWindows platforms support XPMs for small bitmaps and icons. You may include the XPM inline as below, since it's C code, or you can load it at run-time.
#include "mondrian.xpm"

Sometimes you wish to use a .ico resource on Windows, and XPMs on other platforms (for example to take advantage of Windows' support for multiple icon resolutions). A macro, wxICON (p. 1500), is available which creates an icon using an XPM on the appropriate platform, or an icon resource on Windows.
wxIcon icon(wxICON(mondrian)); // Equivalent to: #if defined(__WXGTK__) || defined(__WXMOTIF__) wxIcon icon(mondrian_xpm); #endif #if defined(__WXMSW__) wxIcon icon("mondrian"); #endif

There is also a corresponding wxBITMAP (p. 1498) macro which allows to create the bitmaps in much the same way as wxICON (p. 1500) creates icons. It assumes that bitmaps live in resources under Windows or OS2 and XPM files under all other platforms

1638


CHAPTER 11
(for XPMs, the corresponding file must be included before this macro is used, of course, and the name of the bitmap should be the same as the resource name under Windows with _xpmsuffix). For example:
// an easy and portable way to create a bitmap wxBitmap bmp(wxBITMAP(bmpname)); // which is roughly equivalent to the following #if defined(__WXMSW__) || defined(__WXPM__) wxBitmap bmp("bmpname", wxBITMAP_TYPE_RESOURCE); #else // Unix wxBitmap bmp(bmpname_xpm, wxBITMAP_TYPE_XPM); #endif

You should always use wxICON and wxBITMAP macros because they work for any platform (unlike the code above which doesn't deal with wxMac, wxX11, ...) and are more short and clear than versions with #ifdefs. Even better, use the same XPMs on all platforms.

Supported bitmap file formats
The following lists the formats handled on different platforms. Note that missing or partially-implemented formats are automatically supplemented by the wxImage (p. 728) to load the data, and then converting it to wxBitmap form. Note that using wxImage is the preferred way to load images in wxWindows, with the exception of resources (XPM-files or native Windows resources). Writing an image format handler for wxImage is also far easier than writing one for wxBitmap, because wxImage has exactly one format on all platforms whereas wxBitmap can store pixel data very differently, depending on colour depths and platform. wxBitmap Under Windows, wxBitmap may load the following formats:     Windows bitmap resource (wxBITMAP_TYPE_BMP_RESOURCE) Windows bitmap file (wxBITMAP_TYPE_BMP) XPM data and file (wxBITMAP_TYPE_XPM) All formats that are supported by the wxImage (p. 728) class.

Under wxGTK, wxBitmap may load the following formats:   XPM data and file (wxBITMAP_TYPE_XPM) All formats that are supported by the wxImage (p. 728) class.

Under wxMotif and wxX11, wxBitmap may load the following formats:    XBM data and file (wxBITMAP_TYPE_XBM) XPM data and file (wxBITMAP_TYPE_XPM) All formats that are supported by the wxImage (p. 728) class.

1639


CHAPTER 11
wxIcon Under Windows, wxIcon may load the following formats:    Windows icon resource (wxBITMAP_TYPE_ICO_RESOURCE) Windows icon file (wxBITMAP_TYPE_ICO) XPM data and file (wxBITMAP_TYPE_XPM)

Under wxGTK, wxIcon may load the following formats:   XPM data and file (wxBITMAP_TYPE_XPM) All formats that are supported by the wxImage (p. 728) class.

Under wxMotif and wxX11, wxIcon may load the following formats:    XBM data and file (wxBITMAP_TYPE_XBM) XPM data and file (wxBITMAP_TYPE_XPM) All formats that are supported by the wxImage (p. 728) class.

wxCursor Under Windows, wxCursor may load the following formats:     Windows cursor resource (wxBITMAP_TYPE_CUR_RESOURCE) Windows cursor file (wxBITMAP_TYPE_CUR) Windows icon file (wxBITMAP_TYPE_ICO) Windows bitmap file (wxBITMAP_TYPE_BMP)

Under wxGTK, wxCursor may load the following formats (in additional to stock cursors):  None (stock cursors only).

Under wxMotif and wxX11, wxCursor may load the following formats:  XBM data and file (wxBITMAP_TYPE_XBM)

Bitmap format handlers
To provide extensibility, the functionality for loading and saving bitmap formats is not implemented in the wxBitmap class, but in a number of handler classes, derived from wxBitmapHandler. There is a static list of handlers which wxBitmap examines when a file load/save operation is requested. Some handlers are provided as standard, but if you have special requirements, you may wish to initialise the wxBitmap class with some extra handlers which you write yourself or receive from a third party.

1640


CHAPTER 11
To add a handler object to wxBitmap, your application needs to include the header which implements it, and then call the static function wxBitmap::AddHandler (p. 71). Note: bitmap handlers are not implemented on all platforms, and new ones rarely need to be implemented since wxImage can be used for loading most formats, as noted earlier.

Device context overview
Classes: wxBufferedDC (p. 98), wxBufferedPaintDC (p. 99), wxDC (p. 347), wxPostScriptDC (p. 991), wxMetafileDC (p. 917), wxMemoryDC (p. 881), wxPrinterDC (p. 1010), wxScreenDC (p. 1072), wxClientDC (p. 133), wxPaintDC (p. 966), wxWindowDC (p. 1436). A wxDC is a device context onto which graphics and text can be drawn. The device context is intended to represent a number of output devices in a generic way, with the same API being used throughout. Some device contexts are created temporarily in order to draw on a window. This is true of wxScreenDC (p. 1072), wxClientDC (p. 133), wxPaintDC (p. 966), and wxWindowDC (p. 1436). The following describes the differences between these device contexts and when you should use them.   wxScreenDC. Use this to paint on the screen, as opposed to an individual window. wxClientDC. Use this to paint on the client area of window (the part without borders and other decorations), but do not use it from within an wxPaintEvent (p. 967). wxPaintDC. Use this to paint on the client area of a window, but only from within a wxPaintEvent (p. 967). wxWindowDC. Use this to paint on the whole area of a window, including decorations. This may not be available on non-Windows platforms.

 

To use a client, paint or window device context, create an object on the stack with the window as argument, for example:
void MyWindow::OnMyCmd(wxCommandEvent& event) { wxClientDC dc(window); DrawMyPicture(dc); }

Try to write code so it is parameterised by wxDC - if you do this, the same piece of code may write to a number of different devices, by passing a different device context. This doesn't work for everything (for example not all device contexts support bitmap drawing) but will work most of the time.

wxFont overview
1641


CHAPTER 11
Class: wxFont (p. 510), wxFontDialog (p. 522) A font is an object which determines the appearance of text, primarily when drawing text to a window or device context. A font is determined by the following parameters (not all of them have to be specified, of course): Point size Family This is the standard way of referring to text size. Supported families are: wxDEFAULT, wxDECORATIVE, wxROMAN, wxSCRIPT, wxSWISS, wxMODERN. wxMODERN is a fixed pitch font; the others are either fixed or variable pitch. The value can be wxNORMAL, wxSLANT or wxITALIC. The value can be wxNORMAL, wxLIGHT or wxBOLD. The value can be true or false. An optional string specifying the actual typeface to be used. If NULL, a default typeface will chosen based on the family. The font encoding (see wxFONTENCODING_XXXconstants and the font overview (p. 1643) for more details)

Style Weight Underlining Face name

Encoding

Specifying a family, rather than a specific typeface name, ensures a degree of portability across platforms because a suitable font will be chosen for the given font family, however it doesn't allow to choose a font precisely as the parameters above don't suffice, in general, to identify all the available fonts and this is where using the native font descriptions may be helpful - see below. Under Windows, the face name can be one of the installed fonts on the user's system. Since the choice of fonts differs from system to system, either choose standard Windows fonts, or if allowing the user to specify a face name, store the family name with any file that might be transported to a different Windows machine or other platform. Note: There is currently a difference between the appearance of fonts on the two platforms, if the mapping mode is anything other than wxMM_TEXT. Under X, font size is always specified in points. Under MS Windows, the unit for text is points but the text is scaled according to the current mapping mode. However, user scaling on a device context will also scale fonts under both environments.

Native font information
An alternative way of choosing fonts is to use the native font description. This is the only acceptable solution if the user is allowed to choose the font using the wxFontDialog (p. 522) because the selected font cannot be described using only the family name and so, if only family name is stored permanently, the user would almost surely see a different font in the program later.

1642


CHAPTER 11
Instead, you should store the value returned by wxFont::GetNativeFontInfoDesc (p. 514) and pass it to wxFont::SetNativeFontInfo (p. 517) later to recreate exactly the same font. Note that the contents of this string depends on the platform and shouldn't be used for any other purpose (in particular, it is not meant to be shown to the user). Also please note that although the native font information is currently implemented for Windows and Unix (GTK+ and Motif) ports only, all the methods are available for all the ports and should be used to make your program work correctly when they are implemented later.

Font encoding overview
wxWindows has support for multiple font encodings starting from release 2.2. By encoding we mean here the mapping between the character codes and the letters. Probably the most well-known encoding is (7 bit) ASCII one which is used almost universally now to represent the letters of the English alphabet and some other common characters. However, it is not enough to represent the letters of foreign alphabets and here other encodings come into play. Please note that we will only discuss 8-bit fonts here and not Unicode (p. 1583). Font encoding support is assured by several classes: wxFont (p. 510) itself, but also wxFontEnumerator (p. 523) and wxFontMapper (p. 526). wxFont encoding support is reflected by a (new) constructor parameter encoding which takes one of the following values (elements of enumeration type wxFontEncoding): wxFONTENCODING_SYSTEM The default encoding of the underlying operating system (notice that this might be a "foreign" encoding for foreign versions of Windows 9x/NT). wxFONTENCODING_DEFAULT The applications default encoding as returned by wxFont::GetDefaultEncoding (p. 514). On program startup, the applications default encoding is the same as wxFONTENCODING_SYSTEM, but may be changed to make all the fonts created later to use it (by default). wxFONTENCODING_ISO8859_1..15 ISO8859 family encodings which are usually used by all non-Microsoft operating systems wxFONTENCODING_KOI8 Standard Cyrillic encoding for the Internet (but see also wxFONTENCODING_ISO8859_5 and wxFONTENCODING_CP1251) wxFONTENCODING_CP1250 wxFONTENCODING_CP1251 wxFONTENCODING_CP1252 Microsoft analogue of ISO8859-2 Microsoft analogue of ISO8859-5 Microsoft analogue of ISO8859-1

As you may see, Microsoft's encoding partly mirror the standard ISO8859 ones, but there are (minor) differences even between ISO8859-1 (Latin1, ISO encoding for Western Europe) and CP1251 (WinLatin1, standard code page for English versions of Windows) and there are more of them for other encodings.

1643


CHAPTER 11
The situation is particularly complicated with Cyrillic encodings for which (more than) three incompatible encodings exist: KOI8 (the old standard, widely used on the Internet), ISO8859-5 (ISO standard for Cyrillic) and CP1251 (WinCyrillic). This abundance of (incompatible) encodings should make it clear that using encodings is less easy than it might seem. The problems arise both from the fact that the standard encodings for the given language (say Russian, which is written in Cyrillic) are different on different platforms and because the fonts in the given encoding might just not be installed (this is especially a problem with Unix, or, in general, non-Win32 systems). To clarify, the wxFontEnumerator (p. 523) class may be used to enumerate both all available encodings and to find the facename(s) in which the given encoding exists. If you can find the font in the correct encoding with wxFontEnumerator then your troubles are over, but, unfortunately, sometimes this is not enough. For example, there is no standard way (that I know of, please tell me if you do!) to find a font on a Windows system for KOI8 encoding (only for WinCyrillic one which is quite different), so wxFontEnumerator (p. 523) will never return one, even if the user has installed a KOI8 font on his system. To solve this problem, a wxFontMapper (p. 526) class is provided. This class stores the mapping between the encodings and the font face names which support them in wxConfig (p. 1600) object. Of course, it would be fairly useless if it tried to determine these mappings by itself, so, instead, it (optionally) ask the user and remember his answers so that the next time the program will automatically choose the correct font. All these topics are illustrated by the font sample (p. 1565); please refer to it and the documentation of the classes mentioned here for further explanations.

wxSplitterWindow overview
Classes: wxSplitterWindow (p. 1166) The following screenshot shows the appearance of a splitter window with a vertical split.

1644


CHAPTER 11

The style wxSP_3D has been used to show a 3D border and 3D sash.

Example
The following fragment shows how to create a splitter window, creating two subwindows and hiding one of them.
splitter = new wxSplitterWindow(this, -1, wxPoint(0, 0), wxSize(400, 400), wxSP_3D); leftWindow = new MyWindow(splitter); leftWindow->SetScrollbars(20, 20, 50, 50); rightWindow = new MyWindow(splitter); rightWindow->SetScrollbars(20, 20, 50, 50); rightWindow->Show(false); splitter >Initialize(leftWindow); // Set this to prevent unsplitting // splitter->SetMinimumPaneSize(20);

The next fragment shows how the splitter window can be manipulated after creation.
void MyFrame::OnSplitVertical(wxCommandEvent& event) { if ( splitter->IsSplit() ) splitter->Unsplit(); leftWindow->Show(true); rightWindow->Show(true); splitter->SplitVertically( leftWindow, rightWindow );

1645


CHAPTER 11
} void MyFrame::OnSplitHorizontal(wxCommandEvent& event) { if ( splitter->IsSplit() ) splitter->Unsplit(); leftWindow->Show(true); rightWindow->Show(true); splitter->SplitHorizontally( leftWindow, rightWindow ); } void MyFrame::OnUnsplit(wxCommandEvent& event) { if ( splitter->IsSplit() ) splitter->Unsplit(); }

wxTreeCtrl overview
Classes: wxTreeCtrl (p. 1327), wxImageList (p. 754) The tree control displays its items in a tree like structure. Each item has its own (optional) icon and a label. An item may be either collapsed (meaning that its children are not visible) or expanded (meaning that its children are shown). Each item in the tree is identified by its itemId which is of opaque data type wxTreeItemId. You can test whether an item is valid by calling wxTreeItemId::IsOk. The items text and image may be retrieved and changed with GetItemText (p. 1336)/SetItemText (p. 1344) and GetItemImage (p. 1336)/SetItemImage (p. 1344). In fact, an item may even have two images associated with it: the normal one and another one for selected state which is set/retrieved with SetItemSelectedImage (p. 1344)/GetItemSelectedImage (p. 1339) functions, but this functionality might be unavailable on some platforms. Tree items have several attributes: an item may be selected or not, visible or not, bold or not. It may also be expanded or collapsed. All these attributes may be retrieved with the corresponding functions: IsSelected (p. 1341), IsVisible (p. 1341), IsBold (p. 1340) and IsExpanded (p. 1341). Only one item at a time may be selected, selecting another one (with SelectItem (p. 1342)) automatically unselects the previously selected one. In addition to its icon and label, a user-specific data structure may be associated with all tree items. If you wish to do it, you should derive a class from wxTreeItemData which is a very simple class having only one function GetId() which returns the id of the item this data is associated with. This data will be freed by the control itself when the associated item is deleted (all items are deleted when the control is destroyed), so you shouldn't delete it yourself (if you do it, you should call SetItemData(NULL) (p. 1343) to prevent the tree from deleting the pointer second time). The associated data may be retrieved with GetItemData() (p. 1335) function. Working with trees is relatively straightforward if all the items are added to the tree at the moment of its creation. However, for large trees it may be very inefficient. To improve the performance you may want to delay adding the items to the tree until the branch containing the items is expanded: so, in the beginning, only the root item is created (with

1646


CHAPTER 11
AddRoot (p. 1330)). Other items are added when EVT_TREE_ITEM_EXPANDING event is received: then all items lying immediately under the item being expanded should be added, but, of course, only when this event is received for the first time for this item otherwise, the items would be added twice if the user expands/collapses/re-expands the branch. The tree control provides functions for enumerating its items. There are 3 groups of enumeration functions: for the children of a given item, for the sibling of the given item and for the visible items (those which are currently shown to the user: an item may be invisible either because its branch is collapsed or because it is scrolled out of view). Child enumeration functions require the caller to give them a cookie parameter: it is a number which is opaque to the caller but is used by the tree control itself to allow multiple enumerations to run simultaneously (this is explicitly allowed). The only thing to remember is that the cookie passed to GetFirstChild (p. 1334) and to GetNextChild (p. 1337) should be the same variable (and that nothing should be done with it by the user code). Among other features of the tree control are: item sorting with SortChildren (p. 1344) which uses the user-defined comparison function OnCompareItems (p. 1341) (by default the comparison is the alphabetic comparison of tree labels), hit testing (determining to which portion of the control the given point belongs, useful for implementing drag-anddrop in the tree) with HitTest (p. 1339) and editing of the tree item labels in place (see EditLabel (p. 1333)). Finally, the tree control has a keyboard interface: the cursor navigation (arrow) keys may be used to change the current selection. <HOME> and <END> are used to go to the first/last sibling of the current item. '+', '-' and '*' expand, collapse and toggle the current branch. Note, however, that <DEL> and <INS> keys do nothing by default, but it is usual to associate them with deleting item from a tree and inserting a new one into it.

wxListCtrl overview
Classes: wxListCtrl (p. 799), wxImageList (p. 754) Sorry, this topic has yet to be written.

wxImageList overview
Classes: wxImageList (p. 754) An image list is a list of images that may have transparent areas. The class helps an application organise a collection of images so that they can be referenced by integer index instead of by pointer. Image lists are used in wxNotebook (p. 943), wxListCtrl (p. 799), wxTreeCtrl (p. 799) and some other control classes.

Common dialogs overview
1647


CHAPTER 11
Classes: wxColourDialog (p. 156), wxFontDialog (p. 522), wxPrintDialog (p. 1002), wxFileDialog (p. 466), wxDirDialog (p. 384), wxTextEntryDialog (p. 1269), wxMessageDialog (p. 914), wxSingleChoiceDialog (p. 1102), wxMultipleChoiceDialog (p. 938) Common dialog classes and functions encapsulate commonly-needed dialog box requirements. They are all 'modal', grabbing the flow of control until the user dismisses the dialog, to make them easy to use within an application. Some dialogs have both platform-dependent and platform-independent implementations, so that if underlying windowing systems that do not provide the required functionality, the generic classes and functions can stand in. For example, under MS Windows, wxColourDialog uses the standard colour selector. There is also an equivalent called wxGenericColourDialog for other platforms, and a macro defines wxColourDialog to be the same as wxGenericColourDialog on non-MS Windows platforms. However, under MS Windows, the generic dialog can also be used, for testing or other purposes.

wxColourDialog overview
Classes: wxColourDialog (p. 156), wxColourData (p. 153) The wxColourDialog presents a colour selector to the user, and returns with colour information. The MS Windows colour selector Under Windows, the native colour selector common dialog is used. This presents a dialog box with three main regions: at the top left, a palette of 48 commonly-used colours is shown. Under this, there is a palette of 16 'custom colours' which can be set by the application if desired. Additionally, the user may open up the dialog box to show a righthand panel containing controls to select a precise colour, and add it to the custom colour palette. The generic colour selector Under non-MS Windows platforms, the colour selector is a simulation of most of the features of the MS Windows selector. Two palettes of 48 standard and 16 custom colours are presented, with the right-hand area containing three sliders for the user to select a colour from red, green and blue components. This colour may be added to the custom colour palette, and will replace either the currently selected custom colour, or the first one in the palette if none is selected. The RGB colour sliders are not optional in the generic colour selector. The generic colour selector is also available under MS Windows; use the name wxGenericColourDialog. Example In the samples/dialogs directory, there is an example of using the wxColourDialog class. Here is an excerpt, which sets various parameters of a wxColourData object, including a grey scale for the custom colours. If the user did not cancel the dialog, the application retrieves the selected colour and uses it to set the background of a window.
wxColourData data;

1648


CHAPTER 11
data.SetChooseFull(true); for (int i = 0; i < 16; i++) { wxColour colour(i*16, i*16, i*16); data.SetCustomColour(i, colour); } wxColourDialog dialog(this, &data); if (dialog.ShowModal() == wxID_OK) { wxColourData retData = dialog.GetColourData(); wxColour col = retData.GetColour(); wxBrush brush(col, wxSOLID); myWindow->SetBackground(brush); myWindow->Clear(); myWindow->Refresh(); }

wxFontDialog overview
Classes: wxFontDialog (p. 522), wxFontData (p. 519) The wxFontDialog presents a font selector to the user, and returns with font and colour information. The MS Windows font selector Under Windows, the native font selector common dialog is used. This presents a dialog box with controls for font name, point size, style, weight, underlining, strikeout and text foreground colour. A sample of the font is shown on a white area of the dialog box. Note that in the translation from full MS Windows fonts to wxWindows font conventions, strikeout is ignored and a font family (such as Swiss or Modern) is deduced from the actual font name (such as Arial or Courier). The full range of Windows fonts cannot be used in wxWindows at present. The generic font selector Under non-MS Windows platforms, the font selector is simpler. Controls for font family, point size, style, weight, underlining and text foreground colour are provided, and a sample is shown upon a white background. The generic font selector is also available under MS Windows; use the name wxGenericFontDialog. In both cases, the application is responsible for deleting the new font returned from calling wxFontDialog::Show (if any). This returned font is guaranteed to be a new object and not one currently in use in the application. Example In the samples/dialogs directory, there is an example of using the wxFontDialog class. The application uses the returned font and colour for drawing text on a canvas. Here is an excerpt:
wxFontData data; data.SetInitialFont(canvasFont); data.SetColour(canvasTextColour); wxFontDialog dialog(this, &data); if (dialog.ShowModal() == wxID_OK)

1649


CHAPTER 11
{ wxFontData retData = dialog.GetFontData(); canvasFont = retData.GetChosenFont(); canvasTextColour = retData.GetColour(); myWindow->Refresh(); }

wxPrintDialog overview
Classes: wxPrintDialog (p. 1002), wxPrintData (p. 996) This class represents the print and print setup common dialogs. You may obtain a wxPrinterDC (p. 1010) device context from a successfully dismissed print dialog. The samples/printing example shows how to use it: see Printing overview (p. 1664) for an excerpt from this example.

wxFileDialog overview
Classes: wxFileDialog (p. 466) Pops up a file selector box. In Windows, this is the common file selector dialog. In X, this is a file selector box with somewhat less functionality. The path and filename are distinct elements of a full file pathname. If path is "", the current directory will be used. If filename is "", no default filename will be supplied. The wildcard determines what files are displayed in the file selector, and file extension supplies a type extension for the required filename. Flags may be a combination of wxOPEN, wxSAVE, wxOVERWRITE_PROMPT, wxHIDE_READONLY, wxFILE_MUST_EXIST or 0. Both the X and Windows versions implement a wildcard filter. Typing a filename containing wildcards (*, ?) in the filename text item, and clicking on Ok, will result in only those files matching the pattern being displayed. In the X version, supplying no default name will result in the wildcard filter being inserted in the filename text item; the filter is ignored if a default name is supplied. The wildcard may be a specification for multiple types of file with a description for each, such as:
"BMP files (*.bmp)|*.bmp|GIF files (*.gif)|*.gif"

wxDirDialog overview
Classes: wxDirDialog (p. 384) This dialog shows a directory selector dialog, allowing the user to select a single directory.

wxTextEntryDialog overview

1650


CHAPTER 11
Classes: wxTextEntryDialog (p. 1269) This is a dialog with a text entry field. The value that the user entered is obtained using wxTextEntryDialog::GetValue (p. 1270).

wxMessageDialog overview
Classes: wxMessageDialog (p. 914) This dialog shows a message, plus buttons that can be chosen from OK, Cancel, Yes, and No. Under Windows, an optional icon can be shown, such as an exclamation mark or question mark. The return value of wxMessageDialog::ShowModal (p. 916) indicates which button the user pressed.

wxSingleChoiceDialog overview
Classes: wxSingleChoiceDialog (p. 1102) This dialog shows a list of choices, plus OK and (optionally) Cancel. The user can select one of them. The selection can be obtained from the dialog as an index, a string or client data.

wxMultipleChoiceDialog overview
Classes: wxMultipleChoiceDialog (p. 938) This dialog shows a list of choices, plus OK and (optionally) Cancel. The user can select one or more of them.

Document/view overview
Classes: wxDocument (p. 413), wxView (p. 1369), wxDocTemplate (p. 408), wxDocManager (p. 394), wxDocParentFrame (p. 406), wxDocChildFrame (p. 392), wxDocMDIParentFrame (p. 405), wxDocMDIChildFrame (p. 403), wxCommand (p. 163), wxCommandProcessor (p. 170) The document/view framework is found in most application frameworks, because it can dramatically simplify the code required to build many kinds of application. The idea is that you can model your application primarily in terms of documents to store data and provide interface-independent operations upon it, and views to visualise and manipulate the data. Documents know how to do input and output given stream objects, and views are responsible for taking input from physical windows and performing the manipulation on the document data. If a document's data changes, all views should be updated to reflect the change.

1651


CHAPTER 11
The framework can provide many user-interface elements based on this model. Once you have defined your own classes and the relationships between them, the framework takes care of popping up file selectors, opening and closing files, asking the user to save modifications, routing menu commands to appropriate (possibly default) code, even some default print/preview functionality and support for command undo/redo. The framework is highly modular, allowing overriding and replacement of functionality and objects to achieve more than the default behaviour. These are the overall steps involved in creating an application based on the document/view framework: 1. 2. Define your own document and view classes, overriding a minimal set of member functions e.g. for input/output, drawing and initialization. Define any subwindows (such as a scrolled window) that are needed for the view(s). You may need to route some events to views or documents, for example OnPaint needs to be routed to wxView::OnDraw. Decide what style of interface you will use: Microsoft's MDI (multiple document child frames surrounded by an overall frame), SDI (a separate, unconstrained frame for each document), or single-window (one document open at a time, as in Windows Write). Use the appropriate wxDocParentFrame and wxDocChildFrame classes. Construct an instance of wxDocParentFrame in your wxApp::OnInit, and a wxDocChildFrame (if not single-window) when you initialize a view. Create menus using standard menu ids (such as wxID_OPEN, wxID_PRINT), routing non-application-specific identifiers to the base frame's OnMenuCommand. Construct a single wxDocManager instance at the beginning of your wxApp::OnInit, and then as many wxDocTemplate instances as necessary to define relationships between documents and views. For a simple application, there will be just one wxDocTemplate.

3.

4.

5.

If you wish to implement Undo/Redo, you need to derive your own class(es) from wxCommand and use wxCommandProcessor::Submit instead of directly executing code. The framework will take care of calling Undo and Do functions as appropriate, so long as the wxID_UNDO and wxID_REDO menu items are defined in the view menu. Here are a few examples of the tailoring you can do to go beyond the default framework behaviour:     Override wxDocument::OnCreateCommandProcessor to define a different Do/Undo strategy, or a command history editor. Override wxView::OnCreatePrintout to create an instance of a derived wxPrintout (p. 1010) class, to provide multi-page document facilities. Override wxDocManager::SelectDocumentPath to provide a different file selector. Limit the maximum number of open documents and the maximum number of undo commands.

1652


CHAPTER 11
Note that to activate framework functionality, you need to use some or all of the wxWindows predefined command identifiers (p. 1657) in your menus. wxPerl note: The document/view framework is available in wxPerl. To use it, you will need the following statements in your application code:
use Wx::DocView; use Wx ':docview'; # import constants (optional)

wxDocument overview
Document/view framework overview (p. 1651) Class: wxDocument (p. 413) The wxDocument class can be used to model an application's file-based data. It is part of the document/view framework supported by wxWindows, and cooperates with the wxView (p. 1369), wxDocTemplate (p. 408) and wxDocManager (p. 394) classes. Using this framework can save a lot of routine user-interface programming, since a range of menu commands -- such as open, save, save as -- are supported automatically. The programmer just needs to define a minimal set of classes and member functions for the framework to call when necessary. Data, and the means to view and edit the data, are explicitly separated out in this model, and the concept of multiple views onto the same data is supported. Note that the document/view model will suit many but not all styles of application. For example, it would be overkill for a simple file conversion utility, where there may be no call for views on documents or the ability to open, edit and save files. But probably the majority of applications are document-based. See the example application in samples/docview. To use the abstract wxDocument class, you need to derive a new class and override at least the member functions SaveObject and LoadObject. SaveObject and LoadObject will be called by the framework when the document needs to be saved or loaded. Use the macros DECLARE_DYNAMIC_CLASS and IMPLEMENT_DYNAMIC_CLASS in order to allow the framework to create document objects on demand. When you create a wxDocTemplate (p. 408) object on application initialization, you should pass CLASSINFO(YourDocumentClass) to the wxDocTemplate constructor so that it knows how to create an instance of this class. If you do not wish to use the wxWindows method of creating document objects dynamically, you must override wxDocTemplate::CreateDocument to return an instance of the appropriate class.

wxView overview

1653


CHAPTER 11
Document/view framework overview (p. 1651) Class: wxView (p. 1369) The wxView class can be used to model the viewing and editing component of an application's file-based data. It is part of the document/view framework supported by wxWindows, and cooperates with the wxDocument (p. 413), wxDocTemplate (p. 408)and wxDocManager (p. 394) classes. See the example application in samples/docview. To use the abstract wxView class, you need to derive a new class and override at least the member functions OnCreate, OnDraw, OnUpdate and OnClose. You will probably want to override OnMenuCommand to respond to menu commands from the frame containing the view. Use the macros DECLARE_DYNAMIC_CLASS and IMPLEMENT_DYNAMIC_CLASS in order to allow the framework to create view objects on demand. When you create a wxDocTemplate (p. 408) object on application initialization, you should pass CLASSINFO(YourViewClass) to the wxDocTemplate constructor so that it knows how to create an instance of this class. If you do not wish to use the wxWindows method of creating view objects dynamically, you must override wxDocTemplate::CreateView to return an instance of the appropriate class.

wxDocTemplate overview
Document/view framework overview (p. 1651) Class: wxDocTemplate (p. 408) The wxDocTemplate class is used to model the relationship between a document class and a view class. The application creates a document template object for each document/view pair. The list of document templates managed by the wxDocManager instance is used to create documents and views. Each document template knows what file filters and default extension are appropriate for a document/view combination, and how to create a document or view. For example, you might write a small doodling application that can load and save lists of line segments. If you had two views of the data -- graphical, and a list of the segments -then you would create one document class DoodleDocument, and two view classes (DoodleGraphicView and DoodleListView). You would also need two document templates, one for the graphical view and another for the list view. You would pass the same document class and default file extension to both document templates, but each would be passed a different view class. When the user clicks on the Open menu item, the file selector is displayed with a list of possible file filters -- one for each wxDocTemplate. Selecting the filter selects the wxDocTemplate, and when a file is selected, that template will be used for creating a document and view. Under nonWindows platforms, the user will be prompted for a list of templates before the file selector is shown, since most file selectors do not allow a choice of file filters.

1654


CHAPTER 11
For the case where an application has one document type and one view type, a single document template is constructed, and dialogs will be appropriately simplified. wxDocTemplate is part of the document/view framework supported by wxWindows, and cooperates with the wxView (p. 1369), wxDocument (p. 413) and wxDocManager (p. 394) classes. See the example application in samples/docview. To use the wxDocTemplate class, you do not need to derive a new class. Just pass relevant information to the constructor including CLASSINFO(YourDocumentClass) and CLASSINFO(YourViewClass) to allow dynamic instance creation. If you do not wish to use the wxWindows method of creating document objects dynamically, you must override wxDocTemplate::CreateDocument and wxDocTemplate::CreateView to return instances of the appropriate class. NOTE: the document template has nothing to do with the C++ template construct. C++ templates are not used anywhere in wxWindows.

wxDocManager overview
Document/view framework overview (p. 1651) Class: wxDocManager (p. 394) The wxDocManager class is part of the document/view framework supported by wxWindows, and cooperates with the wxView (p. 1369), wxDocument (p. 413) and wxDocTemplate (p. 408) classes. A wxDocManager instance coordinates documents, views and document templates. It keeps a list of document and template instances, and much functionality is routed through this object, such as providing selection and file dialogs. The application can use this class 'as is' or derive a class and override some members to extend or change the functionality. Create an instance of this class near the beginning of your application initialization, before any documents, views or templates are manipulated. There may be multiple wxDocManager instances in an application. See the example application in samples/docview.

wxCommand overview
Document/view framework overview (p. 1651) Classes: wxCommand (p. 163), wxCommandProcessor (p. 170) wxCommand is a base class for modelling an application command, which is an action usually performed by selecting a menu item, pressing a toolbar button or any other means provided by the application to change the data or view. Instead of the application functionality being scattered around switch statements and

1655


CHAPTER 11
functions in a way that may be hard to read and maintain, the functionality for a command is explicitly represented as an object which can be manipulated by a framework or application. When a user interface event occurs, the application submits a command to a wxCommandProcessor (p. 1656) object to execute and store. The wxWindows document/view framework handles Undo and Redo by use of wxCommand and wxCommandProcessor objects. You might find further uses for wxCommand, such as implementing a macro facility that stores, loads and replays commands. An application can derive a new class for every command, or, more likely, use one class parameterized with an integer or string command identifier.

wxCommandProcessor overview
Document/view framework overview (p. 1651) Classes: wxCommandProcessor (p. 170), wxCommand (p. 163) wxCommandProcessor is a class that maintains a history of wxCommand instances, with undo/redo functionality built-in. Derive a new class from this if you want different behaviour.

wxFileHistory overview
Document/view framework overview (p. 1651) Classes: wxFileHistory (p. 471), wxDocManager (p. 394) wxFileHistory encapsulates functionality to record the last few files visited, and to allow the user to quickly load these files using the list appended to the File menu. Although wxFileHistory is used by wxDocManager, it can be used independently. You may wish to derive from it to allow different behaviour, such as popping up a scrolling list of files. By calling wxFileHistory::FileHistoryUseMenu you can associate a file menu with the file history, that will be used for appending the filenames. They are appended using menu identifiers in the range wxID_FILE1 to wxID_FILE9. In order to respond to a file load command from one of these identifiers, you need to handle them using an event handler, for example:
BEGIN_EVENT_TABLE(wxDocParentFrame, wxFrame) EVT_MENU(wxID_EXIT, wxDocParentFrame::OnExit) EVT_MENU_RANGE(wxID_FILE1, wxID_FILE9, wxDocParentFrame::OnMRUFile) END_EVENT_TABLE() void wxDocParentFrame::OnExit(wxCommandEvent& WXUNUSED(event)) { Close(); } void wxDocParentFrame::OnMRUFile(wxCommandEvent& event)

1656


CHAPTER 11
{ wxString f(m_docManager->GetHistoryFile(event.GetId() wxID_FILE1)); if (f != "") (void)m_docManager->CreateDocument(f, wxDOC_SILENT); }

wxWindows predefined command identifiers
To allow communication between the application's menus and the document/view framework, several command identifiers are predefined for you to use in menus. The framework recognizes them and processes them if you forward commands from wxFrame::OnMenuCommand (or perhaps from toolbars and other user interface constructs).              wxID_OPEN (5000) wxID_CLOSE (5001) wxID_NEW (5002) wxID_SAVE (5003) wxID_SAVEAS (5004) wxID_REVERT (5005) wxID_EXIT (5006) wxID_UNDO (5007) wxID_REDO (5008) wxID_HELP (5009) wxID_PRINT (5010) wxID_PRINT_SETUP (5011) wxID_PREVIEW (5012)

Toolbar overview
Classes: wxToolBar (p. 1309) The toolbar family of classes allows an application to use toolbars in a variety of configurations and styles. The toolbar is a popular user interface component and contains a set of bitmap buttons or toggles. A toolbar gives faster access to an application's facilities than menus, which

1657


CHAPTER 11
have to be popped up and selected rather laboriously. Instead of supplying one toolbar class with a number of different implementations depending on platform, wxWindows separates out the classes. This is because there are a number of different toolbar styles that you may wish to use simultaneously, and also, future toolbar implementations will emerge which cannot all be shoe-horned into the one class. For each platform, the symbol wxToolBar is defined to be one of the specific toolbar classes. The following is a summary of the toolbar classes and their differences.   wxToolBarBase. This is a base class with pure virtual functions, and should not be used directly. wxToolBarSimple. A simple toolbar class written entirely with generic wxWindows functionality. A simple 3D effect for buttons is possible, but it is not consistent with the Windows look and feel. This toolbar can scroll, and you can have arbitrary numbers of rows and columns. wxToolBarMSW. This class implements an old-style Windows toolbar, only on Windows. There are small, three-dimensional buttons, which do not (currently) reflect the current Windows colour settings: the buttons are grey. This is the default wxToolBar on 16-bit windows. wxToolBar95. Uses the native Windows 95 toolbar class. It dynamically adjusts its background and button colours according to user colour settings. CreateTools must be called after the tools have been added. No absolute positioning is supported but you can specify the number of rows, and add tool separators with AddSeparator. Tooltips are supported. OnRightClick is not supported. This is the default wxToolBar on Windows 95, Windows NT 4 and above. With the style wxTB_FLAT, the flat toolbar look is used, with a border that is highlighted when the cursor moves over the buttons.





A toolbar might appear as a single row of images under the menubar, or it might be in a separate frame layout in several rows and columns. The class handles the layout of the images, unless explicit positioning is requested. A tool is a bitmap which can either be a button (there is no 'state', it just generates an event when clicked) or it can be a toggle. If a toggle, a second bitmap can be provided to depict the 'on' state; if the second bitmap is omitted, either the inverse of the first bitmap will be used (for monochrome displays) or a thick border is drawn around the bitmap (for colour displays where inverting will not have the desired result). The Windows-specific toolbar classes expect 16-colour bitmaps that are 16 pixels wide and 15 pixels high. If you want to use a different size, call SetToolBitmapSize as the demo shows, before adding tools to the button bar. Don't supply more than one bitmap for each tool, because the toolbar generates all three images (normal, depressed and checked) from the single bitmap you give it.

1658


CHAPTER 11 Using the toolbar library
Include "wx/toolbar.h", or if using a class directly, one of:    "wx/msw/tbarmsw.h for wxToolBarMSW "wx/msw/tbar95.h for wxToolBar95 "wx/tbarsmpl.h for wxToolBarSimple

Example of toolbar use are given in the sample program "toolbar''. The source is given below. In fact it is out of date because recommended practise is to use event handlers (using EVT_MENU or EVT_TOOL) instead of overriding OnLeftClick.
////////////////////////////////////////////////////////////////////////// /// // Name: test.cpp // Purpose: wxToolBar sample // Author: Julian Smart // Modified by: // Created: 04/01/98 // RCS-ID: $Id: ttoolbar.tex,v 1.8 2003/01/18 00:16:34 VS Exp $ // Copyright: (c) Julian Smart // License: wxWindows license ////////////////////////////////////////////////////////////////////////// /// // For compilers that support precompilation, includes "wx/wx.h". #include "wx/wxprec.h" #ifdef __BORLANDC__ #pragma hdrstop #endif #ifndef WX_PRECOMP #include "wx/wx.h" #endif #include "wx/toolbar.h" #include <wx/log.h> #include "test.h" #if defined(__WXGTK__) || defined(__WXMOTIF__) #include "mondrian.xpm" #include "bitmaps/new.xpm" #include "bitmaps/open.xpm" #include "bitmaps/save.xpm" #include "bitmaps/copy.xpm" #include "bitmaps/cut.xpm" #include "bitmaps/print.xpm" #include "bitmaps/preview.xpm" #include "bitmaps/help.xpm" #endif IMPLEMENT_APP(MyApp) // The `main program' equivalent, creating the windows and returning the // main frame bool MyApp:OnInit(void) : { // Create the main frame window MyFrame* frame = new MyFrame((wxFrame *) NULL, -1, (const wxString) "wxToolBar Sample", wxPoint(100, 100), wxSize(450, 300)); // Give it a status line

1659


CHAPTER 11
frame->CreateStatusBar(); // Give it anicon frame->SetIcon(wxICON(mondrian)); // Make a menubar wxMenu *fileMenu = new wxMenu; fileMenu >Append(wxID_EXIT, "E&xit", "Quit toolbar sample" ); wxMenu *helpMenu = new wxMenu; helpMenu >Append(wxID_HELP, "&About", "About toolbar sample"); wxMenuBar* menuBar = new wxMenuBar; menuBar->Append(fileMenu, "&File"); menuBar->Append(helpMenu, "&Help"); // Associate the menu bar with the frame frame->SetMenuBar(menuBar); // Create the toolbar frame->CreateToolBar(wxNO_BORDER|wxHORIZONTAL|wxTB_FLAT, ID_TOOLBAR); frame->GetToolBar()->SetMargins( 2, 2 ); InitToolbar(frame->GetToolBar()); // Force a resize. This should probably be replaced by a call to a wxFrame // function that lays out default decorations and the remaining content window. wxSizeEvent event(wxSize(-1, -1), frame->GetId()); frame->OnSize(event); frame->Show(true); frame->SetStatusText("Hello, wxWindows"); SetTopWindow(frame); return true; } bool MyApp::InitToolbar(wxToolBar* toolBar) { // Set up toolbar wxBitmap* toolBarBitmaps[8]; #ifdef __WXMSW__ toolBarBitmaps[0] toolBarBitmaps[1] toolBarBitmaps[2] toolBarBitmaps[3] toolBarBitmaps[4] toolBarBitmaps[5] toolBarBitmaps[6] toolBarBitmaps[7] #else toolBarBitmaps[0] toolBarBitmaps[1] toolBarBitmaps[2] toolBarBitmaps[3] toolBarBitmaps[4] toolBarBitmaps[5] toolBarBitmaps[6] toolBarBitmaps[7] #endif #ifdef __WXMSW__ int width = 24; #else int width = 16; #endif = = = = = = = = = = = = = = = = new new new new new new new new new new new new new new new new wxBitmap("icon1"); wxBitmap("icon2"); wxBitmap("icon3"); wxBitmap("icon4"); wxBitmap("icon5"); wxBitmap("icon6"); wxBitmap("icon7"); wxBitmap("icon8"); wxBitmap( wxBitmap( wxBitmap( wxBitmap( wxBitmap( wxBitmap( wxBitmap( wxBitmap( new_xpm ); open_xpm ); save_xpm ); copy_xpm ); cut_xpm ); preview_xpm ); print_xpm ); help_xpm );

1660


CHAPTER 11
int currentX = 5; toolBar->AddTool(wxID_NEW, *(toolBarBitmaps[0]), wxNullBitmap, false, currentX,- 1, (wxObject *) NULL, "New file"); currentX += width + 5; toolBar->AddTool(wxID_OPEN, *(toolBarBitmaps[1]), wxNullBitmap, false, currentX,- 1, (wxObject *) NULL, "Open file"); currentX += width + 5; toolBar->AddTool(wxID_SAVE, *(toolBarBitmaps[2]), wxNullBitmap, false, currentX, -1, (wxObject *) NULL, "Save file"); currentX += width + 5; toolBar->AddSeparator(); toolBar->AddTool(wxID_COPY, *(toolBarBitmaps[3]), wxNullBitmap, false, currentX,- 1, (wxObject *) NULL, "Copy"); currentX += width + 5; toolBar->AddTool(wxID_CUT, *(toolBarBitmaps[4]), wxNullBitmap, false, currentX,- 1, (wxObject *) NULL, "Cut"); currentX += width + 5; toolBar->AddTool(wxID_PASTE, *(toolBarBitmaps[5]), wxNullBitmap, false, currentX,- 1, (wxObject *) NULL, "Paste"); currentX += width + 5; toolBar->AddSeparator(); toolBar->AddTool(wxID_PRINT, *(toolBarBitmaps[6]), wxNullBitmap, false, currentX,- 1, (wxObject *) NULL, "Print"); currentX += width + 5; toolBar->AddSeparator(); toolBar->AddTool(wxID_HELP, *(toolBarBitmaps[7]), wxNullBitmap, false, currentX,- 1, (wxObject *) NULL, "Help"); toolBar->Realize(); // Can delete the bitmaps since they're reference counted int i; for (i = 0; i < 8; i++) delete toolBarBitmaps[i]; return true; } // wxID_HELP will be processed for the 'About' menu and the toolbar help button. BEGIN_EVENT_TABLE(MyFrame, wxFrame) EVT_MENU(wxID_EXIT, MyFrame::OnQuit) EVT_MENU(wxID_HELP, MyFrame::OnAbout) EVT_CLOSE(MyFrame::OnCloseWindow) EVT_TOOL_RANGE(wxID_OPEN, wxID_PASTE, MyFrame::OnToolLeftClick) EVT_TOOL_ENTER(wxID_OPEN, MyFrame::OnToolEnter) END_EVENT_TABLE() // Define my frame constructor MyFrame::MyFrame(wxFrame* parent, wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, long style): wxFrame(parent, id, title, pos, size, style) { m_textWindow = new wxTextCtrl(this, -1, "", wxPoint(0, 0), wxSize(-1, 1), wxTE_MULTILINE); } void MyFrame::OnQuit(wxCommandEvent& WXUNUSED(event)) { Close(true); } void MyFrame::OnAbout(wxCommandEvent& WXUNUSED(event)) { (void)wxMessageBox("wxWindows toolbar sample", "About wxToolBar"); } // Define the behaviour for the frame closing // - must delete all frames except for the main one.

1661


CHAPTER 11
void MyFrame::OnCloseWindow(wxCloseEvent& WXUNUSED(event)) { Destroy(); } void MyFrame::OnToolLeftClick(wxCommandEvent& event) { wxString str; str.Printf("Clicked on tool %d", event.GetId()); SetStatusText(str); } void MyFrame::OnToolEnter(wxCommandEvent& event) { if (event.GetSelection() > -1) { wxString str; str.Printf("This is tool number %d", event.GetSelection()); SetStatusText(str); } else SetStatusText(""); }

wxGrid classes overview
Classes: wxGrid (p. 569)

Introduction
wxGrid and its related classes are used for displaying and editing tabular data.

Getting started: a simple example
For simple applications you need only refer to the wxGrid class in your code. This example shows how you might create a grid in a frame or dialog constructor and illustrates some of the formatting functions.
// Create a wxGrid object grid = new wxGrid( this, -1, wxPoint( 0, 0 ), wxSize( 400, 300 ) ); // Then we call CreateGrid to set the dimensions of the grid // (100 rows and 10 columns in this example) grid->CreateGrid( 100, 10 ); // We can set the sizes of individual rows and columns // in pixels grid->SetRowSize( 0, 60 ); grid->SetColSize( 0, 120 ); // And set grid cell contents as strings grid->SetCellValue( 0, 0, "wxGrid is good" ); // We can specify that some cells are read-only

1662


CHAPTER 11
grid->SetCellValue( 0, 3, "This is read-only" ); grid->SetReadOnly( 0, 3 ); // Colours can be specified for grid cell contents grid->SetCellValue(3, 3, "green on grey"); grid->SetCellTextColour(3, 3, *wxGREEN); grid->SetCellBackgroundColour(3, 3, *wxLIGHT_GREY); // We can specify the some cells will store numeric // values rather than strings. Here we set grid column 5 // to hold floating point values displayed with width of 6 // and precision of 2 grid->SetColFormatFloat(5, 6, 2); grid->SetCellValue(0, 6, "3.1415");

A more complex example
Yet to be written

How the wxGrid classes relate to each other
Yet to be written

Keyboard and mouse actions
Yet to be written

wxTipProvider overview
Many "modern" Windows programs have a feature (some would say annoyance) of presenting the user tips at program startup. While this is probably useless to the advanced users of the program, the experience shows that the tips may be quite helpful for the novices and so more and more programs now do this. For a wxWindows programmer, implementing this feature is extremely easy. To show a tip, it is enough to just call wxShowTip (p. 1497) function like this:
if ( ...show tips at startup?... ) { wxTipProvider *tipProvider = wxCreateFileTipProvider("tips.txt", 0); wxShowTip(windowParent, tipProvider); delete tipProvider; }

Of course, you need to get the text of the tips from somewhere - in the example above, the text is supposed to be in the file tips.txt from where it is read by the tip provider. The tip provider is just an object of a class deriving from wxTipProvider (p. 1304). It has to implement one pure virtual function of the base class: GetTip (p. 1305). In the case of the tip provider created by wxCreateFileTipProvider (p. 1489), the tips are just the lines of the text file.

1663


CHAPTER 11
If you want to implement your own tip provider (for example, if you wish to hardcode the tips inside your program), you just have to derive another class from wxTipProvider and pass a pointer to the object of this class to wxShowTip - then you don't need wxCreateFileTipProvider at all. You will probably want to save somewhere the index of the tip last shown - so that the program doesn't always show the same tip on startup. As you also need to remember whether to show tips or not (you shouldn't do it if the user unchecked "Show tips on startup" checkbox in the dialog), you will probably want to store both the index of the last shown tip (as returned by wxTipProvider::GetCurrentTip (p. 1305) and the flag telling whether to show the tips at startup at all. In a tips.txt file, lines that begin with a # character are considered comments and are automatically skipped. Blank lines and lines only having spaces are also skipped. You can easily add runtime-translation capacity by placing each line of the tips.txt file inside the usual translation macro. For example, your tips.txt file would look like this:
_("This is my first tip") _("This is my second tip")

Now add your tips.txt file into the list of files that gettext searches for translatable strings. The tips will thus get included into your generated .po file catalog and be translated at runtime along with the rest of your aplication's translatable strings. Note1: Each line in the tips.txt file needs to strictly begin with exactly the 3 characters of underscore-parenthesis-doublequote, and end with doublequote-parenthesis, as shown above. Note2: Remember to escape any doublequote characters within the tip string with a backslash-doublequote. See the dialogs program in your samples folder for a working example inside a program.

Printing overview
Classes: wxPrintout (p. 1010), wxPrinter (p. 1007), wxPrintPreview (p. 1014), wxPrinterDC (p. 1010), wxPrintDialog (p. 1002), wxPrintData (p. 996), wxPrintDialogData (p. 1003), wxPageSetupDialog (p. 960), wxPageSetupDialogData (p. 961) The printing framework relies on the application to provide classes whose member functions can respond to particular requests, such as 'print this page' or 'does this page exist in the document?'. This method allows wxWindows to take over the housekeeping duties of turning preview pages, calling the print dialog box, creating the printer device context, and so on: the application can concentrate on the rendering of the information onto a device context. The document/view framework (p. 1651) creates a default wxPrintout object for every view, calling wxView::OnDraw to achieve a prepackaged print/preview facility. A document's printing ability is represented in an application by a derived wxPrintout class. This class prints a page on request, and can be passed to the Print function of a wxPrinter object to actually print the document, or can be passed to a wxPrintPreview

1664


CHAPTER 11
object to initiate previewing. The following code (from the printing sample) shows how easy it is to initiate printing, previewing and the print setup dialog, once the wxPrintout functionality has been defined. Notice the use of MyPrintout for both printing and previewing. All the preview user interface functionality is taken care of by wxWindows. For details on how MyPrintout is defined, please look at the printout sample code.
case WXPRINT_PRINT: { wxPrinter printer; MyPrintout printout("My printout"); printer.Print(this, &printout, true); break; } case WXPRINT_PREVIEW: { // Pass two printout objects: for preview, and possible printing. wxPrintPreview *preview = new wxPrintPreview(new MyPrintout, new MyPrintout); wxPreviewFrame *frame = new wxPreviewFrame(preview, this, "Demo Print Preview", 100, 100, 600, 650); frame->Centre(wxBOTH); frame->Initialize(); frame->Show(true); break; } case WXPRINT_PRINT_SETUP: { wxPrintDialog printerDialog(this); printerDialog.GetPrintData().SetSetupDialog(true); printerDialog.Show(true); break; }

Multithreading overview
Classes: wxThread (p. 1284), wxMutex (p. 938), wxCriticalSection (p. 206), wxCondition (p. 173) wxWindows provides a complete set of classes encapsulating objects necessary in multithreaded (MT) programs: the thread (p. 1284) class itself and different synchronization objects: mutexes (p. 938) and critical sections (p. 206) with conditions (p. 173). The thread API in wxWindows resembles to POSIX1.c threads API (a.k.a. pthreads), although several functions have different names and some features inspired by Win32 thread API are there as well. These classes will hopefully make writing MT programs easier and they also provide some extra error checking (compared to the native (be it Win32 or Posix) thread API), however it is still an non-trivial undertaking especially for large projects. Before starting an MT application (or starting to add MT features to an existing one) it is worth asking oneself if there is no easier and safer way to implement the same functionality. Of course, in some situations threads really make sense (classical example is a server application which launches a new thread for each new client), but in others it might be a very poor choice (example: launching a separate thread when doing a long computation to show a progress dialog). Other implementation choices are available: for the progress dialog example it is far better to do the calculations in the idle handler (p. 726) or call wxYield() (p. 1468) periodically to update the screen.

1665


CHAPTER 11
If you do decide to use threads in your application, it is strongly recommended that no more than one thread calls GUI functions. The thread sample shows that it is possible for many different threads to call GUI functions at once (all the threads created in the sample access GUI), but it is a very poor design choice for anything except an example. The design which uses one GUI thread and several worker threads which communicate with the main one using events is much more robust and will undoubtedly save you countless problems (example: under Win32 a thread can only access GDI objects such as pens, brushes, &c created by itself and not by the other threads). For communication between threads, use wxEvtHandler::AddPendingEvent (p. 444)or its short version wxPostEvent (p. 1512). These functions have thread safe implementation so that they can be used as they are for sending event from one thread to another.

Drag and drop overview
Classes: wxDataObject (p. 222), wxTextDataObject (p. 1266), wxDropSource (p. 427), wxDropTarget (p. 429), wxTextDropTarget (p. 1268), wxFileDropTarget (p. 470) Note that wxUSE_DRAG_AND_DROP must be defined in setup.h in order to use drag and drop in wxWindows. See also: wxDataObject overview (p. 1667) and DnD sample (p. 1563) It may be noted that data transfer to and from the clipboard is quite similar to data transfer with drag and drop and the code to implement these two types is almost the same. In particular, both data transfer mechanisms store data in some kind of wxDataObject (p. 222)and identify its format(s) using the wxDataFormat (p. 217)class. To be a drag source, i.e. to provide the data which may be dragged by the user elsewhere, you should implement the following steps:  Preparation: First of all, a data object must be created and initialized with the data you wish to drag. For example:
wxTextDataObject my_data("This text will be dragged.");



Drag start: To start the dragging process (typically in response to a mouse click) you must call wxDropSource::DoDragDrop (p. 429)like this:
wxDropSource dragSource( this ); dragSource.SetData( my_data ); wxDragResult result = dragSource.DoDragDrop( TRUE );



Dragging: The call to DoDragDrop() blocks the program until the user releases the mouse button (unless you override the GiveFeedback (p. 429) function to do something special). When the mouse moves in a window of a program which understands the same drag-and-drop protocol (any program under Windows or any program supporting the XDnD protocol under X Windows), the corresponding wxDropTarget (p. 429) methods are called - see below. Processing the result: DoDragDrop() returns an effect code which is one of the values of wxDragResult enum (explained here (p. 429)):



1666


CHAPTER 11
switch (result) { case wxDragCopy: /* copy the data */ break; case wDragMove: /* move the data */ break; x default: /* do nothing */ break; }

To be a drop target, i.e. to receive the data dropped by the user you should follow the instructions below:  Initialization: For a window to be a drop target, it needs to have an associated wxDropTarget (p. 429) object. Normally, you will call wxWindow::SetDropTarget (p. 1422) during window creation associating your drop target with it. You must derive a class from wxDropTarget and override its pure virtual methods. Alternatively, you may derive from wxTextDropTarget (p. 1268) orwxFileDropTarget (p. 470) and override their OnDropText() or OnDropFiles() method. Drop: When the user releases the mouse over a window, wxWindows asks the associated wxDropTarget object if it accepts the data. For this, a wxDataObject (p. 222) must be associated with the drop target and this data object will be responsible for the format negotiation between the drag source and the drop target. If all goes well, then OnData (p. 431) will get called and the wxDataObject belonging to the drop target can get filled with data. The end: After processing the data, DoDragDrop() returns either wxDragCopy or wxDragMove depending on the state of the keys <Ctrl>, <Shift> and <Alt> at the moment of the drop. There is currently no way for the drop target to change this return code.





wxDataObject overview
Classes: wxDataObject (p. 222), wxClipboard (p. 136), wxDataFormat (p. 217), wxDropSource (p. 427), wxDropTarget (p. 429) See also: Drag and drop overview (p. 1666) and DnD sample (p. 1563) This overview discusses data transfer through clipboard or drag and drop. In wxWindows, these two ways to transfer data (either between different applications or inside one and the same) are very similar which allows to implement both of them using almost the same code - or, in other words, if you implement drag and drop support for your application, you get clipboard support for free and vice versa. At the heart of both clipboard and drag and drop operations lies the wxDataObject (p. 222) class. The objects of this class (or, to be precise, classes derived from it) represent the data which is being carried by the mouse during drag and drop operation or copied to or pasted from the clipboard. wxDataObject is a "smart" piece of data because it knows which formats it supports (see GetFormatCount and GetAllFormats) and knows how to render itself in any of them (see GetDataHere). It can also receive its value from the outside in a format it supports if it implements the SetData method. Please see the documentation of this class for more details.

1667


CHAPTER 11
Both clipboard and drag and drop operations have two sides: the source and target, the data provider and the data receiver. These which may be in the same application and even the same window when, for example, you drag some text from one position to another in a word processor. Let us describe what each of them should do.

The data provider (source) duties
The data provider is responsible for creating a wxDataObject (p. 222) containing the data to be transferred. Then it should either pass it to the clipboard using SetData (p. 138) function or to wxDropSource (p. 427) and call DoDragDrop (p. 429) function. The only (but important) difference is that the object for the clipboard transfer must always be created on the heap (i.e. using new) and it will be freed by the clipboard when it is no longer needed (indeed, it is not known in advance when, if ever, the data will be pasted from the clipboard). On the other hand, the object for drag and drop operation must only exist while DoDragDrop (p. 429) executes and may be safely deleted afterwards and so can be created either on heap or on stack (i.e. as a local variable). Another small difference is that in the case of clipboard operation, the application usually knows in advance whether it copies or cuts (i.e. copies and deletes) data - in fact, this usually depends on which menu item the user chose. But for drag and drop it can only know it after DoDragDrop (p. 429) returns (from its return value).

The data receiver (target) duties
To receive (paste in usual terminology) data from the clipboard, you should create a wxDataObject (p. 222) derived class which supports the data formats you need and pass it as argument to wxClipboard::GetData (p. 138). If it returns false, no data in (any of) the supported format(s) is available. If it returns true, the data has been successfully transferred to wxDataObject. For drag and drop case, the wxDropTarget::OnData (p. 431) virtual function will be called when a data object is dropped, from which the data itself may be requested by calling wxDropTarget::GetData (p. 430) method which fills the data object.

Database classes overview
Following is a detailed overview of how to use the wxWindows ODBC classes - wxDb (p. 263) and wxDbTable (p. 301) and their associated functions. These are the ODBC classes donated by Remstar International, and are collectively referred to herein as the wxODBC classes.

wxDb/wxDbTable wxODBC Overview
Classes: wxDb (p. 263), wxDbTable (p. 301) The wxODBC classes were designed for database independence. Although SQL and

1668


CHAPTER 11
ODBC both have standards which define the minimum requirements they must support to be in compliance with specifications, different database vendors may implement things slightly differently. One example of this is that Oracle requires all user names for the datasources to be supplied in uppercase characters. In situations like this, the wxODBC classes have been written to make this transparent to the programmer when using functions that require database-specific syntax. Currently several major databases, along with other widely used databases, have been tested and supported through the wxODBC classes. The list of supported databases is certain to grow as more users start implementing software with these classes, but at the time of the writing of this document, users have successfully used the classes with the following datasources:             Oracle (v7, v8, v8i) Sybase (ASA and ASE) MS SQL Server (v7 - minimal testing) MS Access (97 and 2000) MySQL DBase (IV, V)** PostgreSQL INFORMIX VIRTUOSO DB2 Interbase Pervasive SQL

An up-to-date list can be obtained by looking in the comments of the function wxDb::Dbms (p. 272) in db.cpp, or in the enumerated type wxDBMS (p. 263) in db.h. **dBase is not truly an ODBC datasource, but there are drivers which can emulate much of the functionality of an ODBC connection to a dBase table. See the wxODBC Known Issues (p. 1682) section of this overview for details.

wxODBC Where To Start
First, if you are not familiar with SQL and ODBC, go to your local bookstore and pick up a good book on each. This documentation is not meant to teach you many details about SQL or ODBC, though you may learn some just from immersion in the subject. If you have worked with non-SQL/ODBC datasources before, there are some things you will need to un-learn. First some terminology as these phrases will be used heavily in

1669


CHAPTER 11
this section of the manual. Datasource Data table ODBC driver (usually a database) that contains the data that will be accessed by the wxODBC classes. The section of the datasource that contains the rows and columns of data. The middle-ware software that interprets the ODBC commands sent by your application and converts them to the SQL format expected by the target datasource. An open pipe between your application and the ODBC driver which in turn has a connection to the target datasource. Datasource connections can have a virtually unlimited number of wxDbTable instances using the same connect (dependent on the ODBC driver). A separate connection is not needed for each table (the exception is for isolating commits/rollbacks on different tables from affecting more than the desired table. See the class documentation on wxDb::CommitTrans (p. 271) and wxDb::RollbackTrans (p. 286).) Similar to records in old relational databases, a row is a collection of one instance of each column of the data table that are all associated with each other. Individual fields associated with each row of a data table. Request from the client to the datasource asking for the data that matches the requirements specified in the users request. When a query is performed, the datasource performs the lookup of the rows with satisfy the query, and creates a result set. The data which matches the requirements specified in a query sent to the datasource. Dependent on drivers, a result set typically remains at the datasource (no data is transmitted to the ODBC driver) until the client actually instructs the ODBC driver to retrieve it. A logical pointer into the result set that a query generates, indicating the next record that will be returned to the client when a request for the next record is made. Scrolling refers to the movement of cursors through the result set. Cursors can always scroll forward sequentially in the result set (FORWARD ONLY scrolling cursors). With Forward only scrolling cursors, once a row in the result set has been returned to the ODBC driver and on to the client, there is no way to have the cursor move backward in the result set to look at the row that is previous to the current row in the result set. If BACKWARD scrolling cursors are

Datasource connection

Rows

Columns Query

Result set

Cursor

Scrolling cursors

1670


CHAPTER 11
supported by both the ODBC driver and the datasource that are being used, then backward scrolling cursor functions may be used (wxDbTable::GetPrev (p. 318), wxDbTable::GetFirst (p. 316), and wxDbTable::GetLast (p. 316)). If the datasource or the ODBC driver only support forward scrolling cursors, your program and logic must take this in to account. Commit/Rollback Commit will physically save insertions/deletions/updates, while rollback basically does an undo of everything done against the datasource connection that has not been previously committed. Note that Commit and Rollbacks are done on a connection, not on individual tables. All tables which use a shared connection to the datasource are all committed/rolled back at the same time when a call to wxDb::CommitTrans (p. 271) or wxDb::RollbackTrans (p. 286) is made. Indexes are datasource-maintained lookup structures that allow the datasource to quickly locate data rows based on the values of certain columns. Without indexes, the datasource would need to do a sequential search of a table every time a query request is made. Proper unique key index construction can make datasource queries nearly instantaneous.

Index

Before you are able to read data from a data table in a datasource, you must have a connection to the datasource. Each datasource connection may be used to open multiple tables all on the same connection (number of tables open are dependent on the driver, datasource configuration and the amount of memory on the client workstation). Multiple connections can be opened to the same datasource by the same client (number of concurrent connections is dependent on the driver and datasource configuration). When a query is performed, the client passes the query to the ODBC driver, and the driver then translates it and passes it along to the datasource. The database engine (in most cases - exceptions are text and dBase files) running on the machine hosting the database does all the work of performing the search for the requested data. The client simply waits for a status to come back through the ODBC driver from the datasource. Depending on the ODBC driver, the result set either remains "queued" on the database server side, or is transferred to the machine that the driver is queued on. The client does not receive this data. The client must request some or all of the result set to be returned before any data rows are returned to the client application. Result sets do not need to include all columns of every row matching the query. In fact, result sets can actually be joinings of columns from two or more data tables, may have derived column values, or calculated values returned. For each result set, a cursor is maintained (typically by the database) which keeps track of where in the result set the user currently is. Depending on the database, ODBC driver, and how you configured the wxWindows ODBC settings in setup.h (see

1671


CHAPTER 11
wxODBC - Compiling (p. 1673)), cursors can be either forward or backward scrolling. At a minimum, cursors must scroll forward. For example, if a query resulted in a result set with 100 rows, as the data is read by the client application, it will read row 1, then 2, then 3, etc. With forward only cursors, once the cursor has moved to the next row, the previous row cannot be accessed again without re-querying the datasource for the result set over again. Backward scrolling cursors allow you to request the previous row from the result set, actually scrolling the cursor backward. Backward scrolling cursors are not supported on all database/driver combinations. For this reason, forward-only cursors are the default in the wxODBC classes. If your datasource does support backward scrolling cursors and you wish to use them, make the appropriate changes in setup.h to enable them (see wxODBC - Compiling (p. 1673)). For greatest portability between datasources, writing your program in such a way that it only requires forward scrolling cursors is your best bet. On the other hand, if you are focusing on using only datasources that support backward scrolling cursors, potentially large performance benefits can be gained from using them. There is a limit to the number of cursors that can be open on each connection to the datasource, and usually a maximum number of cursors for the datasource itself. This is all dependent on the database. Each connection that is opened (each instance of a wxDb) opens a minimum of 5 cursors on creation that are required for things such as updates/deletions/rollbacks/queries. Cursors are a limited resource, so use care in creating large numbers of cursors. Additional cursors can be created if necessary with the wxDbTable::GetNewCursor (p. 317) function. One example use for additional cursors is to track multiple scroll points in result sets. By creating a new cursor, a program could request a second result set from the datasource while still maintaining the original cursor position in the first result set. Different than non-SQL/ODBC datasources, when a program performs an insertion, deletion, or update (or other SQL functions like altering tables, etc) through ODBC, the program must issue a "commit" to the datasource to tell the datasource that the action(s) it has been told to perform are to be recorded as permanent. Until a commit is performed, any other programs that query the datasource will not see the changes that have been made (although there are databases that can be configured to auto-commit). NOTE: With most datasources, until the commit is performed, any cursor that is open on that same datasource connection will be able to see the changes that are uncommitted. Check your database's documentation/configuration to verify this before relying on it though. A rollback is basically an UNDO command on the datasource connection. When a rollback is issued, the datasource will flush all commands it has been told to do since the last commit that was performed. NOTE: Commits/Rollbacks are done on datasource connections (wxDb instances) not on the wxDbTable instances. This means that if more than one table shares the same connection, and a commit or rollback is done on that connection, all pending changes for ALL tables using that connection are committed/rolled back.

wxODBC - Configuring your system for ODBC use

1672


CHAPTER 11
Before you are able to access a datasource, you must have installed and configured an ODBC driver. Doing this is system specific, so it will not be covered in detail here. But here are a few details to get you started. Most database vendors provide at least a minimal ODBC driver with their database product. In practice, many of these drivers have proven to be slow and/or incomplete. Rumour has it that this is because the vendors do not want you using the ODBC interface to their products; they want you to use their applications to access the data. Whatever the reason, for database-intensive applications, you may want to consider using a third-party ODBC driver for your needs. One example of a third-party set of ODBC drivers that has been heavily tested and used is Rogue Wave's drivers. Rogue Wave has drivers available for many different platforms and databases. Under Microsoft Windows, install the ODBC driver you are planning to use. You will then use the ODBC Administrator in the Control Panel to configure an instance of the driver for your intended datasource. Note that with all flavors of NT, this configuration can be set up as a System or User DSN (datasource name). Configuring it as a system resource will make it available to all users (if you are logged in as 'administrator'), otherwise the datasource will only be available to the user who configured the DSN. Under Unix, iODBC is used for implementation of the ODBC API. To compile the wxODBC classes, you must first obtain iODBC from http://www.iodbc.org (www.iodbc.org) and install it. (Note: wxWindows currently includes a version of iODBC.) Then you must create the file " /.odbc.ini" (or optionally create "/etc/odbc.ini" for access for all users on the system). This file contains the settings for your system/datasource. Below is an example section of a odbc.ini file for use with the "samples/db" sample program using MySQL:
[contacts] Trace = TraceFile= Driver = DSN = SERVER = USER = PASSWORD = PORT = Off stderr /usr/local/lib/libmyodbc.so contacts 192.168.1.13 qet 3306

wxODBC - Compiling
The wxWindows setup.h file has several settings in it pertaining to compiling the wxODBC classes. wxUSE_ODBC This must be set to 1 in order for the compiler to compile the wxODBC classes. Without setting this to 1, there will be no access to any of the wxODBC classes. The default is 0.

wxODBC_FWD_ONLY_CURSORS When a new database connection is requested, this setting controls the default of whether the connection allows only forward scrolling cursors, or forward and backward scrolling cursors (see the section in "WHERE TO START" on cursors for more information on cursors). This default can be overridden by passing a second

1673


CHAPTER 11
parameter to either the wxDbGetConnection (p. 267) or wxDb constructor (p. 269). The default is 1. wxODBC_BACKWARD_COMPATABILITY Between v2.0 and 2.2, massive renaming efforts were done to the ODBC classes to get naming conventions similar to those used throughout wxWindows, as well as to preface all wxODBC classes names and functions with a wxDb preface. Because this renaming would affect applications written using the v2.0 names, this compile-time directive was added to allow those programs written for v2.0 to still compile using the old naming conventions. These deprecated names are all #define'd to their corresponding new function names at the end of the db.cpp/dbtable.cpp source files. These deprecated class/function names should not be used in future development, as at some point in the future they will be removed. The default is 0. Under MS Windows You are required to include the "odbc32.lib" provided by your compiler vendor in the list of external libraries to be linked in. If using the makefiles supplied with wxWindows, this library should already be included for use with makefile.b32, makefile.vc, and makefile.g95. You cannot compile the wxODBC classes under Win16 - sorry. MORE TO COME Under Unix--with-odbc flag for configure MORE TO COME

wxODBC - Basic Step-By-Step Guide
To use the classes in an application, there are eight basic steps:         Define datasource connection information Get a datasource connection Create table definition Open the table Use the table Close the table Close the datasource connection Release the ODBC environment handle

1674


CHAPTER 11
Following each of these steps is detailed to explain the step, and to hopefully mention as many of the pitfalls that beginning users fall in to when first starting to use the classes. Throughout the steps, small snippets of code are provided to show the syntax of performing the step. A complete code snippet is provided at the end of this overview that shows a complete working flow of all these steps (see wxODBC - Sample Code (p. 1684)). Define datasource connection information To be able to connect to a datasource through the ODBC driver, a program must supply a minimum of three pieces of information: Datasource name, User ID, and Authorization string (password). A fourth piece of information, a default directory indicating where the data file is stored, is required for Text and dBase drivers for ODBC. The wxWindows data class wxDbConnectInf exists for holding all of these values, plus some others that may be desired. The 'Henv' member is the environment handle used to access memory for use by the ODBC driver. Use of this member is described below in the "Getting a Connection to the Datasource" section. The 'Dsn' must exactly match the datasource name used to configure the ODBC datasource (in the ODBC Administrator (MSW only) or in the .odbc.ini file). The 'Uid' is the User ID that is to be used to log in to the datasource. This User ID must already have been created and assigned rights within the datasource to which you are connecting. The user that the connection is establish by will determine what rights and privileges the datasource connection will allow the program to have when using the connection that this connection information was used to establish. Some datasources are case sensitive for User IDs, and though the wxODBC classes attempt to hide this from you by manipulating whatever data you pass in to match the datasource's needs, it is always best to pass the 'Uid' in the case that the datasource requires. The 'AuthStr' is the password for the User ID specified in the 'Uid' member. As with the 'Uid', some datasources are case sensitive (in fact most are). The wxODBC classes do NOT try to manage the case of the 'AuthStr' at all. It is passed verbatim to the datasource, so you must use the case that the datasource is expecting. The 'defaultDir' member is used with file based datasources (i.e. dBase, FoxPro, text files). It contains a full path to the location where the data table or file is located. When setting this value, use forward slashes '/' rather than backslashes ' avoid compatibility differences between ODBC drivers. The other fields are currently unused. The intent of these fields are that they will be used to write our own ODBC Administrator type program that will work on both MSW and Un*x systems, regardless of the datasource. Very little work has been done on this to date. Get a Datasource Connection There are two methods of establishing a connection to a datasource. You may either manually create your own wxDb instance and open the connection, or you may use the caching functions provided with the wxODBC classes to create/maintain/delete the

1675


CHAPTER 11
connections. Regardless of which method you use, you must first have a fully populated wxDbConnectInf object. In the wxDbConnectInf instance, provide a valid Dns, Uid, and AuthStr (along with a 'defaultDir' if necessary). Before using this though, you must allocate an environment handle to the 'Henv' member.
wxDbConnectInf DbConnectInf; DbConnectInf.SetDsn("MyDSN"); DbConnectInf.SetUserID("MyUserName"); DbConnectInf.SetPassword("MyPassword"); DbConnectInf.SetDefaultDir("");

To allocate an environment handle for the ODBC connection to use, the wxDbConnectInf class has a datasource independent method for creating the necessary handle:
if (DbConnectInf.AllocHenv()) { wxMessageBox("Unable to allocate an ODBC environment handle", "DB CONNECTION ERROR", wxOK | wxICON_EXCLAMATION); return; }

When the wxDbConnectInf::AllocHenv() function is called successfully, a value of true will be returned. A value of false means allocation failed, and the handle will be undefined. A shorter form of doing the above steps is encapsulated into the long form of the constructor for wxDbConnectInf.
wxDbConnectInf *DbConnectInf; DbConnectInf = new wxDbConnectInf(NULL, "MyDSN", "MyUserName", "MyPassword", "");

This shorthand form of initializing the constructor passes a NULL for the SQL environment handle, telling the constructor to allocate a handle during construction. This handle is also managed for the life of wxDbConnectInf instance, and is freed automatically upon destruction of the instance. Once the wxDbConnectInf instance is initialized, you are ready to connect to the datasource. To manually create datasource connections, you must create a wxDb instance, and then open it.
wxDb *db = new wxDb(DbConnectInf->GetHenv()); opened= db >Open(DbConnectInf);

The first line does the house keeping needed to initialize all the members of the wxDb class. The second line actually sends the request to the ODBC driver to open a connection to its associated datasource using the parameters supplied in the call to wxDb::Open (p. 285). A more advanced form of opening a connection is to use the connection caching functions that are included with the wxODBC classes. The caching mechanisms

1676


CHAPTER 11
perform the same functions as the manual approach to opening a connection, but they also manage each connection they have created, re-using them and cleaning them up when they are closed, without you needing to do the coding. To use the caching function wxDbGetConnection (p. 267) to get a connection to a datasource, simply call it with a single parameter of the type wxDbConnectInf:
db = wxDbGetConnection(DbConnectInf);

The wxDb pointer that is returned is both initialized and opened. If something failed in creating or opening the connection, the return value from wxDbGetConnection (p. 267) will be NULL. The connection that is returned is either a new connection, or it is a "free" connection from the cache of connections that the class maintains that was no longer in use. Any wxDb instance created with a call to wxDbGetConnection (p. 267) is recorded in a linked list of established connections. When a program is finished with a connection, a call to wxDbFreeConnection (p. 267) is made, and the datasource connection will then be tagged as FREE, making it available for the next call to wxDbGetConnection (p. 267) that needs a connection using the same connection information (Dsn, Uid, AuthStr). The cached connections remain cached until a call to wxDbCloseConnections (p. 267) is made, at which time all cached connections are closed and deleted. Besides the obvious advantage of using the single command caching routine to obtain a datasource connection, using cached connections can be quite a performance boost as well. Each time that a new connection is created (not retrieved from the cache of free connections), the wxODBC classes perform many queries against the datasource to determine the datasource's datatypes and other fundamental behaviours. Depending on the hardware, network bandwidth, and datasource speed, this can in some cases take a few seconds to establish the new connection (with well-balanced systems, it should only be a fraction of a second). Re-using already established datasource connections rather than creating/deleting, creating/deleting connections can be quite a time-saver. Another time-saver is the "copy connection" features of both wxDb::Open (p. 285) and wxDbGetConnection (p. 267). If manually creating a wxDb instance and opening it, you must pass an existing connection to the wxDb::Open (p. 285) function yourself to gain the performance benefit of copying existing connection settings. The wxDbGetConnection (p. 267) function automatically does this for you, checking the Dsn, Uid, and AuthStr parameters when you request a connection for any existing connections that use those same settings. If one is found, wxDbGetConnection (p. 267) copies the datasource settings for datatypes and other datasource specific information that was previously queried, rather than re-querying the datasource for all those same settings. One final note on creating a connection. When a connection is created, it will default to only allowing cursor scrolling to be either forward only, or both backward and forward scrolling. The default behavior is determined by the setting wxODBC_FWD_ONLY_CURSORS in setup.h when you compile the wxWindows library. The library default is to only support forward scrolling cursors only, though this can be overridden by parameters for wxDb() constructor or the wxDbGetConnection (p. 267) function. All datasources and ODBC drivers must support forward scrolling cursors. Many datasources support backward scrolling cursors, and many ODBC drivers support

1677


CHAPTER 11
backward scrolling cursors. Before planning on using backward scrolling cursors, you must be certain that both your datasource and ODBC driver fully support backward scrolling cursors. See the small blurb about "Scrolling cursors" in the definitions at the beginning of this overview, or other details of setting the cursor behavior in the wxDb class documentation. Create Table Definition Data can be accessed in a datasource's tables directly through various functions of the wxDb class (see wxDb::GetData (p. 278)). But to make life much simpler, the wxDbTable class encapsulates all of the SQL specific API calls that would be necessary to do this, wrapping it in an intuitive class of APIs. The first step in accessing data in a datasource's tables via the wxDbTable class is to create a wxDbTable instance.
table = new wxDbTable(db, tableName, numTableColumns, "", !wxDB_QUERY_ONLY, "");

When you create the instance, you indicate the previously established datasource connection to be used to access the table, the name of the primary table that is to be accessed with the datasource's tables, how many columns of each row are going to be returned, the name of the view of the table that will actually be used to query against (works with Oracle only at this time), whether the data returned is for query purposes only, and finally the path to the table, if different than the path specified when connecting to the datasource. Each of the above parameters are described in detail in the wxDbTable class' description, but one special note here about the fifth parameter - the queryOnly setting. If a wxDbTable instance is created as wxDB_QUERY_ONLY, then no inserts/deletes/updates can be performed using this instance of the wxDbTable. Any calls to wxDb::CommitTrans (p. 271) or wxDb::RollbackTrans (p. 286) against the datasource connection used by this wxDbTable instance are ignored by this instance. If the wxDbTable instance is created with !wxDB_QUERY_ONLY as shown above, then all the cursors and other overhead associated with being able to insert/update/delete data in the table are created, and thereby those operations can then be performed against the associated table with this wxDbTable instance. If a table is to be accessed via a wxDbTable instance, and the table will only be read from, not written to, there is a performance benefit (not as many cursors need to be maintained/updated, hence speeding up access times), as well as a resource savings due to fewer cursors being created for the wxDbTable instance. Also, with some datasources, the number of simultaneous cursors is limited. When defining the columns to be retrievable by the wxDbTable instance, you can specify anywhere from one column up to all columns in the table.
table->SetColDefs(0, "FIRST_NAME", DB_DATA_TYPE_VARCHAR, FirstName, SQL_C_CHAR, sizeof(name), true, true); table->SetColDefs(1, "LAST_NAME", DB_DATA_TYPE_VARCHAR, LastName, SQL_C_CHAR, sizeof(LastName), true, true);

Notice that column definitions start at index 0 and go up to one less than the number of columns specified when the wxDbTable instance was created (in this example, two

1678


CHAPTER 11
columns - one with index 0, one with index 1). The above lines of code "bind" the datasource columns specified to the memory variables in the client application. So when the application makes a call to wxDbTable::GetNext (p. 317) (or any other function that retrieves data from the result set), the variables that are bound to the columns will have the column value stored into them. See the wxDbTable::SetColDefs (p. 328) class documentation for more details on all the parameters for this function. The bound memory variables have undefined data in them until a call to a function that retrieves data from a result set is made (e.g. wxDbTable::GetNext (p. 317),wxDbTable::GetPrev (p. 318), etc). The variables are not initialized to any data by the wxODBC classes, and they still contain undefined data after a call to wxDbTable::Query (p. 323). Only after a successful call to one of the ::GetXxxx() functions is made do the variables contain valid data. It is not necessary to define column definitions for columns whose data is not going to be returned to the client. For example, if you want to query the datasource for all users with a first name of 'GEORGE', but you only want the list of last names associated with those rows (why return the FIRST_NAME column every time when you already know it is 'GEORGE'), you would only have needed to define one column above. You may have as many wxDbTable instances accessing the same table using the same wxDb instance as you desire. There is no limit imposed by the classes on this. All datasources supported (so far) also have no limitations on this. Open the table Opening the table is not technically doing anything with the datasource itself. Calling wxDbTable::Open (p. 321) simply does all the housekeeping of checking that the specified table exists, that the current connected user has at least SELECT privileges for accessing the table, setting up the requisite cursors, binding columns and cursors, and constructing the default INSERT statement that is used when a new row is inserted into the table (non-wxDB_QUERY_ONLY tables only).
if (!table->Open()) { // An error occurred opening (setting up) the table }

The only reason that a call to wxDbTable::Open (p. 321) is likely to fail is if the user has insufficient privileges to even SELECT the table. Other problems could occur, such as being unable to bind columns, but these other reason point to some lack of resource (like memory). Any errors generated internally in the wxDbTable::Open (p. 321) function are logged to the error log if SQL logging is turned on for the classes. Use the table To use the table and the definitions that are now set up, we must first define what data we want the datasource to collect in to a result set, tell it where to get the data from, and in what sequence we want the data returned.
// the WHERE clause limits/specifies which rows in the table // are to be returned in the result set table->SetWhereClause("FIRST_NAME = 'GEORGE'");

1679


CHAPTER 11

// Result set will be sorted in ascending alphabetical // order on the data in the 'LAST_NAME' column of each row // If the same last name is in the table for two rows, // sub sort on the 'AGE' column table->SetOrderByClause("LAST_NAME, AGE"); // No other tables (joins) are used for this query table->SetFromClause("");

The above lines will be used to tell the datasource to return in the result all the rows in the table whose column "FIRST_NAME" contains the name 'GEORGE' (note the required use of the single quote around the string literal) and that the result set will return the rows sorted by ascending last names (ascending is the default, and can be overridden with the "DESC" keyword for datasources that support it - "LAST_NAME DESC"). Specifying a blank WHERE clause will result in the result set containing all rows in the datasource. Specifying a blank ORDERBY clause means that the datasource will return the result set in whatever sequence it encounters rows which match the selection criteria. What this sequence is can be hard to determine. Typically it depends on the index that the datasource used to find the rows which match the WHERE criteria. BEWARE - relying on the datasource to return data in a certain sequence when you have not provided an ORDERBY clause will eventually cause a problem for your program. Databases can be tuned to be COST-based, SPEED-based, or some other basis for how it gets your result set. In short, if you need your result set returned in a specific sequence, ask for it that way by providing an ORDERBY clause. Using an ORDERBY clause can be a performance hit, as the database must sort the items before making the result set available to the client. Creating efficient indexes that cause the data to be "found" in the correct ORDERBY sequence can be a big performance benefit. Also, in the large majority of cases, the database will be able to sort the records faster than your application can read all the records in (unsorted) and then sort them. Let the database do the work for you! Notice in the example above, a column that is not included in the bound data columns ('AGE') will be used to sub-sort the result set. The FROM clause in this example is blanked, as we are not going to be performing any table joins with this simple query. When the FROM clause is blank, it is assumed that all columns referenced are coming from the default table for the wxDbTable instance. After the selection criteria have been specified, the program can now ask the datasource to perform the search and create a result set that can be retrieved:
// Instruct the datasource to perform a query based on the // criteria specified above in the where/orderBy/from clauses. if (!table->Query()) { // An error occurred performing the query }

Typically, when an error occurs when calling wxDbTable::Query (p. 323), it is a syntax problem in the WHERE clause that was specified. The exact SQL (datasource-specific) reason for what caused the failure of wxDbTable::Query (p. 323) (and all other

1680


CHAPTER 11
operations against the datasource can be found by parsing the table's database connection's "errorList[]" array member for the stored text of the error. When the wxDbTable::Query (p. 323) returns true, the database was able to successfully complete the requested query using the provided criteria. This does not mean that there are any rows in the result set, it just mean that the query was successful. IMPORTANT: The result created by the call to wxDbTable::Query (p. 323) can take one of two forms. It is either a snapshot of the data at the exact moment that the database determined the record matched the search criteria, or it is a pointer to the row that matched the selection criteria. Which form of behavior is datasource dependent. If it is a snapshot, the data may have changed since the result set was constructed, so beware if your datasource uses snapshots and call wxDbTable::Refresh (p. 328). Most larger brand databases do not use snapshots, but it is important to mention so that your application can handle it properly if your datasource does. To retrieve the data, one of the data fetching routines must be used to request a row from the result set, and to store the data from the result set into the bound memory variables. After wxDbTable::Query (p. 323) has completed successfully, the default/current cursor is placed so it is pointing just before the first record in the result set. If the result set is empty (no rows matched the criteria), then any calls to retrieve data from the result set will return false.
wxString msg; while (table->GetNext()) { msg.Printf("Row #%lu -- First Name : %s Last Name is %s", table->GetRowNum(), FirstName, LastName); wxMessageBox(msg, "Data", wxOK | wxICON_INFORMATION, NULL); }

The sample code above will read the next record in the result set repeatedly until the end of the result set has been reached. The first time that wxDbTable::GetNext (p. 317) is called right after the successful call to wxDbTable::Query (p. 323), it actually returns the first record in the result set. When wxDbTable::GetNext (p. 317) is called and there are no rows remaining in the result set after the current cursor position, wxDbTable::GetNext (p. 317) (as well as all the other wxDbTable::GetXxxxx() functions) will return false. Close the table When the program is done using a wxDbTable instance, it is as simple as deleting the table pointer (or if declared statically, letting the variable go out of scope). Typically the default destructor will take care of all that is required for cleaning up the wxDbTable instance.
if (table) { delete table; table = NULL; }

Deleting a wxDbTable instance releases all of its cursors, deletes the column definitions

1681


CHAPTER 11
and frees the SQL environment handles used by the table (but not the environment handle used by the datasource connection that the wxDbTable instance was using). Close the datasource connection After all tables that have been using a datasource connection have been closed (this can be verified by calling wxDb::GetTableCount (p. 281) and checking that it returns 0), then you may close the datasource connection. The method of doing this is dependent on whether the non-caching or caching method was used to obtain the datasource connection. If the datasource connection was created manually (non-cached), closing the connection is done like this:
if (db) { db->Close(); delete db; db = NULL; }

If the program used the wxDbGetConnection (p. 267) function to get a datasource connection, the following is the code that should be used to free the connection(s):
if (db) { wxDbFreeConnection(db); db = NULL; }

Note that the above code just frees the connection so that it can be re-used on the next call the wxDbGetConnection (p. 267). To actually dispose of the connection, releasing all of its resources (other than the environment handle), do the following:
wxDbCloseConnections();

Release the ODBC environment handle Once all of the connections that used the ODBC environment handle (in this example it was stored in "DbConnectInf.Henv") have been closed, then it is safe to release the environment handle:
DbConnectInf->FreeHenv();

Or, if the long form of the constructor was used and the constructor was allowed to allocate its own SQL environment handle, leaving scope or destruction of the wxDbConnectInf will free the handle automatically.
delete DbConnectInf;

Remember to never release this environment handle if there are any connections still using the handle.

wxODBC - Known Issues

1682


CHAPTER 11
As with creating wxWindows, writing the wxODBC classes was not the simple task of writing an application to run on a single type of computer system. The classes need to be cross-platform for different operating systems, and they also needed to take in to account different database manufacturers and different ODBC driver manufacturers. Because of all the possible combinations of OS/database/drivers, it is impossible to say that these classes will work perfectly with datasource ABC, ODBC driver XYZ, on platform LMN. You may run in to some incompatibilities or unsupported features when moving your application from one environment to another. But that is what makes cross-platform programming fun. It is also pinpoints one of the great things about open source software. It can evolve! The most common difference between different database/ODBC driver manufacturers in regards to these wxODBC classes is the lack of standard error codes being returned to the calling program. Sometimes manufacturers have even changed the error codes between versions of their databases/drivers. In all the tested databases, every effort has been made to determine the correct error codes and handle them in the class members that need to check for specific error codes (such as TABLE DOES NOT EXIST when you try to open a table that has not been created yet). Adding support for additional databases in the future requires adding an entry for the database in the wxDb::Dbms (p. 272) function, and then handling any error codes returned by the datasource that do not match the expected values. Databases Following is a list of known issues and incompatibilities that the wxODBC classes have between different datasources. An up to date listing of known issues can be seen in the comments of the source for wxDb::Dbms (p. 272). ORACLE  DBASE NOTE: dBase is not a true ODBC datasource. You only have access to as much functionality as the driver can emulate.    Does not support the SQL_TIMESTAMP structure Supports only one cursor and one connect (apparently? with Microsoft driver only?) Does not automatically create the primary index if the 'keyField' param of SetColDef is true. The user must create ALL indexes from their program with calls to wxDbTable::CreateIndex (p. 308) Table names can only be 8 characters long Column names can only be 10 characters long Currently cannot CREATE a dBase table - bug or limitation of the drivers used?? Currently the only database supported by the wxODBC classes to support VIEWS

  

1683


CHAPTER 11
 Currently cannot insert rows that have integer columns - bug??

SYBASE (all)  To lock a record during QUERY functions, the reserved word 'HOLDLOCK' must be added after every table name involved in the query/join if that table's matching record(s) are to be locked Ignores the keywords 'FOR UPDATE'. Use the HOLDLOCK functionality described above



SYBASE (Enterprise)   mySQL    If a column is part of the Primary Key, the column cannot be NULL. Cannot support selecting for update [wxDbTable::CanSelectForUpdate (p. 305)]. Always returns false. Columns that are part of primary or secondary keys must be defined as being NOT NULL when they are created. Some code is added in wxDbTable::CreateIndex (p. 308) to try to adjust the column definition if it is not defined correctly, but it is experimental (as of wxWindows v2.2.1) Does not support sub-queries in SQL statements If a column is part of the Primary Key, the column cannot be NULL Maximum row size is somewhere in the neighborhood of 1920 bytes



POSTGRES   DB2  Columns which are part of a primary key must be declared as NOT NULL Does not support the keywords 'ASC' or 'DESC' as of release v6.5.0 Does not support sub-queries in SQL statements

UNICODE with wxODBC classes The ODBC classes support for Unicode is yet in early experimental stage and hasn't been tested extensively. It might work for you or it might not: please report the bugs/problems you have encountered in the latter case.

wxODBC - Sample Code
Simplest example of establishing/opening a connection to an ODBC datasource, binding variables to the columns for read/write usage, opening an existing table in the datasource, setting the query parameters (where/orderBy/from), querying the datasource, reading each row of the result set, then cleaning up.

1684


CHAPTER 11
NOTE: Not all error trapping is shown here, to reduce the size of the code and to make it more easily readable.
wxDbConnectInf wxDb wxDbTable *DbConnectInf = NULL; // The database connection // The data table to access // buffer for data from column // buffer for data from column

*db = NULL; *table = NULL;

wxChar FirstName[50+1]; "FIRST_NAME" wxChar LastName[50+1]; "LAST_NAME" bool

errorOccured = false; = "CONTACTS"; = 2; // Number of bound

const wxChar tableName[] const UWORD numTableColumns columns FirstName[0] = 0; LastName[0] = 0;

DbConnectInf = new wxDbConnectInf(NULL,"MyDSN","MyUserName", "MyPassword"); if (!DbConnectInf || !DbConnectInf->GetHenv()) { wxMessageBox("Unable to allocate an ODBC environment handle", "DB CONNECTION ERROR", wxOK | wxICON_EXCLAMATION); return; } // Get a database connection from the cached connections db = wxDbGetConnection(DbConnectInf); // Create the table connection table = new wxDbTable(db, tableName, numTableColumns, "", !wxDB_QUERY_ONLY, ""); // // Bind the columns that you wish to retrieve. Note that there must be // 'numTableColumns' calls to SetColDefs(), to match the wxDbTable definition // // Not all columns need to be bound, only columns whose values are to be // returned back to the client. // table->SetColDefs(0, "FIRST_NAME", DB_DATA_TYPE_VARCHAR, FirstName, SQL_C_CHAR, sizeof(name), true, true); table->SetColDefs(1, "LAST_NAME", DB_DATA_TYPE_VARCHAR, LastName, SQL_C_CHAR, sizeof(LastName), true, true); // Open the table for access table->Open(); // Set the WHERE clause to limit the result set to return // all rows that have a value of 'GEORGE' in the FIRST_NAME // column of the table. table->SetWhereClause("FIRST_NAME = 'GEORGE'"); // Result set will be sorted in ascending alphabetical // order on the data in the 'LAST_NAME' column of each row table->SetOrderByClause("LAST_NAME"); // No other tables (joins) are used for this query table->SetFromClause(""); // Instruct the datasource to perform a query based on the // criteria specified above in the where/orderBy/from clauses. if (!table >Query()) {

1685


CHAPTER 11
wxMessageBox("Error on Query()","ERROR!", wxOK | wxICON_EXCLAMATION); errorOccured = true; } wxString msg; // Start and continue reading every record in the table // displaying info about each record read. while (table->GetNext()) { msg.Printf("Row #%lu -- First Name : %s Last Name is %s", table->GetRowNum(), FirstName, LastName); wxMessageBox(msg, "Data", wxOK | wxICON_INFORMATION, NULL); } // // Select the rw which has FIRST_NAME of 'GEORGE' and LAST_NAME o // of 'TASKER', then delete the retrieved row // table->SetWhereClause("FIRST_NAME = 'GEORGE' and "LAST_NAME = 'TASKER'"); if (table->Query()) { table->Delete(); // Must commit the deletion table->GetDb()->CommitTrans(); } // // Insert a new row into the table // wxStrcpy(FirstName, "JULIAN"); wxStrcpy(LastName, "SMART"); table->Insert(); // Must commit the insert table->GetDb()->CommitTrans(); // If the wxDbTable instance was successfully created // then delete it as we are done with it now. if (table) { wxDelete(table); } // // // // if { } // The program is now ending, so we need to close // any cached connections that are still being // maintained. wxDbCloseConnections(); // Release the environment handle that was created // for use with the ODBC datasource connections wxDelete(DbConnectInf); If we have a valid wxDb instance, then free the connection (meaning release it back in to the cache of datasource connections) for the next time a call to wxDbGetConnection() is made. (db) wxDbFreeConnection(db); db = NULL;

1686


CHAPTER 11 A selection of SQL commands
The following is a very brief description of some common SQL commands, with examples. See also Database classes overview (p. 1668)

Create
Creates a table. Example:
CREATE TABLE Book (BookNumber INTEGER PRIMARY KEY , CategoryCode CHAR(2) DEFAULT 'RO' NOT NULL , Title VARCHAR(100) UNIQUE , NumberOfPages SMALLINT , RetailPriceAmount NUMERIC(5,2) )

Insert
Inserts records into a table. Example:
INSERT INTO Book (BookNumber, CategoryCode, Title) VALUES(5, 'HR', 'The Lark Ascending')

Select
The Select operation retrieves rows and columns from a table. The criteria for selection and the columns returned may be specified. Examples: SELECT * FROM Book Selects all rows and columns from table Book. SELECT Title, RetailPriceAmount FROM Book WHERE RetailPriceAmount > 20.0 Selects columns Title and RetailPriceAmount from table Book, returning only the rows that match the WHERE clause. SELECT * FROM Book WHERE CatCode = 'LL' OR CatCode = 'RR' Selects all columns from table Book, returning only the rows that match the WHERE clause. SELECT * FROM Book WHERE CatCode IS NULL Selects all columns from table Book, returning only rows where the CatCode column is

1687


CHAPTER 11
NULL. SELECT * FROM Book ORDER BY Title Selects all columns from table Book, ordering by Title, in ascending order. To specify descending order, add DESC after the ORDER BY Title clause. SELECT Title FROM Book WHERE RetailPriceAmount >= 20.0 AND RetailPriceAmount <= 35.0 Selects records where RetailPriceAmount conforms to the WHERE expression.

Update
Updates records in a table. Example: UPDATE Incident SET X = 123 WHERE ASSET = 'BD34' This example sets a field in column 'X' to the number 123, for the record where the column ASSET has the value 'BD34'.

Interprocess communication overview
Classes: wxServer (p. 1101),wxConnection (p. 191),wxClient (p. 131)wxWindows has a number of different classes to help with interprocess communication and network programming. This section only discusses one family of classes -- the DDE-like protocol -- but here's a list of other useful classes:   wxSocketEvent (p. 1150),wxSocketBase (p. 1131),wxSocketClient (p. 1148),wxSocketServer (p. 1152): classes for the low-level TCP/IP API. wxProtocol (p. 1027), wxURL (p. 1355), wxFTP (p. 545), wxHTTP (p. 715): classes for programming popular Internet protocols.

wxWindows' DDE-like protocol is a high-level protocol based on Windows DDE. There are two implementations of this DDE-like protocol: one using real DDE running on Windows only, and another using TCP/IP (sockets) that runs on most platforms. Since the API and virtually all of the behaviour is the same apart from the names of the classes, you should find it easy to switch between the two implementations. Notice that by including <wx/ipc.h> you may define convenient synonyms for the IPC classes: wxServer for eitherwxDDEServer or wxTCPServer depending on whether DDE-based or socket-based implementation is used and the same thing for wxClient and wxConnection. By default, DDE implementation is used under Windows. DDE works only within one computer. If you want to use IPC between different workstations you should define wxUSE_DDE_FOR_IPC as 0 before including this header -- this will force using TCP/IP implementation even under Windows. The following description refers to wx... but remember that the equivalent wxTCP... and

1688


CHAPTER 11
wxDDE... classes can be used in much the same way. Three classes are central to the DDE-like API: 1. 2. 3. wxClient. This represents the client application, and is used only within a client program. wxServer. This represents the server application, and is used only within a server program. wxConnection. This represents the connection from the client to the server both the client and the server use an instance of this class, one per connection. Most DDE transactions operate on this object.

Messages between applications are usually identified by three variables: connection object, topic name and item name. A data string is a fourth element of some messages. To create a connection (a conversation in Windows parlance), the client application uses wxClient::MakeConnection to send a message to the server object, with a string service name to identify the server and a topic name to identify the topic for the duration of the connection. Under Unix, the service name may be either an integer port identifier in which case an Internet domain socket will be used for the communications or a valid file name (which shouldn't exist and will be deleted afterwards) in which case a Unix domain socket is created. SECURITY NOTE: Using Internet domain sockets if extremely insecure for IPC as there is absolutely no access control for them, use Unix domain sockets whenever possible! The server then responds and either vetoes the connection or allows it. If allowed, both the server and client objects create wxConnection objects which persist until the connection is closed. The connection object is then used for sending and receiving subsequent messages between client and server - overriding virtual functions in your class derived from wxConnection allows you to handle the DDE messages. To create a working server, the programmer must: 1. Derive a class from wxConnection, providing handlers for various messages sent to the server side of a wxConnection (e.g. OnExecute, OnRequest, OnPoke). Only the handlers actually required by the application need to be overridden. Derive a class from wxServer, overriding OnAcceptConnection to accept or reject a connection on the basis of the topic argument. This member must create and return an instance of the derived connection class if the connection is accepted. Create an instance of your server object and call Create to activate it, giving it a service name.

2.

3.

To create a working client, the programmer must: 1. Derive a class from wxConnection, providing handlers for various messages sent to the client side of a wxConnection (e.g. OnAdvise). Only the handlers actually required by the application need to be overridden.

1689


CHAPTER 11
2. 3. 4. Derive a class from wxClient, overriding OnMakeConnection to create and return an instance of the derived connection class. Create an instance of your client object. When appropriate, create a new connection usingwxClient::MakeConnection (p. 132), with arguments host name (processed in Unix only, use 'localhost' for local computer), service name, and topic name for this connection. The client object will callOnMakeConnection (p. 133) to create a connection object of the derived class if the connection is successful. Use the wxConnection member functions to send messages to the server.

5.

Data transfer
These are the ways that data can be transferred from one application to another. These are methods of wxConnection.  Execute: the client calls the server with a data string representing a command to be executed. This succeeds or fails, depending on the server's willingness to answer. If the client wants to find the result of the Execute command other than success or failure, it has to explicitly call Request. Request: the client asks the server for a particular data string associated with a given item string. If the server is unwilling to reply, the return value is NULL. Otherwise, the return value is a string (actually a pointer to the connection buffer, so it should not be deallocated by the application). Poke: The client sends a data string associated with an item string directly to the server. This succeeds or fails. Advise: The client asks to be advised of any change in data associated with a particular item. If the server agrees, the server will send an OnAdvise message to the client along with the item and data.



 

The default data type is wxCF_TEXT (ASCII text), and the default data size is the length of the null-terminated string. Windows-specific data types could also be used on the PC.

Examples
See the sample programs server and client in the IPC samples directory. Run the server, then the client. This demonstrates using the Execute, Request, and Poke commands from the client, together with an Advise loop: selecting an item in the server list box causes that item to be highlighted in the client list box.

More DDE details
A wxClient object initiates the client part of a client-server DDE-like (Dynamic Data Exchange) conversation (available in both Windows and Unix).

1690


CHAPTER 11
To create a client which can communicate with a suitable server, you need to derive a class from wxConnection and another from wxClient. The custom wxConnection class will receive communications in a 'conversation' with a server. and the custom wxServer is required so that a user-overriddenwxDDEClient::OnMakeConnection (p. 133)member can return a wxDDEConnection of the required class, when a connection is made. For example:
class MyConnection: public wxConnection { public: MyConnection(void)::wxConnection() {} ~MyConnection(void) { } bool OnAdvise(const wxString& topic, const wxString& item, char *data, int size, wxIPCFormat format) { wxMessageBox(topic, data); } }; class MyClient: public wxClient { public: MyClient(void) {} wxConnectionBase *OnMakeConnection(void) { return new MyConnection; } };

Here, MyConnection will respond toOnAdvise (p. 193) messages sent by the server by displaying a message box. When the client application starts, it must create an instance of the derived wxClient. In the following, command line arguments are used to pass the host name (the name of the machine the server is running on) and the server name (identifying the server process). CallingwxDDEClient::MakeConnection (p. 132) implicitly creates an instance of MyConnection if the request for a connection is accepted, and the client then requests an Advise loop from the server (an Advise loop is where the server calls the client when data has changed).
wxString server = "4242"; wxString hostName; wxGetHostName(hostName); // Create a new client MyClient *client = new MyClient; connection = (MyConnection *)client->MakeConnection(hostName, server, "IPC TEST"); if (!connection) { wxMessageBox("Failed to make connection to server", "Client Demo Error"); return NULL; } connection->StartAdvise("Item");

Note that it is no longer necessary to call wxDDEInitialize or wxDDECleanUp, since wxWindows will do this itself if necessary.

wxHTML overview
This topic was written by Vaclav Slavik, the author of the wxHTML library.

1691


CHAPTER 11
The wxHTML library provides classes for parsing and displaying HTML. It is not intended to be a high-end HTML browser. If you are looking for something like that try http://www.mozilla.org (http://www.mozilla.org). wxHTML can be used as a generic rich text viewer - for example to display a nice About Box (like those of GNOME apps) or to display the result of database searching. There is a wxFileSystem (p. 492) class which allows you to use your own virtual file systems. wxHtmlWindow supports tag handlers. This means that you can easily extend wxHtml library with new, unsupported tags. Not only that, you can even use your own application-specific tags! See src/html/m_*.cpp files for details. There is a generic wxHtmlParser class, independent of wxHtmlWindow.

wxHTML quick start
Displaying HMTL First of all, you must include <wx/wxhtml.h>. Class wxHtmlWindow (p. 699) (derived from wxScrolledWindow) is used to display HTML documents. It has two important methods: LoadPage (p. 702) and SetPage (p. 707). LoadPage loads and displays HTML file while SetPage displays directly the passed string. See the example:
mywin- > LoadPage("test.htm"); mywin- > SetPage("<html><body>" "<h1>Error</h1>" "Some error occurred :-H)" "</body></hmtl>");

I think the difference is quite clear. Displaying Help See wxHtmlHelpController (p. 672). Setting up wxHtmlWindow Because wxHtmlWindow is derived from wxScrolledWindow and not from wxFrame, it doesn't have visible frame. But the user usually want to see the title of HTML page displayed somewhere and frame's titlebar is ideal place for it. wxHtmlWindow provides 2 methods in order to handle this: SetRelatedFrame (p. 707) and SetRelatedStatusBar (p. 707). See the example:
html = new wxHtmlWindow(this); html -> SetRelatedFrame(this, "HTML : %%s"); html -> SetRelatedStatusBar(0);

The first command associates html object with it is parent frame (this points to wxFrame object there) and sets format of title. Page title "Hello, world!" will be displayed as "HTML : Hello, world!" in this example.

1692


CHAPTER 11
The second command sets which frame's status bar should be used to display browser's messages (such as "Loading..." or "Done" or hypertext links). Customizing wxHtmlWindow You can customize wxHtmlWindow by setting font size, font face and borders (space between border of window and displayed HTML). Related functions:     SetFonts (p. 706) SetBorders (p. 706) ReadCustomization (p. 705) WriteCustomization (p. 708)

The last two functions are used to store user customization info wxConfig stuff (for example in the registry under Windows, or in a dotfile under Unix).

HTML Printing
The wxHTML library provides printing facilities with several levels of complexity. The easiest way to print an HTML document is to use wxHtmlEasyPrinting class (p. 668). It lets you print HTML documents with only one command and you don't have to worry about deriving from the wxPrintout class at all. It is only a simple wrapper around the wxHtmlPrintout (p. 690), normal wxWindows printout class. And finally there is the low level class wxHtmlDCRenderer (p. 665) which you can use to render HTML into a rectangular area on any DC. It supports rendering into multiple rectangles with the same width. (The most common use of this is placing one rectangle on each page or printing into two columns.)

Help Files Format
wxHTML library uses a reduced version of MS HTML Workshop format. Tex2RTF can produce these files when generating HTML, if you set htmlWorkshopFiles to true in your tex2rtf.ini file. (See wxHtmlHelpController (p. 672) for help controller description.) A book consists of three files: header file, contents file and index file. You can make a regular zip archive of these files, plus the HTML and any image files, for wxHTML (or helpview) to read; and the .zip file can optionally be renamed to .htb. Header file (.hhp) Header file must contain these lines (and may contain additional lines which are ignored) :
Contents file=<filename.hhc> Index file=<filename.hhk>

1693


CHAPTER 11
Title=<title of your book> Default topic=<default page to be displayed.htm>

All filenames (including the Default topic) are relative to the location of .hhp file. Localization note: In addition, .hhp file may contain line
Charset=<rfc_charset>

which specifies what charset (e.g. "iso8859_1") was used in contents and index files. Please note that this line is incompatible with MS HTML Help Workshop and it would either silently remove it or complain with some error. See also Writing non-English applications (p. 1590). Contents file (.hhc) Contents file has HTML syntax and it can be parsed by regular HTML parser. It contains exactly one list (<ul>....</ul> statement):
<ul> <li> <object type="text/sitemap"> <param name="Name" value="@topic name@"> <param name="ID" value=@numeric_id@> <param name="Local" value="@filename.htm@"> </object> <li> <object type="text/sitemap"> <param name="Name" value="@topic name@"> <param name="ID" value=@numeric_id@> <param name="Local" value="@filename.htm@"> </object> ... </ul>

You can modify value attributes of param tags. topic name is name of chapter/topic as is displayed in contents, filename.htm is HTML page name (relative to .hhp file) and numeric_id is optional - it is used only when you use wxHtmlHelpController::Display(int) (p. 675) Items in the list may be nested - one <li> statement may contain a <ul> substatement:
<ul> <li> <object type="text/sitemap"> <param name="Name" value="Top node"> <param name="Local" value="top.htm"> </object> <ul> <li> <object type="text/sitemap"> <param name="Name" value="subnode in topnode"> <param name="Local" value="subnode1.htm"> </object> ... </ul> <li> <object type="text/sitemap"> <param name="Name" value="Another Top"> <param name="Local" value="top2.htm"> </object> ...

1694


CHAPTER 11
</ul>

Index file (.hhk) Index files have same format as contents file except that ID params are ignored and sublists are not allowed.

Input Filters
The wxHTML library provides a mechanism for reading and displaying files of many different file formats. wxHtmlWindow::LoadPage (p. 702) can load not only HTML files but any known file. To make a file type known to wxHtmlWindow you must create a wxHtmlFilter (p. 671) filter and register it using wxHtmlWindow::AddFilter (p. 700).

Cells and Containers
This article describes mechanism used by wxHtmlWinParser (p. 708) and wxHtmlWindow (p. 699) to parse and display HTML documents. Cells You can divide any text (or HTML) into small fragments. Let's call these fragments cells. Cell is for example one word, horizontal line, image or any other part of document. Each cell has width and height (except special "magic" cells with zero dimensions - e.g. colour changers or font changers). See wxHtmlCell (p. 653). Containers Container is kind of cell that may contain sub-cells. Its size depends on number and sizes of its sub-cells (and also depends on width of window). See wxHtmlContainerCell (p. 659), wxHtmlCell::Layout (p. 657). Using Containers in Tag Handler wxHtmlWinParser (p. 708) provides a user-friendly way of managing containers. It is based on the idea of opening and closing containers. Use OpenContainer (p. 712) to open new a container within an already opened container. This new container is a sub-container of the old one. (If you want to create a new container with the same depth level you can call CloseContainer(); OpenContainer();.) Use CloseContainer (p. 709) to close the container. This doesn't create a new container with same depth level but it returns "control" to the parent container. It is clear there must be same number of calls to OpenContainer as to CloseContainer...

1695


CHAPTER 11
Example This code creates a new paragraph (container at same depth level) with "Hello, world!":
m_WParser- > CloseContainer(); c = m_WParser -> OpenContainer(); m_WParser- > AddWord("Hello, "); m_WParser- > AddWord("world!"); m_WParser- > CloseContainer(); m_WParser- > OpenContainer();

You can see that there was opened container before running the code. We closed it, created our own container, then closed our container and opened new container. The result was that we had same depth level after executing. This is general rule that should be followed by tag handlers: leave depth level of containers unmodified (in other words, number of OpenContainer and CloseContainer calls should be same within HandleTag (p. 697)'s body).

Tag Handlers
The wxHTML library provides architecture of pluggable tag handlers. Tag handler is class that understands particular HTML tag (or tags) and is able to interpret it. wxHtmlWinParser (p. 708) has static table of modules. Each module contains one or more tag handlers. Each time a new wxHtmlWinParser object is constructed all modules are scanned and handlers are added to wxHtmlParser's list of available handlers (note: wxHtmlParser's list is non-static). How it works Common tag handler's HandleTag (p. 697) method works in four steps: 1. 2. 3. 4. Save state of parent parser into local variables Change parser state according to tag's params Parse text between the tag and paired ending tag (if present) Restore original parser state

See wxHtmlWinParser (p. 708) for methods for modifying parser's state. In general you can do things like opening/closing containers, changing colors, fonts etc. Providing own tag handlers You should create new .cpp file and place following lines into it:
#include <mod_templ.h> #include <forcelink.h> FORCE_LINK_ME(yourmodulefilenamewithoutcpp)

Then you must define handlers and one module. Tag handlers

1696


CHAPTER 11
The handler is derived from wxHtmlWinTagHandler (p. 714)(or directly from wxHtmlTagHandler (p. 696)) You can use set of macros to define the handler (see src/html/m_*.cpp files for details). Handler definition must start with TAG_HANDLER_BEGIN macro and end with TAG_HANDLER_END macro. I strongly recommend to have a look at include/wxhtml/mod_templ.h file. Otherwise you won't understand the structure of macros. See macros reference: TAG_HANDLER_BEGIN(name, tags) Starts handler definition. name is handler identifier (in fact part of class name), tags is string containing list of tags supported by this handler (in uppercase). This macro derives new class from wxHtmlWinTagHandler and implements it is GetSupportedTags (p. 696) method. Example: TAG_HANDLER_BEGIN(FONTS, "B,I,U,T") TAG_HANDLER_VARS This macro starts block of variables definitions. (Variables are identical to class attributes.) Example:
TAG_HANDLER_BEGIN(VARS_ONLY, "CRAZYTAG") TAG_HANDLER_VARS int my_int_var; wxString something_else; TAG_HANDLER_END(VARS_ONLY)

This macro is used only in rare cases. TAG_HANDLER_CONSTR(name) This macro supplies object constructor. name is same name as the one from TAG_HANDLER_BEGIN macro. Body of constructor follow after this macro (you must use and ). Example:
TAG_HANDLER_BEGIN(VARS2, "CRAZYTAG") TAG_HANDLER_VARS int my_int_var; TAG_HANDLER_CONSTR(vars2) { // !!!!!! my_int_var = 666; } // !!!!!! TAG_HANDLER_END(VARS2)

Never used in wxHTML :-) TAG_HANDLER_PROC(varib) This is very important macro. It defines HandleTag (p. 697)method. varib is name of parameter passed to the method, usuallytag. Body of method follows after this macro. Note than you must use and ! Example:
TAG_HANDLER_BEGIN(TITLE, "TITLE") TAG_HANDLER_PROC(tag) { printf("TITLE found...\n"); }

1697


CHAPTER 11
TAG_HANDLER_END(TITLE)

TAG_HANDLER_END(name) Ends definition of tag handler name. Tags Modules You can use set of 3 macros TAGS_MODULE_BEGIN, TAGS_MODULE_ADD and TAGS_MODULE_END to inherit new module fromwxHtmlTagsModule (p. 697) and to create instance of it. See macros reference: TAGS_MODULE_BEGIN(modname) Begins module definition. modname is part of class name and must be unique. TAGS_MODULE_ADD(name) Adds the handler to this module. name is the identifier from TAG_HANDLER_BEGIN. TAGS_MODULE_END(modname) Ends the definition of module. Example:
TAGS_MODULE_BEGIN(Examples) TAGS_MODULE_ADD(VARS_ONLY) TAGS_MODULE_ADD(VARS2) TAGS_MODULE_ADD(TITLE) TAGS_MODULE_END(Examples)

Tags supported by wxHTML
wxHTML is not full implementation of HTML standard. Instead, it supports most common tags so that it is possible to display simple HTML documents with it. (For example it works fine with pages created in Netscape Composer or generated by tex2rtf). Following tables list all tags known to wxHTML, together with supported parameters. A tag has general form of <tagname param_1 param_2 ... param_n> where param_i is either paramname="paramvalue" or paramname=paramvalue - these two are equivalent. Unless stated otherwise, wxHTML is case-insensitive. Table of common parameter values We will use these substitutions in tags descriptions:
[alignment] CENTER LEFT RIGHT JUSTIFY TOP BOTTOM CENTER HTML 4.0-compliant colour specification

[v_alignment]

[color]

1698


CHAPTER 11

[fontsize]

-2 -1 +0 +1 +2 +3 +4 1 2 3 4 5 6 7 integer value that represents dimension in pixels i% where i is integer an URL text string c(1),c(2),c(3),...,c(n) where c(i) is integer

[pixels] [percent] [url] [string] [coords]

List of supported tags
A ADDRESS AREA NAME=[string] HREF=[url] TARGET=[target window spec] SHAPE=POLY SHAPE=CIRCLE SHAPE=RECT COORDS=[coords] HREF=[url]

B BIG BLOCKQUOTE BODY BR CENTER CITE CODE DD DIV DL DT EM FONT HR

TEXT=[color] LINK=[color] BGCOLOR=[color] ALIGN=[alignment]

ALIGN=[alignment]

COLOR=[color] SIZE=[fontsize] FACE=[comma-separated list of facenames] ALIGN=[alignment] SIZE=[pixels] WIDTH=[percent|pixels] NOSHADE

H1 H2 H3 H4 H5 H6 I IMG

SRC=[url] WIDTH=[pixels]

1699


CHAPTER 11
HEIGHT=[pixels] ALIGN=TEXTTOP ALIGN=CENTER ALIGN=ABSCENTER ALIGN=BOTTOM USEMAP=[url] KBD LI MAP META OL P PRE SAMP SMALL STRIKE STRONG TABLE NAME=[string] HTTP-EQUIV="Content-Type" CONTENT=[string] ALIGN=[alignment]

TD

TH

ALIGN=[alignment] WIDTH=[percent|pixels] BORDER=[pixels] VALIGN=[v_alignment] BGCOLOR=[color] CELLSPACING=[pixels] CELLPADDING=[pixels] ALIGN=[alignment] VALIGN=[v_alignment] BGCOLOR=[color] WIDTH=[percent|pixels] COLSPAN=[pixels] ROWSPAN=[pixels] ALIGN=[alignment] VALIGN=[v_alignment] BGCOLOR=[color] WIDTH=[percent|pixels] COLSPAN=[pixels] ROWSPAN=[pixels] ALIGN=[alignment] VALIGN=[v_alignment] BGCOLOR=[color]

TITLE TR TT U UL

Environment variables
This section describes all environment variables that affect execution of wxWindows programs. WXTRACE (Debug build only.) This variable can be set to commaseparated list of trace masks used inwxLogTrace (p. 1523) calls;wxLog::AddTraceMask (p. 846) is called for every mask in the list during wxWindows initialization. (Unix only.) Overrides installation prefix. Normally, the prefix is hard-coded and is same as the value passed to configure via the --prefix switch when compiling the library (typically/usr/local or /usr). You can set WXPREFIX if you are for example distributing binary version of an application and you don't know in advance

WXPREFIX

1700


CHAPTER 11
where it will be installed. WXMODE WXSTDERR (wxMGL only.) Sets MGL video mode. The value must be in formwidthxheight-depth. The default is 640x480-16. (wxMGL only.) Redirects stderr output to a file.

wxPython overview
This topic was written by Robin Dunn, author of the wxPython wrapper.

What is wxPython?
wxPython is a blending of the wxWindows GUI classes and thePython (http://www.python.org/) programming language. Python So what is Python? Go tohttp://www.python.org (http://www.python.org) to learn more, but in a nutshell Python is an interpreted, interactive, object-oriented programming language. It is often compared to Tcl, Perl, Scheme or Java. Python combines remarkable power with very clear syntax. It has modules, classes, exceptions, very high level dynamic data types, and dynamic typing. There are interfaces to many system calls and libraries, and new built-in modules are easily written in C or C++. Python is also usable as an extension language for applications that need a programmable interface. Python is copyrighted but freely usable and distributable, even for commercial use. wxPython wxPython is a Python package that can be imported at runtime that includes a collection of Python modules and an extension module (native code). It provides a series of Python classes that mirror (or shadow) many of the wxWindows GUI classes. This extension module attempts to mirror the class hierarchy of wxWindows as closely as possible. This means that there is a wxFrame class in wxPython that looks, smells, tastes and acts almost the same as the wxFrame class in the C++ version. wxPython is very versatile. It can be used to create standalone GUI applications, or in situations where Python is embedded in a C++ application as an internal scripting or macro language. Currently wxPython is available for Win32 platforms and the GTK toolkit (wxGTK) on most Unix/X-windows platforms. See the wxPython website http://wxPython.org/ (http://wxPython.org/) for details about getting wxPython working for you.

Why use wxPython?

1701


CHAPTER 11
So why would you want to use wxPython over just C++ and wxWindows? Personally I prefer using Python for everything. I only use C++ when I absolutely have to eke more performance out of an algorithm, and even then I usually code it as an extension module and leave the majority of the program in Python. Another good thing to use wxPython for is quick prototyping of your wxWindows apps. With C++ you have to continuously go though the edit-compile-link-run cycle, which can be quite time consuming. With Python it is only an edit-run cycle. You can easily build an application in a few hours with Python that would normally take a few days or longer with C++. Converting a wxPython app to a C++/wxWindows app should be a straight forward task.

Other Python GUIs
There are other GUI solutions out there for Python. Tkinter Tkinter is the de facto standard GUI for Python. It is available on nearly every platform that Python and Tcl/TK are. Why Tcl/Tk? Well because Tkinter is just a wrapper around Tcl's GUI toolkit, Tk. This has its upsides and its downsides... The upside is that Tk is a pretty versatile toolkit. It can be made to do a lot of things in a lot of different environments. It is fairly easy to create new widgets and use them interchangeably in your programs. The downside is Tcl. When using Tkinter you actually have two separate language interpreters running, the Python interpreter and the Tcl interpreter for the GUI. Since the guts of Tcl is mostly about string processing, it is fairly slow as well. (Not too bad on a fast Pentium II, but you really notice the difference on slower machines.) It wasn't until the latest version of Tcl/Tk that native Look and Feel was possible on nonMotif platforms. This is because Tk usually implements its own widgets (controls) even when there are native controls available. Tkinter is a pretty low-level toolkit. You have to do a lot of work (verbose program code) to do things that would be much simpler with a higher level of abstraction. PythonWin PythonWin is an add-on package for Python for the Win32 platform. It includes wrappers for MFC as well as much of the Win32 API. Because of its foundation, it is very familiar for programmers who have experience with MFC and the Win32 API. It is obviously not compatible with other platforms and toolkits. PythonWin is organized as separate packages and modules so you can use the pieces you need without having to use the GUI portions. Others There are quite a few other GUI modules available for Python, some in active use, some that haven't been updated for ages. Most are simple wrappers around some C or C++ toolkit or another, and most are not cross-platform compatible. See this link

1702


CHAPTER 11
(http://www.python.org/download/Contributed.html#Graphics)for a listing of a few of them.

Using wxPython
First things first... I'm not going to try and teach the Python language here. You can do that at the Python Tutorial (http://www.python.org/doc/tut/tut.html). I'm also going to assume that you know a bit about wxWindows already, enough to notice the similarities in the classes used. Take a look at the following wxPython program. You can find a similar program in the wxPython/demo directory, named DialogUnits.py. If your Python and wxPython are properly installed, you should be able to run it by issuing this command: python DialogUnits.py

001: ## import all of the wxPython GUI package 002: from wxPython.wx import * 003: 004: ## Create a new frame class, derived from the wxPython Frame. 005: class MyFrame(wxFrame): 006: 007: def __init__(self, parent, id, title): 008: # First, call the base class' __init__ method to create the frame 009: wxFrame.__init__(self, parent, id, title, 010: wxPoint(100, 100), wxSize(160, 100)) 011: 012: # Associate some events with methods of this class 013: EVT_SIZE(self, self.OnSize) 014: EVT_MOVE(self, self.OnMove) 015: 016: # Add a panel and some controls to display the size and position 017: panel = wxPanel(self, -1) 018: wxStaticText(panel, -1, "Size:", 019: wxDLG_PNT(panel, wxPoint(4, 4)), wxDefaultSize) 020: wxStaticText(panel, -1, "Pos:", 021: wxDLG_PNT(panel, wxPoint(4, 14)), wxDefaultSize) 022: self.sizeCtrl = wxTextCtrl(panel, -1, "", 023: wxDLG_PNT(panel, wxPoint(24, 4)), 024: wxDLG_SZE(panel, wxSize(36, -1)), 025: wxTE_READONLY) 026: self.posCtrl = wxTextCtrl(panel, -1, "", 027: wxDLG_PNT(panel, wxPoint(24, 14)), 028: wxDLG_SZE(panel, wxSize(36, -1)), 029: wxTE_READONLY) 030: 031: 032: # This method is called automatically when the CLOSE event is 033: # sent to this window 034: def OnCloseWindow(self, event): 035: # tell the window to kill itself 036: self.Destroy() 037: 038: # This method is called by the system when the window is resized, 039: # because of the association above. 040: def OnSize(self, event): 041: size = event.GetSize()

1703


CHAPTER 11
042: self.sizeCtrl.SetValue("%s, %s" % (size.width, size.height)) 043: 044: # tell the event system to continue looking for an event handler, 045: # so the default handler will get called. 046: event.Skip() 047: 048: # This method is called by the system when the window is moved, 049: # because of the association above. 050: def OnMove(self, event): 051: pos = event.GetPosition() 052: self.posCtrl.SetValue("%s, %s" % (pos.x, pos.y)) 053: 054: 055: # Every wxWindows application must have a class derived from wxApp 056: class MyApp(wxApp): 057: 058: # wxWindows calls this method to initialize the application 059: def OnInit(self): 060: 061: # Create an instance of our customized Frame class 062: frame = MyFrame(NULL, -1, "This is a test") 063: frame.Show(true) 064: 065: # Tell wxWindows that this is our main window 066: self.SetTopWindow(frame) 067: 068: # Return a success flag 069: return true 070: 071: 072: app = MyApp(0) # Create an instance of the application class 073: app.MinLoop() a # Tell it to start processing events 074:

Things to notice 1. At line 2 the wxPython classes, constants, and etc. are imported into the current module's namespace. If you prefer to reduce namespace pollution you can use "from wxPython import wx" and then access all the wxPython identifiers through the wx module, for example, "wx.wxFrame". At line 13 the frame's sizing and moving events are connected to methods of the class. These helper functions are intended to be like the event table macros that wxWindows employs. But since static event tables are impossible with wxPython, we use helpers that are named the same to dynamically build the table. The only real difference is that the first argument to the event helpers is always the window that the event table entry should be added to. Notice the use of wxDLG_PNT and wxDLG_SZE in lines 19 - 29 to convert from dialog units to pixels. These helpers are unique to wxPython since Python can't do method overloading like C++. There is an OnCloseWindow method at line 34 but no call to EVT_CLOSE to attach the event to the method. Does it really get called? The answer is, yes it does. This is because many of thestandard events are attached to windows that have the associatedstandard method names. I have tried to follow the lead of the C++ classes in this area to determine what is standard but since that changes from time to time I can make no guarantees, nor will it be fully documented. When in doubt, use an EVT_*** function.

2.

3.

4.

1704


CHAPTER 11
5. At lines 17 to 21 notice that there are no saved references to the panel or the static text items that are created. Those of you who know Python might be wondering what happens when Python deletes these objects when they go out of scope. Do they disappear from the GUI? They don't. Remember that in wxPython the Python objects are just shadows of the corresponding C++ objects. Once the C++ windows and controls are attached to their parents, the parents manage them and delete them when necessary. For this reason, most wxPython objects do not need to have a __del__ method that explicitly causes the C++ object to be deleted. If you ever have the need to forcibly delete a window, use the Destroy() method as shown on line 36. Just like wxWindows in C++, wxPython apps need to create a class derived from wxApp (line 56) that implements a method namedOnInit, (line 59.) This method should create the application's main window (line 62) and use wxApp.SetTopWindow() (line 66) to inform wxWindows about it. And finally, at line 72 an instance of the application class is created. At this point wxPython finishes initializing itself, and calls the OnInit method to get things started. (The zero parameter here is a flag for functionality that isn't quite implemented yet. Just ignore it for now.) The call to MainLoop at line 73 starts the event loop which continues until the application terminates or all the top level windows are closed.

6.

7.

wxWindows classes implemented in wxPython
The following classes are supported in wxPython. Most provide nearly full implementations of the public interfaces specified in the C++ documentation, others are less so. They will all be brought as close as possible to the C++ spec over time.             wxAcceleratorEntry (p. 18) wxAcceleratorTable (p. 19) wxActivateEvent (p. 29) wxBitmap (p. 67) wxBitmapButton (p. 80) wxBitmapDataObject (p. 84) wxBMPHandler wxBoxSizer (p. 89) wxBrush (p. 90) wxBusyInfo (p. 102) wxBusyCursor (p. 101) wxButton (p. 103)

1705


CHAPTER 11
                            wxCalculateLayoutEvent (p. 107) wxCalendarCtrl (p. 108) wxCaret wxCheckBox (p. 120) wxCheckListBox (p. 124) wxChoice (p. 127) wxClientDC (p. 133) wxClipboard (p. 136) wxCloseEvent (p. 139) wxColourData (p. 153) wxColourDialog (p. 156) wxColour (p. 150) wxComboBox (p. 158) wxCommandEvent (p. 164) wxConfig (p. 177) wxControl (p. 198) wxCursor (p. 209) wxCustomDataObject (p. 215) wxDataFormat (p. 217) wxDataObject (p. 222) wxDataObjectComposite (p. 225) wxDataObjectSimple (p. 226) wxDateTime (p. 236) wxDateSpan (p. 230) wxDC (p. 347) wxDialog (p. 367) wxDirDialog (p. 384) wxDragImage (p. 421)

1706


CHAPTER 11
                            wxDropFilesEvent (p. 425) wxDropSource (p. 427) wxDropTarget (p. 429) wxEraseEvent (p. 438) wxEvent (p. 439) wxEvtHandler (p. 443) wxFileConfig wxFileDataObject (p. 465) wxFileDialog (p. 466) wxFileDropTarget (p. 470) wxFileSystem (p. 492) wxFileSystemHandler (p. 494) wxFocusEvent (p. 509) wxFontData (p. 519) wxFontDialog (p. 522) wxFont (p. 510) wxFrame (p. 530) wxFSFile (p. 543) wxGauge (p. 551) wxGIFHandler wxGLCanvas wxHtmlCell (p. 653) wxHtmlContainerCell (p. 659) wxHtmlDCRenderer (p. 665) wxHtmlEasyPrinting (p. 668) wxHtmlParser (p. 685) wxHtmlTagHandler (p. 696) wxHtmlTag (p. 692)

1707


CHAPTER 11
                            wxHtmlWinParser (p. 708) wxHtmlPrintout (p. 690) wxHtmlWinTagHandler (p. 714) wxHtmlWindow (p. 699) wxIconizeEvent wxIcon (p. 716) wxIdleEvent (p. 726) wxImage (p. 728) wxImageHandler (p. 750) wxImageList (p. 754) wxIndividualLayoutConstraint (p. 758) wxInitDialogEvent (p. 761) wxInputStream (p. 762) wxInternetFSHandler (p. 1601) wxJoystickEvent (p. 774) wxJPEGHandler wxKeyEvent (p. 777) wxLayoutAlgorithm (p. 781) wxLayoutConstraints (p. 784) wxListBox (p. 793) wxListCtrl (p. 799) wxListEvent (p. 818) wxListItem (p. 814) wxMask (p. 860) wxMaximizeEvent wxMDIChildFrame (p. 869) wxMDIClientWindow (p. 872) wxMDIParentFrame (p. 874)

1708


CHAPTER 11
                            wxMemoryDC (p. 881) wxMemoryFSHandler (p. 882) wxMenuBar (p. 898) wxMenuEvent (p. 907) wxMenuItem (p. 909) wxMenu (p. 885) wxMessageDialog (p. 914) wxMetaFileDC (p. 917) wxMiniFrame (p. 922) wxMouseEvent (p. 928) wxMoveEvent (p. 937) wxNotebookEvent (p. 950) wxNotebook (p. 943) wxPageSetupDialogData (p. 961) wxPageSetupDialog (p. 960) wxPaintDC (p. 966) wxPaintEvent (p. 967) wxPalette (p. 968) wxPanel (p. 972) wxPen (p. 976) wxPNGHandler wxPoint (p. 991) wxPostScriptDC (p. 991) wxPreviewFrame (p. 995) wxPrintData (p. 996) wxPrintDialogData (p. 1003) wxPrintDialog (p. 1002) wxPrinter (p. 1007)

1709


CHAPTER 11
                            wxPrintPreview (p. 1014) wxPrinterDC (p. 1010) wxPrintout (p. 1010) wxProcess (p. 1019) wxQueryLayoutInfoEvent (p. 1030) wxRadioBox (p. 1033) wxRadioButton (p. 1039) wxRealPoint (p. 1041) wxRect (p. 1042) wxRegionIterator (p. 1057) wxRegion (p. 1052) wxSashEvent (p. 1063) wxSashLayoutWindow (p. 1065) wxSashWindow (p. 1068) wxScreenDC (p. 1072) wxScrollBar (p. 1079) wxScrollEvent (p. 1094) wxScrolledWindow (p. 1085) wxScrollWinEvent (p. 1097) wxShowEvent wxSingleChoiceDialog (p. 1102) wxSizeEvent (p. 1108) wxSize (p. 1106) wxSizer (p. 1109) wxSizerItem wxSlider (p. 1121) wxSpinButton (p. 1154) wxSpinEvent

1710


CHAPTER 11
                            wxSplitterWindow (p. 1166) wxStaticBitmap (p. 1176) wxStaticBox (p. 1178) wxStaticBoxSizer (p. 1180) wxStaticLine (p. 1181) wxStaticText (p. 1183) wxStatusBar (p. 1185) wxSysColourChangedEvent (p. 1227) wxTaskBarIcon (p. 1240) wxTextCtrl (p. 1248) wxTextDataObject (p. 1266) wxTextDropTarget (p. 1268) wxTextEntryDialog (p. 1269) wxTimer (p. 1294) wxTimerEvent (p. 1297) wxTimeSpan (p. 1298) wxTipProvider (p. 1304) wxToolBarTool wxToolBar (p. 1309) wxToolTip wxTreeCtrl (p. 1327) wxTreeEvent (p. 1345) wxTreeItemData (p. 1348) wxTreeItemId wxUpdateUIEvent (p. 1350) wxValidator (p. 1358) wxWindowDC (p. 1436) wxWindow (p. 1386)

1711


CHAPTER 11
 wxZipFSHandler (p. 1601)

Where to go for help
Since wxPython is a blending of multiple technologies, help comes from multiple sources. Seehttp://wxpython.org/ (http://wxpython.org/) for details on various sources of help, but probably the best source is the wxPython-users mail list. You can view the archive or subscribe by going to http://lists.wxwindows.org/mailman/listinfo/wxpython-users (http://lists.wxwindows.org/mailman/listinfo/wxpython-users) Or you can send mail directly to the list using this address: wxpython-users@lists.wxwindows.org

Syntax of the builtin regular expression library
A regular expression describes strings of characters. It's a pattern that matches certain strings and doesn't match others. See also wxRegEx (p. 1049)

Different Flavors of REs
Syntax of the builtin regular expression library (p. 1712) Regular expressions ("RE''s), as defined by POSIX, come in two flavors: extended REs ("EREs'') and basic REs ("BREs''). EREs are roughly those of the traditional egrep, while BREs are roughly those of the traditional ed. This implementation adds a third flavor, advanced REs ("AREs''), basically EREs with some significant extensions. This manual page primarily describes AREs. BREs mostly exist for backward compatibility in some old programs; they will be discussed at the end (p. 1721). POSIX EREs are almost an exact subset of AREs. Features of AREs that are not present in EREs will be indicated.

Regular Expression Syntax
Syntax of the builtin regular expression library (p. 1712) These regular expressions are implemented using the package written by Henry Spencer, based on the 1003.2 spec and some (not quite all) of the Perl5 extensions (thanks, Henry!). Much of the description of regular expressions below is copied verbatim from his manual entry.

1712


CHAPTER 11
An ARE is one or more branches, separated by '|', matching anything that matches any of the branches. A branch is zero or more constraints or quantified atoms, concatenated. It matches a match for the first, followed by a match for the second, etc; an empty branch matches the empty string. A quantified atom is an atom possibly followed by a single quantifier. Without a quantifier, it matches a match for the atom. The quantifiers, and what a so-quantified atom matches, are: * + ? {m} {m,} {m,n} a sequence of 0 or more matches of the atom a sequence of 1 or more matches of the atom a sequence of 0 or 1 matches of the atom a sequence of exactly m matches of the atom a sequence of m or more matches of the atom a sequence of m through n (inclusive) matches of the atom; m may not exceed n

*? +? ?? {m}? {m,}? {m,n}? non-greedy quantifiers, which match the same possibilities, but prefer the smallest number rather than the largest number of matches (see Matching (p. 1719)) The forms using { and } are known as bounds. The numbers m and n are unsigned decimal integers with permissible values from 0 to 255 inclusive. An atom is one of: (re) (?:re) () (?:) [chars] . \k (where re is any regular expression) matches a match for re, with the match noted for possible reporting as previous, but does no reporting (a "non-capturing'' set of parentheses) matches an empty string, noted for possible reporting matches an empty string, without reporting a bracket expression, matching any one of the chars(see Bracket Expressions (p. 1714) for more detail) matches any single character (where k is a non-alphanumeric character) matches that character taken as an ordinary character, e.g. \\ matches a backslash character where c is alphanumeric (possibly followed by other characters), an escape (AREs only), see Escapes (p. 1716) below when followed by a character other than a digit, matches the leftbrace character '{'; when followed by a digit, it is the beginning of

\c {

1713


CHAPTER 11
a bound (see above) x where x is a single character with no other significance, matches that character.

A constraint matches an empty string when specific conditions are met. A constraint may not be followed by a quantifier. The simple constraints are as follows; some more constraints are described later, under Escapes (p. 1716). ^ $ (?=re) (?!re) matches at the beginning of a line matches at the end of a line positive lookahead(AREs only), matches at any point where a substring matching re begins negative lookahead (AREs only), matches at any point where no substring matching re begins

The lookahead constraints may not contain back references (see later), and all parentheses within them are considered non-capturing. An RE may not end with '\'.

Bracket Expressions
Syntax of the builtin regular expression library (p. 1712) A bracket expression is a list of characters enclosed in '[]'. It normally matches any single character from the list (but see below). If the list begins with '^', it matches any single character (but see below) not from the rest of the list. If two characters in the list are separated by '-', this is shorthand for the full range of characters between those two (inclusive) in the collating sequence, e.g. [0-9] in ASCII matches any decimal digit. Two ranges may not share an endpoint, so e.g. a-c-e is illegal. Ranges are very collating-sequence-dependent, and portable programs should avoid relying on them. To include a literal ] or - in the list, the simplest method is to enclose it in [. and .] to make it a collating element (see below). Alternatively, make it the first character (following a possible '^'), or (AREs only) precede it with '\'. Alternatively, for '-', make it the last character, or the second endpoint of a range. To use a literal - as the first endpoint of a range, make it a collating element or (AREs only) precede it with '\'. With the exception of these, some combinations using [ (see next paragraphs), and escapes, all other special characters lose their special significance within a bracket expression. Within a bracket expression, a collating element (a character, a multi-character sequence that collates as if it were a single character, or a collating-sequence name for either) enclosed in [. and .] stands for the sequence of characters of that collating element. wxWindows: Currently no multi-character collating elements are defined. So in [.X.], X

1714


CHAPTER 11
can either be a single character literal or the name of a character. For example, the following are both identical [[.0.]-[.9.]] and [[.zero.]-[.nine.]] and mean the same as [09]. See Character Names (p. 1721). Within a bracket expression, a collating element enclosed in [= and =]is an equivalence class, standing for the sequences of characters of all collating elements equivalent to that one, including itself. An equivalence class may not be an endpoint of a range. wxWindows: Currently no equivalence classes are defined, so [=X=] stands for just the single character X. X can either be a single character literal or the name of a character, see Character Names (p. 1721). Within a bracket expression, the name of a character class enclosed in [: and :] stands for the list of all characters (not all collating elements!) belonging to that class. Standard character classes are: alpha upper lower digit xdigit alnum print blank space punct graph cntrl A letter. An upper-case letter. A lower-case letter. A decimal digit. A hexadecimal digit. An alphanumeric (letter or digit). An alphanumeric (same as alnum). A space or tab character. A character producing white space in displayed text. A punctuation character. A character with a visible representation. A control character.

A character class may not be used as an endpoint of a range. wxWindows: In a non-Unicode build, these character classifications depend on the current locale, and correspond to the values return by the ANSI C 'is' functions: isalpha, isupper, etc. In Unicode mode they are based on Unicode classifications, and are not affected by the current locale. There are two special cases of bracket expressions: the bracket expressions [[:<:]] and [[:>:]] are constraints, matching empty strings at the beginning and end of a word respectively. A word is defined as a sequence of word characters that is neither preceded nor followed by word characters. A word character is an alnum character or an underscore (_). These special bracket expressions are deprecated; users of AREs should use constraint escapes instead (see Escapes (p. 1716) below).

1715


CHAPTER 11 Escapes
Syntax of the builtin regular expression library (p. 1712) Escapes (AREs only), which begin with a \ followed by an alphanumeric character, come in several varieties: character entry, class shorthands, constraint escapes, and back references. A \ followed by an alphanumeric character but not constituting a valid escape is illegal in AREs. In EREs, there are no escapes: outside a bracket expression, a \ followed by an alphanumeric character merely stands for that character as an ordinary character, and inside a bracket expression, \ is an ordinary character. (The latter is the one actual incompatibility between EREs and AREs.) Character-entry escapes (AREs only) exist to make it easier to specify non-printing and otherwise inconvenient characters in REs: \a \b \B \cX \e \f \n \r \t \uwxyz \Ustuvwxyz \v \xhhh alert (bell) character, as in C backspace, as in C synonym for \ to help reduce backslash doubling in some applications where there are multiple levels of backslash processing (where X is any character) the character whose low-order 5 bits are the same as those of X, and whose other bits are all zero the character whose collating-sequence name is 'ESC', or failing that, the character with octal value 033 formfeed, as in C newline, as in C carriage return, as in C horizontal tab, as in C (where wxyz is exactly four hexadecimal digits) the Unicode character U+wxyz in the local byte ordering (where stuvwxyz is exactly eight hexadecimal digits) reserved for a somewhat-hypothetical Unicode extension to 32 bits vertical tab, as in C are all available. (where hhh is any sequence of hexadecimal digits) the character whose hexadecimal value is 0xhhh (a single character no matter how many hexadecimal digits are used). the character whose value is 0 (where xy is exactly two octal digits, and is not a back reference (see below)) the character whose octal value is 0xy (where xyz is exactly three octal digits, and is not a back reference

\0 \x y \xyz

1716


CHAPTER 11
(see below)) the character whose octal value is 0xyz Hexadecimal digits are '0'-'9', 'a'-'f', and 'A'-'F'. Octal digits are '0'-'7'. The character-entry escapes are always taken as ordinary characters. For example, \135 is ] in ASCII, but \135 does not terminate a bracket expression. Beware, however, that some applications (e.g., C compilers) interpret such sequences themselves before the regular-expression package gets to see them, which may require doubling (quadrupling, etc.) the '\'. Class-shorthand escapes (AREs only) provide shorthands for certain commonly-used character classes: \d \s \w \D \S \W [[:digit:]] [[:space:]] [[:alnum:]_] (note underscore) [^[:digit:]] [^[:space:]] [^[:alnum:]_] (note underscore)

Within bracket expressions, '\d', '\s', and '\w' lose their outer brackets, and '\D', '\S', and '\W' are illegal. (So, for example, [a-c\d] is equivalent to [a-c[:digit:]]. Also, [a-c\D], which is equivalent to [a-c^[:digit:]], is illegal.) A constraint escape (AREs only) is a constraint, matching the empty string if specific conditions are met, written as an escape: \A \m \M \y \Y \Z \m \mnn matches only at the beginning of the string (see Matching (p. 1719), below, for how this differs from '^') matches only at the beginning of a word matches only at the end of a word matches only at the beginning or end of a word matches only at a point that is not the beginning or end of a word matches only at the end of the string (see Matching (p. 1719), below, for how this differs from '$') (where m is a nonzero digit) a back reference, see below (where m is a nonzero digit, and nn is some more digits, and the decimal value mnn is not greater than the number of closing capturing parentheses seen so far) a back reference, see below

A word is defined as in the specification of [[:<:]] and [[:>:]] above. Constraint escapes are illegal within bracket expressions.

1717


CHAPTER 11
A back reference (AREs only) matches the same string matched by the parenthesized subexpression specified by the number, so that (e.g.) ([bc])\1 matches bb or cc but not 'bc'. The subexpression must entirely precede the back reference in the RE. Subexpressions are numbered in the order of their leading parentheses. Non-capturing parentheses do not define subexpressions. There is an inherent historical ambiguity between octal character-entry escapes and back references, which is resolved by heuristics, as hinted at above. A leading zero always indicates an octal escape. A single non-zero digit, not followed by another digit, is always taken as a back reference. A multi-digit sequence not starting with a zero is taken as a back reference if it comes after a suitable subexpression (i.e. the number is in the legal range for a back reference), and otherwise is taken as octal.

Metasyntax
Syntax of the builtin regular expression library (p. 1712) In addition to the main syntax described above, there are some special forms and miscellaneous syntactic facilities available. Normally the flavor of RE being used is specified by application-dependent means. However, this can be overridden by a director. If an RE of any flavor begins with '***:', the rest of the RE is an ARE. If an RE of any flavor begins with '***=', the rest of the RE is taken to be a literal string, with all characters considered ordinary characters. An ARE may begin with embedded options: a sequence (?xyz)(where xyz is one or more alphabetic characters) specifies options affecting the rest of the RE. These supplement, and can override, any options specified by the application. The available option letters are: b c e i m n p q s t w rest of RE is a BRE case-sensitive matching (usual default) rest of RE is an ERE case-insensitive matching (see Matching (p. 1719), below) historical synonym for n newline-sensitive matching (see Matching (p. 1719), below) partial newline-sensitive matching (see Matching (p. 1719), below) rest of RE is a literal ("quoted'') string, all ordinary characters non-newline-sensitive matching (usual default) tight syntax (usual default; see below) inverse partial newline-sensitive ("weird'') matching (see Matching (p. 1719), below)

1718


CHAPTER 11
x expanded syntax (see below)

Embedded options take effect at the ) terminating the sequence. They are available only at the start of an ARE, and may not be used later within it. In addition to the usual (tight) RE syntax, in which all characters are significant, there is an expanded syntax, available in AREs with the embedded x option. In the expanded syntax, white-space characters are ignored and all characters between a # and the following newline (or the end of the RE) are ignored, permitting paragraphing and commenting a complex RE. There are three exceptions to that basic rule: white-space character or '#' preceded by '\' is retained space or '#' within a bracket expression is retained space and comments are illegal within multi-character symbols like the ARE '(?:' or the BRE '\(' Expanded-syntax white-space characters are blank, tab, newline, and any character that belongs to the space character class. Finally, in an ARE, outside bracket expressions, the sequence '(?#ttt)' (where ttt is any text not containing a ')') is a comment, completely ignored. Again, this is not allowed between the characters of multi-character symbols like '(?:'. Such comments are more a historical artifact than a useful facility, and their use is deprecated; use the expanded syntax instead. None of these metasyntax extensions is available if the application (or an initial ***=director) has specified that the user's input be treated as a literal string rather than as an RE.

Matching
Syntax of the builtin regular expression library (p. 1712) In the event that an RE could match more than one substring of a given string, the RE matches the one starting earliest in the string. If the RE could match more than one substring starting at that point, its choice is determined by its preference: either the longest substring, or the shortest. Most atoms, and all constraints, have no preference. A parenthesized RE has the same preference (possibly none) as the RE. A quantified atom with quantifier {m} or {m}? has the same preference (possibly none) as the atom itself. A quantified atom with other normal quantifiers (including {m,n} with m equal to n) prefers longest match. A quantified atom with other non-greedy quantifiers (including {m,n}? with m equal to n) prefers shortest match. A branch has the same preference as the first quantified atom in it which has a preference. An RE consisting of two or more branches connected by the | operator prefers longest match. Subject to the constraints imposed by the rules for matching the whole RE, subexpressions also match the longest or shortest possible substrings, based on their preferences, with subexpressions starting earlier in the RE taking priority over ones starting later. Note that outer subexpressions thus take priority over their component subexpressions.

1719


CHAPTER 11
Note that the quantifiers {1,1} and {1,1}? can be used to force longest and shortest preference, respectively, on a subexpression or a whole RE. Match lengths are measured in characters, not collating elements. An empty string is considered longer than no match at all. For example, bb* matches the three middle characters of 'abbbc', (week|wee)(night|knights)matches all ten characters of 'weeknights', when (.*).* is matched against abc the parenthesized subexpression matches all three characters, and when (a*)* is matched against bc both the whole RE and the parenthesized subexpression match an empty string. If case-independent matching is specified, the effect is much as if all case distinctions had vanished from the alphabet. When an alphabetic that exists in multiple cases appears as an ordinary character outside a bracket expression, it is effectively transformed into a bracket expression containing both cases, so that x becomes '[xX]'. When it appears inside a bracket expression, all case counterparts of it are added to the bracket expression, so that [x] becomes [xX] and [^x] becomes '[^xX]'. If newline-sensitive matching is specified, . and bracket expressions using ^ will never match the newline character (so that matches will never cross newlines unless the RE explicitly arranges it) and ^ and $ will match the empty string after and before a newline respectively, in addition to matching at beginning and end of string respectively. ARE \A and \Z continue to match beginning or end of string only. If partial newline-sensitive matching is specified, this affects . and bracket expressions as with newline-sensitive matching, but not ^ and '$'. If inverse partial newline-sensitive matching is specified, this affects ^ and $ as with newline-sensitive matching, but not . and bracket expressions. This isn't very useful but is provided for symmetry.

Limits And Compatibility
Syntax of the builtin regular expression library (p. 1712) No particular limit is imposed on the length of REs. Programs intended to be highly portable should not employ REs longer than 256 bytes, as a POSIX-compliant implementation can refuse to accept such REs. The only feature of AREs that is actually incompatible with POSIX EREs is that \does not lose its special significance inside bracket expressions. All other ARE features use syntax which is illegal or has undefined or unspecified effects in POSIX EREs; the *** syntax of directors likewise is outside the POSIX syntax for both BREs and EREs. Many of the ARE extensions are borrowed from Perl, but some have been changed to clean them up, and a few Perl extensions are not present. Incompatibilities of note include '\b', '\B', the lack of special treatment for a trailing newline, the addition of complemented bracket expressions to the things affected by newline-sensitive matching, the restrictions on parentheses and back references in lookahead constraints, and the longest/shortest-match (rather than first-match) matching semantics. The matching rules for REs containing both normal and non-greedy quantifiers have changed since early beta-test versions of this package. (The new rules are much simpler

1720


CHAPTER 11
and cleaner, but don't work as hard at guessing the user's real intentions.) Henry Spencer's original 1986 regexp package, still in widespread use, implemented an early version of today's EREs. There are four incompatibilities between regexp's nearEREs ('RREs' for short) and AREs. In roughly increasing order of significance:  In AREs, \ followed by an alphanumeric character is either an escape or an error, while in RREs, it was just another way of writing the alphanumeric. This should not be a problem because there was no reason to write such a sequence in RREs.



{ followed by a digit in an ARE is the beginning of a bound, while in RREs, { was always an ordinary character. Such sequences should be rare, and will often result in an error because following characters will not look like a valid bound.



In AREs, \ remains a special character within '[]', so a literal \ within [] must be written '\\'. \\ also gives a literal \ within [] in RREs, but only truly paranoid programmers routinely doubled the backslash.



AREs report the longest/shortest match for the RE, rather than the first found in a specified search order. This may affect some RREs which were written in the expectation that the first match would be reported. (The careful crafting of RREs to optimize the search order for fast matching is obsolete (AREs examine all possible matches in parallel, and their performance is largely insensitive to their complexity) but cases where the search order was exploited to deliberately find a match which was not the longest/shortest will need rewriting.)

Basic Regular Expressions
Syntax of the builtin regular expression library (p. 1712) BREs differ from EREs in several respects. '|', '+', and ? are ordinary characters and there is no equivalent for their functionality. The delimiters for bounds are \{ and '\}', with { and } by themselves ordinary characters. The parentheses for nested subexpressions are \( and '\)', with ( and ) by themselves ordinary characters. ^ is an ordinary character except at the beginning of the RE or the beginning of a parenthesized subexpression, $ is an ordinary character except at the end of the RE or the end of a parenthesized subexpression, and * is an ordinary character if it appears at the beginning of the RE or the beginning of a parenthesized subexpression (after a possible leading '^'). Finally, single-digit back references are available, and \< and \> are synonyms for [[:<:]] and [[:>:]] respectively; no other escapes are available.

Regular Expression Character Names

1721


CHAPTER 11
Syntax of the builtin regular expression library (p. 1712) Note that the character names are case sensitive. NUL SOH STX ETX EOT ENQ ACK BEL alert BS backspace HT tab LF newline VT vertical-tab FF form-feed CR carriage-return SO SI DLE DC1 DC2 DC3 '\0' '\001' '\002' '\003' '\004' '\005' '\006' '\007' '\007' '\010' '\b' '\011' '\t' '\012' '\n' '\013' '\v' '\014' '\f' '\015' '\r' '\016' '\017' '\020' '\021' '\022' '\023'

1722


CHAPTER 11
DC4 NAK SYN ETB CAN EM SUB ESC IS4 FS IS3 GS IS2 RS IS1 US space exclamation-mark quotation-mark number-sign dollar-sign percent-sign ampersand apostrophe left-parenthesis right-parenthesis asterisk plus-sign comma '\024' '\025' '\026' '\027' '\030' '\031' '\032' '\033' '\034' '\034' '\035' '\035' '\036' '\036' '\037' '\037' '' '!' '"' '#' '$' '%' '&' '\'' '(' ')' '*' '+' ','

1723


CHAPTER 11
hyphen hyphen-minus period full-stop slash solidus zero one two three four five six seven eight nine colon semicolon less-than-sign equals-sign greater-than-sign question-mark commercial-at left-square-bracket backslash reverse-solidus right-square-bracket circumflex circumflex-accent '-' '-' '.' '.' '/' '/' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' ':' ';' '<' '=' '>' '?' '@' '[' '\' '\' ']' '^' '^'

1724


CHAPTER 11
underscore low-line grave-accent left-brace left-curly-bracket vertical-line right-brace right-curly-bracket tilde DEL '_' '_' ''' '{' '{' '|' '}' '}' '' '\177'

1725


Chapter 12 Port notes
This chapter contains port specific notes.

wxGTK port
wxGTK is a port of wxWindows using the GTK+ library available from www.gtk.org. It makes use of GTK+'s native widgets wherever possible and uses wxWindows' generic controls when needed. GTK+ itself has been ported to a number of systems, but so far only the original X11 version is supported. Support for the recently released GTK+ 2.0 including Unicode support is work in progress. You will need GTK+ 1.2.3 or higher which is available from: http://www.gtk.org (http://www.gtk.org) In order to configure wxWindows to compile wxGTK you will need to type:
configure --with-gtk

For further information, please see the files in docs/gtk in the distribution.

wxMSW port
wxMSW is a port of wxWindows for the Windows platforms including Windows 95, 98, ME, 2000, NT, XP in ANSI and Unicode mode (for Windows 95 through the MSLU extension library). wxMSW ensures native look and feel for XP as well when using wxWindows version 2.3.3 or higher. wxMSW can be compile with a great variety of compilers including MS VC++, Borland 5.5, MinGW32, Cygwin and Watcom as well as cross-compilation with a Linux hosted MinGW32 tool chain. For further information, please see the files in docs/msw in the distribution.

wxMac port
wxMac is a port of wxWindows for the Macintosh OS platform. Currently MacOS 8.6 or higher, MacOS 9.0 or higher and MacOS X 10.0 or higher are supported, although most development effort goes into MacOS X support. wxMac can be compiled both using Apple's developer tools and MetroWerks CodeWarrior in different versions. Support for MacOS 8.X and MacOS 9.X is only available through CodeWarrior. wxMac uses the Carbon API (and optionally the Classic API under MacOS 8.X). You will need wxWindows version 2.3.3 or higher for a stable version of wxMac. For further information, please see the files in docs/mac in the distribution.

1726


CHAPTER 12

wxOS2 port
wxOS2 is a port of wxWindows for the IBM OS/2 platform. It is currently under construction.

wxMGL port
wxMGL is a port of wxWindows using the MGL library available from SciTech as the underlying graphics backend. wxMGL draws its widgets using the wxUniversal widget set which is now part of wxWindows. MGL itself runs on a variety of platforms including DOS, Linux hardware (similar to the Linux framebuffer) and various graphics systems such as Win32, X11 and OS/2. Note that currently MGL for Linux runs only on x86based systems. You will need wxWindows 2.3.3 or higher and MGL 5.0 or higher. The latter is available from http://www.scitechsoft.com/products/product_download.html (http://www.scitechsoft.com/products/product_download.html) In order to configure wxWindows to compile wxMGL you will need to type:
configure --with-mgl --with-universal

Under DOS, wxMGL uses a dmake based make system. For further information, please see the files in docs/mgl in the distribution.

wxX11 port
wxX11 is a port of wxWindows using X11 (The X Window System) as the underlying graphics backend. wxX11 draws its widgets using the wxUniversal widget set which is now part of wxWindows. wxX11 is well-suited for a number of special applications such as those running on systems with few resources (PDAs) or for applications which need to use a special themed look. You will need wxWindows 2.3.2 or higher. In order to configure wxWindows to compile wxX11 you will need to type:
configure-- with-x11 --with-universal

For further information, please see the files in docs/x11 in the distribution. There is also a page on the use of wxWindows for embedded applications on the wxWindows web site.

1727


CHAPTER 12

1728


Chapter 13 Index

--:--
::copystring, 1492 ::wxBeginBusyCursor, 1496 ::wxBell, 1496 ::wxClientDisplayRect, 1506 ::wxClipboardOpen, 1511 ::wxCloseClipboard, 1511 ::wxColourDisplay, 1506 ::wxConcatFiles, 1485 ::wxCopyFile, 1485 ::wxCreateDynamicObject, 1526 ::wxCreateFileTipProvider, 1497 ::wxDDECleanUp, 1515 ::wxDDEInitialize, 1515 ::wxDebugMsg, 1528 ::wxDirExists, 1482 ::wxDirSelector, 1497 ::wxDisplayDepth, 1506 ::wxDisplaySize, 1506 ::wxDisplaySizeMM, 1507 ::wxDos2UnixFilename, 1483 ::wxDROP_ICON, 1507 ::wxEmptyClipboard, 1511 ::wxEnableTopLevelWindows, 1515 ::wxEndBusyCursor, 1498 ::wxEntry, 1473 ::wxEnumClipboardFormats, 1511 ::wxError, 1528 ::wxExecute, 1476 ::wxExit, 1478 ::wxFatalError, 1529 ::wxFileExists, 1483 ::wxFileModificationTime, 1483 ::wxFileNameFromPath, 1483 ::wxFileSelector, 1497 ::wxFindFirstFile, 1483 ::wxFindMenuItemId, 1516 ::wxFindNextFile, 1484 ::wxFindWindowAtPoint, 1516 ::wxFindWindowAtPointer, 1517 ::wxFindWindowByLabel, 1516 ::wxFindWindowByName, 1516 ::wxGetActiveWindow, 1517 ::wxGetApp, 1473 ::wxGetClipboardData, 1511 ::wxGetClipboardFormatName, 1512 ::wxGetColourFromUser, 1498 ::wxGetCwd, 1485 ::wxGetDiskSpace, 1484 ::wxGetDisplayName, 1517 ::wxGetElapsedTime, 1534

::wxGetEmailAddress, 1488 ::wxGetFontFromUser, 1499 ::wxGetFreeMemory, 1488 ::wxGetFullHostName, 1488 ::wxGetHomeDir, 1488 ::wxGetHostName, 1489 ::wxGetLocalTime, 1534 ::wxGetLocalTimeMillis, 1535 ::wxGetMousePosition, 1517 ::wxGetMultipleChoice, 1501 ::wxGetMultipleChoices, 1499 ::wxGetNumberFromUser, 1500 ::wxGetOsDescription, 1490 ::wxGetOSDirectory, 1484 ::wxGetOsVersion, 1490 ::wxGetPasswordFromUser, 1500 ::wxGetPrinterCommand, 1508 ::wxGetPrinterFile, 1508 ::wxGetPrinterMode, 1508 ::wxGetPrinterOptions, 1509 ::wxGetPrinterOrientation, 1509 ::wxGetPrinterPreviewCommand, 1509 ::wxGetPrinterScaling, 1509 ::wxGetPrinterTranslation, 1509 ::wxGetProcessId, 1479 ::wxGetResource, 1517 ::wxGetSingleChoice, 1502 ::wxGetSingleChoiceData, 1503 ::wxGetSingleChoiceIndex, 1502 ::wxGetTempFileName, 1485 ::wxGetTextFromUser, 1501 ::wxGetTopLevelParent, 1518 ::wxGetTranslation, 1492 ::wxGetUserHome, 1491 ::wxGetUserId, 1489 ::wxGetUserName, 1491 ::wxGetUTCTime, 1535 ::wxGetWorkingDirectory, 1485 ::wxHandleFatalExceptions, 1474 ::wxInitAllImageHandlers, 1474 ::wxInitialize, 1474 ::wxIsAbsolutePath, 1484 ::wxIsBusy, 1503 ::wxIsClipboardFormatAvailable, 1512 ::wxIsDebuggerRunning, 1540 ::wxIsEmpty, 1493 ::wxIsMainThread, 1481 ::wxIsWild, 1486 ::wxKill, 1478 ::wxLoadUserResource, 1518 ::wxLogDebug, 1531 ::wxLogError, 1529 ::wxLogFatalError, 1529

1729


INDEX
::wxLogMessage, 1530 ::wxLogStatus, 1530 ::wxLogSysError, 1530 ::wxLogTrace, 1531 ::wxLogVerbose, 1530 ::wxLogWarning, 1529 ::wxMakeMetafilePlaceable, 1507 ::wxMatchWild, 1486 ::wxMessageBox, 1504 ::wxMkdir, 1486 ::wxMutexGuiEnter, 1481 ::wxMutexGuiLeave, 1482 ::wxNewId, 1514 ::wxNow, 1535 ::wxOnAssert, 1536 ::wxOpenClipboard, 1512 ::wxPathOnly, 1485 ::wxPostDelete, 1519 ::wxPostEvent, 1519 ::wxRegisterClipboardFormat, 1512 ::wxRegisterId, 1515 ::wxRemoveFile, 1486 ::wxRenameFile, 1486 ::wxRmdir, 1486 ::wxSafeShowMessage, 1532 ::wxSafeYield, 1475 ::wxSetClipboardData, 1512 ::wxSetCursor, 1508 ::wxSetDisplayName, 1519 ::wxSetPrinterCommand, 1509 ::wxSetPrinterFile, 1509 ::wxSetPrinterMode, 1510 ::wxSetPrinterOptions, 1510 ::wxSetPrinterOrientation, 1510 ::wxSetPrinterPreviewCommand, 1510 ::wxSetPrinterScaling, 1510 ::wxSetPrinterTranslation, 1510 ::wxSetWorkingDirectory, 1487 ::wxShell, 1479 ::wxShowTip, 1504 ::wxShutdown, 1479 ::wxSleep, 1535 ::wxSnprintf, 1494 ::wxSplitPath, 1487 ::wxStartTimer, 1536 ::wxStrcmp, 1493 ::wxStricmp, 1493 ::wxStringEq, 1493 ::wxStringMatch, 1493 ::wxStripMenuCodes, 1519 ::wxStrlen, 1494 ::wxSysErrorCode, 1532 ::wxSysErrorMsg, 1533 ::wxTrace, 1533 ::wxTraceLevel, 1534 ::wxTransferFileToStream, 1487 ::wxTransferStreamToFile, 1487 ::wxTrap, 1540 ::wxUninitialize, 1475 ::wxUnix2DosFilename, 1485 ::wxUsleep, 1536 ::wxVsnprintf, 1495 ::wxWakeUpIdle, 1475 ::wxWriteResource, 1520 ::wxYield, 1475

--_--
_, 1495 _T, 1496

--~--
~wxAcceleratorTable, 21 ~wxAccessible, 26 ~wxApp, 32 ~wxArray, 49 ~wxArrayString, 55 ~wxAutomationObject, 64 ~wxBitmap, 71 ~wxBitmapButton, 82 ~wxBitmapHandler, 87 ~wxBrush, 93 ~wxBufferedOutputStream, 102 ~wxBusyCursor, 103 ~wxBusyInfo, 104 ~wxButton, 106 ~wxCalendarCtrl, 111 ~wxCheckBox, 123 ~wxCheckListBox, 127 ~wxChoice, 129 ~wxClientData, 135 ~wxClientDataContainer, 136 ~wxClipboard, 138 ~wxCmdLineParser, 147 ~wxColourData, 154 ~wxColourDialog, 158 ~wxComboBox, 161 ~wxCommand, 164 ~wxCommandProcessor, 172 ~wxCondition, 176 ~wxConfigBase, 185 ~wxContextHelp, 197 ~wxCountingOutputStream, 207 ~wxCriticalSection, 208 ~wxCriticalSectionLocker, 210 ~wxCSConv, 210 ~wxCursor, 216 ~wxCustomDataObject, 217 ~wxDataInputStream, 222 ~wxDataObject, 226 ~wxDataOutputStream, 230 ~wxDbConnectInf, 298 ~wxDbGridColInfo, 340 ~wxDbTable, 305 ~wxDC, 351 ~wxDCClipper, 370 ~wxDialog, 373 ~wxDialUpManager, 381 ~wxDir, 385 ~wxDirDialog, 388 ~wxDisplay, 391 ~wxDocChildFrame, 396 ~wxDocManager, 399

1730


INDEX
~wxDocMDIChildFrame, 407 ~wxDocMDIParentFrame, 409 ~wxDocParentFrame, 410 ~wxDocTemplate, 414 ~wxDocument, 418 ~wxDropSource, 431 ~wxDropTarget, 434 ~wxEvtHandler, 447 ~wxFFile, 455 ~wxFFileInputStream, 460 ~wxFFileOutputStream, 461 ~wxFile, 464 ~wxFileDialog, 471 ~wxFileHistory, 476 ~wxFileInputStream, 478 ~wxFileOutputStream, 494 ~wxFileType, 502 ~wxFindReplaceDialog, 509 ~wxFont, 517 ~wxFontData, 523 ~wxFontDialog, 526 ~wxFontMapper, 531 ~wxFrame, 536 ~wxFTP, 550 ~wxGauge, 557 ~wxGenericDirCtrl, 566 ~wxGenericValidator, 569 ~wxGrid, 576 ~wxGridCellEditor, 619 ~wxGridTableBase, 633 ~wxGzipInputStream, 640 ~wxGzipOutputStream, 641 ~wxHashTable, 647 ~wxHelpController, 650 ~wxHelpProvider, 656 ~wxHtmlListBox, 688 ~wxIcon, 724 ~wxIconBundle, 728 ~wxImage, 737 ~wxImageHandler, 755 ~wxInputStream, 766 ~wxJoystick, 772 ~wxLayoutAlgorithm, 787 ~wxList, 793 ~wxListBox, 800 ~wxListCtrl, 806 ~wxLocale, 842 ~wxLogChain, 855 ~wxMask, 866 ~wxMDIChildFrame, 876 ~wxMDIClientWindow, 878 ~wxMDIParentFrame, 881 ~wxMemoryInputStream, 889 ~wxMemoryOutputStream, 889 ~wxMenu, 892 ~wxMenuBar, 904 ~wxMenuItem, 914 ~wxMessageDialog, 920, 1031 ~wxMetafile, 921 ~wxMetafileDC, 923 ~wxMimeTypesManager, 925 ~wxMiniFrame, 928 ~wxModule, 930 ~wxMutex, 944 ~wxMutexLocker, 946 ~wxNotebook, 950 ~wxObjArray, 50 ~wxOutputStream, 963 ~wxPageSetupDialog, 965 ~wxPageSetupDialogData, 966 ~wxPalette, 974 ~wxPanel, 978 ~wxPen, 984 ~wxPlotWindow, 993 ~wxPreviewCanvas, 998 ~wxPreviewControlBar, 999 ~wxPreviewFrame, 1000 ~wxPrintData, 1002 ~wxPrintDialog, 1007 ~wxPrintDialogData, 1009 ~wxPrinter, 1013, 1020 ~wxPrintout, 1016 ~wxProcess, 1025 ~wxRadioBox, 1040 ~wxRadioButton, 1046 ~wxRecursionGuard, 1053 ~wxRegEx, 1056 ~wxRegion, 1059 ~wxRendererNative, 1065 ~wxSashLayoutWindow, 1072 ~wxSashWindow, 1075 ~wxScopedPtr, 1082 ~wxScopedTiedPtr, 1084 ~wxScrollBar, 1088 ~wxScrolledWindow, 1093 ~wxSemaphore, 1105 ~wxSingleChoiceDialog, 1109 ~wxSingleInstanceChecker, 1112 ~wxSizer, 1116 ~wxSizerItem, 1122 ~wxSlider, 1130 ~wxSockAddress, 1136 ~wxSocketBase, 1140 ~wxSocketClient, 1154 ~wxSocketServer, 1158 ~wxSortedArray, 50 ~wxSound, 1392 ~wxSpinButton, 1162 ~wxSplashScreen, 1168 ~wxSplitterWindow, 1174 ~wxStaticBox, 1185 ~wxStatusBar, 1192 ~wxStreamBase, 1197 ~wxStreamToTextRedirector, 1205 ~wxString, 1213 ~wxStringBuffer, 1228 ~wxStringList, 1230 ~wxTabCtrl, 1241 ~wxTaskBarIcon, 1247 ~wxTempFile, 1250 ~wxTextCtrl, 1259 ~wxTextEntryDialog, 1276 ~wxTextFile, 1278 ~wxTextInputStream, 1284

1731


INDEX
~wxTextOutputStream, 1287 ~wxTextValidator, 1289 ~wxThread, 1292 ~wxThreadHelper, 1299 ~wxTimer, 1302 ~wxToggleButton, 1315 ~wxToolBar, 1319 ~wxTreeCtrl, 1337 ~wxTreeItemData, 1356 ~wxURL, 1363 ~wxValidator, 1365 ~wxVariant, 1368 ~wxView, 1376 ~wxWindow, 1396 ~wxWindowDisabler, 1444 ~wxXmlResource, 1455 ~wxXmlResourceHandler, 1459 AddLine, 1278 AddModule, 713 AddOption, 149 AddPage, 950 AddParam, 149 AddPen, 989 AddPendingEvent, 447 AddRadioTool, 1321 AddRoot, 1337 AddSeparator, 1319 AddStyle, 1459 AddSwitch, 149 AddTag, 690 AddTagHandler, 690 AddTool, 1320 AddToolbarButtons, 686 AddTraceMask, 850 AddView, 418 AddWindowStyles, 1459 AddWord, 690 AdjustPagebreak, 658 AdvanceSelection, 950 Advise, 194 AfterFirst, 1214 AfterLast, 1214 age, 1068 All date/time classes at a glance, 1589 Alloc, 50, 56, 217, 1213 AllocHenv, 299 Allow, 958 AltDown, 625, 626, 628, 784, 936 AnyAddress, 769, 771 Append, 201, 793, 892, 904, 1214, 1368 AppendCheckItem, 894 AppendCols, 576, 635 AppendDir, 482 AppendItem, 1337 AppendRadioItem, 894 AppendRows, 576, 635 AppendSeparator, 894 AppendText, 1259 AppendToPage, 704 Application shutdown, 1581 AreLongOptionsEnabled, 148 argc, 32 argv, 32 Arrange, 806 ArrangeIcons, 882 Art provider sample, 1570 AsIs, 764 Assign, 482, 863 AssignButtonsImageList, 1338 AssignCwd, 482 AssignDbTable, 343 AssignDir, 482 AssignHomeDir, 483 AssignImageList, 807, 951, 1338 AssignStateImageList, 1338 AssignTempFileName, 483 Associated non-class functions, 269 AssociateTemplate, 400 Astronomical/historical functions, 244

--A--
A more complex example, 1674 A selection of SQL commands, 1698 Abort, 550, 1013, 1033 Above, 763 Abs, 863, 1306 Absolute, 764 Accept, 1158 AcceptWith, 1159 Access, 464 Accessors, 242, 1305 Activate, 876, 1377 ActivateNext, 881 ActivatePrevious, 882 ActivateView, 399 Add, 50, 56, 228, 233, 256, 613, 759, 980, 993, 1116, 1230, 1306 AddBook, 678, 681 AddBrush, 98 AddCatalog, 842 AddCatalogLookupPathPrefix, 843 AddCheckTool, 1321 AddChild, 1397 AddColInfo, 340 AddColour, 157 AddControl, 1319 AddData, 138 AddDocument, 399 AddEnvList, 980 AddFallbacks, 925 AddFile, 469, 888 AddFilesToMenu, 476 AddFileToHistory, 399, 476 AddFilter, 694, 704 AddFont, 529 AddGrowableCol, 511 AddGrowableRow, 511 AddHandler, 72, 496, 737, 1455 AddHelp, 657 AddIcon, 728 Adding items, 46 Adding new resource handlers, 1647 AddLanguage, 843

1732


INDEX
Attach, 455, 464 AttachUnknownControl, 1455 AutoSize, 576 AutoSizeColOrRow, 609 AutoSizeColumn, 576 AutoSizeColumns, 577 AutoSizeRow, 577 AutoSizeRows, 577 CanDragColSize, 578 CanDragGridSize, 578 CanDragRowSize, 578 CanEnableCellControl, 578 CanGetValueAs, 634 CanHandle, 1460 CanHaveAttributes, 609, 636 CanonicalizeName, 436 CanonicalizePluginName, 436 CanOpen, 498 CanPaste, 1260 CanRead, 676, 737 CanRedo, 1260 CanSelectForUpdate, 308 CanSend, 731 CanSetValueAs, 634 CanUndo, 165, 172, 1260 CanUpdate, 1359 CanUpdateByROWID, 308 CanVeto, 141 CaptureMouse, 1397 Cascade, 882 Case conversion, 1208 Catalog, 272 Cells and Containers, 1707 CellToRect, 578 Center, 1397 CenterOnParent, 1397 CenterOnScreen, 1397 Centre, 373, 536, 1398 CentreOnParent, 1398 CentreOnScreen, 1398 centreX, 789 centreY, 790 Chain, 1453 ChangePathTo, 496 Character access, 1206 CharsetToEncoding, 532 ChDir, 551 Check, 127, 344, 895, 905, 915, 1359 CheckCommand, 550 Checked, 169 CheckForIntersection, 614 Checklist sample, 1571 CLASSINFO, 1522 CleanUpHandlers, 72, 737 CleanupModules, 930 clear, 644 Clear, 50, 56, 138, 201, 353, 483, 635, 647, 794, 826, 1059, 1136, 1215, 1230, 1260, 1282, 1380 ClearAll, 807 ClearBackground, 1399 ClearColumnImage, 830 ClearCommands, 172 ClearGrid, 579 ClearHandlers, 1455 ClearList, 1369 ClearMemberVar, 309 ClearMemberVars, 309 ClearSel, 1130 ClearSelection, 579

--B--
Background: The need for conversion, 1595 Background: The wxString class, 1596 Basic IO, 1138 Basic Regular Expressions, 1733 BeforeFirst, 1214 BeforeLast, 1214 begin, 644 BeginBatch, 577 BeginContextHelp, 197 BeginDrag, 426 BeginDrawing, 351 BeginEdit, 618 BeginFind, 647 Below, 764 BigEndianOrdered, 222, 230 Bitmap format handlers, 1651 Blit, 351 BlockToDeviceRect, 602 Blue, 152 border, 1181 bottom, 789 Bracket Expressions, 1726 Break, 895 Broadcast, 176 BuildDeleteStmt, 305 BuildSelectStmt, 305, 307 BuildUpdateStmt, 306 Button, 936 ButtonDClick, 936 ButtonDown, 779, 936 ButtonIsDown, 779 ButtonUp, 780, 937

--C--
c_str, 1214 C++ header file generation, 1645 CalcBoundingBox, 353 CalcMin, 91, 614, 1117, 1122 CalcScrolledPosition, 1093 CalcUnscrolledPosition, 1094 Calendar calculations, 244 Calendar sample, 1571 Callback, 1140 CallbackData, 1140 CallEntry, 1301 CallMethod, 64 CancelDialing, 382 CanConvert, 439 CanCopy, 1260 CanCut, 1260

1733


INDEX
ClearTicks, 1130 ClearTraceMasks, 850 Clients, 61 ClientToScreen, 1399 Clone, 444, 569, 610, 619, 632, 1289, 1365 Close, 138, 273, 418, 456, 464, 923, 1141, 1279, 1377, 1400 CloseContainer, 713 CloseCursor, 310 CloseDocuments, 400 CloseOutput, 1025 cMB2WC, 869 cMB2WX, 869 Cmp, 1215 CmpNoCase, 1215 Collapse, 1338 CollapseAndReset, 1338 Command, 200, 537 Commit, 1249 CommitTrans, 273 Common features, 1630 CompareTo, 1215 CompareVersion, 1455 Comparison, 1207 Comparison of wxString to other string classes, 1584 Comparison operators, 1227 Compatibility, 1592 Compile, 1056 Compilers, 1544 Compiling and using XRC, 1638 ComputeHistogram, 737 Concatenation, 1207 Config sample, 1571 Connect, 448, 1154 Constraint layout: more detail, 1627 Construction, 144 Construction and destruction, 1138 Constructor and destructor, 180, 924 Constructors, 1305 Constructors and assignment operators, 1206 Constructors and destructors, 45 Constructors and initialization, 575 Constructors, assignment operators and setters, 241 Contains, 1059, 1215 ControlDown, 625, 626, 628, 784, 937 Controls sample, 1571 Conversion to numbers, 1208 Convert, 439, 440 ConvertDialogToPixels, 1400 Converting buffers, 1597 Converting strings, 1597 ConvertPixelsToDialog, 1401 ConvertStringToArgs, 146 ConvertToBitmap, 738, 1059 ConvertToImage, 72 ConvertToMono, 738 ConvertToValidURI, 1364 ConvertYearToBC, 245 Copy, 161, 738, 1260, 1374 CopyFromBitmap, 724 CopyFromIcon, 72 copystring, 1492 CopyTo, 889 count, 644 Count, 51, 56, 310 CountTokens, 1232 Create, 72, 73, 82, 87, 106, 111, 119, 123, 130, 158, 161, 185, 373, 380, 464, 510, 526, 537, 557, 566, 618, 684, 688, 738, 760, 800, 807, 866, 876, 882, 928, 951, 974, 979, 1040, 1046, 1088, 1094, 1107, 1111, 1131, 1162, 1165, 1175, 1183, 1186, 1188, 1190, 1192, 1241, 1261, 1279, 1292, 1299, 1315, 1380, 1388, 1392, 1446, 1698 CreateAbortWindow, 1013 CreateBitmap, 62 CreateButtons, 999 CreateButtonSizer, 1637 CreateCanvas, 1001 CreateChildren, 1460 CreateChildrenPrivately, 1460 CreateClient, 878 CreateContents, 684 CreateControlBar, 1000 CreateCurrentFont, 713 CreateDocument, 400, 414 CreateGrid, 579 CreateHelpFrame, 678 CreateIndex, 311, 684 CreateInstance, 65 CreateLogTarget, 32 CreateObject, 131 CreateResFromNode, 1455, 1460 CreateResource, 1460 CreateSearch, 684 CreateStatusBar, 537 CreateTable, 313 CreateTempFileName, 483 CreateToolBar, 538 CreateView, 274, 400, 414 CrossHair, 353 Customization, 145, 849 Cut, 161, 1261 cWC2MB, 869 cWC2WX, 869 cWX2MB, 869 cWX2WC, 870

--D--
Data transfer, 1701 Database sample, 1572 Date arithmetics, 243, 1590 Date comparison, 242 Day, 233, 1306 Daylight saving time (DST), 1591 Days, 233, 1306 DB_STATUS, 313 Dbms, 275 DECLARE_ABSTRACT_CLASS, 1522, 1523 DECLARE_APP, 1523 DECLARE_CLASS, 1523

1734


INDEX
DECLARE_DYNAMIC_CLASS, 1523, 1524 DecRef, 610 DecTo, 1113 Default constructors, 49 Deflate, 1048 delete, 962 Delete, 130, 201, 313, 647, 895, 994, 1230, 1293, 1339, 1369 Delete entries/groups, 183 DeleteAll, 186 DeleteAllItems, 807, 1241, 1339 DeleteAllPages, 951 DeleteAllViews, 418 DeleteChildren, 1339 DeleteCols, 579, 635 DeleteColumn, 807 DeleteContents, 647, 794 DeleteCursor, 314 DeleteEntry, 186 DeleteGroup, 186 DeleteItem, 808, 1241 DeleteMatching, 314 DeleteNode, 794 DeleteObject, 794 DeletePage, 951 DeleteRows, 579, 635 DeleteSubMenu, 915 DeleteTool, 1322 DeleteToolByPos, 1322 DeleteWhere, 315 DeleteWindows, 1122 Deselect, 800 DeselectAll, 1381 Destroy, 619, 739, 895, 1141, 1402 DestroyChildren, 1402 DestroyClippingRegion, 354 Detach, 51, 437, 456, 465, 1025, 1118 DetachSizer, 1123 DeviceToLogicalX, 354 DeviceToLogicalXRel, 354 DeviceToLogicalY, 354 DeviceToLogicalYRel, 354 Dial, 381 Dialogs sample, 1572 Dialup sample, 1572 Difference between wxDateSpan and wxTimeSpan, 1590 Different Flavors of REs, 1724 DirExists, 484 DirName, 484 Disable, 1402 DisableAutoCheckOnlineStatus, 383 DisableCellEditControl, 580 DisableDragColSize, 580 DisableDragGridSize, 580 DisableDragRowSize, 580 DisableLongOptions, 148 DisassociateTemplate, 400 Discard, 1141, 1250 DiscardEdits, 1261 Disconnect, 194, 449 DispAllErrors, 275 Dispatch, 32 Display, 679, 684 Display format, 575 DisplayBlock, 650 DisplayContents, 651, 679, 685 DisplayContextPopup, 651 DisplayIndex, 679, 685 DisplaySection, 651 DisplayTextPopup, 651 DispNextError, 276 DnD sample, 1572 Do, 165 DoCreateResource, 1460 DoDefaultAction, 26 DoDragDrop, 432 DoDrawImage, 427 DoFindResource, 1456 DoGetBestSize, 608 DoLog, 852 DoLogString, 852 DoneParser, 691 DontCreateOnDemand, 185, 852 DoParsing, 691 DoQuantize, 1035 DoUpdateWindowUI, 1402 DragAcceptFiles, 1403 Dragging, 937 Draw, 632, 658, 760 DrawArc, 354 DrawBitmap, 355 DrawBlankPage, 1021 DrawCheckMark, 355 DrawCircle, 355 DrawEllipse, 355 DrawEllipticArc, 356 DrawHeaderButton, 1066 DrawIcon, 356 DrawInvisible, 659 DrawLine, 356 DrawLines, 356 DrawPoint, 357 DrawPolygon, 357 DrawPolyPolygon, 357 DrawRectangle, 357 DrawRotatedText, 358 DrawRoundedRectangle, 358 DrawSpline, 358 DrawSplitterBorder, 1066 DrawSplitterSash, 1066 DrawText, 359 DrawTreeItemButton, 1066 DrawXXX, 350 DropIndex, 316 DropTable, 316 DropView, 277 Dump, 344, 960 Dynamic sample, 1573

--E--
Edges and relationships, 763 EditLabel, 808, 1339

1735


INDEX
empty, 644 Empty, 51, 57, 1215 EmulateKeyPress, 1261 Enable, 896, 905, 915, 1040, 1333, 1359, 1403 EnableAutoCheckOnlineStatus, 383 EnableCellEditControl, 580 EnableDragColSize, 580 EnableDragGridSize, 580 EnableDragRowSize, 581 EnableEditing, 581 EnableEffects, 523 EnableGridLines, 581 EnableHelp, 966, 1009 EnableHolidayDisplay, 112 EnableLongOptions, 147 EnableMargins, 967 EnableMonthChange, 112 EnableOrientation, 967 EnablePageNumbers, 1009 EnablePaper, 967 EnablePrinter, 967 EnablePrintToFile, 1009 EnableScrolling, 1094 EnableSelection, 1009 EnableTool, 1322 EnableTop, 906 EnableYearChange, 111 end, 645 EndBatch, 581 EndContextHelp, 198 EndDoc, 359 EndDrag, 427 EndDrawing, 359 EndDrawingOnTop, 1079 EndEdit, 618 EndEditLabel, 1340 EndModal, 374 EndPage, 359 Enlarge, 994 EnsureFileAccessible, 981 EnsureVisible, 808, 1340 Enter, 208 Entering, 937 Entry, 1293, 1299, 1300 Enumerated types, 265 EnumerateEncodings, 528 EnumerateFacenames, 527 Enumeration, 181 Eof, 456, 465, 766, 1280 Eq, 1374 erase, 645 Error, 1142 Escapes, 1728 EstimateTotalHeight, 1388 Event macros summary, 1618 Event sample, 1573 EVT_COMMAND(id, event, func), 1618 EVT_COMMAND_RANGE(id1, id2, event, func), 1618 EVT_CUSTOM(event, id, func), 1618 EVT_CUSTOM_RANGE(event, id1, id2, func), 1618 Example, 1583, 1656 Example 1: subwindow layout, 1628 Example 2: panel item layout, 1629 Examples, 1702 Except(ions) sample, 1573 Exec sample, 1574 ExecSql, 277 Execute, 194 Exists, 186, 385, 465, 1028, 1279 Exit, 930, 1293 ExitMainLoop, 34 Expand, 1340 ExpandCommand, 504 ExpandPath, 566 explicit wxScopedPtr, 1082

--F--
fd, 465 File name components, 480 File name construction, 480 File name format, 479 File tests, 480 FileExists, 484, 553 FileHistoryAddFilesToMenu, 401 FileHistoryLoad, 401 FileHistoryRemoveMenu, 401 FileHistorySave, 401 FileHistoryUseMenu, 401 FileName, 484 FileNameToURL, 497 FillBuffer, 1204 FillHandlersTable, 702 FilterEvent, 33 find, 645 Find, 659, 794, 1216 FindAbsoluteValidPath, 981 FindById, 1323 FindClass, 131 FindColour, 157 FindControl, 1323 FindFirst, 497, 500 FindFirstUnusedColour, 739 FindFocus, 1404 FindHandler, 73, 739 FindHandlerMime, 740 FindItem, 614, 808, 896, 907 FindItemAtPoint, 614 FindItemAtPosition, 614 FindItemByPosition, 897 FindItemWithData, 614 FindLanguageInfo, 843 FindMenu, 906 FindMenuItem, 906 FindName, 157 FindNext, 497, 500 FindOrCreateBrush, 98 FindOrCreateFont, 529 FindOrCreatePen, 989 FindPageById, 681 FindPageByName, 681 FindResource, 1456

1736


INDEX
FindString, 202, 1041 FindTemplateForPath, 402 FindToolForPosition, 1323 FindValidPath, 981 FindWindow, 1404 FindWindowById, 1404 FindWindowByLabel, 1405 FindWindowByName, 1404 First, 1216 Fit, 607, 1118, 1405 FitInside, 1118, 1405 FitToPage, 1447 Fixed, 1203 FloodFill, 359 Flush, 138, 186, 457, 465, 852 Flushable, 1203 FlushActive, 853 FlushBuffer, 1203 Focus, 830 Font sample, 1574 ForceRefresh, 581 Format, 259, 296, 1216, 1306 FormatDate, 259 FormatISODate, 259 FormatISOTime, 260 FormatTime, 259 Formatting time spans, 1305 Found, 150 fp, 456 Free, 218 FreeHenv, 299 Freeze, 1406 Freq, 1217 From, 317 FromAscii, 1217 GetAppName, 33, 186 GetAsDOS, 255 GetAt, 993 GetAttr, 113, 637 GetAttrProvider, 636 GetAuthStr, 299 GetAuto3D, 33 GetBackground, 360 GetBackgroundColour, 117, 612, 664, 826, 915, 1252, 1406 GetBackgroundMode, 360 GetBaseClassName1, 131 GetBaseClassName2, 131 GetBatchCount, 581 GetBeginDST, 245 GetBeginPos, 697 GetBestSize, 632, 1407 GetBezelFace, 557 GetBitmap, 62, 86, 915, 1183, 1452, 1461 GetBitmapDisabled, 83 GetBitmapFocus, 83 GetBitmapLabel, 83 GetBitmapSelected, 83 GetBlinkTime, 119 GetBlue, 741 GetBookRecArray, 682 GetBool, 1369, 1461 GetBorder, 117, 1123 GetBorderColour, 117 GetBottom, 1049 GetBottomRight, 1049 GetBottomRightCoords, 626 GetBottomRow, 627 GetBoundingRect, 1340 GetBox, 1059, 1060 GetBrush, 360 GetBufferEnd, 1202 GetBufferPos, 1202 GetBufferStart, 1202 GetButton, 937 GetButtonChange, 780 GetButtonsImageList, 1340 GetButtonState, 772, 780 GetC, 766 GetCacheFrom, 823 GetCacheTo, 824 GetCanvas, 1021 GetCap, 985 GetCapture, 1407 GetCapturedWindow, 932 GetCaret, 1407 GetCatalog, 278 GetCellAlignment, 582 GetCellBackgroundColour, 582 GetCellEditor, 582 GetCellFont, 582 GetCellRenderer, 582 GetCellSize, 615 GetCellTextColour, 583 GetCellTextFont, 606 GetCellValue, 583 GetCentury, 246

--G--
get, 1080, 1083 Get, 186, 531, 647, 656, 1066, 1456 Get3StateValue, 124 GetAcceleratorTable, 1406 GetAccessible, 1406 GetActive, 31 GetActiveChild, 883 GetActiveTarget, 851 GetActualColor, 713 GetAdjustedBestSize, 1406 GetAlign, 713, 826 GetAlignHor, 664 GetAlignment, 612, 1036, 1072, 1252 GetAlignVer, 664 GetAllEquivalents, 441 GetAllFiles, 385 GetAllFormats, 226 GetAllowSymbols, 523 GetAllPages, 1009 GetAllParams, 697 GetAlpha, 740, 741 GetAltForEncoding, 531 GetAmPmStrings, 245 GetAnchor, 499, 548

1737


INDEX
GetChar, 1200, 1217, 1369 GetCharHeight, 360, 713, 1407 GetCharWidth, 360, 714, 1407 GetChecked, 1360 GetCheckPrevious, 345 GetChild, 27 GetChildCount, 27 GetChildren, 1407 GetChildrenCount, 1341 GetChooseFull, 154 GetChosenFont, 524 GetClassInfo, 960 GetClassName, 33, 132 GetClientAreaOrigin, 539 GetClientData, 136, 170, 202, 449, 1142, 1156 GetClientObject, 136, 202, 450 GetClientSize, 882, 1408 GetClientWindow, 883 GetClippingBox, 360 GetCol, 560, 622, 625 GetColDefs, 317 GetColLabelAlignment, 583 GetColLabelSize, 583 GetColLabelValue, 583, 636 GetCollate, 1002, 1010 GetColLeft, 608 GetColMinimalAcceptableWidth, 597 GetColMinimalWidth, 609 GetColour, 94, 155, 523, 985, 1003, 1236, 1461 GetColourData, 158 GetColRight, 608 GetCols, 604, 638 GetColSize, 584 GetColspan, 563 GetColumn, 809, 824, 826 GetColumnCount, 278, 809 GetColumns, 130, 279 GetColumnWidth, 605, 809 GetColWidth, 608 GetCommand, 19 GetCommandProcessor, 419 GetCommands, 172 GetConstraints, 1408 GetContainer, 714 GetContainingSizer, 1408 GetContents, 682 GetContentsCnt, 682 GetContentType, 1034 GetControl, 622 GetCount, 51, 57, 203, 392, 648, 794, 993, 1041, 1341, 1369 GetCountPerPage, 809 GetCountry, 246 GetCPUCount, 1294 GetCurFileSystem, 1461 GetCurFocus, 1242 GetCurrent, 993 GetCurrentDocument, 402 GetCurrentId, 1294 GetCurrentLine, 1280 GetCurrentMonth, 246 GetCurrentPage, 1021, 1447 GetCurrentTip, 1312 GetCurrentView, 402 GetCurrentYear, 246 GetCursor, 318, 1408 GetCursorColumn, 604 GetCursorRow, 604 GetCustomColour, 155 GetCwd, 484 GetDashes, 985 GetData, 138, 218, 280, 434, 510, 685, 741, 825, 826, 947, 1217, 1229, 1369 GetDatabaseName, 281 GetDataHere, 226, 229 GetDataLeft, 1204 GetDataSize, 226, 229 GetDatasourceName, 281 GetDate, 111, 118 GetDateTime, 640 GetDay, 253 GetDayOfYear, 254 GetDays, 234, 1307 GetDb, 318 GetDC, 442, 714, 1016 GetDebugMode, 345 GetDefault, 1066 GetDefaultAction, 27 GetDefaultCellAlignment, 584 GetDefaultCellBackgroundColour, 584 GetDefaultCellFont, 584 GetDefaultCellTextColour, 584 GetDefaultColLabelSize, 584 GetDefaultColSize, 585 GetDefaultDir, 299 GetDefaultEditor, 585 GetDefaultEditorForCell, 603 GetDefaultEditorForType, 603 GetDefaultEncoding, 517 GetDefaultExtension, 414 GetDefaultInfo, 968 GetDefaultItem, 979 GetDefaultMinMargins, 967 GetDefaultPath, 566 GetDefaultRenderer, 585 GetDefaultRendererForCell, 603 GetDefaultRendererForType, 603 GetDefaultRowLabelSize, 585 GetDefaultRowSize, 585 GetDefaultSize, 107, 1188 GetDefaultStyle, 1261 GetDepth, 74, 392, 724 GetDescent, 660 GetDescription, 27, 300, 414, 503 GetDialog, 507 GetDimension, 1461 GetDirCount, 485 GetDirection, 1450 GetDirectory, 415, 471 GetDirList, 553 GetDirs, 485 GetDispatchPtr, 65 GetDividerPen, 607 GetDllExt, 394

1738


INDEX
GetDocument, 396, 408, 1377 GetDocumentManager, 415, 419, 1377 GetDocumentName, 415, 419 GetDocuments, 402 GetDocumentTemplate, 419 GetDocumentWindow, 419 GetDouble, 1369 GetDragRect, 1070 GetDragStatus, 1070 GetDropTarget, 1409 GetDsn, 300 GetDuplex, 1003 GetEdge, 1070 GetEditable, 607 GetEditControl, 809, 1341 GetEditInPlace, 607 GetEditMenu, 172 GetEditor, 612 GetEmptyCellSize, 615 GetEnabled, 1360 GetEnableEffects, 524 GetEnableHelp, 968 GetEnableMargins, 967 GetEnableOrientation, 967 GetEnablePaper, 968 GetEnablePrinter, 968 GetEncoding, 532 GetEncodingConverter, 714 GetEncodingDescription, 532 GetEncodingName, 532 GetEncodings, 528 GetEndDST, 246 GetEndPos, 561 GetEndPos1, 697 GetEndPos2, 697 GetEndX, 990 GetEndY, 990 GetEntryType, 187 GetEOL, 1280 GetError, 1033, 1363 GetErrorStream, 1026 GetEvent, 687 GetEventHandler, 1409 GetEventObject, 444 GetEventType, 444 GetEvtHandlerEnabled, 450 GetExcludeList, 1290 GetExitCode, 1030 GetExitOnFrameDelete, 33 GetExt, 485 GetExtension, 88, 755 GetExtensions, 503 GetExtraLong, 170 GetExtraStyle, 1409 GetFaceName, 518 GetFacenames, 528 GetFamily, 518 GetFieldRect, 1192 GetFieldsCount, 1193 GetFileFilter, 415 GetFileHistory, 402 GetFilename, 419, 471 GetFilenames, 469, 471 GetFilePath, 567 GetFiles, 430 GetFileSize, 553 GetFilesList, 554 GetFileType, 300 GetFileTypeFromExtension, 925 GetFileTypeFromMimeType, 925 GetFilter, 567 GetFilterIndex, 472, 567 GetFilterListCtrl, 567 GetFindString, 506, 508 GetFirst, 318, 385, 795 GetFirstCell, 664 GetFirstChild, 1341 GetFirstEntry, 187 GetFirstGroup, 187 GetFirstLine, 1280 GetFirstSelected, 831, 1381 GetFirstView, 420 GetFirstVisibleItem, 1342 GetFirstVisibleLine, 1388 GetFlag, 1123 GetFlags, 19, 108, 415, 506, 508, 1036, 1142, 1253, 1456 GetFlexibleDirections, 511 GetFocus, 27 GetFocusedItem, 831 GetFont, 117, 361, 612, 826, 915, 1237, 1252, 1409, 1461 GetFontBold, 714 GetFontData, 526 GetFontFace, 714 GetFontFixed, 715 GetFontItalic, 715 GetFontSize, 715 GetFontUnderlined, 715 GetForbiddenChars, 485 GetForce, 141 GetForegroundColour, 1409 GetFormat, 229, 485 GetFormatCount, 226 GetFrame, 861, 1021, 1377 GetFrameParameters, 652 GetFromClause, 319 GetFromPage, 1010 GetFromPoint, 392 GetFS, 691 GetFullName, 485 GetFullPath, 485 GetGeneric, 1067 GetGeometry, 392 GetGrandParent, 1410 GetGreen, 741 GetGridCursorCol, 585 GetGridCursorRow, 585 GetGridLineColour, 586 GetH, 1063 GetHandle, 1410 GetHandlers, 74, 742 GetHDBC, 282 GetHeader, 720

1739


INDEX
GetHeaderColourBg, 112 GetHeaderColourFg, 112 GetHeight, 74, 660, 724, 742, 1049, 1113 GetHelp, 657, 915 GetHelpController, 654 GetHelpString, 897, 907 GetHelpText, 27, 1410 GetHenv, 300 GetHENV, 282 GetHGap, 638 GetHi, 863 GetHighlightColourBg, 113 GetHighlightColourFg, 113 GetHistoryFile, 476 GetHistoryFilesCount, 403 GetHolidayColourBg, 113 GetHolidayColourFg, 113 GetHomeDir, 486 GetHour, 253 GetHours, 1307 GetHref, 687 GetHSTMT, 282 GetHtmlCell, 687 GetIcon, 63, 503, 728, 729, 1462 GetId, 220, 444, 660, 827, 915, 1024, 1294, 1356, 1410 GetID, 1461 GetImage, 825, 827 GetImageCount, 741, 755, 761 GetImageExtWildcard, 740 GetImageList, 810, 951, 1242, 1342 GetImageRect, 427 GetIncludeList, 1290 GetIndent, 665, 1342 GetIndentUnits, 665 GetIndex, 682, 824 GetIndexCnt, 682 GetInitialFont, 524 GetInputEncoding, 715 GetInputStream, 554, 719, 1026, 1032, 1363 GetInsertionPoint, 162, 1262 GetInstance, 65 GetInt, 170 GetInternalRepresentation, 704 GetInterval, 1302, 1304 GetIntPosition, 1203 GetISPNames, 381 GetItem, 810, 825, 1354 GetItemBackgroundColour, 810, 1342 GetItemCount, 810, 1242, 1381 GetItemData, 811, 1242, 1342 GetItemFont, 1343 GetItemImage, 1242, 1343 GetItemParent, 1344 GetItemPosition, 615, 811 GetItemRect, 811, 1242 GetItemSelectedImage, 1345 GetItemSpacing, 811 GetItemSpan, 615 GetItemState, 811 GetItemText, 812, 1243, 1343 GetItemTextColour, 812, 1343 GetJDN, 263 GetJoin, 985 GetJoystick, 780 GetJulianDayNumber, 263 GetKeyboardShortcut, 28 GetKeyCode, 19, 784, 824, 1354 GetKeyEvent, 1354 GetKeyFields, 282 GetKind, 916 GetLabel, 106, 200, 824, 898, 907, 916, 1041, 1190, 1354, 1411 GetLabelAlignment, 606 GetLabelBackgroundColour, 586 GetLabelFont, 586 GetLabelFromText, 916 GetLabelSize, 606 GetLabelTextColour, 586 GetLabelTop, 908 GetLabelValue, 606 GetLanguage, 844 GetLanguageInfo, 844 GetLanguageName, 844 GetLast, 319, 795 GetLastAccess, 1203 GetLastChild, 1343 GetLastDirectory, 402 GetLastError, 1014, 1197 GetLastLine, 1281 GetLastMonthDay, 262 GetLastPosition, 162, 1262 GetLastResult, 551 GetLastVisibleLine, 1388 GetLastWeekDay, 261 GetLeft, 1049 GetLeftCol, 627 GetLeftIndent, 1252 GetLeftLocation, 499 GetLevel, 345 GetLine, 1279 GetLineCount, 1279, 1388 GetLineLength, 1262 GetLineSize, 1131 GetLinesPerAction, 938 GetLineText, 1262 GetLineType, 1281 GetLink, 660, 715 GetLinkColor, 715 GetLo, 863 GetLocal, 1142 GetLocale, 844 GetLocation, 28, 548 GetLoggingOff, 141 GetLogicalFunction, 361 GetLogicalPosition, 938 GetLogLevel, 853 GetLong, 1369, 1462 GetLongPath, 486 GetManufacturerId, 773 GetMapMode, 361 GetMarginBottomRight, 968 GetMargins, 1324, 1381 GetMarginTopLeft, 968

1740


INDEX
GetMarginWidth, 916 GetMask, 75, 825, 827 GetMaskBlue, 743 GetMaskGreen, 743 GetMaskRed, 743 GetMatch, 1056 GetMax, 1131, 1162, 1166 GetMaxCommands, 172 GetMaxDocsOpen, 402 GetMaxFiles, 477 GetMaximumSizeX, 1075 GetMaximumSizeY, 1076 GetMaxPage, 1010, 1021 GetMenu, 908 GetMenuBar, 539 GetMenuCount, 908 GetMenuId, 913 GetMenuItemCount, 898 GetMenuItems, 898 GetMessage, 388, 472 GetMetric, 1238 GetMillisecond, 253 GetMilliseconds, 1307 GetMimeType, 502, 503, 548, 755 GetMimeTypeFromExt, 499 GetMin, 1131, 1162, 1166 GetMinimumPaneSize, 1175 GetMinimumSizeX, 1076 GetMinimumSizeY, 1076 GetMinMarginBottomRight, 969 GetMinMarginTopLeft, 968 GetMinPage, 1010, 1021 GetMinSize, 1119, 1123 GetMinute, 253 GetMinutes, 1307 GetMJD, 263 GetMode, 731, 1360 GetModificationTime, 486, 548 GetModifiedJulianDayNumber, 263 GetMonth, 253 GetMonthName, 246 GetMonths, 234 GetMovementThreshold, 773 GetName, 28, 88, 165, 386, 392, 486, 640, 698, 755, 845, 916, 1282, 1370, 1411, 1462 GetNativeFontInfoDesc, 518 GetNewCursor, 319 GetNext, 283, 320, 386, 660, 947, 1452 GetNextChild, 1344 GetNextEntry, 188 GetNextError, 283 GetNextGroup, 187 GetNextHandler, 450 GetNextItem, 812 GetNextLine, 1281 GetNextSelected, 831, 1382 GetNextSibling, 1344 GetNextToken, 1232 GetNextVisible, 1344 GetNextWeekDay, 260 GetNoCopies, 1003, 1010 GetNodeContent, 1462 GetNoHistoryFiles, 477 GetNonFlexibleGrowMode, 511 GetNotebook, 958 GetNumberAxes, 773 GetNumberButtons, 773 GetNumberCols, 586, 633 GetNumberJoysticks, 773 GetNumberOfColumns, 320 GetNumberOfDays, 247 GetNumberOfEntries, 188 GetNumberOfFiles, 430 GetNumberOfGroups, 188 GetNumberOfLines, 1263 GetNumberRows, 586, 633 GetObject, 65 GetOffsetY, 991 GetOldItem, 1355 GetOldLog, 855 GetOldSelection, 956 GetOpenCommand, 503, 504 GetOpenedAnchor, 705 GetOpenedPage, 705 GetOpenedPageTitle, 705 GetOptimization, 361 GetOption, 744, 1235 GetOptionInt, 744, 1235 GetOrCreateCellAttr, 609 GetOrderByClause, 320 GetOrientation, 91, 1003, 1036, 1072, 1102, 1103 GetOutputEncoding, 716 GetOutputStream, 554, 1026 GetPage, 951, 1450 GetPageAreaSizer, 1447 GetPageCount, 952 GetPageImage, 952 GetPageInfo, 1016 GetPageSetupData, 675, 965 GetPageSize, 1089, 1131, 1448 GetPageSizeMM, 1017 GetPageSizePixels, 1017 GetPageText, 952 GetPalette, 74, 743 GetPaperId, 969, 1003 GetPaperSize, 969 GetParam, 151, 698 GetParamAsColour, 698 GetParamAsInt, 698 GetParamCount, 150 GetParamNode, 1462 GetParamValue, 1462 GetParent, 28, 661, 1345, 1411 GetPartialTextExtents, 361 GetPassword, 283, 300 GetPath, 188, 388, 472, 486, 497, 566, 1363 GetPaths, 472 GetPathSeparator, 486 GetPathSeparators, 487 GetPeer, 1142 GetPen, 362 GetPid, 1030 GetPixel, 153, 362, 975, 976

1741


INDEX
GetPlatformEquivalents, 440 GetPoint, 824, 1355 GetPointSize, 518 GetPollingMax, 773 GetPollingMin, 773 GetPos, 561 GetPosition, 119, 430, 625, 629, 655, 774, 780, 785, 938, 942, 1049, 1102, 1104, 1119, 1123, 1167, 1232, 1411, 1462 GetPosX, 661 GetPosY, 661 GetPOVCTSPosition, 774 GetPOVPosition, 774 GetPPIPrinter, 1017 GetPPIScreen, 1018 GetPrecision, 630 GetPreferredFormat, 227 GetPrev, 320, 1452 GetPrevious, 947 GetPreviousHandler, 450 GetPrevLine, 1281 GetPrevSibling, 1345 GetPrevVisible, 1345 GetPrevWeekDay, 261 GetPrintableName, 420 GetPrintCommand, 504 GetPrintData, 675, 969, 1010, 1021 GetPrintDC, 1008 GetPrintDialogData, 1007, 1014 GetPrinterName, 1003 GetPrintout, 1021 GetPrintoutForPrinting, 1022 GetPrintPreview, 999 GetPrintToFile, 1010 GetPriority, 1294 GetProduct, 691 GetProductId, 774 GetProductName, 774 GetProgramHandle, 394 GetProperty, 66 GetProportion, 1123 GetProtocol, 499, 1363 GetProtocolName, 1363 GetQuality, 1003 GetQueryTableName, 321 GetRange, 557, 1088, 1263 GetRataDie, 263 GetRatio, 1123 GetRawKeyCode, 784 GetRawKeyFlags, 784 GetRect, 108, 1063, 1412 GetRed, 743 GetRedoAccelerator, 173 GetRedoMenuLabel, 173 GetRefData, 960 GetRelatedFrame, 705 GetRenderer, 612 GetReplaceString, 507, 508 GetRequestedLength, 1037 GetResolution, 997 GetResponse, 719 GetReturnCode, 374 GetRight, 1050 GetRightCol, 627 GetRightIndent, 1252 GetRightLocation, 499 GetRole, 28 GetRootId, 567 GetRootItem, 1345 GetRow, 560, 623, 625 GetRowBottom, 609 GetRowCount, 952, 1243 GetRowHeight, 608 GetRowLabelAlignment, 587 GetRowLabelSize, 587 GetRowLabelValue, 587, 635 GetRowMinimalAcceptableHeight, 600 GetRowMinimalHeight, 609 GetRowNum, 321 GetRowOrCol, 629 GetRows, 604, 638 GetRowSize, 587 GetRowspan, 563 GetRowTop, 608 GetRudderMax, 774 GetRudderMin, 774 GetRudderPosition, 775 GetSashPosition, 1171, 1175 GetSashVisible, 1075 GetScrollPixelsPerUnit, 1095 GetScrollPos, 1412 GetScrollPosX, 604 GetScrollPosY, 605 GetScrollRange, 1413 GetScrollThumb, 1412 GetSecond, 253 GetSeconds, 1307 GetSelectedCells, 587 GetSelectedCols, 587 GetSelectedCount, 1382 GetSelectedItemCount, 813 GetSelectedRows, 588 GetSelectedTextBgColour, 688 GetSelectedTextColour, 689 GetSelection, 170, 203, 952, 956, 1010, 1042, 1109, 1243, 1263, 1345, 1382 GetSelectionBackground, 602, 1382 GetSelectionBlockBottomRight, 588 GetSelectionBlockTopLeft, 588 GetSelectionClientData, 1109 GetSelectionForeground, 603 GetSelectionMode, 587 GetSelections, 28, 801, 1346 GetSelEnd, 1132 GetSelStart, 1132 GetSessionEnding, 141 GetSetChecked, 1360 GetSetEnabled, 1360 GetSetText, 1360 GetShadowWidth, 557 GetShortPath, 487 GetShowHelp, 524 GetSize, 120, 132, 207, 218, 362, 761, 1037, 1050, 1115, 1118, 1123, 1198, 1413, 1462

1742


INDEX
GetSizer, 1124, 1413 GetSkipped, 445 GetSocket, 1156 GetSocketEvent, 1156 GetSource, 691 GetSpacer, 1124 GetSpan, 561 GetSplashStyle, 1169 GetSplashWindow, 1169 GetSplitMode, 1175 GetSplitterParams, 1067 GetStartX, 991 GetStartY, 991 GetState, 29, 827 GetStateImageList, 1346 GetStaticBox, 1186 GetStatusBar, 539 GetStatusBarPane, 539 GetStatusText, 1193 GetStipple, 94, 985 GetStream, 345, 548 GetStreamBuf, 346 GetString, 170, 203, 621, 845, 1042, 1233, 1370 GetStringSelection, 204, 1042, 1109, 1264 GetStyle, 94, 389, 472, 519, 986, 1264, 1290, 1463 GetSubBitmap, 75 GetSubImage, 743 GetSubMenu, 917 GetSupportedEncodingsCount, 532 GetSupportedTags, 700 GetSymbol, 394, 437 GetSysName, 844, 845 GetSystemEncoding, 845 GetSystemEncodingName, 846 GetSystemLanguage, 846 GetTable, 588 GetTableCount, 284 GetTableName, 321 GetTablePath, 322 GetTabs, 1252 GetTarget, 687 GetText, 824, 827, 917, 1274, 1360, 1463 GetTextBackground, 363 GetTextColour, 117, 612, 813, 828, 917, 1252 GetTextExtent, 363, 1414 GetTextForeground, 363 GetTextLength, 1274 GetThread, 1300 GetThumbLength, 1089, 1132 GetThumbPosition, 1089 GetTickFreq, 1132 GetTicks, 252 GetTimeout, 1169 GetTimes, 487 GetTimestamp, 445, 854 Getting results, 145 Getting started: a simple example, 1673 GetTip, 1311, 1333 GetTitle, 374, 420, 539, 898, 1018, 1414 GetTm, 252 GetToolBar, 540, 884 GetToolBitmapSize, 1324 GetToolClientData, 1324 GetToolEnabled, 1324 GetToolLongHelp, 1325 GetToolPacking, 1325 GetToolPos, 1325 GetToolSeparation, 1325 GetToolShortHelp, 1326 GetToolSize, 1323 GetToolState, 1326 GetToolTip, 1415 GetTop, 1050 GetToPage, 1011 GetTopItem, 813 GetTopLeft, 1049 GetTopLeftCoords, 627 GetTopRow, 627 GetTopWindow, 34 GetTotalDays, 234 GetTotalHeight, 671 GetTraceMasks, 851 GetTreeCtrl, 567 GetType, 88, 220, 755, 1370, 1375 GetTypeName, 633 GetUid, 300 GetUMax, 775 GetUMin, 775 GetUnderlined, 519 GetUndoAccelerator, 173 GetUndoMenuLabel, 173 GetUnitsPerValue, 994 GetUpdateInterval, 1361 GetUpdateRegion, 1415 GetUPosition, 775 GetUseBestVisual, 34 GetUserData, 1124 GetUserID, 301 GetUsername, 284 GetUserScale, 364 GetValidator, 1415 GetValue, 29, 123, 162, 558, 633, 863, 1046, 1133, 1162, 1165, 1264, 1276, 1308, 1315 GetValueAsBool, 634 GetValueAsCustom, 634 GetValueAsDouble, 634 GetValueAsLong, 634 GetValueClassInfo, 1375 GetVendorName, 34, 188 GetVerbose, 853 GetVersion, 1067, 1456 GetVGap, 638 GetView, 397, 408, 635 GetViewHeight, 605 GetViewName, 415, 1377 GetViewRect, 813 GetViews, 420 GetViewStart, 1095 GetViewWidth, 605 GetVirtualSize, 1096, 1415 GetVMax, 775 GetVMin, 775 GetVoidPtr, 1370

1743


INDEX
GetVolume, 487 GetVolumeSeparator, 488 GetVPosition, 775 GetW, 1063 GetWeek, 262 GetWeekDay, 118, 253, 261 GetWeekDayInSameWeek, 260 GetWeekDayName, 247 GetWeekOfMonth, 254 GetWeekOfYear, 254 GetWeeks, 234, 1308 GetWeight, 519 GetWheelDelta, 938 GetWheelRotation, 938 GetWhereClause, 322 GetWidth, 75, 630, 661, 724, 743, 828, 986, 1050, 1063, 1113 GetWildcard, 472 GetWindow, 29, 120, 716, 1124, 1333, 1366 GetWindow1, 1175 GetWindow2, 1176 GetWindowBeingRemoved, 1171 GetWindowMenu, 884 GetWindowStyleFlag, 1416 GetWritableChar, 1217 GetWriteBuf, 1217 GetWxObjectPtr, 1370 GetX, 784, 938, 1050, 1063, 1171 GetXMax, 775 GetXMin, 776 GetXRCID, 1456 GetY, 785, 939, 991, 1050, 1063, 1171 GetYear, 253 GetYearDay, 262 GetYears, 234 GetYMax, 776 GetYMin, 776 GetZMax, 776 GetZoom, 995 GetZoomControl, 999 GetZPosition, 776, 781 GiveFeedback, 432 GoToLine, 1280 Grant, 284 Green, 153 Grid sample, 1574 GridLinesEnabled, 586 GuessType, 1281 GUI system, 1542 HasBorderColour, 116 HasCapture, 1416 HasEditor, 612 HasEnding, 699 HasEntry, 188 HasExt, 488 HasFiles, 386 HasFont, 116, 611, 1253 HasGroup, 189 HasMask, 744 HasModifiers, 785 HasMoreTokens, 1232 HasMultipleSelection, 1383 HasName, 488 HasNextPage, 1448 HasOption, 744, 1235 HasPage, 1018 HasParam, 699, 1463 HasPOV, 776 HasPOV4Dir, 777 HasPOVCTS, 777 HasPrevPage, 1448 HasRange, 621 HasRenderer, 612 HasRudder, 777 HasStream, 346 HasSubDirs, 386 HasTextColour, 116, 611, 1253 HasU, 777 HasV, 777 HasVolume, 488 HasZ, 777 HaveRects, 1064 height, 790, 1048 Help Files Format, 1705 Helper functions, 924 Hide, 120, 428, 1416 HideCellEditControl, 588 Hiding controls using sizers, 1632 HistoryBack, 705 HistoryCanBack, 705 HistoryCanForward, 706 HistoryClear, 706 HistoryForward, 706 HitTest, 29, 114, 813, 952, 1243, 1264, 1346, 1389 Hostname, 768, 769, 770, 771 Hour, 1308 Hours, 1308 How events are processed, 1613 How the wxGrid classes relate to each other, 1674 HTML Printing, 1705 HTML samples, 1574

--H--
HandleEvent, 41 HandleReturn, 619 HandleTag, 701 Handling socket events, 1139 HangUp, 382 Hardware architectures, 1544 HasAlignment, 612 HasAlpha, 744 HasBackgroundColour, 116, 611, 1253 HasBorder, 116, 1076

--I--
Iconize, 374, 540 Iconized, 730 identifiers, 1617 Identifying art resources, 60 Image sample, 1575

1744


INDEX
IMPLEMENT_ABSTRACT_CLASS, 1524 IMPLEMENT_ABSTRACT_CLASS2, 1524 IMPLEMENT_APP, 1524, 1525 IMPLEMENT_CLASS, 1525 IMPLEMENT_CLASS2, 1525 IMPLEMENT_DYNAMIC_CLASS, 1525 IMPLEMENT_DYNAMIC_CLASS2, 1526 IncRef, 610 IncTo, 1113 Index, 51, 57, 1217, 1218 IndexOf, 795, 948 Inflate, 1050 Init, 100, 439, 566, 846, 931 InitAllHandlers, 1456 InitColWidths, 608 InitDialog, 979, 1416 Initialization functions, 924 Initialize, 173, 403, 650, 1001, 1176 InitializeClasses, 132 InitializeModules, 931 InitParser, 691 InitRowHeights, 608 InitStandardHandlers, 75, 745 Input Filters, 1706 insert, 645 Insert, 52, 57, 204, 322, 795, 899, 908, 1119, 1370, 1699 InsertCell, 665 InsertCheckItem, 899 InsertCols, 588, 635 InsertColumn, 814 InsertControl, 1326 InsertDir, 488 InsertHandler, 75, 745 InsertItem, 815, 1244, 1347 InsertItems, 801 InsertLine, 1282 InsertPage, 953 InsertRadioItem, 899 InsertRows, 589, 635 InsertSeparator, 899, 1327 InsertTool, 1327 Inside, 1051 Internat(ionalization) sample, 1575 InterruptWait, 1143 Intersect, 1060 Intersects, 562, 1051 Introduction, 1584, 1588, 1612, 1620, 1673 Invoke, 66 IPAddress, 769, 771 Is3rdStateAllowedForUser, 124 Is3State, 124 IsAbsolute, 488 IsAlive, 1294 IsAllowed, 959 IsAllowedTraceMask, 854 IsAlwaysOnline, 382 IsAnotherRunning, 1112 IsAscii, 1218 IsBetween, 256 IsBold, 1347 IsButton, 781, 939 IsCaseSensitive, 488 IsCellEditControlEnabled, 589 IsCheckable, 917 IsChecked, 124, 127, 170, 899, 909, 917 IsColNull, 323 IsColor, 393 IsColour, 392 IsCommandEvent, 445 IsCompatible, 1068 IsConnected, 1143 IsConnectedEvent, 379 IsCreated, 618 IsCurrent, 1383 IsCurrentCellReadOnly, 589 IsCursorClosedOnCommit, 323 IsData, 1143 IsDefault, 1253 IsDetached, 1295 IsDialing, 381 IsDir, 489 IsDisconnected, 1143 IsDST, 264 IsDSTApplicable, 247 IsEarlierThan, 255 IsEditable, 589, 1265 IsEditCancelled, 825, 1355 IsEmpty, 52, 58, 205, 795, 1060, 1218 IsEmptyCell, 633 IsEnabled, 900, 909, 917, 1416 IsEncodingAvailable, 531 IsEnding, 699 IsEqualTo, 255, 1308 IsEqualUpTo, 256 IsErrorAvailable, 1026 IsExpanded, 1347 IsExpandingEnvVars, 189 IsExposed, 1416, 1417 IsFixedWidth, 517 IsFullScreen, 540 IsFwdOnlyCursors, 278, 285 IsGregorianDate, 254 IsHoliday, 117 isHotSensitive, 1182 IsIconInstalled, 1247 IsIconized, 375, 540 IsInputAvailable, 1026 IsInputOpened, 1027 IsInSelection, 589 IsInside, 1053 IsKindOf, 132, 961 IsLaterThan, 255 IsLeapYear, 247 IsLoaded, 437, 847 IsLocalHost, 770 IsLongerThan, 1308 IsMain, 1295 IsMaximized, 540 IsModal, 375 IsModified, 420, 1265 IsMove, 781 IsMultiLine, 1265 IsNegative, 1308

1745


INDEX
IsNull, 1218, 1308, 1370 IsNumber, 1218 IsOfClass, 1463 IsOfType, 925 IsOk, 120, 177, 381, 489, 729, 777, 847, 946, 1197, 1247, 1392 IsOneShot, 1302 IsOnline, 382 IsOpen, 285 IsOpened, 139, 386, 457, 466, 1249, 1279 IsOwnEvent, 379 IsPageScroll, 939 IsPassingMessages, 855 IsPathSeparator, 489 IsPaused, 1295 IsPlaying, 1392 IsPopup, 913 IsPositive, 1309 IsPreview, 1018 IsPrimary, 393 IsQueryOnly, 324 IsReadOnly, 590, 613 IsRecordingDefaults, 189 IsRelative, 489 IsRetained, 1096, 1417 IsRunning, 1295, 1302 IsSameAs, 1218, 1219 IsSameDate, 256 IsSameTime, 256 IsSelected, 831, 1347, 1383 IsSelection, 170, 590 IsSeparator, 917 IsShorterThan, 1309 IsShown, 1124, 1417 IsSingleLine, 1265 IsSizer, 1124 IsSpacer, 1124 IsSplit, 1176 IsStrictlyBetween, 255 IsSupported, 139 IsTopLevel, 1417 IsType, 1371 IsValid, 252, 1056 IsValueKindOf, 1371 IsVertical, 558, 1188 IsVisible, 120, 415, 590, 1348, 1389 IsWestEuropeanCountry, 247 IsWindow, 1125 IsWord, 1219 IsWorkDay, 254 IsZMove, 781 Item, 52, 58, 795 ItemHasChildren, 1348

--L--
Last, 52, 58, 1219 LastCount, 1143 LastError, 1143 LastRead, 767 LastWrite, 964 Layout, 661, 1119, 1417 Layout sample, 1575 LayoutFrame, 788 LayoutMDIFrame, 788 LayoutWindow, 788 Leave, 208 Leaving, 939 left, 790 Left, 1219 LeftDClick, 939 LeftDown, 939 LeftIsDown, 939 LeftOf, 764 LeftUp, 940 Len, 1219 Length, 457, 466, 1219 Limits And Compatibility, 1732 Listctrl sample, 1576 ListToArray, 1230 Load, 437, 477, 1067, 1457 LoadBitmap, 1457 LoadDialog, 1457 LoadFile, 76, 88, 652, 706, 725, 745, 756, 1266 LoadFrame, 1457 LoadIcon, 1457 LoadLibrary, 395 LoadMenu, 1457 LoadMenuBar, 1458 LoadObject, 420 LoadPage, 706 LoadPanel, 1458 LoadToolBar, 1458 LocalHost, 770, 772 Lock, 945 LogError, 286 Logging functions, 848 LogicalToDeviceX, 364 LogicalToDeviceXRel, 364 LogicalToDeviceY, 364 LogicalToDeviceYRel, 364 Lower, 1220, 1418 LowerCase, 1220

--M--
m_active, 31 m_altDown, 782, 934 m_checked, 1358 m_childDocument, 396, 407 m_childView, 396, 407 m_clientData, 169 m_commandInt, 169 m_commandProcessor, 417 m_commandString, 169 m_controlDown, 783, 934

--K--
Key access, 182 Keyboard and mouse actions, 1674 KeywordSearch, 652, 680, 685 Kill, 1027, 1295

1746


INDEX
m_count, 963 m_currentView, 398 m_dc, 442 m_defaultDocumentNameCounter, 398 m_defaultExt, 411 m_description, 411 m_directory, 411 m_docClassInfo, 412 m_docs, 398 m_docTypeName, 412 m_documentFile, 417 m_documentManager, 412 m_documentModified, 417 m_documentTemplate, 417 m_documentTitle, 417 m_documentTypeName, 418 m_documentViews, 418 m_eventObject, 443 m_eventType, 443 m_extraLong, 169 m_fileFilter, 412 m_fileHistory, 398, 399, 475 m_fileHistoryN, 475 m_fileMaxFiles, 475 m_fileMenu, 476 m_files, 429 m_flags, 398, 412 m_id, 443 m_keyCode, 783 m_leftDown, 934 m_linesPerAction, 935 m_maxDocsOpen, 398 m_menuId, 913 m_metaDown, 783, 934 m_middleDown, 934 m_noFiles, 429 m_owner, 1300 m_pos, 430 m_propagationLevel, 443 m_refData, 960 m_rightDown, 934 m_setChecked, 1358 m_setEnabled, 1359 m_setText, 1359 m_shiftDown, 783, 934 m_skipped, 444 m_text, 1359 m_thread, 1299 m_timeStamp, 444 m_viewClassInfo, 412 m_viewDocument, 1376 m_viewFrame, 1376 m_viewTypeName, 412, 1376 m_wheelDelta, 935 m_wheelRotation, 935 m_x, 783, 935 m_y, 783, 935 Macros for template array definition, 44 MainLoop, 35 MakeAbsolute, 489 MakeCellVisible, 590 MakeConnection, 133 MakeDefaultName, 403 MakeGMT, 264 MakeKey, 648 MakeLower, 1220 MakeModal, 1418 MakeNull, 1371 MakeRelativeTo, 489 MakeString, 1371 MakeTimezone, 264 MakeUpper, 1220 Matches, 1057, 1220 Matching, 1731 Maximize, 541, 877 MaxX, 364 MaxY, 364 MB2WC, 211, 868, 870, 871, 872, 873, 874 Member, 796, 981, 1230, 1371 Memory management, 45, 1209 MessageParameters class, 501 MetaDown, 625, 627, 629, 785, 940 Metasyntax, 1730 Mid, 1220 MiddleDClick, 940 MiddleDown, 940 MiddleIsDown, 940 MiddleUp, 940 Minimal sample, 1570 Minute, 1309 Minutes, 1309 MinX, 365 MinY, 365 Mirror, 749 Miscellaneous, 1209, 1545 Miscellaneous functions, 182 Mkdir, 490 MkDir, 551 mnTemplates, 399 Modify, 421 ModifyColumn, 286 Month, 235 Months, 235 More DDE details, 1702 MoreRequested, 732 Move, 121, 428, 994, 1418 MoveCursorDown, 590 MoveCursorDownBlock, 591 MoveCursorLeft, 590 MoveCursorLeftBlock, 591 MoveCursorRight, 591 MoveCursorRightBlock, 592 MoveCursorUp, 591 MoveCursorUpBlock, 592 MovePageDown, 592 MovePageUp, 592 Moving, 941 Multiply, 235, 1309

--N--
Native font information, 1653 Navigate, 29 Neg, 235, 1310

1747


INDEX
Negate, 235, 1309 new, 962 Next, 648 ngettext, 1492 Normalize, 490 Notebook sample, 1576 Notify, 1144, 1302 NotifyEvent, 29 Now, 248 Nth, 796 NullList, 1371 Number, 205, 796, 1042 Number of elements and simple item access, 46 OnDropText, 1275 OnEndDocument, 1019 OnEndPrinting, 1019 OnEnter, 434 OnExecute, 195 OnExit, 36, 931, 1296 OnFacename, 528 OnFatalException, 36 OnFile, 390 OnFileClose, 403 OnFileCloseAll, 403 OnFileNew, 404 OnFileOpen, 404 OnFileSave, 404 OnFileSaveAs, 404 OnFontEncoding, 528 OnFrameClose, 861 OnFrameCreate, 861 OnFrameDelete, 861 OnGetItem, 689 OnGetItemAttr, 816 OnGetItemImage, 816 OnGetItemMarkup, 689 OnGetItemText, 816 OnGetLineHeight, 1389 OnGetLinesHint, 1389 OnInit, 37, 931 OnInitCmdLine, 37 OnInternalIdle, 1419 OnLeave, 435 OnLeftClick, 1327 OnLinkClicked, 707 OnLog, 851 OnMakeConnection, 133 OnMeasureItem, 1384 OnMenuCommand, 404 OnMouseClick, 661 OnMouseEnter, 1328 OnNewDocument, 422 OnOK, 376 OnOpenDocument, 422 OnOpenError, 391 OnOpeningURL, 708 OnPaint, 998 OnPoke, 195 OnPreparePrinting, 1019 OnPrintPage, 1019 OnQueryEndSession, 37 OnQueryLayoutInfo, 1072 OnQuit, 653 OnRequest, 195 OnRightClick, 1328 OnRun, 38 OnSashPositionChange, 1177 OnSaveDocument, 422 OnSaveModified, 422 OnSelChange, 954 OnSetTitle, 708 OnStartAdvise, 195 OnStopAdvise, 195 OnSysColourChanged, 376, 979 OnSysRead, 1197

--O--
Offset, 1051, 1061 Ok, 21, 77, 95, 153, 216, 365, 460, 461, 479, 495, 519, 725, 747, 921, 969, 976, 986, 1004, 1008, 1011, 1022, 1144 OnAcceptConnection, 1107 OnActivate, 397, 408, 607 OnActivateView, 1378 OnAdvise, 194 OnApply, 375 OnAssert, 35 OnBeginDocument, 1018 OnBeginPrinting, 1019 OnCalculateLayout, 1072 OnCancel, 376 OnCellClicked, 707 OnCellMouseHover, 707 OnChangedViewList, 421 OnChangeFilename, 1378 OnChar, 1290 OnCharHook, 375 OnClose, 1378 OnCloseDocument, 421 OnCloseWindow, 397, 408, 409, 410, 1001, 1168 OnClosingDoocument, 1378 OnCmdLineError, 35 OnCmdLineHelp, 36 OnCmdLineParsed, 36 OnCompareItems, 1348 OnCreate, 421, 1378 OnCreateClient, 884 OnCreateCommandProcessor, 421 OnCreateFileHistory, 403 OnCreatePrintout, 1378 OnCreateStatusBar, 541 OnCreateToolBar, 542 OnData, 434 OnDir, 390 OnDisconnect, 195 OnDoubleClickSash, 1176 OnDragOver, 435 OnDraw, 1097 OnDrawBackground, 1383 OnDrawItem, 1383 OnDrawSeparator, 1384 OnDrop, 434, 474, 1275 OnDropFiles, 474, 1266

1748


INDEX
OnSysSeek, 1198 OnSysTell, 1198 OnSysWrite, 1198 OnTerminate, 1028 OnUnhandledException, 38 OnUnsplit, 1177 OnUpdate, 1379 Open, 139, 287, 324, 386, 457, 466, 1028, 1249, 1282 OpenContainer, 716 OpenFile, 497, 500 OpenURL, 692 Operating systems, 1543 Operations, 481, 1305 operator, 252, 560, 563, 1225 =, 237, 493 operator-, 235 operator =, 55, 220 operator =, 754 operator-, 864 operator-, 864 operator-, 864 operator--, 864 operator--, 865 operator-, 1310 operator --, 339 operator !=, 22, 80, 97, 154, 216, 522, 727, 977, 988, 1052, 1227, 1372, 1373 operator (), 1226 operator *, 1083 operator [], 1080, 1226, 1373 operator +, 1225 operator ++, 338, 1064 operator +=, 1225, 1226 operator <, 1227 operator <<, 1226, 1272 operator <=, 1227 operator =, 21, 55, 79, 96, 153, 156, 216, 522, 525, 726, 753, 971, 976, 988, 1006, 1012, 1052, 1062, 1114, 1225, 1372 operator ==, 21, 55, 80, 96, 154, 216, 220, 522, 727, 753, 977, 988, 1052, 1227, 1372 operator >, 1227 operator ->, 1083 operator >=, 1227 operator >>, 1226 operator bool, 1064 operator char, 1373 operator const char*, 1227 operator double, 1373 operator long, 1373 operator void*, 1374 operator wxChar *, 1228 operator wxString, 1373 operator*=, 235, 1309 operator[], 56, 645, 1280 operator+, 864 operator++, 864 operator+=, 233, 236, 256, 1306 operator=, 49, 493, 729, 862 operator-=, 257 operator-=, 257 operator-=, 1310 operator==, 237, 493, 560, 563 Options, 183 OrderBy, 325 Other Python GUIs, 1714 Other string related functions and classes, 1586

--P--
Pad, 1220 PageSetup, 674 PaintBackground, 618 PaintPage, 1022 Parse, 149, 692 ParseDate, 258 ParseDateTime, 258 ParseFormat, 258 ParseInner, 701 ParseRfc822Date, 257 ParseTime, 259 Parsing and formatting dates, 243 Parsing command line, 145 PassMessages, 855 Paste, 162, 1266 Path management, 180 Pause, 1196, 1296 Peek, 767, 1147 Pending, 39 PercentOf, 764 Play, 921, 1392 Pluggable event handlers, 1616 Poke, 196 PopEventHandler, 1419 PopProvider, 63 PopStatusText, 1193 PopTagHandler, 694 PopupMenu, 1247, 1420 PositionToXY, 1266 Positive thinking, 13 Post, 1105 Precompiled headers, 9 PrepareDC, 1097 Prepend, 900, 1119, 1221 PrependCheckItem, 900 PrependDir, 491 PrependItem, 1348 PrependRadioItem, 901 PrependSeparator, 901 PreProcessTip, 1311 PreviewFile, 672 PreviewText, 673 Print, 1014, 1022 PrintClasses, 346 PrintDialog, 1014 PrinterSetup, 674 Printf, 1221 PrintFile, 673

1749


INDEX
PrintfV, 1221 PrintStatistics, 346 PrintText, 673 ProcessEvent, 451 ProcessMessage, 38 Programming with wxBoxSizer, 1634 Programming with wxFlexGridSizer, 1636 Programming with wxGridSizer, 1636 Programming with wxNotebookSizer, 1636 Programming with wxStaticBoxSizer, 1637 PushEventHandler, 1421 PushProvider, 63 PushStatusText, 1193 PushTagHandler, 693 Put, 648 PutC, 964 PutChar, 1200 PutProperty, 67 Pwd, 551 RefreshItem, 817 RefreshItems, 817 RefreshLine, 1389 RefreshLines, 1390 RefreshLists, 685 RegisterDataType, 603 RegisterHotKey, 1422 RegisterModule, 931 RegisterModules, 931 Regular Expression Character Names, 1734 Regular Expression Syntax, 1725 release, 1082 ReleaseCapture, 778 ReleaseMouse, 1423 Remove, 52, 58, 162, 761, 901, 910, 1120, 1221, 1267 RemoveAll, 761 RemoveAt, 53, 58 RemoveBrush, 98 RemoveChild, 1423 RemoveDir, 491 RemoveDocument, 405 RemoveEventHandler, 1423 RemoveFile, 888 RemoveFont, 529 RemoveGrowableCol, 512 RemoveGrowableRow, 512 RemoveHandler, 77, 747 RemoveHelp, 657 RemoveIcon, 1247 RemoveLast, 1221 RemoveLine, 1282 RemoveMenu, 477 RemovePage, 954 RemovePen, 990 RemoveProvider, 63 RemoveTool, 1329 RemoveTraceMask, 854 RemoveView, 422 Removing items, 46 Rename, 551 Rename entries/groups, 183 RenameEntry, 190 RenameGroup, 191 Render, 671 Render sample, 1576 RenderPage, 1022 Reparent, 1424 Replace, 162, 749, 761, 762, 910, 1057, 1221, 1267 ReplaceAll, 1057 ReplaceFirst, 1057 ReplaceWindow, 1177 ReportError, 1015 Request, 196 RequestMore, 732 Rescale, 750 reset, 1080, 1083 Reset, 619, 1064 ResetAttr, 114 ResetBoundingBox, 365 ResetBuffer, 1201

--Q--
Quantize, 1035 Query, 325 Query database, 924 QueryBySqlStmt, 327 QueryMatching, 328 QueryOnKeyFields, 329 Quit, 653

--R--
Raise, 1421 Read, 189, 190, 457, 466, 767, 1148, 1200, 1375 Read16, 222, 1284 Read16S, 1285 Read32, 223, 1285 Read32S, 1285 Read64, 223 Read8, 222, 1284 Read8S, 1284 ReadCustomization, 680, 685, 709 ReadDouble, 223, 1285 ReadFile, 676 ReadMailcap, 926 ReadMimeTypes, 926 ReadMsg, 1148 ReadString, 223 Realize, 1329 RecalcSizes, 90, 615, 1120 Reconnect, 1032 Red, 153 Redirect, 1029 Redo, 172, 1267 RedrawEverything, 995 RedrawXAxis, 995 RedrawYAxis, 995 Ref, 961 Reference counting and why you shouldn't care about it, 1586 Refresh, 330, 910, 1421, 1422 RefreshAll, 1390

1750


INDEX
ResetTime, 251 ResetUpdateTime, 1361 Resource file, 7 Restore, 877 RestoreState, 1144 Resume, 852, 1031, 1196, 1297 ResumePropagation, 445 right, 790 Right, 1222 RightDClick, 941 RightDown, 941 RightIsDown, 941 RightOf, 765 RightUp, 941 Rmdir, 491 RmDir, 551 RmFile, 552 RollbackTrans, 289 Rotate, 750 Rotate sample, 1576 Rotate90, 750 RTTI, 8 Run, 1296 RunWizard, 1448 Selection functions, 575 SelectionToDeviceRect, 602 SelectItem, 1348 SelectLine, 709 SelectObject, 886 SelectRange, 1385 SelectRow, 593 SelectViewType, 406 SelectWord, 709 SendCommand, 551 SendIdleEvents, 39 SendSizeEvent, 542 Service, 769, 771 Set, 19, 153, 191, 250, 251, 255, 533, 656, 765, 802, 1067, 1113, 1458 Set3StateValue, 125 SetAcceleratorTable, 1426 SetAccessible, 1426 SetActiveTarget, 851 SetActualColor, 716 SetAlign, 665, 716, 828 SetAlignHor, 665 SetAlignment, 611, 1037, 1073, 1253 SetAlignVer, 666 SetAllowSymbols, 524 SetAlpha, 751 SetAppName, 39 SetAscii, 552 SetAttr, 114, 637 SetAttrProvider, 636 SetAuthStr, 301 SetAuto3D, 39 SetAutoLayout, 1426 SetAxisOrientation, 365 SetBackground, 366 SetBackgroundColour, 115, 611, 666, 817, 828, 918, 1253, 1426 SetBackgroundMode, 366 SetBellOnError, 1366 SetBezelFace, 558 SetBinary, 552 SetBitmap, 86, 918, 1184 SetBitmapDisabled, 84 SetBitmapFocus, 84 SetBitmapLabel, 84 SetBitmaps, 918 SetBitmapSelected, 85 SetBlinkTime, 121 SetBorder, 116, 667, 1125, 1449 SetBorderColour, 115 SetBorders, 710 SetBoundingRect, 1313 SetBrush, 367 SetBufferIO, 1201, 1202 SetButtonsImageList, 1349 SetCanvas, 1022 SetCanVeto, 141 SetCap, 986 SetCapture, 778 SetCaret, 1427 SetCellAlignment, 593 SetCellBackgroundColour, 606, 607

--S--
SameAs, 492, 765 Save, 422, 477 SaveAs, 423 SaveEditControlValue, 592 SaveFile, 77, 89, 748, 756, 1268 SaveObject, 423 SaveState, 1144 Scale, 750 ScanParam, 699 ScreenToClient, 1424 Scroll, 1097 Scroll subwindow sample, 1576 ScrollLines, 1390, 1424 ScrollList, 817 ScrollPages, 1390, 1425 ScrollTo, 1348 ScrollToLine, 1391 ScrollWindow, 1425 SearchEventTable, 452 Searching and replacing, 1208 Searching and sorting, 46 Second, 1310 Seconds, 1310 Seek, 458, 466, 1201 SeekEnd, 458, 467 SeekI, 767 SeekO, 102, 964 Select, 30, 832, 1384, 1699 SelectAll, 593, 709, 1385 SelectBlock, 593 SelectCol, 593 SelectDocumentPath, 405 SelectDocumentType, 405 Selected, 802 Selecting, 625, 627

1751


INDEX
SetCellBitmap, 607 SetCellEditor, 594 SetCellFont, 594 SetCellRenderer, 594 SetCellTextColour, 594 SetCellTextFont, 606 SetCellValue, 594 SetChar, 1222 SetCheckpoint, 347 SetCheckPrevious, 347 SetChooseFull, 155 SetChosenFont, 524 SetClassName, 40 SetClientData, 136, 171, 205, 452, 1145 SetClientObject, 136, 205, 453 SetClientSize, 1427 SetClipboard, 921 SetClippingRegion, 366 SetCmdLine, 147 SetCol, 560, 623 SetColAttr, 595, 637 SetColDefs, 331 SetColFormatBool, 595 SetColFormatCustom, 595 SetColFormatFloat, 595 SetColFormatNumber, 595 SetColLabelAlignment, 596 SetColLabelSize, 596 SetColLabelValue, 596, 636 SetCollate, 1004, 1011 SetColMinimalAcceptableWidth, 596 SetColMinimalWidth, 596 SetColNull, 334 SetColour, 95, 155, 525, 573, 986, 1004 SetCols, 638 SetColSize, 597 SetColspan, 563 SetColumn, 817, 828 SetColumnImage, 832 SetColumns, 130 SetColumnWidth, 605, 817 SetCommandProcessor, 423 SetConcurrency, 1297 SetConfig, 533 SetConfigPath, 533 SetConnectCommand, 383 SetConstraints, 1428 SetContainer, 716 SetContainingSizer, 1428 SetControl, 623 SetCount, 53 SetCountry, 248 SetCurrent, 572, 993 SetCurrentPage, 1023 SetCursor, 333, 1428 SetCustomColour, 155 SetCwd, 492 SetDashes, 987 SetData, 139, 218, 227, 229, 432, 751, 828, 947, 1229, 1371 SetDataObject, 436 SetDate, 111, 118 SetDay, 251 SetDays, 236 SetDC, 670, 716 SetDebugErrorMessages, 289 SetDebugMode, 347 SetDefAttr, 613 SetDefault, 107 SetDefaultCellAlignment, 597 SetDefaultCellBackgroundColour, 597 SetDefaultCellFont, 597 SetDefaultColSize, 598 SetDefaultDir, 301 SetDefaultEditor, 598 SetDefaultEncoding, 519 SetDefaultExtension, 416 SetDefaultInfo, 969 SetDefaultItem, 980 SetDefaultMinMargins, 969 SetDefaultPath, 567 SetDefaultProxy, 1364 SetDefaultRenderer, 598 SetDefaultRowSize, 598 SetDefaultSize, 1073 SetDefaultStyle, 1268 SetDelay, 1333 SetDepth, 78, 725 SetDesc, 148 SetDescription, 301, 416 SetDeviceOrigin, 366 SetDialogParent, 532 SetDialogTitle, 533 SetDimension, 1120, 1125 SetDirectory, 416, 472 SetDispatchPtr, 67 SetDividerPen, 607 SetDocument, 397, 408, 1379 SetDocumentManager, 416 SetDocumentName, 423 SetDocumentTemplate, 423 SetDropTarget, 1429 SetDsn, 301 SetDuplex, 1004 SetEditable, 607, 1269 SetEditInPlace, 607 SetEditMenu, 173 SetEditor, 611 SetEmptyCellSize, 615 SetEndY, 991 SetEnlargeAroundWindowCentre, 995 SetEventHandler, 1145, 1429 SetEventObject, 445 SetEventType, 445 SetEvtHandlerEnabled, 453 SetExcludeList, 1290 SetExitOnFrameDelete, 40 SetExpandEnvVars, 191 SetExt, 492 SetExtension, 89, 757 SetExtraLong, 171 SetExtraStyle, 1430 SetFaceName, 520 SetFamily, 520

1752


INDEX
SetFieldsCount, 1193 SetFile, 348 SetFileFilter, 416 SetFilename, 424, 473 SetFileType, 301 SetFilter, 568 SetFilterIndex, 473, 568 SetFindString, 509 SetFirstItem, 802 SetFlag, 1125 SetFlags, 108, 416, 508, 1037, 1145, 1254, 1458 SetFlexibleDirections, 512 SetFocus, 1430 SetFocusFromKbd, 1431 SetFont, 115, 367, 611, 828, 918, 1254, 1431 SetFontBold, 717 SetFontFace, 717 SetFontFixed, 717 SetFontItalic, 717 SetFonts, 670, 674, 695, 710, 717 SetFontSize, 717 SetFontUnderlined, 717 SetFooter, 674, 695 SetForce, 141 SetForegroundColour, 1431 SetFormat, 229 SetFrame, 1023, 1379 SetFrameParameters, 653 SetFromClause, 333 SetFromPage, 1011 SetFS, 694 SetFullName, 492 SetGridCursor, 598 SetGridLineColour, 598 SetHeader, 674, 695, 720 SetHeaderColours, 112 SetHeight, 78, 726, 1051, 1113 SetHelp, 918 SetHelpController, 654 SetHelpString, 902, 911 SetHelpText, 1432 SetHenv, 302 SetHGap, 638 SetHighlightColours, 112 SetHoliday, 114, 116 SetHolidayColours, 113 SetHour, 251 SetHtmlFile, 696 SetHtmlText, 670, 696 SetIcon, 377, 543, 1248 SetIcons, 377, 543 SetId, 220, 445, 662, 829, 1024, 1356, 1432 SetImage, 829 SetImageList, 818, 954, 1244, 1349 SetIncludeList, 1290 SetIndent, 667, 1349 SetInitialFont, 525 SetInitSize, 1125 SetInputEncoding, 718 SetInsertionPoint, 163, 1269 SetInsertionPointEnd, 163, 1269 SetInt, 171 SetIntPosition, 1203 SetItem, 818, 819 SetItemBackgroundColour, 819, 1349 SetItemBold, 1349 SetItemCount, 820, 1385 SetItemData, 820, 1244, 1350 SetItemFont, 1350 SetItemHasChildren, 1350 SetItemImage, 820, 1244, 1350 SetItemMinSize, 1121 SetItemPosition, 616, 820 SetItemSelectedImage, 1350 SetItemSize, 1245 SetItemSpan, 616 SetItemState, 820 SetItemText, 820, 1245, 1351 SetItemTextColour, 821, 1351 SetJoin, 987 SetLabel, 107, 200, 902, 911, 1043, 1190 SetLabelAlignment, 606 SetLabelBackgroundColour, 599 SetLabelFont, 599 SetLabelSize, 606 SetLabelTextColour, 599 SetLabelTop, 911 SetLabelValue, 606 SetLastDirectory, 406 SetLeftIndent, 1254 SetLevel, 348 SetLineCount, 1391 SetLineSize, 1134 SetLink, 662, 718 SetLinkColor, 718 SetLog, 856 SetLoggingOff, 142 SetLogicalFunction, 367 SetLogLevel, 853 SetLogo, 148 SetMapMode, 368 SetMarginBottomRight, 970 SetMargins, 603, 696, 1329, 1385 SetMarginTopLeft, 970 SetMarginWidth, 918 SetMask, 78, 751, 829 SetMaskColour, 752 SetMaskFromImage, 752 SetMaxDocsOpen, 406 SetMaximumSizeX, 1076 SetMaximumSizeY, 1076 SetMaxLength, 1269 SetMaxPage, 1011 SetMenuBar, 543 SetMenuStrings, 173 SetMessage, 389, 473 SetMillisecond, 252 SetMimeType, 757 SetMinHeight, 668, 1194 SetMinimumPaneSize, 1178 SetMinimumSizeX, 1077 SetMinimumSizeY, 1077 SetMinMarginBottomRight, 970 SetMinMarginTopLeft, 970

1753


INDEX
SetMinPage, 1011 SetMinSize, 1120 SetMinute, 251 SetModal, 377 SetMode, 732, 1361 SetMonth, 251 SetMonths, 236 SetMovementThreshold, 778 SetName, 89, 492, 757, 1432 SetNativeFontInfo, 520 SetNext, 662, 1453 SetNextHandler, 453 SetNoCopies, 1004, 1011 SetNonFlexibleGrowMode, 512 SetNotify, 1146 SetOffsetY, 991 SetOk, 726 SetOldSelection, 957 SetOnlineStatus, 382 SetOptimization, 368 SetOption, 752, 1235 SetOrCalcColumnSizes, 609 SetOrCalcRowSizes, 609 SetOrderByClause, 335 SetOrientation, 1004, 1037, 1073 SetOwner, 1303 SetPadding, 954, 1245 SetPage, 711 SetPageImage, 955 SetPageSize, 954, 1134, 1449 SetPageText, 955 SetPalette, 79, 366, 753, 1432 SetPaperId, 970, 1005 SetPaperSize, 970 SetParameters, 617, 620, 621, 622, 630 SetParent, 662 SetParentResource, 1463 SetParser, 701 SetPassword, 302, 553, 1034 SetPath, 191, 389, 473, 568 SetPen, 369 SetPointSize, 521 SetPos, 562, 663 SetPosition, 655, 1167 SetPrecision, 630 SetPrev, 1453 SetPreviousHandler, 454 SetPrintData, 970, 1012 SetPrinterName, 1006 SetPrintout, 1023 SetPrintToFile, 1012 SetPriority, 1296 SetProportion, 1125 SetProxy, 1364 SetQuality, 1006 SetQueryTimeout, 335 SetRange, 525, 558, 1133, 1163, 1166 SetRatio, 1125 SetReadOnly, 599, 611 SetRecordDefaults, 191 SetRect, 109 SetRedoAccelerator, 174 SetRefData, 961 SetRelatedFrame, 711 SetRelatedStatusBar, 711 SetRenderer, 611 SetReplaceString, 509 SetRequestedLength, 1037 SetResolution, 997 SetReturnCode, 378 SetRGB, 753 SetRightIndent, 1254 SetRow, 560, 623 SetRowAttr, 599, 637 SetRowHeight, 605 SetRowLabelAlignment, 599 SetRowLabelSize, 599 SetRowLabelValue, 600, 636 SetRowMinimalAcceptableHeight, 600 SetRowMinimalHeight, 600 SetRows, 638 SetRowSize, 600 SetRowspan, 563 SetSashBorder, 1077 SetSashPosition, 1171, 1178 SetSashVisible, 1077 SetScrollbar, 1090, 1433 SetScrollbars, 1098 SetScrollOnThumbRelease, 995 SetScrollPos, 1434 SetScrollRate, 1099 SetScrollX, 605 SetScrollY, 605 SetSecond, 252 SetSelection, 163, 206, 955, 957, 1012, 1043, 1110, 1134, 1166, 1245, 1270, 1386 SetSelectionBackground, 603, 1386 SetSelectionForeground, 603 SetSelectionMode, 601 SetSetupDialog, 1012 SetShadowWidth, 559 SetShape, 544 SetShowHelp, 525 SetSingleStyle, 821 SetSize, 121, 618, 670, 1038, 1434 SetSizeHints, 1121, 1436 SetSizer, 1126, 1436 SetSizerAndFit, 1437 SetSpacer, 1126 SetSpan, 562 SetSplitMode, 1179 SetSqlLogging, 290 SetStandardError, 348 SetStartY, 991 SetState, 829 SetStateImageList, 1351 SetStateMask, 829 SetStatusBar, 544 SetStatusBarPane, 544 SetStatusText, 544, 1194 SetStatusWidths, 545, 1194 SetStipple, 95, 987 SetStream, 348 SetString, 171, 206, 1233

1754


INDEX
SetStringSelection, 206, 1043 SetStringSeparators, 1286 SetStyle, 96, 389, 473, 521, 987, 1270, 1290 SetSwitchChars, 147 SetTable, 601 SetTabs, 1254 SetTargetWindow, 1099 SetTempDir, 680, 682 SetText, 829, 918, 1274, 1361 SetTextBackground, 369 SetTextColour, 115, 610, 821, 829, 919, 1254 SetTextForeground, 369 SetThemeEnabled, 1437 SetThumbLength, 1135 SetThumbPosition, 1089 SetTick, 1135 SetTickFreq, 1133 SetTimeout, 1147 SetTimes, 492 SetTimestamp, 446, 853 SetTip, 1333 SetTipWindowPtr, 1313 SetTitle, 378, 424, 545, 902, 1437 SetTitleFormat, 680, 685 SetToCurrent, 250 SetToLastMonthDay, 262 SetToLastWeekDay, 261 SetToNextWeekDay, 260 SetToolBar, 545, 884 SetToolBitmapSize, 1330 SetToolClientData, 1330 SetToolLongHelp, 1330 SetToolPacking, 1331 SetToolSeparation, 1332 SetToolShortHelp, 1331 SetToolTip, 1355, 1438 SetToPage, 1012 SetToPrevWeekDay, 260 SetTopWindow, 40 SetToTheWeek, 262 SetToWeekDay, 261 SetToWeekDayInSameWeek, 260 SetToYearDay, 262 SetTraceMask, 854 SetTransferMode, 552 SetType, 90, 221, 757 SetUid, 302 SetUmask, 192 SetUnderlined, 521 SetUndoAccelerator, 174 SetUnitsPerValue, 994 Setup, 1015 SetUpdateInterval, 1362 SetupWindow, 1463 SetUseBestVisual, 41 SetUser, 552, 1034 SetUserID, 302 SetUserScale, 369 SetValidator, 1438 SetValue, 124, 163, 559, 633, 1046, 1135, 1163, 1165, 1271, 1277, 1316 SetValueAsBool, 634 SetValueAsCustom, 634 SetValueAsDouble, 634 SetValueAsLong, 634 SetVendorName, 41 SetVerbose, 853 SetVGap, 638 SetView, 397, 408, 635 SetViewer, 653 SetViewName, 1379 SetVirtualSize, 1438 SetVirtualSizeHints, 1121, 1438 SetVolume, 492 SetWeekDay, 118 SetWeeks, 236 SetWeight, 522 SetWellKnownHost, 383 SetWhereClause, 336 SetWidth, 79, 631, 726, 830, 988, 1051, 1114 SetWidthFloat, 669 SetWildcard, 473 SetWindow, 30, 1126, 1366 SetWindowMenu, 885 SetWindowStyle, 1351, 1439 SetWindowStyleFlag, 821, 1439 SetX, 1052 SetY, 1052 SetYear, 251 SetYears, 236 SetZoom, 994, 1023 SetZoomControl, 1000 ShiftDown, 625, 627, 629, 785, 941 ShouldPropagate, 446 Show, 121, 378, 428, 618, 861, 1044, 1121, 1126, 1439 ShowCellEditControl, 601 ShowFullScreen, 546 ShowHelp, 657 ShowModal, 158, 379, 389, 473, 527, 920, 965, 1008, 1110, 1277 ShowPosition, 1271 Shrink, 53, 58, 1222 Signal, 177 Simplify the problem, 13 size, 646 Skip, 446 Sleep, 1296 SockAddrLen, 1136 Socket state, 1138 Sockets sample, 1576 Some advice about using wxString, 1585 Sort, 54, 59, 796, 1230 SortChildren, 1351 SortItems, 821 Sound sample, 1577 SplitHorizontally, 1179 SplitPath, 493 SplitVertically, 1180 sprintf, 1222 SQLColumnName, 290 SQLTableName, 291 Start, 1196, 1303 StartAdvise, 196

1755


INDEX
StartDoc, 369 StartDrawingOnTop, 1078 StartingClick, 619 StartingKey, 619 StartPage, 369 StartsWith, 1222 Statbar sample, 1577 Static functions, 179, 240, 848, 1305 std::string compatibility functions, 1210 Stop, 1303, 1393 StopAdvise, 196 StopParsing, 694 StopPropagation, 446 Strategies for exceptions handling, 1620 Stream, 1204 String length, 1206 Strip, 1222 Submit, 174 Substract, 1310 SubString, 1222 Substring extraction, 1207 Subtract, 236, 257, 1060 Supported bitmap file formats, 1650 Supported languages, 833 Suspend, 851 swap, 1081, 1083 SwapBuffers, 573 Sync, 102 ToLong, 863, 1223 Toolbar sample, 1578 top, 790 ToString, 864 ToTimezone, 263 Touch, 493 ToULong, 1224 TransferDataFromWindow, 1440 TransferDataToWindow, 1440 TransferFromWindow, 569, 1291 TransferToWindow, 570, 1291, 1366 TranslateSqlState, 293 Traverse, 386 Treectrl sample, 1579 Trim, 1224 Truncate, 1224 TryLock, 945 TryWait, 1105 Tuning wxString for your application, 1587 Type of NULL, 8

--U--
Unconstrained, 764 Undo, 165, 174, 1271 Ungetch, 768 UngetWriteBuf, 1224 Unicode and ANSI modes, 1593 Unicode and the outside world, 1595 Unicode support in wxWindows, 1594 Unicode-related compilation settings, 1595 Union, 1061 Unload, 438 UnloadLibrary, 395 Unlock, 945 UNow, 248 Unread, 1149 UnRef, 962 UnregisterHotKey, 1440 Unselect, 1352 UnselectAll, 1352 UnselectItem, 1352 Unsplit, 1181 Update, 337, 1032, 1441, 1699 UpdateAllViews, 424 UpdateAttrCols, 636 UpdateAttrRows, 636 UpdateBackingFromWindow, 428 UpdateDimensions, 604 UpdateResources, 1458 UpdateRow, 343 UpdateUI, 903 UpdateWhere, 337 UpdateWindowUI, 1441 Upper, 1224 UpperCase, 1225 URLToFileName, 497 Usage, 150 Use a debugger, 13 Use ASSERT, 12 Use logging functions, 13 Use relative positioning or constraints, 12

--T--
TableExists, 291 TablePrivileges, 292 Tag Handlers, 1708 Tags supported by wxHTML, 1710 TakeData, 218 Technicalities, 1621 Tell, 458, 467, 1201 TellI, 767 TellO, 964 Templates, 8 TestDestroy, 1297 Tests, 1305 Tests of existence, 182 Text sample, 1578 Thaw, 1440 The data provider (source) duties, 1679 The data receiver (target) duties, 1679 The idea behind sizers, 1630 This, 1297 Thread sample, 1578 Tile, 885 Time, 1196 Time zone and DST support, 244 Time zone considerations, 1591 ToAscii, 1223 Today, 248 ToDouble, 1223 Toggle, 1352, 1386 ToggleItemSelection, 1352 ToggleTool, 1332 ToGMT, 264

1756


INDEX
Use the wxWindows debugging facilities, 14 Use wxString in preference to character arrays, 12 Use wxWindows resource files, 12 UseConfig, 680, 686 UseMenu, 477 UsePrimarySelection, 139 Using binary resource files, 1639 Using embedded resources, 1640 Using the toolbar library, 1669 Using wxPython, 1715 WX_DEFINE_EXPORTED_ARRAY, 46 WX_DEFINE_EXPORTED_OBJARRAY, 48 WX_DEFINE_OBJARRAY, 48 WX_DEFINE_SORTED_ARRAY, 47 WX_DEFINE_SORTED_EXPORTED_ARRAY, 47 WX_DEFINE_SORTED_USER_EXPORTED_AR RAY, 47 WX_DEFINE_USER_EXPORTED_ARRAY, 46 WX_DEFINE_USER_EXPORTED_OBJARRAY, 48 WX_GL_AUX_BUFFERS, 571 WX_GL_BUFFER_SIZE, 571 WX_GL_DEPTH_SIZE, 571 WX_GL_DOUBLEBUFFER, 571 WX_GL_LEVEL, 571 WX_GL_MIN_ACCUM_ALPHA, 571 WX_GL_MIN_ACCUM_BLUE, 571 WX_GL_MIN_ACCUM_GREEN, 571 WX_GL_MIN_ACCUM_RED, 571 WX_GL_MIN_ALPHA, 571 WX_GL_MIN_BLUE, 571 WX_GL_MIN_GREEN, 571 WX_GL_MIN_RED, 571 WX_GL_RGBA, 570 WX_GL_STENCIL_SIZE, 571 WX_GL_STEREO, 571 wxAcceleratorEntry, 18 wxAcceleratorEntry::GetCommand, 18 wxAcceleratorEntry::GetFlags, 19 wxAcceleratorEntry::GetKeyCode, 19 wxAcceleratorEntry::Set, 19 wxAcceleratorEntry::wxAcceleratorEntry, 18 wxAcceleratorTable, 20 wxAcceleratorTable::~wxAcceleratorTable, 21 wxAcceleratorTable::Ok, 21 wxAcceleratorTable::operator !=, 22 wxAcceleratorTable::operator =, 21 wxAcceleratorTable::operator ==, 21 wxAcceleratorTable::wxAcceleratorTable, 20 wxAccessible, 26 wxAccessible::~wxAccessible, 26 wxAccessible::DoDefaultAction, 26 wxAccessible::GetChild, 27 wxAccessible::GetChildCount, 27 wxAccessible::GetDefaultAction, 27 wxAccessible::GetDescription, 27 wxAccessible::GetFocus, 27 wxAccessible::GetHelpText, 27 wxAccessible::GetKeyboardShortcut, 28 wxAccessible::GetLocation, 28 wxAccessible::GetName, 28 wxAccessible::GetParent, 28 wxAccessible::GetRole, 28 wxAccessible::GetSelections, 28 wxAccessible::GetState, 29 wxAccessible::GetValue, 29 wxAccessible::GetWindow, 29 wxAccessible::HitTest, 29 wxAccessible::Navigate, 29 wxAccessible::NotifyEvent, 29 wxAccessible::Select, 30

--V--
Validate, 1291, 1366, 1442 ValidateRow, 343 ValidHost, 134 version, 1068 Veto, 142, 959

--W--
Wait, 177, 178, 1105, 1150, 1298 WaitForAccept, 1159 WaitForRead, 1151 WaitForWrite, 1151 WaitOnConnect, 1155 WaitTimeout, 1106 WarpPointer, 1442 WC2MB, 211, 868, 870, 871, 872, 873, 874 Week, 236, 1310 Weeks, 237, 1310 What is Unicode?, 1592 What is wxPython?, 1713 Where, 338 Where to go for help, 1724 Why use wxPython?, 1714 width, 790, 1048 widthSash, 1181 Window identifiers, 1617 Window layout examples, 1628 Wizard sample, 1579 Write, 192, 458, 459, 467, 468, 964, 1152, 1200, 1249, 1282, 1375 Write16, 231 Write32, 231 Write64, 231 Write8, 231 WriteCustomization, 681, 686, 712 WriteDouble, 231, 232 WriteMsg, 1153 WriteSqlLog, 294 WriteString, 232 WriteText, 1272 Writing values into the string, 1208 WX_APPEND_ARRAY, 48 WX_CLEAR_ARRAY, 49 WX_DECLARE_EXPORTED_OBJARRAY, 48 WX_DECLARE_OBJARRAY, 47 WX_DECLARE_USER_EXPORTED_OBJARRA Y, 48 WX_DEFINE_ARRAY, 46

1757


INDEX
wxAccessible::SetWindow, 30 wxAccessible::wxAccessible, 26 wxActivateEvent, 31 wxActivateEvent::GetActive, 31 wxActivateEvent::GetCapturedWindow, 932 wxActivateEvent::m_active, 31 wxActivateEvent::wxActivateEvent, 30 wxALIGN_CENTRE, 1189 wxALIGN_LEFT, 1188 wxALIGN_RIGHT, 122, 1189 wxALWAYS_SHOW_SB, 1394 wxANIHandler, 733 wxApp, 32 wxApp::~wxApp, 32 wxApp::argc, 32 wxApp::argv, 32 wxApp::CreateLogTarget, 32 wxApp::Dispatch, 32 wxApp::ExitMainLoop, 34 wxApp::FilterEvent, 33 wxApp::GetAppName, 33 wxApp::GetAuto3D, 33 wxApp::GetClassName, 33 wxApp::GetExitOnFrameDelete, 33 wxApp::GetTopWindow, 34 wxApp::GetUseBestVisual, 34 wxApp::GetVendorName, 34 wxApp::HandleEvent, 41 wxApp::MainLoop, 34 wxApp::OnAssert, 35 wxApp::OnCmdLineError, 35 wxApp::OnCmdLineHelp, 36 wxApp::OnCmdLineParsed, 36 wxApp::OnExit, 36 wxApp::OnFatalException, 36 wxApp::OnInit, 37 wxApp::OnInitCmdLine, 37 wxApp::OnQueryEndSession, 37 wxApp::OnRun, 38 wxApp::OnUnhandledException, 38 wxApp::Pending, 39 wxApp::ProcessMessage, 38 wxApp::SendIdleEvents, 39 wxApp::SetAppName, 39 wxApp::SetAuto3D, 39 wxApp::SetClassName, 40 wxApp::SetExitOnFrameDelete, 40 wxApp::SetTopWindow, 40 wxApp::SetUseBestVisual, 41 wxApp::SetVendorName, 41 wxApp::wxApp, 32 wxApp::Yield, 42 wxArray, 49 wxArray copy constructor and assignment operator, 49 wxArray::~wxArray, 49 wxArray::Add, 50 wxArray::Alloc, 50 wxArray::Clear, 50 wxArray::Count, 51 wxArray::Empty, 51 wxArray::GetCount, 51 wxArray::Index, 51 wxArray::Insert, 52 wxArray::IsEmpty, 52 wxArray::Item, 52 wxArray::Last, 52 wxArray::Remove, 52 wxArray::RemoveAt, 53 wxArray::SetCount, 53 wxArray::Shrink, 53 wxArray::Sort, 53 wxArrayString, 55 wxArrayString::~wxArrayString, 55 wxArrayString::Add, 56 wxArrayString::Alloc, 56 wxArrayString::Clear, 56 wxArrayString::Count, 56 wxArrayString::Empty, 57 wxArrayString::GetCount, 57 wxArrayString::Index, 57 wxArrayString::Insert, 57 wxArrayString::IsEmpty, 57 wxArrayString::Item, 58 wxArrayString::Last, 58 wxArrayString::operator!=, 55 wxArrayString::operator[], 56 wxArrayString::operator=, 55 wxArrayString::operator==, 55 wxArrayString::Remove, 58 wxArrayString::RemoveAt, 58 wxArrayString::Shrink, 58 wxArrayString::Sort, 59 wxArrayString::wxArrayString, 55 wxArtProvider::CreateBitmap, 62 wxArtProvider::GetBitmap, 62 wxArtProvider::GetIcon, 63 wxArtProvider::PopProvider, 63 wxArtProvider::PushProvider, 63 wxArtProvider::RemoveProvider, 63 wxASSERT, 1537 wxASSERT_MIN_BITSIZE, 1537 wxASSERT_MSG, 1537 wxAutomationObject, 64 wxAutomationObject::~wxAutomationObject, 64 wxAutomationObject::CallMethod, 64 wxAutomationObject::CreateInstance, 65 wxAutomationObject::GetDispatchPtr, 65 wxAutomationObject::GetInstance, 65 wxAutomationObject::GetObject, 65 wxAutomationObject::GetProperty, 66 wxAutomationObject::Invoke, 66 wxAutomationObject::PutProperty, 67 wxAutomationObject::SetDispatchPtr, 67 wxAutomationObject::wxAutomationObject, 64 wxBeginBusyCursor, 1496 wxBell, 1496 wxBitmap, 68, 69 wxBITMAP, 1506 wxBitmap::~wxBitmap, 71 wxBitmap::AddHandler, 72 wxBitmap::CleanUpHandlers, 72 wxBitmap::ConvertToImage, 72 wxBitmap::CopyFromIcon, 72

1758


INDEX
wxBitmap::Create, 72 wxBitmap::FindHandler, 73 wxBitmap::GetDepth, 74 wxBitmap::GetHandlers, 74 wxBitmap::GetHeight, 74 wxBitmap::GetMask, 75 wxBitmap::GetPalette, 74 wxBitmap::GetSubBitmap, 75 wxBitmap::GetWidth, 75 wxBitmap::InitStandardHandlers, 75 wxBitmap::InsertHandler, 75 wxBitmap::LoadFile, 76 wxBitmap::Ok, 77 wxBitmap::operator !=, 80 wxBitmap::operator =, 79 wxBitmap::operator ==, 80 wxBitmap::RemoveHandler, 77 wxBitmap::SaveFile, 77 wxBitmap::SetDepth, 78 wxBitmap::SetHeight, 78 wxBitmap::SetMask, 78 wxBitmap::SetPalette, 79 wxBitmap::SetWidth, 79 wxBitmap::wxBitmap, 68 wxBITMAP_TYPE_ANI, 735, 742, 746 wxBITMAP_TYPE_ANY, 735, 742 wxBITMAP_TYPE_BMP, 70, 735, 742 wxBITMAP_TYPE_BMP_RESOURCE, 70 wxBITMAP_TYPE_CUR, 213, 735, 742 wxBITMAP_TYPE_CUR_RESOURCE, 213 wxBITMAP_TYPE_GIF, 70, 722, 735, 742 wxBITMAP_TYPE_ICO, 213, 722, 735, 742 wxBITMAP_TYPE_ICO_RESOURCE, 722 wxBITMAP_TYPE_JPEG, 735, 742 wxBITMAP_TYPE_PCX, 735, 742 wxBITMAP_TYPE_PNG, 735, 742 wxBITMAP_TYPE_PNM, 735, 742 wxBITMAP_TYPE_RESOURCE, 70 wxBITMAP_TYPE_TIF, 735, 742 wxBITMAP_TYPE_XBM, 70, 213, 722 wxBITMAP_TYPE_XPM, 70, 722, 735, 742 wxBitmapButton, 81 wxBitmapButton::~wxBitmapButton, 82 wxBitmapButton::Create, 82 wxBitmapButton::GetBitmapDisabled, 83 wxBitmapButton::GetBitmapFocus, 83 wxBitmapButton::GetBitmapLabel, 83 wxBitmapButton::GetBitmapSelected, 83 wxBitmapButton::SetBitmapDisabled, 84 wxBitmapButton::SetBitmapFocus, 84 wxBitmapButton::SetBitmapLabel, 84 wxBitmapButton::SetBitmapSelected, 85 wxBitmapButton::wxBitmapButton, 81 wxBitmapDataObject, 86 wxBitmapDataObject::GetBitmap, 86 wxBitmapDataObject::SetBitmap, 86 wxBitmapHandler, 87 wxBitmapHandler::~wxBitmapHandler, 87 wxBitmapHandler::Create, 87 wxBitmapHandler::GetExtension, 88 wxBitmapHandler::GetName, 88 wxBitmapHandler::GetType, 88 wxBitmapHandler::LoadFile, 88 wxBitmapHandler::SaveFile, 89 wxBitmapHandler::SetExtension, 89 wxBitmapHandler::SetName, 89 wxBitmapHandler::SetType, 90 wxBitmapHandler::wxBitmapHandler, 87 wxBMPHandler, 733 wxBoxSizer, 90 wxBoxSizer::CalcMin, 91 wxBoxSizer::GetOrientation, 91 wxBoxSizer::RecalcSizes, 90 wxBoxSizer::wxBoxSizer, 90 wxBrush, 92 wxBrush::~wxBrush, 93 wxBrush::GetColour, 94 wxBrush::GetStipple, 94 wxBrush::GetStyle, 94 wxBrush::Ok, 95 wxBrush::operator !=, 97 wxBrush::operator =, 96 wxBrush::operator ==, 96 wxBrush::SetColour, 95 wxBrush::SetStipple, 95 wxBrush::SetStyle, 96 wxBrush::wxBrush, 92 wxBrushList, 98 wxBrushList::AddBrush, 98 wxBrushList::FindOrCreateBrush, 98 wxBrushList::RemoveBrush, 98 wxBrushList::wxBrushList, 98 wxBU_AUTODRAW, 81 wxBU_BOTTOM, 81, 105 wxBU_EXACTFIT, 105 wxBU_LEFT, 81, 105 wxBU_RIGHT, 81, 105 wxBU_TOP, 81, 105 wxBufferedDC, 99 wxBufferedDC::~wxBufferedDC, 100 wxBufferedDC::Init, 100 wxBufferedDC::wxBufferedDC, 99 wxBufferedOutputStream, 102 wxBufferedOutputStream::~wxBufferedOutputStr eam, 102 wxBufferedOutputStream::SeekO, 102 wxBufferedOutputStream::Sync, 102 wxBufferedOutputStream::wxBufferedOutputStre am, 102 wxBufferedPaintDC, 101 wxBufferedPaintDC::~wxBufferedPaintDC, 101 wxBufferedPaintDC::wxBufferedPaintDC, 100 wxBusyCursor, 103 wxBusyCursor::~wxBusyCursor, 103 wxBusyCursor::wxBusyCursor, 103 wxBusyInfo, 104 wxBusyInfo::~wxBusyInfo, 104 wxBusyInfo::wxBusyInfo, 104 wxButton, 105 wxButton::~wxButton, 106 wxButton::Create, 106 wxButton::GetDefaultSize, 107 wxButton::GetLabel, 106 wxButton::SetDefault, 107

1759


INDEX
wxButton::SetLabel, 107 wxButton::wxButton, 105 wxCAL_MONDAY_FIRST, 109 wxCAL_NO_MONTH_CHANGE, 109 wxCAL_NO_YEAR_CHANGE, 109 wxCAL_SEQUENTIAL_MONTH_SELECTION, 110 wxCAL_SHOW_HOLIDAYS, 109 wxCAL_SHOW_SURROUNDING_WEEKS, 110 wxCAL_SUNDAY_FIRST, 109 wxCalculateLayoutEvent, 108 wxCalculateLayoutEvent::GetFlags, 108 wxCalculateLayoutEvent::GetRect, 108 wxCalculateLayoutEvent::SetFlags, 108 wxCalculateLayoutEvent::SetRect, 108 wxCalculateLayoutEvent::wxCalculateLayoutEve nt, 108 wxCalendarCtrl, 110, 111 wxCalendarCtrl::~wxCalendarCtrl, 111 wxCalendarCtrl::Create, 111 wxCalendarCtrl::EnableHolidayDisplay, 112 wxCalendarCtrl::EnableMonthChange, 111 wxCalendarCtrl::EnableYearChange, 111 wxCalendarCtrl::GetAttr, 113 wxCalendarCtrl::GetDate, 111 wxCalendarCtrl::GetHeaderColourBg, 112 wxCalendarCtrl::GetHeaderColourFg, 112 wxCalendarCtrl::GetHighlightColourBg, 113 wxCalendarCtrl::GetHighlightColourFg, 112 wxCalendarCtrl::GetHolidayColourBg, 113 wxCalendarCtrl::GetHolidayColourFg, 113 wxCalendarCtrl::HitTest, 114 wxCalendarCtrl::ResetAttr, 114 wxCalendarCtrl::SetAttr, 114 wxCalendarCtrl::SetDate, 111 wxCalendarCtrl::SetHeaderColours, 112 wxCalendarCtrl::SetHighlightColours, 112 wxCalendarCtrl::SetHoliday, 114 wxCalendarCtrl::SetHolidayColours, 113 wxCalendarCtrl::wxCalendarCtrl, 110, 111 wxCalendarDateAttr, 115 wxCalendarDateAttr::GetBackgroundColour, 117 wxCalendarDateAttr::GetBorder, 117 wxCalendarDateAttr::GetBorderColour, 117 wxCalendarDateAttr::GetFont, 117 wxCalendarDateAttr::GetTextColour, 117 wxCalendarDateAttr::HasBackgroundColour, 116 wxCalendarDateAttr::HasBorder, 116 wxCalendarDateAttr::HasBorderColour, 116 wxCalendarDateAttr::HasFont, 116 wxCalendarDateAttr::HasTextColour, 116 wxCalendarDateAttr::IsHoliday, 116 wxCalendarDateAttr::SetBackgroundColour, 115 wxCalendarDateAttr::SetBorder, 116 wxCalendarDateAttr::SetBorderColour, 115 wxCalendarDateAttr::SetFont, 115 wxCalendarDateAttr::SetHoliday, 116 wxCalendarDateAttr::SetTextColour, 115 wxCalendarDateAttr::wxCalendarDateAttr, 115 wxCalendarEvent::GetDate, 117 wxCalendarEvent::GetWeekDay, 118 wxCalendarEvent::SetDate, 118 wxCalendarEvent::SetWeekDay, 118 wxCAPTION, 371, 534, 874, 879, 926 wxCaret, 119 wxCaret::Create, 119 wxCaret::GetBlinkTime, 119 wxCaret::GetPosition, 119 wxCaret::GetSize, 120 wxCaret::GetWindow, 120 wxCaret::Hide, 120 wxCaret::IsOk, 120 wxCaret::IsVisible, 120 wxCaret::Move, 120 wxCaret::SetBlinkTime, 121 wxCaret::SetSize, 121 wxCaret::Show, 121 wxCaret::wxCaret, 119 wxCB_DROPDOWN, 159 wxCB_READONLY, 159 wxCB_SIMPLE, 159 wxCB_SORT, 159 wxCHECK, 1539 wxCHECK_GCC_VERSION, 1472 wxCHECK_MSG, 1539 wxCHECK_RET, 1539 wxCHECK_VERSION, 1472 wxCHECK_W32API_VERSION, 1472 wxCHECK2, 1539 wxCHECK2_MSG, 1539 wxCheckBox, 122 wxCheckBox::~wxCheckBox, 123 wxCheckBox::Create, 123 wxCheckBox::Get3StateValue, 124 wxCheckBox::GetValue, 123 wxCheckBox::Is3rdStateAllowedForUser, 124 wxCheckBox::Is3State, 124 wxCheckBox::IsChecked, 124 wxCheckBox::Set3StateValue, 125 wxCheckBox::SetValue, 124 wxCheckBox::wxCheckBox, 122 wxCheckListBox, 126 wxCheckListBox::~wxCheckListBox, 127 wxCheckListBox::Check, 127 wxCheckListBox::IsChecked, 127 wxCheckListBox::wxCheckListBox, 126 wxCHK_2STATE, 122 wxCHK_3STATE, 122 wxCHK_ALLOW_3RD_STATE_FOR_USER, 122 wxChoice, 128 wxChoice::~wxChoice, 129 wxChoice::Create, 129 wxChoice::Delete, 130 wxChoice::GetColumns, 130 wxChoice::SetColumns, 130 wxChoice::wxChoice, 128 wxClassInfo, 131, 1582 wxClassInfo::CreateObject, 131 wxClassInfo::FindClass, 131 wxClassInfo::GetBaseClassName1, 131 wxClassInfo::GetBaseClassName2, 131 wxClassInfo::GetClassName, 132 wxClassInfo::GetSize, 132 wxClassInfo::InitializeClasses, 132

1760


INDEX
wxClassInfo::IsKindOf, 132 wxClassInfo::wxClassInfo, 131 wxClient, 133 wxClient::MakeConnection, 133 wxClient::OnMakeConnection, 133 wxClient::ValidHost, 134 wxClient::wxClient, 133 wxClientData, 135 wxClientData::~wxClientData, 135 wxClientData::wxClientData, 135 wxClientDataContainer, 136 wxClientDataContainer::~wxClientDataContainer, 136 wxClientDataContainer::GetClientData, 136 wxClientDataContainer::GetClientObject, 136 wxClientDataContainer::SetClientData, 136 wxClientDataContainer::SetClientObject, 136 wxClientDataContainer::wxClientDataContainer, 136 wxClientDC, 134 wxClientDC::wxClientDC, 134 wxClientDisplayRect, 1506 wxCLIP_CHILDREN, 1395 wxClipboard, 137 wxClipboard::~wxClipboard, 138 wxClipboard::AddData, 138 wxClipboard::Clear, 138 wxClipboard::Close, 138 wxClipboard::Flush, 138 wxClipboard::GetData, 138 wxClipboard::IsOpened, 139 wxClipboard::IsSupported, 139 wxClipboard::Open, 139 wxClipboard::SetData, 139 wxClipboard::UsePrimarySelection, 139 wxClipboard::wxClipboard, 137 wxClipboardOpen, 1511 wxCLOSE_BOX, 371, 534, 927 wxCloseClipboard, 1511 wxCloseEvent, 141 wxCloseEvent::CanVeto, 141 wxCloseEvent::GetForce, 141 wxCloseEvent::GetLoggingOff, 141 wxCloseEvent::GetSessionEnding, 141 wxCloseEvent::SetCanVeto, 141 wxCloseEvent::SetForce, 141 wxCloseEvent::SetLoggingOff, 141 wxCloseEvent::Veto, 142 wxCloseEvent::wxCloseEvent, 140 wxCmdLineParser, 146 wxCmdLineParser::~wxCmdLineParser, 147 wxCmdLineParser::AddOption, 149 wxCmdLineParser::AddParam, 149 wxCmdLineParser::AddSwitch, 149 wxCmdLineParser::AreLongOptionsEnabled, 148 wxCmdLineParser::ConvertStringToArgs, 146 wxCmdLineParser::DisableLongOptions, 148 wxCmdLineParser::EnableLongOptions, 147 wxCmdLineParser::Found, 150 wxCmdLineParser::GetParam, 150 wxCmdLineParser::GetParamCount, 150 wxCmdLineParser::Parse, 149 wxCmdLineParser::SetCmdLine, 147 wxCmdLineParser::SetDesc, 148 wxCmdLineParser::SetLogo, 148 wxCmdLineParser::SetSwitchChars, 147 wxCmdLineParser::Usage, 149 wxCmdLineParser::wxCmdLineParser, 146 wxColour, 152 wxColour::Blue, 152 wxColour::GetPixel, 153 wxColour::Green, 153 wxColour::Ok, 153 wxColour::operator !=, 154 wxColour::operator =, 153 wxColour::operator ==, 154 wxColour::Red, 153 wxColour::Set, 153 wxColour::wxColour, 151 wxColourData, 154 wxColourData::~wxColourData, 154 wxColourData::GetChooseFull, 154 wxColourData::GetColour, 155 wxColourData::GetCustomColour, 155 wxColourData::operator =, 156 wxColourData::SetChooseFull, 155 wxColourData::SetColour, 155 wxColourData::SetCustomColour, 155 wxColourData::wxColourData, 154 wxColourDatabase, 156 wxColourDatabase::AddColour, 157 wxColourDatabase::Find, 157 wxColourDatabase::FindColour, 157 wxColourDatabase::FindName, 157 wxColourDatabase::wxColourDatabase, 156 wxColourDialog, 158 wxColourDialog overview, 1658 wxColourDialog::~wxColourDialog, 158 wxColourDialog::Create, 158 wxColourDialog::GetColourData, 158 wxColourDialog::ShowModal, 158 wxColourDialog::wxColourDialog, 158 wxColourDisplay, 1506 wxComboBox, 160 wxComboBox::~wxComboBox, 161 wxComboBox::Copy, 161 wxComboBox::Create, 161 wxComboBox::Cut, 161 wxComboBox::GetInsertionPoint, 161 wxComboBox::GetLastPosition, 162 wxComboBox::GetValue, 162 wxComboBox::Paste, 162 wxComboBox::Remove, 162 wxComboBox::Replace, 162 wxComboBox::SetInsertionPoint, 163 wxComboBox::SetInsertionPointEnd, 163 wxComboBox::SetSelection, 163 wxComboBox::SetValue, 163 wxComboBox::wxComboBox, 160 wxCommand, 164 wxCommand overview, 1666 wxCommand::~wxCommand, 164 wxCommand::CanUndo, 165 wxCommand::Do, 165

1761


INDEX
wxCommand::GetName, 165 wxCommand::Undo, 165 wxCommand::wxCommand, 164 wxCommandEvent, 169 wxCommandEvent::Checked, 169 wxCommandEvent::GetClientData, 170 wxCommandEvent::GetExtraLong, 170 wxCommandEvent::GetInt, 170 wxCommandEvent::GetSelection, 170 wxCommandEvent::GetString, 170 wxCommandEvent::IsChecked, 170 wxCommandEvent::IsSelection, 170 wxCommandEvent::m_clientData, 169 wxCommandEvent::m_commandInt, 169 wxCommandEvent::m_commandString, 169 wxCommandEvent::m_extraLong, 169 wxCommandEvent::SetClientData, 171 wxCommandEvent::SetExtraLong, 171 wxCommandEvent::SetInt, 171 wxCommandEvent::SetString, 171 wxCommandEvent::wxCommandEvent, 169 wxCommandProcessor, 171 wxCommandProcessor overview, 1666 wxCommandProcessor::~wxCommandProcessor , 172 wxCommandProcessor::CanUndo, 172 wxCommandProcessor::ClearCommands, 172 wxCommandProcessor::GetCommands, 172 wxCommandProcessor::GetEditMenu, 172 wxCommandProcessor::GetMaxCommands, 172 wxCommandProcessor::GetRedoAccelerator, 173 wxCommandProcessor::GetRedoMenuLabel, 173 wxCommandProcessor::GetUndoAccelerator, 173 wxCommandProcessor::GetUndoMenuLabel, 173 wxCommandProcessor::Initialize, 173 wxCommandProcessor::Redo, 172 wxCommandProcessor::SetEditMenu, 173 wxCommandProcessor::SetMenuStrings, 173 wxCommandProcessor::SetRedoAccelerator, 174 wxCommandProcessor::SetUndoAccelerator, 174 wxCommandProcessor::Submit, 174 wxCommandProcessor::Undo, 174 wxCommandProcessor::wxCommandProcessor, 171 wxCOMPILE_TIME_ASSERT, 1538 wxCOMPILE_TIME_ASSERT2, 1538 wxCONCAT, 1513 wxConcatFiles, 1485 wxCondition, 176 wxCondition::~wxCondition, 176 wxCondition::Broadcast, 176 wxCondition::IsOk, 177 wxCondition::Signal, 177 wxCondition::Wait, 177 wxCondition::WaitTimeout, 178 wxCondition::wxCondition, 176 wxConfigBase, 184 wxConfigBase::~wxConfigBase, 185 wxConfigBase::Create, 185 wxConfigBase::DeleteAll, 185 wxConfigBase::DeleteEntry, 186 wxConfigBase::DeleteGroup, 186 wxConfigBase::DontCreateOnDemand, 185 wxConfigBase::Exists, 186 wxConfigBase::Flush, 186 wxConfigBase::Get, 186 wxConfigBase::GetAppName, 186 wxConfigBase::GetEntryType, 186 wxConfigBase::GetFirstEntry, 187 wxConfigBase::GetFirstGroup, 187 wxConfigBase::GetNextEntry, 188 wxConfigBase::GetNextGroup, 187 wxConfigBase::GetNumberOfEntries, 188 wxConfigBase::GetNumberOfGroups, 188 wxConfigBase::GetPath, 188 wxConfigBase::GetVendorName, 188 wxConfigBase::HasEntry, 188 wxConfigBase::HasGroup, 188 wxConfigBase::IsExpandingEnvVars, 189 wxConfigBase::IsRecordingDefaults, 189 wxConfigBase::Read, 189 wxConfigBase::RenameEntry, 190 wxConfigBase::RenameGroup, 191 wxConfigBase::Set, 191 wxConfigBase::SetExpandEnvVars, 191 wxConfigBase::SetPath, 191 wxConfigBase::SetRecordDefaults, 191 wxConfigBase::SetUmask, 192 wxConfigBase::Write, 192 wxConfigBase::wxConfigBase, 184 wxConnection, 193 wxConnection::Advise, 194 wxConnection::Disconnect, 194 wxConnection::Execute, 194 wxConnection::OnAdvise, 194 wxConnection::OnDisconnect, 195 wxConnection::OnExecute, 195 wxConnection::OnPoke, 195 wxConnection::OnRequest, 195 wxConnection::OnStartAdvise, 195 wxConnection::OnStopAdvise, 195 wxConnection::Poke, 196 wxConnection::Request, 196 wxConnection::StartAdvise, 196 wxConnection::StopAdvise, 196 wxConnection::wxConnection, 193 wxConstCast, 1526 wxContextHelp, 197 wxContextHelp::~wxContextHelp, 197 wxContextHelp::BeginContextHelp, 197 wxContextHelp::EndContextHelp, 198 wxContextHelp::wxContextHelp, 197 wxContextHelpButton, 198, 199 wxContextHelpButton::wxContextHelpButton, 198 wxControl::Command, 200 wxControl::GetLabel, 200 wxControl::SetLabel, 200

1762


INDEX
wxControlWithItems::Append, 201 wxControlWithItems::Clear, 201 wxControlWithItems::Delete, 201 wxControlWithItems::FindString, 202 wxControlWithItems::GetClientData, 202 wxControlWithItems::GetClientObject, 202 wxControlWithItems::GetCount, 203 wxControlWithItems::GetSelection, 203 wxControlWithItems::GetString, 203 wxControlWithItems::GetStringSelection, 204 wxControlWithItems::Insert, 204 wxControlWithItems::IsEmpty, 205 wxControlWithItems::Number, 205 wxControlWithItems::SetClientData, 205 wxControlWithItems::SetClientObject, 205 wxControlWithItems::SetSelection, 206 wxControlWithItems::SetString, 206 wxControlWithItems::SetStringSelection, 206 wxCopyFile, 1485 wxCountingOutputStream, 207 wxCountingOutputStream::~wxCountingOutputSt ream, 207 wxCountingOutputStream::GetSize, 207 wxCountingOutputStream::wxCountingOutputStr eam, 207 wxCreateDynamicObject, 1526 wxCreateFileTipProvider, 1497 wxCRIT_SECT_DECLARE, 1480 wxCRIT_SECT_DECLARE_MEMBER, 1480 wxCRIT_SECT_LOCKER, 1480 wxCRITICAL_SECTION, 1481 wxCriticalSection, 208 wxCriticalSection::~wxCriticalSection, 208 wxCriticalSection::Enter, 208 wxCriticalSection::Leave, 208 wxCriticalSection::wxCriticalSection, 208 wxCriticalSectionLocker, 209 wxCriticalSectionLocker::~wxCriticalSectionLock er, 210 wxCriticalSectionLocker::wxCriticalSectionLocker , 209 wxCSConv, 210, 1596 wxCSConv::~wxCSConv, 210 wxCSConv::MB2WC, 210 wxCSConv::WC2MB, 211 wxCSConv::wxCSConv, 210 wxCURHandler, 733 wxCurrentTipProvider::GetCurrentTip, 1312 wxCursor, 212 wxCursor::~wxCursor, 216 wxCursor::Ok, 216 wxCursor::operator !=, 216 wxCursor::operator =, 216 wxCursor::operator ==, 216 wxCursor::wxCursor, 212 wxCustomDataObject, 217 wxCustomDataObject::~wxCustomDataObject, 217 wxCustomDataObject::Alloc, 217 wxCustomDataObject::Free, 218 wxCustomDataObject::GetData, 218 wxCustomDataObject::GetSize, 218 wxCustomDataObject::SetData, 218 wxCustomDataObject::TakeData, 218 wxCustomDataObject::wxCustomDataObject, 217 wxDataFormat, 220 wxDataFormat::GetId, 220 wxDataFormat::GetType, 220 wxDataFormat::operator !=, 220 wxDataFormat::operator ==, 220 wxDataFormat::SetId, 220 wxDataFormat::SetType, 221 wxDataFormat::wxDataFormat, 219, 220 wxDataInputStream, 221 wxDataInputStream::~wxDataInputStream, 222 wxDataInputStream::BigEndianOrdered, 222 wxDataInputStream::Read16, 222 wxDataInputStream::Read32, 223 wxDataInputStream::Read64, 223 wxDataInputStream::Read8, 222 wxDataInputStream::ReadDouble, 223 wxDataInputStream::ReadString, 223 wxDataInputStream::wxDataInputStream, 221 wxDataObject, 226 wxDataObject::~wxDataObject, 226 wxDataObject::GetAllFormats, 226 wxDataObject::GetDataHere, 226 wxDataObject::GetDataSize, 226 wxDataObject::GetFormatCount, 226 wxDataObject::GetPreferredFormat, 226 wxDataObject::SetData, 227 wxDataObject::wxDataObject, 226 wxDataObjectComposite, 227 wxDataObjectComposite::Add, 228 wxDataObjectComposite::wxDataObjectComposi te, 227 wxDataObjectSimple, 228 wxDataObjectSimple::GetDataHere, 229 wxDataObjectSimple::GetDataSize, 229 wxDataObjectSimple::GetFormat, 229 wxDataObjectSimple::SetData, 229 wxDataObjectSimple::SetFormat, 229 wxDataObjectSimple::wxDataObjectSimple, 228 wxDataOutputStream, 230 wxDataOutputStream::~wxDataOutputStream, 230 wxDataOutputStream::BigEndianOrdered, 230 wxDataOutputStream::Write16, 231 wxDataOutputStream::Write32, 231 wxDataOutputStream::Write64, 231 wxDataOutputStream::Write8, 231 wxDataOutputStream::WriteDouble, 231 wxDataOutputStream::WriteString, 232 wxDataOutputStream::wxDataOutputStream, 230 wxDateSpan, 233 wxDateSpan::Add, 233 wxDateSpan::Day, 233 wxDateSpan::Days, 233 wxDateSpan::GetDays, 234 wxDateSpan::GetMonths, 234 wxDateSpan::GetTotalDays, 234 wxDateSpan::GetWeeks, 234 wxDateSpan::GetYears, 234

1763


INDEX
wxDateSpan::Month, 235 wxDateSpan::Months, 235 wxDateSpan::Multiply, 235 wxDateSpan::Neg, 235 wxDateSpan::Negate, 235 wxDateSpan::operator!=, 237 wxDateSpan::operator==, 237 wxDateSpan::SetDays, 236 wxDateSpan::SetMonths, 236 wxDateSpan::SetWeeks, 236 wxDateSpan::SetYears, 236 wxDateSpan::Subtract, 236 wxDateSpan::Week, 236 wxDateSpan::Weeks, 237 wxDateSpan::wxDateSpan, 233 wxDateSpan::Year, 237 wxDateSpan::Years, 237 wxDateTime, 249, 250 wxDateTime and Holidays, 1592 wxDateTime characteristics, 1589 wxDateTime::Add, 256 wxDateTime::ConvertYearToBC, 245 wxDateTime::Format, 259 wxDateTime::FormatDate, 259 wxDateTime::FormatISODate, 259 wxDateTime::FormatISOTime, 260 wxDateTime::FormatTime, 259 wxDateTime::GetAmPmStrings, 245 wxDateTime::GetAsDOS, 255 wxDateTime::GetBeginDST, 245 wxDateTime::GetCentury, 246 wxDateTime::GetCountry, 245 wxDateTime::GetCurrentMonth, 246 wxDateTime::GetCurrentYear, 246 wxDateTime::GetDay, 253 wxDateTime::GetDayOfYear, 254 wxDateTime::GetEndDST, 246 wxDateTime::GetHour, 253 wxDateTime::GetJDN, 263 wxDateTime::GetJulianDayNumber, 263 wxDateTime::GetLastMonthDay, 262 wxDateTime::GetLastWeekDay, 261 wxDateTime::GetMillisecond, 253 wxDateTime::GetMinute, 253 wxDateTime::GetMJD, 263 wxDateTime::GetModifiedJulianDayNumber, 263 wxDateTime::GetMonth, 253 wxDateTime::GetMonthName, 246 wxDateTime::GetNextWeekDay, 260 wxDateTime::GetNumberOfDays, 247 wxDateTime::GetPrevWeekDay, 261 wxDateTime::GetRataDie, 263 wxDateTime::GetSecond, 253 wxDateTime::GetTicks, 252 wxDateTime::GetTm, 252 wxDateTime::GetWeek, 262 wxDateTime::GetWeekDay, 253, 261 wxDateTime::GetWeekDayInSameWeek, 260 wxDateTime::GetWeekDayName, 247 wxDateTime::GetWeekOfMonth, 254 wxDateTime::GetWeekOfYear, 254 wxDateTime::GetYear, 253 wxDateTime::GetYearDay, 262 wxDateTime::IsBetween, 255 wxDateTime::IsDST, 264 wxDateTime::IsDSTApplicable, 247 wxDateTime::IsEarlierThan, 255 wxDateTime::IsEqualTo, 255 wxDateTime::IsEqualUpTo, 256 wxDateTime::IsGregorianDate, 254 wxDateTime::IsLaterThan, 255 wxDateTime::IsLeapYear, 247 wxDateTime::IsSameDate, 256 wxDateTime::IsSameTime, 256 wxDateTime::IsStrictlyBetween, 255 wxDateTime::IsValid, 252 wxDateTime::IsWestEuropeanCountry, 247 wxDateTime::IsWorkDay, 254 wxDateTime::MakeGMT, 264 wxDateTime::MakeTimezone, 264 wxDateTime::Now, 248 wxDateTime::operator=, 252 wxDateTime::ParseDate, 258 wxDateTime::ParseDateTime, 258 wxDateTime::ParseFormat, 258 wxDateTime::ParseRfc822Date, 257 wxDateTime::ParseTime, 259 wxDateTime::ResetTime, 251 wxDateTime::Set, 250, 251 wxDateTime::SetCountry, 248 wxDateTime::SetDay, 251 wxDateTime::SetFromDOS, 255 wxDateTime::SetHour, 251 wxDateTime::SetMillisecond, 252 wxDateTime::SetMinute, 251 wxDateTime::SetMonth, 251 wxDateTime::SetSecond, 252 wxDateTime::SetToCurrent, 250 wxDateTime::SetToLastMonthDay, 262 wxDateTime::SetToLastWeekDay, 261 wxDateTime::SetToNextWeekDay, 260 wxDateTime::SetToPrevWeekDay, 260 wxDateTime::SetToTheWeek, 262 wxDateTime::SetToWeekDay, 261 wxDateTime::SetToWeekDayInSameWeek, 260 wxDateTime::SetToYearDay, 262 wxDateTime::SetYear, 251 wxDateTime::Subtract, 257 wxDateTime::Today, 248 wxDateTime::ToGMT, 264 wxDateTime::ToTimezone, 263 wxDateTime::UNow, 248 wxDateTime::wxDateTime, 249 wxDb, 271 wxDb/wxDbTable wxODBC Overview, 1680 wxDb::Catalog, 272 wxDb::Close, 272 wxDb::CommitTrans, 273 wxDb::CreateView, 274 wxDb::Dbms, 275 wxDb::DispAllErrors, 275 wxDb::DispNextError, 276 wxDb::DropView, 277 wxDb::ExecSql, 277

1764


INDEX
wxDb::FwdOnlyCursors, 278 wxDb::GetCatalog, 278 wxDb::GetColumnCount, 278 wxDb::GetColumns, 279 wxDb::GetData, 280 wxDb::GetDatabaseName, 281 wxDb::GetDatasourceName, 281 wxDb::GetHDBC, 282 wxDb::GetHENV, 282 wxDb::GetHSTMT, 282 wxDb::GetKeyFields, 282 wxDb::GetNext, 283 wxDb::GetNextError, 283 wxDb::GetPassword, 283 wxDb::GetTableCount, 284 wxDb::GetUsername, 284 wxDb::Grant, 284 wxDb::IsFwdOnlyCursors, 285 wxDb::IsOpen, 285 wxDb::LogError, 286 wxDb::ModifyColumn, 286 wxDb::Open, 287 wxDb::RollbackTrans, 289 wxDb::SetDebugErrorMessages, 289 wxDb::SetSqlLogging, 290 wxDb::SQLColumnName, 290 wxDb::SQLTableName, 291 wxDb::TableExists, 291 wxDb::TablePrivileges, 292 wxDb::TranslateSqlState, 293 wxDb::WriteSqlLog, 293 wxDb::wxDb, 271 wxDbCloseConnections, 269 wxDbColDef::Initialize, 295 wxDbColFor::Format, 296 wxDbColFor::Initialize, 296 wxDbColInf::Initialize, 297 wxDbConnectInf, 297 wxDbConnectInf::~wxDbConnectInf, 298 wxDbConnectInf::AllocHenv, 299 wxDbConnectInf::FreeHenv, 299 wxDbConnectInf::GetAuthStr, 299 wxDbConnectInf::GetDefaultDir, 299 wxDbConnectInf::GetDescription, 300 wxDbConnectInf::GetDsn, 300 wxDbConnectInf::GetFileType, 300 wxDbConnectInf::GetHenv, 300 wxDbConnectInf::GetPassword, 300 wxDbConnectInf::GetUid, 300 wxDbConnectInf::GetUserID, 300 wxDbConnectInf::Initialize, 299 wxDbConnectInf::SetAuthStr, 301 wxDbConnectInf::SetDefaultDir, 301 wxDbConnectInf::SetDescription, 301 wxDbConnectInf::SetDsn, 301 wxDbConnectInf::SetFileType, 301 wxDbConnectInf::SetHenv, 301 wxDbConnectInf::SetPassword, 302 wxDbConnectInf::SetUid, 302 wxDbConnectInf::SetUserID, 302 wxDbConnectInf::wxDbConnectInf, 297 wxDbConnectionsInUse, 269 wxDbFreeConnection, 270 wxDbGetConnection, 270 wxDbGetDataSource, 271 wxDbGridColInfo, 340 wxDbGridColInfo::~wxDbGridColInfo, 340 wxDbGridColInfo::AddColInfo, 340 wxDbGridColInfo::wxDbGridColInfo, 340 wxDbGridTableBase, 342 wxDbGridTableBase::AssignDbTable, 343 wxDbGridTableBase::UpdateRow, 343 wxDbGridTableBase::ValidateRow, 343 wxDbGridTableBase::wxDbGridTableBase, 342 wxDbInf::Initialize, 303 wxDbLogExtendedErrorMsg, 270 wxDbSqlLog, 271 wxDbTable, 304 wxDbTable::BuildDeleteStmt, 305 wxDbTable::BuildSelectStmt, 305 wxDbTable::BuildUpdateStmt, 306 wxDbTable::BuildWhereStmt, 307 wxDbTable::CanSelectForUpdate, 308 wxDbTable::CanUpdateByROWID, 308 wxDbTable::ClearMemberVar, 309 wxDbTable::ClearMemberVars, 309 wxDbTable::CloseCursor, 310 wxDbTable::Count, 310 wxDbTable::CreateIndex, 311 wxDbTable::CreateTable, 313 wxDbTable::DB_STATUS, 313 wxDbTable::Delete, 313 wxDbTable::DeleteCursor, 314 wxDbTable::DeleteMatching, 314 wxDbTable::DeleteWhere, 315 wxDbTable::DropIndex, 316 wxDbTable::DropTable, 316 wxDbTable::From, 317 wxDbTable::GetColDefs, 317 wxDbTable::GetCursor, 318 wxDbTable::GetDb, 318 wxDbTable::GetFirst, 318 wxDbTable::GetFromClause, 319 wxDbTable::GetLast, 319 wxDbTable::GetNewCursor, 319 wxDbTable::GetNext, 320 wxDbTable::GetNumberOfColumns, 320 wxDbTable::GetOrderByClause, 320 wxDbTable::GetPrev, 320 wxDbTable::GetQueryTableName, 321 wxDbTable::GetRowNum, 321 wxDbTable::GetTableName, 321 wxDbTable::GetTablePath, 322 wxDbTable::GetWhereClause, 322 wxDbTable::Insert, 322 wxDbTable::IsColNull, 323 wxDbTable::IsCursorClosedOnCommit, 323 wxDbTable::IsQueryOnly, 324 wxDbTable::Open, 324 wxDbTable::operator --, 339 wxDbTable::operator ++, 338 wxDbTable::OrderBy, 325 wxDbTable::Query, 325 wxDbTable::QueryBySqlStmt, 327

1765


INDEX
wxDbTable::QueryMatching, 328 wxDbTable::QueryOnKeyFields, 329 wxDbTable::Refresh, 330 wxDbTable::SetColDefs, 331 wxDbTable::SetColNull, 334 wxDbTable::SetCursor, 333 wxDbTable::SetFromClause, 333 wxDbTable::SetOrderByClause, 335 wxDbTable::SetQueryTimeout, 335 wxDbTable::SetWhereClause, 336 wxDbTable::Update, 337 wxDbTable::UpdateWhere, 337 wxDbTable::Where, 338 wxDbTable::wxDbTable, 304, 305 wxDbTableInf::Initialize, 339 wxDC, 351 wxDC::~wxDC, 351 wxDC::BeginDrawing, 351 wxDC::Blit, 351 wxDC::CalcBoundingBox, 353 wxDC::Clear, 353 wxDC::CrossHair, 353 wxDC::DestroyClippingRegion, 354 wxDC::DeviceToLogicalX, 354 wxDC::DeviceToLogicalXRel, 354 wxDC::DeviceToLogicalY, 354 wxDC::DeviceToLogicalYRel, 354 wxDC::DrawArc, 354 wxDC::DrawBitmap, 355 wxDC::DrawCheckMark, 355 wxDC::DrawCircle, 355 wxDC::DrawEllipse, 355 wxDC::DrawEllipticArc, 356 wxDC::DrawIcon, 356 wxDC::DrawLine, 356 wxDC::DrawLines, 356 wxDC::DrawPoint, 357 wxDC::DrawPolygon, 357 wxDC::DrawPolyPolygon, 357 wxDC::DrawRectangle, 357 wxDC::DrawRotatedText, 358 wxDC::DrawRoundedRectangle, 358 wxDC::DrawSpline, 358 wxDC::DrawText, 358 wxDC::EndDoc, 359 wxDC::EndDrawing, 359 wxDC::EndPage, 359 wxDC::FloodFill, 359 wxDC::GetBackground, 360 wxDC::GetBackgroundMode, 360 wxDC::GetBrush, 360 wxDC::GetCharHeight, 360 wxDC::GetCharWidth, 360 wxDC::GetClippingBox, 360 wxDC::GetFont, 361 wxDC::GetLogicalFunction, 361 wxDC::GetMapMode, 361 wxDC::GetOptimization, 361 wxDC::GetPartialTextExtents, 361 wxDC::GetPen, 361 wxDC::GetPixel, 362 wxDC::GetSize, 362 wxDC::GetTextBackground, 363 wxDC::GetTextExtent, 363 wxDC::GetTextForeground, 363 wxDC::GetUserScale, 363 wxDC::LogicalToDeviceX, 364 wxDC::LogicalToDeviceXRel, 364 wxDC::LogicalToDeviceY, 364 wxDC::LogicalToDeviceYRel, 364 wxDC::MaxX, 364 wxDC::MaxY, 364 wxDC::MinX, 365 wxDC::MinY, 365 wxDC::Ok, 365 wxDC::ResetBoundingBox, 365 wxDC::SetAxisOrientation, 365 wxDC::SetBackground, 366 wxDC::SetBackgroundMode, 366 wxDC::SetBrush, 367 wxDC::SetClippingRegion, 366 wxDC::SetDeviceOrigin, 366 wxDC::SetFont, 367 wxDC::SetLogicalFunction, 367 wxDC::SetMapMode, 368 wxDC::SetOptimization, 368 wxDC::SetPalette, 366 wxDC::SetPen, 369 wxDC::SetTextBackground, 369 wxDC::SetTextForeground, 369 wxDC::SetUserScale, 369 wxDC::StartDoc, 369 wxDC::StartPage, 369 wxDC::wxDC, 351 wxDCClipper, 370 wxDCClipper::~wxDCClipper, 370 wxDCClipper::wxDCClipper, 370 wxDD_NEW_DIR_BUTTON, 387 wxDDECleanUp, 1515 wxDDEInitialize, 1515 WXDEBUG_NEW, 1526 wxDebugContext overview, 1609 wxDebugContext::Check, 344 wxDebugContext::Dump, 344 wxDebugContext::GetCheckPrevious, 345 wxDebugContext::GetDebugMode, 345 wxDebugContext::GetLevel, 345 wxDebugContext::GetStream, 345 wxDebugContext::GetStreamBuf, 346 wxDebugContext::HasStream, 346 wxDebugContext::PrintClasses, 346 wxDebugContext::PrintStatistics, 346 wxDebugContext::SetCheckpoint, 347 wxDebugContext::SetCheckPrevious, 347 wxDebugContext::SetDebugMode, 347 wxDebugContext::SetFile, 347 wxDebugContext::SetLevel, 348 wxDebugContext::SetStandardError, 348 wxDebugContext::SetStream, 348 wxDebugMsg, 1528 wxDEFAULT_DIALOG_STYLE, 371 wxDEFAULT_FRAME_STYLE, 534, 874, 879, 926 wxDelegateRendererNative, 350

1766


INDEX
wxDelegateRendererNative::DrawXXX, 350 wxDelegateRendererNative::wxDelegateRendere rNative, 350 wxDialog, 372 wxDialog::~wxDialog, 373 wxDialog::Centre, 373 wxDialog::Create, 373 wxDialog::EndModal, 374 wxDialog::GetReturnCode, 374 wxDialog::GetTitle, 374 wxDialog::Iconize, 374 wxDialog::IsIconized, 375 wxDialog::IsModal, 375 wxDialog::OnApply, 375 wxDialog::OnCancel, 376 wxDialog::OnCharHook, 375 wxDialog::OnOK, 376 wxDialog::OnSysColourChanged, 376 wxDialog::SetIcon, 377 wxDialog::SetIcons, 377 wxDialog::SetModal, 377 wxDialog::SetReturnCode, 378 wxDialog::SetTitle, 378 wxDialog::Show, 378 wxDialog::ShowModal, 379 wxDialog::wxDialog, 372 wxDIALOG_EX_CONTEXTHELP, 372 wxDIALOG_NO_PARENT, 372 wxDialUpEvent, 379 wxDialUpEvent::IsConnectedEvent, 379 wxDialUpEvent::IsOwnEvent, 379 wxDialUpEvent::wxDialUpEvent, 379 wxDialUpManager::~wxDialUpManager, 381 wxDialUpManager::CancelDialing, 382 wxDialUpManager::Create, 380 wxDialUpManager::Dial, 381 wxDialUpManager::DisableAutoCheckOnlineStat us, 383 wxDialUpManager::EnableAutoCheckOnlineStatu s, 383 wxDialUpManager::GetISPNames, 381 wxDialUpManager::HangUp, 382 wxDialUpManager::IsAlwaysOnline, 382 wxDialUpManager::IsDialing, 381 wxDialUpManager::IsOk, 380 wxDialUpManager::IsOnline, 382 wxDialUpManager::SetConnectCommand, 383 wxDialUpManager::SetOnlineStatus, 382 wxDialUpManager::SetWellKnownHost, 383 wxDir, 385 wxDir::~wxDir, 385 wxDir::Exists, 385 wxDir::GetAllFiles, 385 wxDir::GetFirst, 385 wxDir::GetName, 386 wxDir::GetNext, 386 wxDir::HasFiles, 386 wxDir::HasSubDirs, 386 wxDir::IsOpened, 386 wxDir::Open, 386 wxDir::Traverse, 386 wxDir::wxDir, 385 wxDIRCTRL_3D_INTERNAL, 564 wxDIRCTRL_DIR_ONLY, 564 wxDIRCTRL_EDIT_LABELS, 564 wxDIRCTRL_SELECT_FIRST, 564 wxDIRCTRL_SHOW_FILTERS, 564 wxDirDialog, 387 wxDirDialog overview, 1661 wxDirDialog::~wxDirDialog, 388 wxDirDialog::GetMessage, 388 wxDirDialog::GetPath, 388 wxDirDialog::GetStyle, 389 wxDirDialog::SetMessage, 389 wxDirDialog::SetPath, 389 wxDirDialog::SetStyle, 389 wxDirDialog::ShowModal, 389 wxDirDialog::wxDirDialog, 387 wxDirExists, 1483 wxDirSelector, 1497 wxDirTraverser::OnDir, 390 wxDirTraverser::OnFile, 390 wxDisplay, 391 wxDisplay::~wxDisplay, 391 wxDisplay::GetCount, 392 wxDisplay::GetDepth, 392 wxDisplay::GetFromPoint, 392 wxDisplay::GetGeometry, 392 wxDisplay::GetName, 392 wxDisplay::IsColor, 393 wxDisplay::IsColour, 392 wxDisplay::IsPrimary, 393 wxDisplay::wxDisplay, 391 wxDisplayDepth, 1506 wxDisplaySize, 1506 wxDisplaySizeMM, 1507 wxDllLoader::GetDllExt, 394 wxDllLoader::GetProgramHandle, 394 wxDllLoader::GetSymbol, 394 wxDllLoader::LoadLibrary, 395 wxDllLoader::UnloadLibrary, 395 wxDocChildFrame, 396 wxDocChildFrame::~wxDocChildFrame, 396 wxDocChildFrame::GetDocument, 396 wxDocChildFrame::GetView, 397 wxDocChildFrame::m_childDocument, 396 wxDocChildFrame::m_childView, 396 wxDocChildFrame::OnActivate, 397 wxDocChildFrame::OnCloseWindow, 397 wxDocChildFrame::SetDocument, 397 wxDocChildFrame::SetView, 397 wxDocChildFrame::wxDocChildFrame, 396 wxDocManager, 399 wxDocManager overview, 1665 wxDocManager::~wxDocManager, 399 wxDocManager::ActivateView, 399 wxDocManager::AddDocument, 399 wxDocManager::AddFileToHistory, 399 wxDocManager::AssociateTemplate, 400 wxDocManager::CloseDocuments, 400 wxDocManager::CreateDocument, 400 wxDocManager::CreateView, 400 wxDocManager::DisassociateTemplate, 400 wxDocManager::FileHistoryAddFilesToMenu,

1767


INDEX
401 wxDocManager::FileHistoryLoad, 401 wxDocManager::FileHistoryRemoveMenu, 401 wxDocManager::FileHistorySave, 401 wxDocManager::FileHistoryUseMenu, 401 wxDocManager::FindTemplateForPath, 402 wxDocManager::GetCurrentDocument, 402 wxDocManager::GetCurrentView, 402 wxDocManager::GetDocuments, 402 wxDocManager::GetFileHistory, 402 wxDocManager::GetHistoryFilesCount, 402 wxDocManager::GetLastDirectory, 402 wxDocManager::GetMaxDocsOpen, 402 wxDocManager::Initialize, 403 wxDocManager::m_currentView, 398 wxDocManager::m_defaultDocumentNameCount er, 398 wxDocManager::m_docs, 398 wxDocManager::m_fileHistory, 398 wxDocManager::m_flags, 398 wxDocManager::m_lastDirectory, 398 wxDocManager::m_maxDocsOpen, 398 wxDocManager::m_templates, 399 wxDocManager::MakeDefaultName, 403 wxDocManager::OnCreateFileHistory, 403 wxDocManager::OnFileClose, 403 wxDocManager::OnFileCloseAll, 403 wxDocManager::OnFileNew, 404 wxDocManager::OnFileOpen, 404 wxDocManager::OnFileSave, 404 wxDocManager::OnFileSaveAs, 404 wxDocManager::OnMenuCommand, 404 wxDocManager::RemoveDocument, 405 wxDocManager::SelectDocumentPath, 405 wxDocManager::SelectDocumentType, 405 wxDocManager::SelectViewType, 406 wxDocManager::SetLastDirectory, 406 wxDocManager::SetMaxDocsOpen, 406 wxDocManager::wxDocManager, 399 wxDocMDIChildFrame, 407 wxDocMDIChildFrame::~wxDocMDIChildFrame, 407 wxDocMDIChildFrame::GetDocument, 408 wxDocMDIChildFrame::GetView, 408 wxDocMDIChildFrame::m_childDocument, 407 wxDocMDIChildFrame::m_childView, 407 wxDocMDIChildFrame::OnActivate, 408 wxDocMDIChildFrame::OnCloseWindow, 408 wxDocMDIChildFrame::SetDocument, 408 wxDocMDIChildFrame::SetView, 408 wxDocMDIChildFrame::wxDocMDIChildFrame, 407 wxDocMDIParentFrame::~wxDocMDIParentFram e, 409 wxDocMDIParentFrame::OnCloseWindow, 409 wxDocMDIParentFrame::wxDocMDIParentFrame , 409 wxDocParentFrame, 409, 410 wxDocParentFrame::~wxDocParentFrame, 410 wxDocParentFrame::OnCloseWindow, 410 wxDocParentFrame::wxDocParentFrame, 410 wxDocTemplate, 413 wxDocTemplate overview, 1665 wxDocTemplate::~wxDocTemplate, 414 wxDocTemplate::CreateDocument, 414 wxDocTemplate::CreateView, 414 wxDocTemplate::GetDefaultExtension, 414 wxDocTemplate::GetDescription, 414 wxDocTemplate::GetDirectory, 415 wxDocTemplate::GetDocumentManager, 415 wxDocTemplate::GetDocumentName, 415 wxDocTemplate::GetFileFilter, 415 wxDocTemplate::GetFlags, 415 wxDocTemplate::GetViewName, 415 wxDocTemplate::IsVisible, 415 wxDocTemplate::m_defaultExt, 411 wxDocTemplate::m_description, 411 wxDocTemplate::m_directory, 411 wxDocTemplate::m_docClassInfo, 412 wxDocTemplate::m_docTypeName, 412 wxDocTemplate::m_documentManager, 412 wxDocTemplate::m_fileFilter, 412 wxDocTemplate::m_flags, 412 wxDocTemplate::m_viewClassInfo, 412 wxDocTemplate::m_viewTypeName, 412 wxDocTemplate::SetDefaultExtension, 416 wxDocTemplate::SetDescription, 416 wxDocTemplate::SetDirectory, 416 wxDocTemplate::SetDocumentManager, 416 wxDocTemplate::SetFileFilter, 416 wxDocTemplate::SetFlags, 416 wxDocTemplate::wxDocTemplate, 413 wxDocument, 418 wxDocument overview, 1663 wxDocument::~wxDocument, 418 wxDocument::AddView, 418 wxDocument::Close, 418 wxDocument::DeleteAllViews, 418 wxDocument::GetCommandProcessor, 419 wxDocument::GetDocumentManager, 419 wxDocument::GetDocumentName, 419 wxDocument::GetDocumentTemplate, 419 wxDocument::GetDocumentWindow, 419 wxDocument::GetFilename, 419 wxDocument::GetFirstView, 419 wxDocument::GetPrintableName, 420 wxDocument::GetTitle, 420 wxDocument::GetViews, 420 wxDocument::IsModified, 420 wxDocument::LoadObject, 420 wxDocument::m_commandProcessor, 417 wxDocument::m_documentFile, 417 wxDocument::m_documentModified, 417 wxDocument::m_documentTemplate, 417 wxDocument::m_documentTitle, 417 wxDocument::m_documentTypeName, 417 wxDocument::m_documentViews, 418 wxDocument::Modify, 421 wxDocument::OnChangedViewList, 421 wxDocument::OnCloseDocument, 421 wxDocument::OnCreate, 421 wxDocument::OnCreateCommandProcessor, 421 wxDocument::OnNewDocument, 422

1768


INDEX
wxDocument::OnOpenDocument, 422 wxDocument::OnSaveDocument, 422 wxDocument::OnSaveModified, 422 wxDocument::RemoveView, 422 wxDocument::Save, 422 wxDocument::SaveAs, 423 wxDocument::SaveObject, 423 wxDocument::SetCommandProcessor, 423 wxDocument::SetDocumentName, 423 wxDocument::SetDocumentTemplate, 423 wxDocument::SetFilename, 423 wxDocument::SetTitle, 424 wxDocument::UpdateAllViews, 424 wxDocument::wxDocument, 418 wxDos2UnixFilename, 1483 wxDOUBLE_BORDER, 1394 wxDragImage, 425 wxDragImage::BeginDrag, 426 wxDragImage::DoDrawImage, 427 wxDragImage::EndDrag, 427 wxDragImage::GetImageRect, 427 wxDragImage::Hide, 428 wxDragImage::Move, 428 wxDragImage::Show, 428 wxDragImage::UpdateBackingFromWindow, 428 wxDragImage::wxDragImage, 425 wxDragResult, 430, 433 wxDROP_ICON, 1507 wxDropFilesEvent, 429 wxDropFilesEvent::GetFiles, 430 wxDropFilesEvent::GetNumberOfFiles, 430 wxDropFilesEvent::GetPosition, 430 wxDropFilesEvent::m_files, 429 wxDropFilesEvent::m_noFiles, 429 wxDropFilesEvent::m_pos, 429 wxDropFilesEvent::wxDropFilesEvent, 429 wxDropSource, 431 wxDropSource::~wxDropSource, 431 wxDropSource::DoDragDrop, 432 wxDropSource::GiveFeedback, 432 wxDropSource::SetData, 432 wxDropSource::wxDropSource, 431 wxDropTarget, 433 wxDropTarget::~wxDropTarget, 433 wxDropTarget::GetData, 434 wxDropTarget::OnData, 434 wxDropTarget::OnDragOver, 435 wxDropTarget::OnDrop, 434 wxDropTarget::OnEnter, 434 wxDropTarget::OnLeave, 435 wxDropTarget::SetDataObject, 435 wxDropTarget::wxDropTarget, 433 wxDynamicCast, 1527 wxDynamicCastThis, 1527 wxDynamicLibrary, 436 wxDynamicLibrary::CanonicalizeName, 436 wxDynamicLibrary::CanonicalizePluginName, 436 wxDynamicLibrary::Detach, 437 wxDynamicLibrary::GetSymbol, 437 wxDynamicLibrary::IsLoaded, 437 wxDynamicLibrary::Load, 437 wxDynamicLibrary::Unload, 438 wxDynamicLibrary::wxDynamicLibrary, 436 wxDYNLIB_FUNCTION, 1513 wxEdge, 763 wxEmptyClipboard, 1511 wxEnableTopLevelWindow, 1515 wxEncodingConverter, 438 wxEncodingConverter::CanConvert, 439 wxEncodingConverter::Convert, 439 wxEncodingConverter::GetAllEquivalents, 441 wxEncodingConverter::GetPlatformEquivalents, 440 wxEncodingConverter::Init, 439 wxEncodingConverter::wxEncodingConverter, 438 wxEndBusyCursor, 1498 wxENTER_CRIT_SECT, 1481 wxEntry, 1473 wxEnumClipboardFormats, 1511 wxEraseEvent, 442 wxEraseEvent::GetDC, 442 wxEraseEvent::m_dc, 442 wxEraseEvent::wxEraseEvent, 442 wxError, 1528 wxEvent, 443 wxEvent::Clone, 444 wxEvent::GetEventObject, 444 wxEvent::GetEventType, 444 wxEvent::GetId, 444 wxEvent::GetSkipped, 445 wxEvent::GetTimestamp, 445 wxEvent::IsCommandEvent, 445 wxEvent::m_eventObject, 443 wxEvent::m_eventType, 443 wxEvent::m_id, 443 wxEvent::m_propagationLevel, 443 wxEvent::m_skipped, 444 wxEvent::m_timeStamp, 444 wxEvent::ResumePropagation, 445 wxEvent::SetEventObject, 445 wxEvent::SetEventType, 445 wxEvent::SetId, 445 wxEvent::SetTimestamp, 446 wxEvent::ShouldPropagate, 446 wxEvent::Skip, 446 wxEvent::StopPropagation, 446 wxEvent::widthSash, 1181 wxEvent::wxEvent, 443 wxEvtHandler, 447 wxEvtHandler::~wxEvtHandler, 447 wxEvtHandler::AddPendingEvent, 447 wxEvtHandler::Connect, 448 wxEvtHandler::Disconnect, 448 wxEvtHandler::GetClientData, 449 wxEvtHandler::GetClientObject, 450 wxEvtHandler::GetEvtHandlerEnabled, 450 wxEvtHandler::GetNextHandler, 450 wxEvtHandler::GetPreviousHandler, 450 wxEvtHandler::ProcessEvent, 451 wxEvtHandler::SearchEventTable, 452 wxEvtHandler::SetClientData, 452 wxEvtHandler::SetClientObject, 453

1769


INDEX
wxEvtHandler::SetEvtHandlerEnabled, 453 wxEvtHandler::SetNextHandler, 453 wxEvtHandler::SetPreviousHandler, 454 wxEvtHandler::wxEvtHandler, 447 wxExecute, 1476 wxExit, 1478 wxEXPLICIT, 1513 wxFAIL, 1538 wxFAIL_MSG, 1538 wxFatalError, 1529 wxFFile, 455 wxFFile::~wxFFile, 455 wxFFile::Attach, 455 wxFFile::Close, 456 wxFFile::Detach, 456 wxFFile::Eof, 456 wxFFile::Error, 456 wxFFile::Flush, 457 wxFFile::fp, 456 wxFFile::IsOpened, 457 wxFFile::Length, 457 wxFFile::Open, 457 wxFFile::Read, 457 wxFFile::Seek, 458 wxFFile::SeekEnd, 458 wxFFile::Tell, 458 wxFFile::Write, 458, 459 wxFFile::wxFFile, 455 wxFFileInputStream, 460 wxFFileInputStream::~wxFFileInputStream, 460 wxFFileInputStream::Ok, 460 wxFFileInputStream::wxFFileInputStream, 459 wxFFileOutputStream, 461 wxFFileOutputStream::~wxFFileOutputStream, 461 wxFFileOutputStream::Ok, 461 wxFFileOutputStream::wxFFileOutputStream, 461 wxFFileStream, 461 wxFFileStream::wxFFileStream, 461 wxFile, 463 wxFile::~wxFile, 464 wxFile::Access, 464 wxFile::Attach, 464 wxFile::Close, 464 wxFile::Create, 464 wxFile::Detach, 465 wxFile::Eof, 465 wxFile::Exists, 465 wxFile::fd, 465 wxFile::Flush, 465 wxFile::IsOpened, 465 wxFile::Length, 466 wxFile::Open, 466 wxFile::Read, 466 wxFile::Seek, 466 wxFile::SeekEnd, 467 wxFile::Tell, 467 wxFile::Write, 467, 468 wxFile::wxFile, 463 wxFileDataObject, 469 wxFileDataObject::AddFile, 469 wxFileDataObject::GetFilenames, 469 wxFileDialog, 470 wxFileDialog overview, 1660 wxFileDialog::~wxFileDialog, 471 wxFileDialog::GetDirectory, 471 wxFileDialog::GetFilename, 471 wxFileDialog::GetFilenames, 471 wxFileDialog::GetFilterIndex, 472 wxFileDialog::GetMessage, 472 wxFileDialog::GetPath, 472 wxFileDialog::GetPaths, 472 wxFileDialog::GetStyle, 472 wxFileDialog::GetWildcard, 472 wxFileDialog::SetDirectory, 472 wxFileDialog::SetFilename, 473 wxFileDialog::SetFilterIndex, 473 wxFileDialog::SetMessage, 473 wxFileDialog::SetPath, 473 wxFileDialog::SetStyle, 473 wxFileDialog::SetWildcard, 473 wxFileDialog::ShowModal, 473 wxFileDialog::wxFileDialog, 470 wxFileDropTarget, 474 wxFileDropTarget::OnDrop, 474 wxFileDropTarget::OnDropFiles, 474 wxFileDropTarget::wxFileDropTarget, 474 wxFileExists, 1483 wxFileHistory, 476 wxFileHistory overview, 1667 wxFileHistory::~wxFileHistory, 476 wxFileHistory::AddFilesToMenu, 476 wxFileHistory::AddFileToHistory, 476 wxFileHistory::GetHistoryFile, 476 wxFileHistory::GetMaxFiles, 477 wxFileHistory::GetNoHistoryFiles, 477 wxFileHistory::Load, 477 wxFileHistory::m_fileHistory, 475 wxFileHistory::m_fileHistoryN, 475 wxFileHistory::m_fileMaxFiles, 475 wxFileHistory::m_fileMenu, 476 wxFileHistory::RemoveMenu, 477 wxFileHistory::Save, 477 wxFileHistory::UseMenu, 477 wxFileHistory::wxFileHistory, 476 wxFileInputStream, 478 wxFileInputStream::~wxFileInputStream, 478 wxFileInputStream::Ok, 478 wxFileInputStream::wxFileInputStream, 478 wxFileModificationTime, 1483 wxFileName, 481 wxFileName::AppendDir, 482 wxFileName::Assign, 482 wxFileName::AssignCwd, 482 wxFileName::AssignDir, 482 wxFileName::AssignHomeDir, 482 wxFileName::AssignTempFileName, 483 wxFileName::Clear, 483 wxFileName::CreateTempFileName, 483 wxFileName::DirExists, 484 wxFileName::DirName, 484 wxFileName::FileExists, 484 wxFileName::FileName, 484

1770


INDEX
wxFileName::GetCwd, 484 wxFileName::GetDirCount, 485 wxFileName::GetDirs, 485 wxFileName::GetExt, 485 wxFileName::GetForbiddenChars, 485 wxFileName::GetFormat, 485 wxFileName::GetFullName, 485 wxFileName::GetFullPath, 485 wxFileName::GetHomeDir, 486 wxFileName::GetLongPath, 486 wxFileName::GetModificationTime, 486 wxFileName::GetName, 486 wxFileName::GetPath, 486 wxFileName::GetPathSeparator, 486 wxFileName::GetPathSeparators, 487 wxFileName::GetShortPath, 487 wxFileName::GetTimes, 487 wxFileName::GetVolume, 487 wxFileName::GetVolumeSeparator, 488 wxFileName::HasExt, 488 wxFileName::HasName, 488 wxFileName::HasVolume, 488 wxFileName::InsertDir, 488 wxFileName::IsAbsolute, 488 wxFileName::IsCaseSensitive, 488 wxFileName::IsDir, 489 wxFileName::IsOk, 488 wxFileName::IsPathSeparator, 489 wxFileName::IsRelative, 489 wxFileName::MakeAbsolute, 489 wxFileName::MakeRelativeTo, 489 wxFileName::Mkdir, 490 wxFileName::Normalize, 490 wxFileName::operator!=, 493 wxFileName::operator=, 493 wxFileName::operator==, 493 wxFileName::PrependDir, 491 wxFileName::RemoveDir, 491 wxFileName::Rmdir, 491 wxFileName::SameAs, 491 wxFileName::SetCwd, 492 wxFileName::SetExt, 492 wxFileName::SetFullName, 492 wxFileName::SetName, 492 wxFileName::SetTimes, 492 wxFileName::SetVolume, 492 wxFileName::SplitPath, 493 wxFileName::Touch, 493 wxFileName::wxFileName, 481 wxFileNameFromPath, 1483 wxFileOutputStream, 494 wxFileOutputStream::~wxFileOutputStream, 494 wxFileOutputStream::Ok, 495 wxFileOutputStream::wxFileOutputStream, 494 wxFileSelector, 1498 wxFileStream, 495 wxFileStream::wxFileStream, 495 wxFileSystem, 496 wxFileSystem::AddHandler, 496 wxFileSystem::ChangePathTo, 496 wxFileSystem::FileNameToURL, 497 wxFileSystem::FindFirst, 497 wxFileSystem::FindNext, 497 wxFileSystem::GetPath, 496 wxFileSystem::OpenFile, 497 wxFileSystem::URLToFileName, 497 wxFileSystem::wxFileSystem, 495 wxFileSystemHandler, 498 wxFileSystemHandler::CanOpen, 498 wxFileSystemHandler::FindFirst, 500 wxFileSystemHandler::FindNext, 500 wxFileSystemHandler::GetAnchor, 499 wxFileSystemHandler::GetLeftLocation, 499 wxFileSystemHandler::GetMimeTypeFromExt, 499 wxFileSystemHandler::GetProtocol, 499 wxFileSystemHandler::GetRightLocation, 499 wxFileSystemHandler::OpenFile, 500 wxFileSystemHandler::wxFileSystemHandler, 498 wxFileType, 502 wxFileType::~wxFileType, 502 wxFileType::ExpandCommand, 504 wxFileType::GetDescription, 503 wxFileType::GetExtensions, 503 wxFileType::GetIcon, 503 wxFileType::GetMimeType, 502 wxFileType::GetMimeTypes, 503 wxFileType::GetOpenCommand, 503 wxFileType::GetPrintCommand, 504 wxFileType::wxFileType, 502 wxFilterInputStream, 505 wxFilterInputStream::wxFilterInputStream, 505 wxFilterOutputStream, 505 wxFilterOutputStream::wxFilterOutputStream, 505 wxFindDialogEvent, 506 wxFindDialogEvent::GetDialog, 507 wxFindDialogEvent::GetFindString, 506 wxFindDialogEvent::GetFlags, 506 wxFindDialogEvent::GetReplaceString, 507 wxFindDialogEvent::wxFindDialogEvent, 506 wxFindFirstFile, 1483 wxFindMenuItemId, 1516 wxFindNextFile, 1484 wxFindReplaceData, 508 wxFindReplaceData::GetFindString, 508 wxFindReplaceData::GetFlags, 508 wxFindReplaceData::GetReplaceString, 508 wxFindReplaceData::SetFindString, 508 wxFindReplaceData::SetFlags, 508 wxFindReplaceData::SetReplaceString, 509 wxFindReplaceData::wxFindReplaceData, 508 wxFindReplaceDialog, 509 wxFindReplaceDialog::~wxFindReplaceDialog, 509 wxFindReplaceDialog::Create, 510 wxFindReplaceDialog::GetData, 510 wxFindReplaceDialog::wxFindReplaceDialog, 509 wxFindWindowAtPoint, 1516 wxFindWindowAtPointer, 1517 wxFindWindowByLabel, 1516 wxFindWindowByName, 1516

1771


INDEX
wxFinite, 1505 wxFlexGridSizer, 510 wxFlexGridSizer::AddGrowableCol, 511 wxFlexGridSizer::AddGrowableRow, 511 wxFlexGridSizer::GetFlexibleDirection, 511 wxFlexGridSizer::GetNonFlexibleGrowMode, 511 wxFlexGridSizer::RemoveGrowableCol, 512 wxFlexGridSizer::RemoveGrowableRow, 512 wxFlexGridSizer::SetFlexibleDirection, 512 wxFlexGridSizer::SetNonFlexibleGrowMode, 512 wxFlexGridSizer::wxFlexGridSizer, 510 wxFocusEvent, 513 wxFocusEvent::wxFocusEvent, 513 wxFont, 515, 516 wxFont::~wxFont, 517 wxFont::GetDefaultEncoding, 517 wxFont::GetFaceName, 518 wxFont::GetFamily, 518 wxFont::GetNativeFontInfoDesc, 518 wxFont::GetPointSize, 518 wxFont::GetStyle, 519 wxFont::GetUnderlined, 519 wxFont::GetWeight, 519 wxFont::IsFixedWidth, 517 wxFont::Ok, 519 wxFont::operator !=, 522 wxFont::operator =, 522 wxFont::operator ==, 522 wxFont::SetDefaultEncoding, 519 wxFont::SetFaceName, 519 wxFont::SetFamily, 520 wxFont::SetNativeFontInfo, 520 wxFont::SetPointSize, 521 wxFont::SetStyle, 521 wxFont::SetUnderlined, 521 wxFont::SetWeight, 522 wxFont::wxFont, 515 wxFontData, 523 wxFontData::~wxFontData, 523 wxFontData::EnableEffects, 523 wxFontData::GetAllowSymbols, 523 wxFontData::GetChosenFont, 524 wxFontData::GetColour, 523 wxFontData::GetEnableEffects, 524 wxFontData::GetInitialFont, 524 wxFontData::GetShowHelp, 524 wxFontData::operator =, 525 wxFontData::SetAllowSymbols, 524 wxFontData::SetChosenFont, 524 wxFontData::SetColour, 525 wxFontData::SetInitialFont, 525 wxFontData::SetRange, 525 wxFontData::SetShowHelp, 525 wxFontData::wxFontData, 523 wxFontDialog, 526 wxFontDialog overview, 1659 wxFontDialog::~wxFontDialog, 526 wxFontDialog::Create, 526 wxFontDialog::GetFontData, 526 wxFontDialog::ShowModal, 527 wxFontDialog::wxFontDialog, 526 wxFontEnumerator::EnumerateEncodings, 528 wxFontEnumerator::EnumerateFacenames, 527 wxFontEnumerator::GetEncodings, 528 wxFontEnumerator::GetFacenames, 528 wxFontEnumerator::OnFacename, 528 wxFontEnumerator::OnFontEncoding, 528 wxFontList, 529 wxFontList::AddFont, 529 wxFontList::FindOrCreateFont, 529 wxFontList::RemoveFont, 529 wxFontList::wxFontList, 529 wxFontMapper, 531 wxFontMapper::~wxFontMapper, 531 wxFontMapper::CharsetToEncoding, 532 wxFontMapper::Get, 531 wxFontMapper::GetAltForEncoding, 531 wxFontMapper::GetEncoding, 532 wxFontMapper::GetEncodingDescription, 532 wxFontMapper::GetEncodingName, 532 wxFontMapper::GetSupportedEncodingsCount, 532 wxFontMapper::IsEncodingAvailable, 531 wxFontMapper::Set, 533 wxFontMapper::SetConfig, 533 wxFontMapper::SetConfigPath, 533 wxFontMapper::SetDialogParent, 532 wxFontMapper::SetDialogTitle, 532 wxFontMapper::wxFontMapper, 531 wxFrame, 535 wxFrame::~wxFrame, 536 wxFrame::Centre, 536 wxFrame::Command, 537 wxFrame::Create, 537 wxFrame::CreateStatusBar, 537 wxFrame::CreateToolBar, 538 wxFrame::GetClientAreaOrigin, 539 wxFrame::GetMenuBar, 539 wxFrame::GetStatusBar, 539 wxFrame::GetStatusBarPane, 539 wxFrame::GetTitle, 539 wxFrame::GetToolBar, 540 wxFrame::Iconize, 540 wxFrame::IsFullScreen, 540 wxFrame::IsIconized, 540 wxFrame::IsMaximized, 540 wxFrame::Maximize, 541 wxFrame::OnCreateStatusBar, 541 wxFrame::OnCreateToolBar, 542 wxFrame::SendSizeEvent, 542 wxFrame::SetIcon, 542 wxFrame::SetIcons, 543 wxFrame::SetMenuBar, 543 wxFrame::SetShape, 544 wxFrame::SetStatusBar, 544 wxFrame::SetStatusBarPane, 544 wxFrame::SetStatusText, 544 wxFrame::SetStatusWidths, 545 wxFrame::SetTitle, 545 wxFrame::SetToolBar, 545 wxFrame::ShowFullScreen, 546 wxFrame::wxFrame, 535 wxFRAME_EX_CONTEXTHELP, 534, 1430 wxFRAME_FLOAT_ON_PARENT, 534

1772


INDEX
wxFRAME_NO_TASKBAR, 534 wxFRAME_NO_WINDOW_MENU, 880 wxFRAME_SHAPED, 535 wxFRAME_TOOL_WINDOW, 534 wxFSFile, 547 wxFSFile::GetAnchor, 548 wxFSFile::GetLocation, 548 wxFSFile::GetMimeType, 548 wxFSFile::GetModificationTime, 548 wxFSFile::GetStream, 548 wxFSFile::wxFSFile, 547 wxFTP, 550 wxFTP::~wxFTP, 550 wxFTP::Abort, 550 wxFTP::ChDir, 551 wxFTP::CheckCommand, 550 wxFTP::FileExists, 553 wxFTP::GetDirList, 553 wxFTP::GetFileSize, 553 wxFTP::GetFilesList, 554 wxFTP::GetInputStream, 554 wxFTP::GetLastResult, 551 wxFTP::GetOutputStream, 554 wxFTP::MkDir, 551 wxFTP::Pwd, 551 wxFTP::Rename, 551 wxFTP::RmDir, 551 wxFTP::RmFile, 552 wxFTP::SendCommand, 551 wxFTP::SetAscii, 552 wxFTP::SetBinary, 552 wxFTP::SetPassword, 552 wxFTP::SetTransferMode, 552 wxFTP::SetUser, 552 wxFTP::wxFTP, 550 wxFULL_REPAINT_ON_RESIZE, 1395 wxGA_HORIZONTAL, 555 wxGA_SMOOTH, 555 wxGA_VERTICAL, 555 wxGauge, 556 wxGauge::~wxGauge, 557 wxGauge::Create, 557 wxGauge::GetBezelFace, 557 wxGauge::GetRange, 557 wxGauge::GetShadowWidth, 557 wxGauge::GetValue, 558 wxGauge::IsVertical, 558 wxGauge::SetBezelFace, 558 wxGauge::SetRange, 558 wxGauge::SetShadowWidth, 559 wxGauge::SetValue, 559 wxGauge::wxGauge, 556 wxGBPosition, 559 wxGBPosition::GetCol, 560 wxGBPosition::GetRow, 560 wxGBPosition::operator!, 560 wxGBPosition::operator==, 560 wxGBPosition::SetCol, 560 wxGBPosition::SetRow, 560 wxGBPosition::wxGBPosition, 559 wxGBSizerItem, 561 wxGBSizerItem::GetEndPos, 561 wxGBSizerItem::GetPos, 561 wxGBSizerItem::GetSpan, 561 wxGBSizerItem::Intersects, 561 wxGBSizerItem::SetPos, 562 wxGBSizerItem::SetSpan, 562 wxGBSizerItem::wxGBSizerItem, 561 wxGBSpan, 562 wxGBSpan::GetColspan, 563 wxGBSpan::GetRowspan, 563 wxGBSpan::operator!, 563 wxGBSpan::operator==, 563 wxGBSpan::SetColspan, 563 wxGBSpan::SetRowspan, 563 wxGBSpan::wxGBSpan, 562 wxGDIObject, 564 wxGDIObject::wxGDIObject, 564 wxGenericDirCtrl, 565 wxGenericDirCtrl::~wxGenericDirCtrl, 566 wxGenericDirCtrl::Create, 566 wxGenericDirCtrl::ExpandPath, 566 wxGenericDirCtrl::GetDefaultPath, 566 wxGenericDirCtrl::GetFilePath, 567 wxGenericDirCtrl::GetFilter, 567 wxGenericDirCtrl::GetFilterIndex, 567 wxGenericDirCtrl::GetFilterListCtrl, 567 wxGenericDirCtrl::GetPath, 566 wxGenericDirCtrl::GetRootId, 567 wxGenericDirCtrl::GetTreeCtrl, 567 wxGenericDirCtrl::Init, 566 wxGenericDirCtrl::SetDefaultPath, 567 wxGenericDirCtrl::SetFilter, 568 wxGenericDirCtrl::SetFilterIndex, 568 wxGenericDirCtrl::SetPath, 568 wxGenericDirCtrl::wxGenericDirCtrl, 565 wxGenericValidator, 569 wxGenericValidator::~wxGenericValidator, 569 wxGenericValidator::Clone, 569 wxGenericValidator::TransferFromWindow, 569 wxGenericValidator::TransferToWindow, 570 wxGenericValidator::wxGenericValidator, 568 wxGetActiveWindow, 1517 wxGetApp, 1473 wxGetClientDisplayRect, 1506 wxGetClipboardData, 1511 wxGetClipboardFormatName, 1512 wxGetColourFromUser, 1499 wxGetCwd, 1485 wxGetDiskSpace, 1484 wxGetDisplayName, 1517 wxGetDisplaySize, 1506 wxGetDisplaySizeMM, 1507 wxGetElapsedTime, 1534 wxGetEmailAddress, 1488 wxGetenv, 1540 wxGetEnv, 1540 wxGetFontFromUser, 1499 wxGetFreeMemory, 1488 wxGetFullHostName, 1488 wxGetHomeDir, 1489 wxGetHostName, 1489 wxGetLocalTime, 1534 wxGetLocalTimeMillis, 1535

1773


INDEX
wxGetMousePosition, 1517 wxGetMultipleChoice, 1501 wxGetMultipleChoices, 1499, 1500 wxGetNumberFromUser, 1500 wxGetOsDescription, 1490 wxGetOSDirectory, 1484 wxGetOsVersion, 1490 wxGetPrinterCommand, 1508 wxGetPrinterFile, 1508 wxGetPrinterMode, 1509 wxGetPrinterOptions, 1509 wxGetPrinterOrientation, 1509 wxGetPrinterPreviewCommand, 1509 wxGetPrinterScaling, 1509 wxGetPrinterTranslation, 1509 wxGetProcessId, 1479 wxGetResource, 1517, 1518 wxGetSingleChoice, 1502 wxGetSingleChoiceData, 1503 wxGetSingleChoiceIndex, 1502, 1503 wxGetTempFileName, 1486 wxGetTextFromUser, 1501 wxGetTopLevelParent, 1518 wxGetTranslation, 1492 wxGetUserHome, 1491 wxGetUserId, 1489 wxGetUserName, 1491 wxGetUTCTime, 1535 wxGetVariantCast, 1375 wxGetWorkingDirectory, 1485 wxGIFHandler, 733 wxGLCanvas, 571 wxGLCanvas::SetColour, 573 wxGLCanvas::SetCurrent, 572 wxGLCanvas::SwapBuffers, 573 wxGLCanvas::wxGLCanvas, 571 wxGrid, 575, 604 wxGrid::~wxGrid, 576 wxGrid::AppendCols, 576 wxGrid::AppendRows, 576 wxGrid::AutoSize, 576 wxGrid::AutoSizeColOrRow, 609 wxGrid::AutoSizeColumn, 576 wxGrid::AutoSizeColumns, 577 wxGrid::AutoSizeRow, 577 wxGrid::AutoSizeRows, 577 wxGrid::BeginBatch, 577 wxGrid::BlockToDeviceRect, 602 wxGrid::CanDragColSize, 578 wxGrid::CanDragGridSize, 578 wxGrid::CanDragRowSize, 578 wxGrid::CanEnableCellControl, 578 wxGrid::CanHaveAttributes, 609 wxGrid::CellToRect, 578 wxGrid::ClearGrid, 579 wxGrid::ClearSelection, 579 wxGrid::CreateGrid, 579 wxGrid::DeleteCols, 579 wxGrid::DeleteRows, 579 wxGrid::DisableCellEditControl, 580 wxGrid::DisableDragColSize, 580 wxGrid::DisableDragGridSize, 580 wxGrid::DisableDragRowSize, 580 wxGrid::DoGetBestSize, 608 wxGrid::EnableCellEditControl, 580 wxGrid::EnableDragColSize, 580 wxGrid::EnableDragGridSize, 580 wxGrid::EnableDragRowSize, 581 wxGrid::EnableEditing, 581 wxGrid::EnableGridLines, 581 wxGrid::EndBatch, 581 wxGrid::Fit, 607 wxGrid::ForceRefresh, 581 wxGrid::GetBatchCount, 581 wxGrid::GetCellAlignment, 582 wxGrid::GetCellBackgroundColour, 582 wxGrid::GetCellEditor, 582 wxGrid::GetCellFont, 582 wxGrid::GetCellRenderer, 582 wxGrid::GetCellTextColour, 583 wxGrid::GetCellTextFont, 606 wxGrid::GetCellValue, 583 wxGrid::GetColLabelAlignment, 583 wxGrid::GetColLabelSize, 583 wxGrid::GetColLabelValue, 583 wxGrid::GetColLeft, 608 wxGrid::GetColMinimalAcceptableWidth, 597 wxGrid::GetColMinimalWidth, 609 wxGrid::GetColRight, 608 wxGrid::GetCols, 604 wxGrid::GetColSize, 584 wxGrid::GetColumnWidth, 605 wxGrid::GetColWidth, 608 wxGrid::GetCursorColumn, 604 wxGrid::GetCursorRow, 604 wxGrid::GetDefaultCellAlignment, 584 wxGrid::GetDefaultCellBackgroundColour, 584 wxGrid::GetDefaultCellFont, 584 wxGrid::GetDefaultCellTextColour, 584 wxGrid::GetDefaultColLabelSize, 584 wxGrid::GetDefaultColSize, 584 wxGrid::GetDefaultEditor, 585 wxGrid::GetDefaultEditorForCell, 603 wxGrid::GetDefaultEditorForType, 603 wxGrid::GetDefaultRenderer, 585 wxGrid::GetDefaultRendererForCell, 603 wxGrid::GetDefaultRendererForType, 603 wxGrid::GetDefaultRowLabelSize, 585 wxGrid::GetDefaultRowSize, 585 wxGrid::GetDividerPen, 607 wxGrid::GetEditable, 607 wxGrid::GetEditInPlace, 607 wxGrid::GetGridCursorCol, 585 wxGrid::GetGridCursorRow, 585 wxGrid::GetGridLineColour, 586 wxGrid::GetLabelAlignment, 606 wxGrid::GetLabelBackgroundColour, 586 wxGrid::GetLabelFont, 586 wxGrid::GetLabelSize, 606 wxGrid::GetLabelTextColour, 586 wxGrid::GetLabelValue, 606 wxGrid::GetNumberCols, 586 wxGrid::GetNumberRows, 586 wxGrid::GetOrCreateCellAttr, 609

1774


INDEX
wxGrid::GetRowBottom, 609 wxGrid::GetRowHeight, 608 wxGrid::GetRowLabelAlignment, 586 wxGrid::GetRowLabelSize, 587 wxGrid::GetRowLabelValue, 587 wxGrid::GetRowMinimalAcceptableHeight, 600 wxGrid::GetRowMinimalHeight, 609 wxGrid::GetRows, 604 wxGrid::GetRowSize, 587 wxGrid::GetRowTop, 608 wxGrid::GetScrollPosX, 604 wxGrid::GetScrollPosY, 605 wxGrid::GetSelectedCells, 587 wxGrid::GetSelectedCols, 587 wxGrid::GetSelectedRows, 588 wxGrid::GetSelectionBackground, 602 wxGrid::GetSelectionBlockBottomRight, 588 wxGrid::GetSelectionBlockTopLeft, 588 wxGrid::GetSelectionForeground, 603 wxGrid::GetSelectionMode, 587 wxGrid::GetTable, 588 wxGrid::GetViewHeight, 605 wxGrid::GetViewWidth, 605 wxGrid::GridLinesEnabled, 586 wxGrid::HideCellEditControl, 588 wxGrid::InitColWidths, 608 wxGrid::InitRowHeights, 608 wxGrid::InsertCols, 588 wxGrid::InsertRows, 589 wxGrid::IsCellEditControlEnabled, 589 wxGrid::IsCurrentCellReadOnly, 589 wxGrid::IsEditable, 589 wxGrid::IsInSelection, 589 wxGrid::IsReadOnly, 590 wxGrid::IsSelection, 590 wxGrid::IsVisible, 590 wxGrid::MakeCellVisible, 590 wxGrid::MoveCursorDown, 590 wxGrid::MoveCursorDownBlock, 591 wxGrid::MoveCursorLeft, 590 wxGrid::MoveCursorLeftBlock, 591 wxGrid::MoveCursorRight, 591 wxGrid::MoveCursorRightBlock, 592 wxGrid::MoveCursorUp, 591 wxGrid::MoveCursorUpBlock, 592 wxGrid::MovePageDown, 592 wxGrid::MovePageUp, 592 wxGrid::OnActivate, 607 wxGrid::RegisterDataType, 603 wxGrid::SaveEditControlValue, 592 wxGrid::SelectAll, 593 wxGrid::SelectBlock, 593 wxGrid::SelectCol, 593 wxGrid::SelectionToDeviceRect, 602 wxGrid::SelectRow, 593 wxGrid::SetCellAlignment, 593 wxGrid::SetCellBackgroundColour, 606 wxGrid::SetCellBitmap, 607 wxGrid::SetCellEditor, 594 wxGrid::SetCellFont, 594 wxGrid::SetCellRenderer, 594 wxGrid::SetCellTextColour, 594 wxGrid::SetCellTextFont, 606 wxGrid::SetCellValue, 594 wxGrid::SetColAttr, 595 wxGrid::SetColFormatBool, 595 wxGrid::SetColFormatCustom, 595 wxGrid::SetColFormatFloat, 595 wxGrid::SetColFormatNumber, 595 wxGrid::SetColLabelAlignment, 596 wxGrid::SetColLabelSize, 596 wxGrid::SetColLabelValue, 596 wxGrid::SetColMinimalAcceptableWidth, 596 wxGrid::SetColMinimalWidth, 596 wxGrid::SetColSize, 597 wxGrid::SetColumnWidth, 605 wxGrid::SetDefaultCellAlignment, 597 wxGrid::SetDefaultCellBackgroundColour, 597 wxGrid::SetDefaultCellFont, 597 wxGrid::SetDefaultColSize, 598 wxGrid::SetDefaultEditor, 598 wxGrid::SetDefaultRenderer, 598 wxGrid::SetDefaultRowSize, 598 wxGrid::SetDividerPen, 607 wxGrid::SetEditable, 607 wxGrid::SetEditInPlace, 607 wxGrid::SetGridCursor, 598 wxGrid::SetGridLineColour, 598 wxGrid::SetLabelAlignment, 606 wxGrid::SetLabelBackgroundColour, 598 wxGrid::SetLabelFont, 599 wxGrid::SetLabelSize, 606 wxGrid::SetLabelTextColour, 599 wxGrid::SetLabelValue, 606 wxGrid::SetMargins, 603 wxGrid::SetOrCalcColumnSizes, 609 wxGrid::SetOrCalcRowSizes, 609 wxGrid::SetReadOnly, 599 wxGrid::SetRowAttr, 599 wxGrid::SetRowHeight, 605 wxGrid::SetRowLabelAlignment, 599 wxGrid::SetRowLabelSize, 599 wxGrid::SetRowLabelValue, 600 wxGrid::SetRowMinimalAcceptableHeight, 600 wxGrid::SetRowMinimalHeight, 600 wxGrid::SetRowSize, 600 wxGrid::SetScrollX, 605 wxGrid::SetScrollY, 605 wxGrid::SetSelectionBackground, 603 wxGrid::SetSelectionForeground, 603 wxGrid::SetSelectionMode, 601 wxGrid::SetTable, 601 wxGrid::ShowCellEditControl, 601 wxGrid::UpdateDimensions, 604 wxGrid::wxGrid, 575, 604 wxGrid::XToCol, 601 wxGrid::XToEdgeOfCol, 602 wxGrid::YToEdgeOfRow, 602 wxGrid::YToRow, 602 wxGridBagSizer, 613 wxGridBagSizer::Add, 613 wxGridBagSizer::CalcMin, 614 wxGridBagSizer::CheckForIntersection, 614 wxGridBagSizer::FindItem, 614

1775


INDEX
wxGridBagSizer::FindItemAtPoint, 614 wxGridBagSizer::FindItemAtPosition, 614 wxGridBagSizer::FindItemWithData, 614 wxGridBagSizer::GetCellSize, 615 wxGridBagSizer::GetEmptyCellSize, 615 wxGridBagSizer::GetItemPosition, 615 wxGridBagSizer::GetItemSpan, 615 wxGridBagSizer::RecalcSizes, 615 wxGridBagSizer::SetEmptyCellSize, 615 wxGridBagSizer::SetItemPosition, 616 wxGridBagSizer::SetItemSpan, 616 wxGridBagSizer::wxGridBagSizer, 613 wxGridCellAttr, 610 wxGridCellAttr::Clone, 610 wxGridCellAttr::DecRef, 610 wxGridCellAttr::GetAlignment, 612 wxGridCellAttr::GetBackgroundColour, 612 wxGridCellAttr::GetEditor, 612 wxGridCellAttr::GetFont, 612 wxGridCellAttr::GetRenderer, 612 wxGridCellAttr::GetTextColour, 612 wxGridCellAttr::HasAlignment, 612 wxGridCellAttr::HasBackgroundColour, 611 wxGridCellAttr::HasEditor, 612 wxGridCellAttr::HasFont, 611 wxGridCellAttr::HasRenderer, 612 wxGridCellAttr::HasTextColour, 611 wxGridCellAttr::IncRef, 610 wxGridCellAttr::IsReadOnly, 612 wxGridCellAttr::SetAlignment, 611 wxGridCellAttr::SetBackgroundColour, 610 wxGridCellAttr::SetDefAttr, 613 wxGridCellAttr::SetEditor, 611 wxGridCellAttr::SetFont, 611 wxGridCellAttr::SetReadOnly, 611 wxGridCellAttr::SetRenderer, 611 wxGridCellAttr::SetTextColour, 610 wxGridCellAttr::wxGridCellAttr, 610 wxGridCellBoolEditor, 616 wxGridCellBoolEditor::wxGridCellBoolEditor, 616 wxGridCellBoolRenderer, 629 wxGridCellBoolRenderer::wxGridCellBoolRender er, 629 wxGridCellChoiceEditor, 617 wxGridCellChoiceEditor::SetParameters, 617 wxGridCellChoiceEditor::wxGridCellChoiceEditor, 617 wxGridCellEditor, 618 wxGridCellEditor::~wxGridCellEditor, 619 wxGridCellEditor::BeginEdit, 618 wxGridCellEditor::Clone, 619 wxGridCellEditor::Create, 618 wxGridCellEditor::Destroy, 619 wxGridCellEditor::EndEdit, 618 wxGridCellEditor::HandleReturn, 619 wxGridCellEditor::IsCreated, 618 wxGridCellEditor::PaintBackground, 618 wxGridCellEditor::Reset, 619 wxGridCellEditor::SetSize, 618 wxGridCellEditor::Show, 618 wxGridCellEditor::StartingClick, 619 wxGridCellEditor::StartingKey, 619 wxGridCellEditor::wxGridCellEditor, 618 wxGridCellFloatEditor, 620 wxGridCellFloatEditor::SetParameters, 620 wxGridCellFloatEditor::wxGridCellFloatEditor, 620 wxGridCellFloatRenderer, 630 wxGridCellFloatRenderer::GetPrecision, 630 wxGridCellFloatRenderer::GetWidth, 630 wxGridCellFloatRenderer::SetParameters, 630 wxGridCellFloatRenderer::SetPrecision, 630 wxGridCellFloatRenderer::SetWidth, 631 wxGridCellFloatRenderer::wxGridCellFloatRende rer, 630 wxGridCellNumberEditor, 621 wxGridCellNumberEditor::GetString, 621 wxGridCellNumberEditor::HasRange, 621 wxGridCellNumberEditor::SetParameters, 621 wxGridCellNumberEditor::wxGridCellNumberEdit or, 621 wxGridCellNumberRenderer, 631 wxGridCellNumberRenderer::wxGridCellNumber Renderer, 631 wxGridCellRenderer::Clone, 632 wxGridCellRenderer::Draw, 632 wxGridCellRenderer::GetBestSize, 632 wxGridCellStringRenderer, 632 wxGridCellStringRenderer::wxGridCellStringRen derer, 632 wxGridCellTextEditor, 621 wxGridCellTextEditor::SetParameters, 622 wxGridCellTextEditor::wxGridCellTextEditor, 621 wxGridEditorCreatedEvent, 622 wxGridEditorCreatedEvent::GetCol, 622 wxGridEditorCreatedEvent::GetControl, 622 wxGridEditorCreatedEvent::GetRow, 622 wxGridEditorCreatedEvent::SetCol, 623 wxGridEditorCreatedEvent::SetControl, 623 wxGridEditorCreatedEvent::SetRow, 623 wxGridEditorCreatedEvent::wxGridEditorCreated Event, 622 wxGridEvent, 624 wxGridEvent::AltDown, 624 wxGridEvent::ControlDown, 625 wxGridEvent::GetCol, 625 wxGridEvent::GetPosition, 625 wxGridEvent::GetRow, 625 wxGridEvent::MetaDown, 625 wxGridEvent::Selecting, 625 wxGridEvent::ShiftDown, 625 wxGridEvent::wxGridEvent, 624 wxGridRangeSelectEvent, 626 wxGridRangeSelectEvent::AltDown, 626 wxGridRangeSelectEvent::ControlDown, 626 wxGridRangeSelectEvent::GetBottomRightCoord s, 626 wxGridRangeSelectEvent::GetBottomRow, 626 wxGridRangeSelectEvent::GetLeftCol, 627 wxGridRangeSelectEvent::GetRightCol, 627 wxGridRangeSelectEvent::GetTopLeftCoords, 627 wxGridRangeSelectEvent::GetTopRow, 627 wxGridRangeSelectEvent::MetaDown, 627

1776


INDEX
wxGridRangeSelectEvent::Selecting, 627 wxGridRangeSelectEvent::ShiftDown, 627 wxGridRangeSelectEvent::wxGridRangeSelectEv ent, 626 wxGridSizeEvent, 628 wxGridSizeEvent::AltDown, 628 wxGridSizeEvent::ControlDown, 628 wxGridSizeEvent::GetPosition, 629 wxGridSizeEvent::GetRowOrCol, 629 wxGridSizeEvent::MetaDown, 629 wxGridSizeEvent::ShiftDown, 629 wxGridSizeEvent::wxGridSizeEvent, 628 wxGridSizer, 637 wxGridSizer::GetCols, 638 wxGridSizer::GetHGap, 638 wxGridSizer::GetRows, 638 wxGridSizer::GetVGap, 638 wxGridSizer::SetCols, 638 wxGridSizer::SetHGap, 638 wxGridSizer::SetRows, 638 wxGridSizer::SetVGap, 638 wxGridSizer::wxGridSizer, 637 wxGridTableBase, 633 wxGridTableBase::~wxGridTableBase, 633 wxGridTableBase::AppendCols, 635 wxGridTableBase::AppendRows, 635 wxGridTableBase::CanGetValueAs, 634 wxGridTableBase::CanHaveAttributes, 636 wxGridTableBase::CanSetValueAs, 634 wxGridTableBase::Clear, 635 wxGridTableBase::DeleteCols, 635 wxGridTableBase::DeleteRows, 635 wxGridTableBase::GetAttr, 636 wxGridTableBase::GetAttrProvider, 636 wxGridTableBase::GetColLabelValue, 636 wxGridTableBase::GetNumberCols, 633 wxGridTableBase::GetNumberRows, 633 wxGridTableBase::GetRowLabelValue, 635 wxGridTableBase::GetTypeName, 633 wxGridTableBase::GetValue, 633 wxGridTableBase::GetValueAsBool, 634 wxGridTableBase::GetValueAsCustom, 634 wxGridTableBase::GetValueAsDouble, 634 wxGridTableBase::GetValueAsLong, 634 wxGridTableBase::GetView, 635 wxGridTableBase::InsertCols, 635 wxGridTableBase::InsertRows, 635 wxGridTableBase::IsEmptyCell, 633 wxGridTableBase::SetAttr, 637 wxGridTableBase::SetAttrProvider, 636 wxGridTableBase::SetColAttr, 637 wxGridTableBase::SetColLabelValue, 636 wxGridTableBase::SetRowAttr, 637 wxGridTableBase::SetRowLabelValue, 636 wxGridTableBase::SetValue, 633 wxGridTableBase::SetValueAsBool, 634 wxGridTableBase::SetValueAsCustom, 634 wxGridTableBase::SetValueAsDouble, 634 wxGridTableBase::SetValueAsLong, 634 wxGridTableBase::SetView, 635 wxGridTableBase::UpdateAttrCols, 636 wxGridTableBase::UpdateAttrRows, 636 wxGridTableBase::wxGridTableBase, 633 wxGzipInputStream, 639 wxGzipInputStream::~wxGzipInputStream, 640 wxGzipInputStream::GetDateTime, 640 wxGzipInputStream::GetName, 640 wxGzipInputStream::wxGzipInputStream, 639 wxGzipOutputStream, 641 wxGzipOutputStream::~wxGzipOutputStream, 641 wxGzipOutputStream::wxGzipOutputStream, 641 wxHandleFatalExceptions, 1474 wxHashMap, 644 wxHashMap::begin, 644 wxHashMap::clear, 644 wxHashMap::count, 644 wxHashMap::empty, 644 wxHashMap::end, 645 wxHashMap::erase, 645 wxHashMap::find, 645 wxHashMap::insert, 645 wxHashMap::operator[], 645 wxHashMap::size, 645 wxHashMap::wxHashMap, 644 wxHashTable, 647 wxHashTable::~wxHashTable, 647 wxHashTable::BeginFind, 647 wxHashTable::Clear, 647 wxHashTable::Delete, 647 wxHashTable::DeleteContents, 647 wxHashTable::Get, 647 wxHashTable::GetCount, 648 wxHashTable::MakeKey, 648 wxHashTable::Next, 648 wxHashTable::Put, 648 wxHashTable::wxHashTable, 646 wxHelpController, 650 wxHelpController::~wxHelpController, 650 wxHelpController::DisplayBlock, 650 wxHelpController::DisplayContents, 651 wxHelpController::DisplayContextPopup, 651 wxHelpController::DisplaySection, 651 wxHelpController::DisplayTextPopup, 651 wxHelpController::GetFrameParameters, 652 wxHelpController::Initialize, 650 wxHelpController::KeywordSearch, 652 wxHelpController::LoadFile, 652 wxHelpController::OnQuit, 653 wxHelpController::Quit, 653 wxHelpController::SetFrameParameters, 653 wxHelpController::SetViewer, 653 wxHelpController::wxHelpController, 650 wxHelpControllerHelpProvider, 654 wxHelpControllerHelpProvider::GetHelpController , 654 wxHelpControllerHelpProvider::SetHelpController , 654 wxHelpControllerHelpProvider::wxHelpController HelpProvider, 654 wxHelpEvent, 655 wxHelpEvent::GetPosition, 655 wxHelpEvent::SetPosition, 655 wxHelpEvent::wxHelpEvent, 655

1777


INDEX
wxHelpProvider::~wxHelpProvider, 656 wxHelpProvider::AddHelp, 657 wxHelpProvider::Get, 656 wxHelpProvider::GetHelp, 656 wxHelpProvider::RemoveHelp, 657 wxHelpProvider::Set, 656 wxHelpProvider::ShowHelp, 657 wxHF_BOOKMARKS, 677, 683 wxHF_CONTENTS, 677, 683 wxHF_DEFAULT_STYLE, 678, 683 wxHF_FLAT_TOOLBAR, 677, 683 wxHF_ICONS_BOOK, 677, 683 wxHF_ICONS_BOOK_CHAPTER, 678, 683 wxHF_ICONS_FOLDER, 677, 683 wxHF_INDEX, 677, 683 wxHF_MERGE_BOOKS, 677, 683 wxHF_OPEN_FILES, 677, 683 wxHF_PRINT, 677, 683 wxHF_SEARCH, 677, 683 wxHF_TOOLBAR, 677, 683 wxHP_NO_SELECTION, 703 wxHP_SCROLLBAR_AUTO, 703 wxHSCROLL, 879, 1255, 1394 wxHTML quick start, 1704 wxHtmlCell, 658 wxHtmlCell::AdjustPagebreak, 658 wxHtmlCell::Draw, 658 wxHtmlCell::DrawInvisible, 659 wxHtmlCell::Find, 659 wxHtmlCell::GetDescent, 660 wxHtmlCell::GetHeight, 660 wxHtmlCell::GetId, 660 wxHtmlCell::GetLink, 660 wxHtmlCell::GetNext, 660 wxHtmlCell::GetParent, 661 wxHtmlCell::GetPosX, 661 wxHtmlCell::GetPosY, 661 wxHtmlCell::GetWidth, 661 wxHtmlCell::Layout, 661 wxHtmlCell::OnMouseClick, 661 wxHtmlCell::SetId, 662 wxHtmlCell::SetLink, 662 wxHtmlCell::SetNext, 662 wxHtmlCell::SetParent, 662 wxHtmlCell::SetPos, 663 wxHtmlCell::wxHtmlCell, 658 wxHtmlColourCell, 663 wxHtmlColourCell::wxHtmlColourCell, 663 wxHtmlContainerCell, 664 wxHtmlContainerCell::GetAlignHor, 664 wxHtmlContainerCell::GetAlignVer, 664 wxHtmlContainerCell::GetBackgroundColour, 664 wxHtmlContainerCell::GetFirstCell, 664 wxHtmlContainerCell::GetIndent, 664 wxHtmlContainerCell::GetIndentUnits, 665 wxHtmlContainerCell::InsertCell, 665 wxHtmlContainerCell::SetAlign, 665 wxHtmlContainerCell::SetAlignHor, 665 wxHtmlContainerCell::SetAlignVer, 666 wxHtmlContainerCell::SetBackgroundColour, 666 wxHtmlContainerCell::SetBorder, 667 wxHtmlContainerCell::SetIndent, 667 wxHtmlContainerCell::SetMinHeight, 668 wxHtmlContainerCell::SetWidthFloat, 668 wxHtmlContainerCell::wxHtmlContainerCell, 664 wxHtmlDCRenderer, 670 wxHtmlDCRenderer::GetTotalHeight, 671 wxHtmlDCRenderer::Render, 671 wxHtmlDCRenderer::SetDC, 670 wxHtmlDCRenderer::SetFonts, 670 wxHtmlDCRenderer::SetHtmlText, 670 wxHtmlDCRenderer::SetSize, 670 wxHtmlDCRenderer::wxHtmlDCRenderer, 670 wxHtmlEasyPrinting, 672 wxHtmlEasyPrinting::GetPageSetupData, 675 wxHtmlEasyPrinting::GetPrintData, 675 wxHtmlEasyPrinting::PageSetup, 674 wxHtmlEasyPrinting::PreviewFile, 672 wxHtmlEasyPrinting::PreviewText, 673 wxHtmlEasyPrinting::PrinterSetup, 674 wxHtmlEasyPrinting::PrintFile, 673 wxHtmlEasyPrinting::PrintText, 673 wxHtmlEasyPrinting::SetFonts, 674 wxHtmlEasyPrinting::SetFooter, 674 wxHtmlEasyPrinting::SetHeader, 674 wxHtmlEasyPrinting::wxHtmlEasyPrinting, 672 wxHtmlFilter, 675 wxHtmlFilter::CanRead, 676 wxHtmlFilter::ReadFile, 676 wxHtmlFilter::wxHtmlFilter, 675 wxHtmlHelpController, 677 wxHtmlHelpController::AddBook, 678 wxHtmlHelpController::CreateHelpFrame, 678 wxHtmlHelpController::Display, 679 wxHtmlHelpController::DisplayContents, 679 wxHtmlHelpController::DisplayIndex, 679 wxHtmlHelpController::KeywordSearch, 679 wxHtmlHelpController::ReadCustomization, 680 wxHtmlHelpController::SetTempDir, 680 wxHtmlHelpController::SetTitleFormat, 680 wxHtmlHelpController::UseConfig, 680 wxHtmlHelpController::WriteCustomization, 681 wxHtmlHelpController::wxHtmlHelpController, 677 wxHtmlHelpData, 681 wxHtmlHelpData::AddBook, 681 wxHtmlHelpData::FindPageById, 681 wxHtmlHelpData::FindPageByName, 681 wxHtmlHelpData::GetBookRecArray, 682 wxHtmlHelpData::GetContents, 682 wxHtmlHelpData::GetContentsCnt, 682 wxHtmlHelpData::GetIndex, 682 wxHtmlHelpData::GetIndexCnt, 682 wxHtmlHelpData::SetTempDir, 682 wxHtmlHelpData::wxHtmlHelpData, 681 wxHtmlHelpFrame, 683 wxHtmlHelpFrame::AddToolbarButtons, 686 wxHtmlHelpFrame::Create, 684 wxHtmlHelpFrame::CreateContents, 684 wxHtmlHelpFrame::CreateIndex, 684 wxHtmlHelpFrame::CreateSearch, 684 wxHtmlHelpFrame::Display, 684 wxHtmlHelpFrame::DisplayContents, 685

1778


INDEX
wxHtmlHelpFrame::DisplayIndex, 685 wxHtmlHelpFrame::GetData, 685 wxHtmlHelpFrame::KeywordSearch, 685 wxHtmlHelpFrame::ReadCustomization, 685 wxHtmlHelpFrame::RefreshLists, 685 wxHtmlHelpFrame::SetTitleFormat, 685 wxHtmlHelpFrame::UseConfig, 686 wxHtmlHelpFrame::WriteCustomization, 686 wxHtmlHelpFrame::wxHtmlHelpFrame, 683 wxHtmlLinkInfo, 686, 687 wxHtmlLinkInfo::GetEvent, 687 wxHtmlLinkInfo::GetHref, 687 wxHtmlLinkInfo::GetHtmlCell, 687 wxHtmlLinkInfo::GetTarget, 687 wxHtmlLinkInfo::wxHtmlLinkInfo, 686 wxHtmlListBox, 688 wxHtmlListBox::~wxHtmlListBox, 688 wxHtmlListBox::Create, 688 wxHtmlListBox::GetSelectedTextBgColour, 688 wxHtmlListBox::GetSelectedTextColour, 689 wxHtmlListBox::OnGetItem, 689 wxHtmlListBox::OnGetItemMarkup, 689 wxHtmlListBox::wxHtmlListBox, 688 wxHtmlParser, 690 wxHtmlParser::AddTag, 690 wxHtmlParser::AddTagHandler, 690 wxHtmlParser::AddText, 690 wxHtmlParser::DoneParser, 691 wxHtmlParser::DoParsing, 691 wxHtmlParser::GetFS, 691 wxHtmlParser::GetProduct, 691 wxHtmlParser::GetSource, 691 wxHtmlParser::InitParser, 691 wxHtmlParser::OpenURL, 692 wxHtmlParser::Parse, 692 wxHtmlParser::PopTagHandler, 694 wxHtmlParser::PushTagHandler, 693 wxHtmlParser::SetFS, 694 wxHtmlParser::StopParsing, 694 wxHtmlParser::wxHtmlParser, 690 wxHtmlPrintout, 694 wxHtmlPrintout::AddFilter, 694 wxHtmlPrintout::SetFonts, 695 wxHtmlPrintout::SetFooter, 695 wxHtmlPrintout::SetHeader, 695 wxHtmlPrintout::SetHtmlFile, 695 wxHtmlPrintout::SetHtmlText, 696 wxHtmlPrintout::SetMargins, 696 wxHtmlPrintout::wxHtmlPrintout, 694 wxHtmlTag, 697 wxHtmlTag::GetAllParams, 697 wxHtmlTag::GetBeginPos, 697 wxHtmlTag::GetEndPos1, 697 wxHtmlTag::GetEndPos2, 697 wxHtmlTag::GetName, 698 wxHtmlTag::GetParam, 698 wxHtmlTag::GetParamAsColour, 698 wxHtmlTag::GetParamAsInt, 698 wxHtmlTag::HasEnding, 699 wxHtmlTag::HasParam, 699 wxHtmlTag::IsEnding, 699 wxHtmlTag::ScanParam, 699 wxHtmlTag::wxHtmlTag, 697 wxHtmlTagHandler, 700 wxHtmlTagHandler::GetSupportedTags, 700 wxHtmlTagHandler::HandleTag, 701 wxHtmlTagHandler::m_Parser, 700 wxHtmlTagHandler::ParseInner, 701 wxHtmlTagHandler::SetParser, 701 wxHtmlTagHandler::wxHtmlTagHandler, 700 wxHtmlTagsModule::FillHandlersTable, 702 wxHtmlWidgetCell, 703 wxHtmlWidgetCell::wxHtmlWidgetCell, 702 wxHtmlWindow, 704 wxHtmlWindow::AddFilter, 704 wxHtmlWindow::AppendToPage, 704 wxHtmlWindow::GetInternalRepresentation, 704 wxHtmlWindow::GetOpenedAnchor, 705 wxHtmlWindow::GetOpenedPage, 705 wxHtmlWindow::GetOpenedPageTitle, 705 wxHtmlWindow::GetRelatedFrame, 705 wxHtmlWindow::HistoryBack, 705 wxHtmlWindow::HistoryCanBack, 705 wxHtmlWindow::HistoryCanForward, 706 wxHtmlWindow::HistoryClear, 706 wxHtmlWindow::HistoryForward, 706 wxHtmlWindow::LoadFile, 706 wxHtmlWindow::LoadPage, 706 wxHtmlWindow::OnCellClicked, 707 wxHtmlWindow::OnCellMouseHover, 707 wxHtmlWindow::OnLinkClicked, 707 wxHtmlWindow::OnOpeningURL, 708 wxHtmlWindow::OnSetTitle, 708 wxHtmlWindow::ReadCustomization, 709 wxHtmlWindow::SelectAll, 709 wxHtmlWindow::SelectLine, 709 wxHtmlWindow::SelectWord, 709 wxHtmlWindow::SetBorders, 710 wxHtmlWindow::SetFonts, 710 wxHtmlWindow::SetPage, 711 wxHtmlWindow::SetRelatedFrame, 711 wxHtmlWindow::SetRelatedStatusBar, 711 wxHtmlWindow::WriteCustomization, 712 wxHtmlWindow::wxHtmlWindow, 704 wxHtmlWinParser, 713 wxHtmlWinParser::AddModule, 713 wxHtmlWinParser::CloseContainer, 713 wxHtmlWinParser::CreateCurrentFont, 713 wxHtmlWinParser::GetActualColor, 713 wxHtmlWinParser::GetAlign, 713 wxHtmlWinParser::GetCharHeight, 713 wxHtmlWinParser::GetCharWidth, 714 wxHtmlWinParser::GetContainer, 714 wxHtmlWinParser::GetDC, 714 wxHtmlWinParser::GetEncodingConverter, 714 wxHtmlWinParser::GetFontBold, 714 wxHtmlWinParser::GetFontFace, 714 wxHtmlWinParser::GetFontFixed, 715 wxHtmlWinParser::GetFontItalic, 715 wxHtmlWinParser::GetFontSize, 715 wxHtmlWinParser::GetFontUnderlined, 715 wxHtmlWinParser::GetInputEncoding, 715 wxHtmlWinParser::GetLink, 715 wxHtmlWinParser::GetLinkColor, 715

1779


INDEX
wxHtmlWinParser::GetOutputEncoding, 716 wxHtmlWinParser::GetWindow, 716 wxHtmlWinParser::OpenContainer, 716 wxHtmlWinParser::SetActualColor, 716 wxHtmlWinParser::SetAlign, 716 wxHtmlWinParser::SetContainer, 716 wxHtmlWinParser::SetDC, 716 wxHtmlWinParser::SetFontBold, 717 wxHtmlWinParser::SetFontFace, 717 wxHtmlWinParser::SetFontFixed, 717 wxHtmlWinParser::SetFontItalic, 717 wxHtmlWinParser::SetFonts, 717 wxHtmlWinParser::SetFontSize, 717 wxHtmlWinParser::SetFontUnderlined, 717 wxHtmlWinParser::SetInputEncoding, 718 wxHtmlWinParser::SetLink, 718 wxHtmlWinParser::SetLinkColor, 718 wxHtmlWinParser::wxHtmlWinParser, 713 wxHtmlWinTagHandler::m_WParser, 718 wxHTTP::GetHeader, 720 wxHTTP::GetInputStream, 719 wxHTTP::GetResponse, 719 wxHTTP::SetHeader, 719 wxHW_SCROLLBAR_NEVER, 703 wxICOHandler, 733 wxIcon, 721 wxICON, 1507 wxIcon::~wxIcon, 724 wxIcon::CopyFromBitmap, 724 wxIcon::GetDepth, 724 wxIcon::GetHeight, 724 wxIcon::GetWidth, 724 wxIcon::LoadFile, 725 wxIcon::Ok, 725 wxIcon::operator !=, 727 wxIcon::operator =, 726 wxIcon::operator ==, 727 wxIcon::SetDepth, 725 wxIcon::SetHeight, 726 wxIcon::SetOk, 726 wxIcon::SetWidth, 726 wxIcon::wxIcon, 721 wxIconBundle, 728 wxIconBundle::~wxIconBundle, 728 wxIconBundle::AddIcon, 728 wxIconBundle::GetIcon, 728 wxIconBundle::operator=, 729 wxIconBundle::wxIconBundle, 728 wxICONIZE, 534, 874, 879, 926 wxIconizeEvent, 730 wxIconizeEvent::Iconized, 730 wxIconizeEvent::wxIconizeEvent, 730 wxIconLocation::IsOk, 729 wxID, 1617 wxIdleEvent, 731 wxIdleEvent::CanSend, 731 wxIdleEvent::GetMode, 731 wxIdleEvent::MoreRequested, 732 wxIdleEvent::RequestMore, 732 wxIdleEvent::SetMode, 732 wxIdleEvent::wxIdleEvent, 731 wxIFFHandler, 733 wxImage, 734, 735 wxImage::~wxImage, 737 wxImage::AddHandler, 737 wxImage::CleanUpHandlers, 737 wxImage::ComputeHistogram, 737 wxImage::ConvertToBitmap, 738 wxImage::ConvertToMono, 738 wxImage::Copy, 738 wxImage::Create, 738 wxImage::Destroy, 739 wxImage::FindFirstUnusedColour, 739 wxImage::FindHandler, 739 wxImage::GetAlpha, 740 wxImage::GetBlue, 741 wxImage::GetData, 741 wxImage::GetGreen, 741 wxImage::GetHandlers, 742 wxImage::GetHeight, 742 wxImage::GetImageCount, 741 wxImage::GetImageExtWildcard, 740 wxImage::GetMaskBlue, 743 wxImage::GetMaskGreen, 743 wxImage::GetMaskRed, 743 wxImage::GetOption, 744 wxImage::GetOptionInt, 744 wxImage::GetPalette, 743 wxImage::GetRed, 743 wxImage::GetSubImage, 743 wxImage::GetWidth, 743 wxImage::HasAlpha, 744 wxImage::HasMask, 744 wxImage::HasOption, 744 wxImage::InitStandardHandlers, 745 wxImage::InsertHandler, 745 wxImage::LoadFile, 745 wxImage::Mirror, 749 wxImage::Ok, 747 wxImage::operator !=, 754 wxImage::operator =, 753 wxImage::operator ==, 753 wxImage::RemoveHandler, 747 wxImage::Replace, 749 wxImage::Rescale, 750 wxImage::Rotate, 750 wxImage::Rotate90, 750 wxImage::SaveFile, 748 wxImage::Scale, 750 wxImage::SetAlpha, 751 wxImage::SetData, 751 wxImage::SetMask, 751 wxImage::SetMaskColour, 751 wxImage::SetMaskFromImage, 752 wxImage::SetOption, 752 wxImage::SetPalette, 753 wxImage::SetRGB, 753 wxImage::wxImage, 734 wxIMAGE_LIST_NORMAL, 810 wxIMAGE_LIST_SMALL, 810 wxIMAGE_LIST_STATE, 810 wxImageHandler, 754 wxImageHandler::~wxImageHandler, 755 wxImageHandler::GetExtension, 755

1780


INDEX
wxImageHandler::GetImageCount, 755 wxImageHandler::GetMimeType, 755 wxImageHandler::GetName, 755 wxImageHandler::GetType, 755 wxImageHandler::LoadFile, 756 wxImageHandler::SaveFile, 756 wxImageHandler::SetExtension, 757 wxImageHandler::SetMimeType, 757 wxImageHandler::SetName, 757 wxImageHandler::SetType, 757 wxImageHandler::wxImageHandler, 754 wxImageList, 758 wxImageList::Add, 759 wxImageList::Create, 760 wxImageList::Draw, 760 wxImageList::GetImageCount, 761 wxImageList::GetSize, 761 wxImageList::Remove, 761 wxImageList::RemoveAll, 761 wxImageList::Replace, 761 wxImageList::wxImageList, 758 wxIndividualLayoutConstraint, 763 wxIndividualLayoutConstraint::Above, 763 wxIndividualLayoutConstraint::Absolute, 764 wxIndividualLayoutConstraint::AsIs, 764 wxIndividualLayoutConstraint::Below, 764 wxIndividualLayoutConstraint::LeftOf, 764 wxIndividualLayoutConstraint::PercentOf, 764 wxIndividualLayoutConstraint::RightOf, 765 wxIndividualLayoutConstraint::SameAs, 765 wxIndividualLayoutConstraint::Set, 765 wxIndividualLayoutConstraint::Unconstrained, 764 wxIndividualLayoutConstraint::wxIndividualLayou tConstraint, 763 wxInitAllImageHandlers, 1474 wxInitDialogEvent, 766 wxInitDialogEvent::wxInitDialogEvent, 766 wxInitialize, 1474 wxInputStream, 766 wxInputStream::~wxInputStream, 766 wxInputStream::Eof, 766 wxInputStream::GetC, 766 wxInputStream::LastRead, 766 wxInputStream::Peek, 767 wxInputStream::Read, 767 wxInputStream::SeekI, 767 wxInputStream::TellI, 767 wxInputStream::Ungetch, 767 wxInputStream::wxInputStream, 766 wxINT16_SWAP_ALWAYS, 1521 wxINT16_SWAP_ON_BE, 1521 wxINT16_SWAP_ON_LE, 1522 wxINT32_SWAP_ALWAYS, 1521 wxINT32_SWAP_ON_BE, 1521 wxINT32_SWAP_ON_LE, 1522 wxINTXX_SWAP_ALWAYS, 1521 wxINTXX_SWAP_ON_BE, 1521 wxINTXX_SWAP_ON_LE, 1522 wxIPaddress::AnyAddress, 769 wxIPaddress::Hostname, 768 wxIPaddress::IPAddress, 769 wxIPaddress::IsLocalHost, 770 wxIPaddress::LocalHost, 770 wxIPaddress::Service, 769 wxIPCFormat, 193 wxIPV4address::AnyAddress, 771 wxIPV4address::Hostname, 770, 771 wxIPV4address::IPAddress, 771 wxIPV4address::LocalHost, 772 wxIPV4address::Service, 771 wxIsAbsolutePath, 1484 wxIsBusy, 1503 wxIsClipboardFormatAvailable, 1512 wxIsDebuggerRunning, 1540 wxIsEmpty, 1493 wxIsMainThread, 1481 wxIsNaN, 1505 wxIsWild, 1486 wxJoystick, 772 wxJoystick::~wxJoystick, 772 wxJoystick::GetButtonState, 772 wxJoystick::GetManufacturerId, 773 wxJoystick::GetMovementThreshold, 773 wxJoystick::GetNumberAxes, 773 wxJoystick::GetNumberButtons, 773 wxJoystick::GetNumberJoysticks, 773 wxJoystick::GetPollingMax, 773 wxJoystick::GetPollingMin, 773 wxJoystick::GetPosition, 774 wxJoystick::GetPOVCTSPosition, 774 wxJoystick::GetPOVPosition, 774 wxJoystick::GetProductId, 774 wxJoystick::GetProductName, 774 wxJoystick::GetRudderMax, 774 wxJoystick::GetRudderMin, 774 wxJoystick::GetRudderPosition, 775 wxJoystick::GetUMax, 775 wxJoystick::GetUMin, 775 wxJoystick::GetUPosition, 775 wxJoystick::GetVMax, 775 wxJoystick::GetVMin, 775 wxJoystick::GetVPosition, 775 wxJoystick::GetXMax, 775 wxJoystick::GetXMin, 776 wxJoystick::GetYMax, 776 wxJoystick::GetYMin, 776 wxJoystick::GetZMax, 776 wxJoystick::GetZMin, 776 wxJoystick::GetZPosition, 776 wxJoystick::HasPOV, 776 wxJoystick::HasPOV4Dir, 777 wxJoystick::HasPOVCTS, 777 wxJoystick::HasRudder, 777 wxJoystick::HasU, 777 wxJoystick::HasV, 777 wxJoystick::HasZ, 777 wxJoystick::IsOk, 777 wxJoystick::ReleaseCapture, 777 wxJoystick::SetCapture, 778 wxJoystick::SetMovementThreshold, 778 wxJoystick::wxJoystick, 772 wxJoystickEvent, 779 wxJoystickEvent::ButtonDown, 779

1781


INDEX
wxJoystickEvent::ButtonIsDown, 779 wxJoystickEvent::ButtonUp, 780 wxJoystickEvent::GetButtonChange, 780 wxJoystickEvent::GetButtonState, 780 wxJoystickEvent::GetJoystick, 780 wxJoystickEvent::GetPosition, 780 wxJoystickEvent::GetZPosition, 781 wxJoystickEvent::IsButton, 781 wxJoystickEvent::IsMove, 781 wxJoystickEvent::IsZMove, 781 wxJoystickEvent::wxJoystickEvent, 779 wxJPEGHandler, 733 wxKeyEvent, 783 wxKeyEvent::AltDown, 784 wxKeyEvent::ControlDown, 784 wxKeyEvent::GetKeyCode, 784 wxKeyEvent::GetPosition, 785 wxKeyEvent::GetRawKeyCode, 784 wxKeyEvent::GetRawKeyFlags, 784 wxKeyEvent::GetX, 784 wxKeyEvent::GetY, 785 wxKeyEvent::HasModifiers, 785 wxKeyEvent::m_altDown, 782 wxKeyEvent::m_controlDown, 783 wxKeyEvent::m_keyCode, 783 wxKeyEvent::m_metaDown, 783 wxKeyEvent::m_shiftDown, 783 wxKeyEvent::m_x, 783 wxKeyEvent::m_y, 783 wxKeyEvent::MetaDown, 785 wxKeyEvent::ShiftDown, 785 wxKeyEvent::wxKeyEvent, 783 wxKill, 1478 wxLayoutAlgorithm, 787 wxLayoutAlgorithm::~wxLayoutAlgorithm, 787 wxLayoutAlgorithm::LayoutFrame, 788 wxLayoutAlgorithm::LayoutMDIFrame, 788 wxLayoutAlgorithm::LayoutWindow, 788 wxLayoutAlgorithm::wxLayoutAlgorithm, 787 wxLayoutConstraints, 789 wxLayoutConstraints::bottom, 789 wxLayoutConstraints::centreX, 789 wxLayoutConstraints::centreY, 790 wxLayoutConstraints::height, 790 wxLayoutConstraints::left, 790 wxLayoutConstraints::right, 790 wxLayoutConstraints::top, 790 wxLayoutConstraints::width, 790 wxLayoutConstraints::wxLayoutConstraints, 789 wxLB_ALWAYS_SB, 798 wxLB_BOTTOM, 797 wxLB_DEFAULT, 797 wxLB_EXTENDED, 798 wxLB_HSCROLL, 798 wxLB_LEFT, 797 wxLB_MULTIPLE, 798 wxLB_NEEDED_SB, 798 wxLB_RIGHT, 797 wxLB_SINGLE, 798 wxLB_SORT, 798 wxLB_TOP, 797 wxLC_ALIGN_LEFT, 804 wxLC_ALIGN_TOP, 804 wxLC_AUTOARRANGE, 804 wxLC_EDIT_LABELS, 804 wxLC_HRULES, 804 wxLC_ICON, 804 wxLC_LIST, 803 wxLC_NO_HEADER, 804 wxLC_REPORT, 804 wxLC_SINGLE_SEL, 804 wxLC_SMALL_ICON, 804 wxLC_SORT_ASCENDING, 804 wxLC_SORT_DESCENDING, 804 wxLC_VIRTUAL, 804 wxLC_VRULES, 804 wxLEAVE_CRIT_SECT, 1481 wxLI_HORIZONTAL, 1187 wxLI_VERTICAL, 1187 wxList, 793 wxList::~wxList, 793 wxList::Append, 793 wxList::Clear, 794 wxList::DeleteContents, 794 wxList::DeleteNode, 794 wxList::DeleteObject, 794 wxList::Find, 794 wxList::GetCount, 794 wxList::GetFirst, 795 wxList::GetLast, 795 wxList::IndexOf, 795 wxList::Insert, 795 wxList::IsEmpty, 795 wxList::Item, 795 wxList::Member, 796 wxList::Nth, 796 wxList::Number, 796 wxList::Sort, 796 wxList::wxList, 793 wxListBox, 799 wxListBox::~wxListBox, 800 wxListBox::Create, 800 wxListBox::Deselect, 800 wxListBox::GetSelections, 801 wxListBox::InsertItems, 801 wxListBox::Selected, 802 wxListBox::Set, 802 wxListBox::SetFirstItem, 802 wxListBox::wxListBox, 799 wxListCtrl, 805 wxListCtrl::~wxListCtrl, 806 wxListCtrl::Arrange, 806 wxListCtrl::AssignImageList, 807 wxListCtrl::ClearAll, 807 wxListCtrl::Create, 807 wxListCtrl::DeleteAllItems, 807 wxListCtrl::DeleteColumn, 807 wxListCtrl::DeleteItem, 808 wxListCtrl::EditLabel, 808 wxListCtrl::EnsureVisible, 808 wxListCtrl::FindItem, 808 wxListCtrl::GetColumn, 809 wxListCtrl::GetColumnCount, 809 wxListCtrl::GetColumnWidth, 809

1782


INDEX
wxListCtrl::GetCountPerPage, 809 wxListCtrl::GetEditControl, 809 wxListCtrl::GetImageList, 810 wxListCtrl::GetItem, 810 wxListCtrl::GetItemBackgroundColour, 810 wxListCtrl::GetItemCount, 810 wxListCtrl::GetItemData, 810 wxListCtrl::GetItemPosition, 811 wxListCtrl::GetItemRect, 811 wxListCtrl::GetItemSpacing, 811 wxListCtrl::GetItemState, 811 wxListCtrl::GetItemText, 812 wxListCtrl::GetItemTextColour, 812 wxListCtrl::GetNextItem, 812 wxListCtrl::GetSelectedItemCount, 813 wxListCtrl::GetTextColour, 813 wxListCtrl::GetTopItem, 813 wxListCtrl::HitTest, 813 wxListCtrl::InsertColumn, 814 wxListCtrl::InsertItem, 815 wxListCtrl::OnGetItemAttr, 816 wxListCtrl::OnGetItemImage, 816 wxListCtrl::OnGetItemText, 816 wxListCtrl::RefreshItem, 817 wxListCtrl::RefreshItems, 817 wxListCtrl::ScrollList, 817 wxListCtrl::SetBackgroundColour, 817 wxListCtrl::SetColumn, 817 wxListCtrl::SetColumnWidth, 817 wxListCtrl::SetImageList, 818 wxListCtrl::SetItem, 818 wxListCtrl::SetItemBackgroundColour, 819 wxListCtrl::SetItemCount, 820 wxListCtrl::SetItemData, 820 wxListCtrl::SetItemImage, 820 wxListCtrl::SetItemPosition, 820 wxListCtrl::SetItemState, 820 wxListCtrl::SetItemText, 820 wxListCtrl::SetItemTextColour, 821 wxListCtrl::SetSingleStyle, 821 wxListCtrl::SetTextColour, 821 wxListCtrl::SetWindowStyleFlag, 821 wxListCtrl::SortItems, 821 wxListCtrl::wxListCtrl, 805 wxListEvent, 823 wxListEvent::GetCacheFrom, 823 wxListEvent::GetCacheTo, 824 wxListEvent::GetColumn, 824 wxListEvent::GetData, 825 wxListEvent::GetImage, 825 wxListEvent::GetIndex, 824 wxListEvent::GetItem, 825 wxListEvent::GetKeyCode, 824 wxListEvent::GetLabel, 824 wxListEvent::GetMask, 825 wxListEvent::GetPoint, 824 wxListEvent::GetText, 824 wxListEvent::IsEditCancelled, 825 wxListEvent::wxListEvent, 823 wxListItem, 826 wxListItem::Clear, 826 wxListItem::GetAlign, 826 wxListItem::GetBackgroundColour, 826 wxListItem::GetColumn, 826 wxListItem::GetData, 826 wxListItem::GetFont, 826 wxListItem::GetId, 826 wxListItem::GetImage, 827 wxListItem::GetMask, 827 wxListItem::GetState, 827 wxListItem::GetText, 827 wxListItem::GetTextColour, 828 wxListItem::GetWidth, 828 wxListItem::SetAlign, 828 wxListItem::SetBackgroundColour, 828 wxListItem::SetColumn, 828 wxListItem::SetData, 828 wxListItem::SetFont, 828 wxListItem::SetId, 829 wxListItem::SetImage, 829 wxListItem::SetMask, 829 wxListItem::SetState, 829 wxListItem::SetStateMask, 829 wxListItem::SetText, 829 wxListItem::SetTextColour, 829 wxListItem::SetWidth, 830 wxListItem::wxListItem, 826 wxListView::ClearColumnImage, 830 wxListView::Focus, 830 wxListView::GetFirstSelected, 831 wxListView::GetFocusedItem, 831 wxListView::GetNextSelected, 831 wxListView::IsSelected, 831 wxListView::Select, 831 wxListView::SetColumnImage, 832 wxLL, 1514 wxLoadUserResource, 1518 wxLocale, 842 wxLocale::~wxLocale, 842 wxLocale::AddCatalog, 842 wxLocale::AddCatalogLookupPathPrefix, 843 wxLocale::AddLanguage, 843 wxLocale::FindLanguageInfo, 843 wxLocale::GetCanonicalName, 844 wxLocale::GetLanguage, 844 wxLocale::GetLanguageInfo, 844 wxLocale::GetLanguageName, 844 wxLocale::GetLocale, 844 wxLocale::GetName, 845 wxLocale::GetString, 845 wxLocale::GetSysName, 845 wxLocale::GetSystemEncoding, 845 wxLocale::GetSystemEncodingName, 846 wxLocale::GetSystemLanguage, 846 wxLocale::Init, 846 wxLocale::IsLoaded, 847 wxLocale::IsOk, 847 wxLocale::wxLocale, 842 wxLOCALE_CONV_ENCODING, 846 wxLOCALE_LOAD_DEFAULT, 846 wxLog::AddTraceMask, 850 wxLog::ClearTraceMasks, 850 wxLog::DoLog, 852 wxLog::DoLogString, 852

1783


INDEX
wxLog::DontCreateOnDemand, 852 wxLog::Flush, 852 wxLog::FlushActive, 853 wxLog::GetActiveTarget, 851 wxLog::GetLogLevel, 853 wxLog::GetTimestamp, 853 wxLog::GetTraceMask, 854 wxLog::GetTraceMasks, 851 wxLog::GetVerbose, 853 wxLog::IsAllowedTraceMask, 854 wxLog::OnLog, 851 wxLog::RemoveTraceMask, 854 wxLog::Resume, 852 wxLog::SetActiveTarget, 851 wxLog::SetLogLevel, 853 wxLog::SetTimestamp, 853 wxLog::SetTraceMask, 854 wxLog::SetVerbose, 853 wxLog::Suspend, 851 wxLogChain, 855 wxLogChain::~wxLogChain, 855 wxLogChain::GetOldLog, 855 wxLogChain::IsPassingMessages, 855 wxLogChain::PassMessages, 855 wxLogChain::SetLog, 856 wxLogChain::wxLogChain, 855 wxLogDebug, 1531 wxLogError, 1529 wxLogFatalError, 1529 wxLogGui, 856 wxLogGui::wxLogGui, 856 wxLogMessage, 1530 wxLogNull, 857 wxLogNull::~wxLogNull, 857 wxLogNull::wxLogNull, 857 wxLogPassThrough::wxLogPassThrough, 858 wxLogStatus, 1530 wxLogStderr, 858 wxLogStderr::wxLogStderr, 858 wxLogStream, 859 wxLogStream::wxLogStream, 859 wxLogSysError, 1530 wxLogTextCtrl, 859 wxLogTextCtrl::wxLogTextCtrl, 859 wxLogTrace, 1531 wxLogVerbose, 1530 wxLogWarning, 1529 wxLogWindow, 860 wxLogWindow::GetFrame, 861 wxLogWindow::OnFrameClose, 861 wxLogWindow::OnFrameCreate, 861 wxLogWindow::OnFrameDelete, 861 wxLogWindow::Show, 861 wxLogWindow::wxLogWindow, 860 wxLongLong, 862 wxLongLong::Abs, 863 wxLongLong::Assign, 863 wxLongLong::GetHi, 863 wxLongLong::GetLo, 863 wxLongLong::GetValue, 863 wxLongLong::operator-, 864 wxLongLong::operator--, 864 wxLongLong::operator+, 864 wxLongLong::operator++, 864 wxLongLong::operator+=, 864 wxLongLong::operator=, 862 wxLongLong::operator-=, 864 wxLongLong::ToLong, 863 wxLongLong::ToString, 863 wxLongLong::wxLongLong, 862 wxLongLongFmtSpec, 1514 wxMakeMetafilePlaceable, 1507 wxMask, 865 wxMask::~wxMask, 866 wxMask::Create, 866 wxMask::wxMask, 865 wxMatchWild, 1486 wxMAXIMIZE, 534, 874, 879, 927 wxMAXIMIZE_BOX, 371, 534, 874, 879, 927 wxMaximizeEvent, 867 wxMaximizeEvent::wxMaximizeEvent, 867 wxMBConv, 868 wxMBConv classes, 1596 wxMBConv objects, 1596 wxMBConv::cMB2WC, 869 wxMBConv::cMB2WX, 869 wxMBConv::cWC2MB, 869 wxMBConv::cWC2WX, 869 wxMBConv::cWX2MB, 869 wxMBConv::cWX2WC, 869 wxMBConv::MB2WC, 868 wxMBConv::WC2MB, 868 wxMBConv::wxMBConv, 868 wxMBConvFile::MB2WC, 870 wxMBConvFile::WC2MB, 870 wxMBConvUTF16::MB2WC, 873 wxMBConvUTF16::WC2MB, 873 wxMBConvUTF32::MB2WC, 873 wxMBConvUTF32::WC2MB, 874 wxMBConvUTF7::MB2WC, 871 wxMBConvUTF7::WC2MB, 871 wxMBConvUTF8::MB2WC, 872 wxMBConvUTF8::WC2MB, 872 wxMDIChildFrame, 875 wxMDIChildFrame::~wxMDIChildFrame, 876 wxMDIChildFrame::Activate, 876 wxMDIChildFrame::Create, 876 wxMDIChildFrame::Maximize, 877 wxMDIChildFrame::Restore, 877 wxMDIChildFrame::wxMDIChildFrame, 875 wxMDIClientWindow, 878 wxMDIClientWindow::~wxMDIClientWindow, 878 wxMDIClientWindow::CreateClient, 878 wxMDIClientWindow::wxMDIClientWindow, 878 wxMDIParentFrame, 880 wxMDIParentFrame::~wxMDIParentFrame, 881 wxMDIParentFrame::ActivateNext, 881 wxMDIParentFrame::ActivatePrevious, 882 wxMDIParentFrame::ArrangeIcons, 882 wxMDIParentFrame::Cascade, 882 wxMDIParentFrame::Create, 882 wxMDIParentFrame::GetActiveChild, 883 wxMDIParentFrame::GetClientSize, 882 wxMDIParentFrame::GetClientWindow, 883

1784


INDEX
wxMDIParentFrame::GetToolBar, 884 wxMDIParentFrame::GetWindowMenu, 884 wxMDIParentFrame::OnCreateClient, 884 wxMDIParentFrame::SetToolBar, 884 wxMDIParentFrame::SetWindowMenu, 885 wxMDIParentFrame::Tile, 885 wxMDIParentFrame::wxMDIParentFrame, 880 wxMemoryDC, 886 wxMemoryDC::SelectObject, 886 wxMemoryDC::wxMemoryDC, 886 wxMemoryFSHandler, 888 wxMemoryFSHandler::AddFile, 888 wxMemoryFSHandler::RemoveFile, 888 wxMemoryFSHandler::wxMemoryFSHandler, 888 wxMemoryInputStream, 888 wxMemoryInputStream::~wxMemoryInputStream, 889 wxMemoryInputStream::wxMemoryInputStream, 888 wxMemoryOutputStream, 889 wxMemoryOutputStream::~wxMemoryOutputStre am, 889 wxMemoryOutputStream::CopyTo, 889 wxMemoryOutputStream::wxMemoryOutputStrea m, 889 wxMenu, 891 wxMenu::~wxMenu, 891 wxMenu::Append, 892 wxMenu::AppendCheckItem, 894 wxMenu::AppendRadioItem, 894 wxMenu::AppendSeparator, 894 wxMenu::Break, 894 wxMenu::Check, 895 wxMenu::Delete, 895 wxMenu::Destroy, 895 wxMenu::Enable, 896 wxMenu::FindItem, 896 wxMenu::FindItemByPosition, 897 wxMenu::GetHelpString, 897 wxMenu::GetLabel, 898 wxMenu::GetMenuItemCount, 898 wxMenu::GetMenuItems, 898 wxMenu::GetTitle, 898 wxMenu::Insert, 898 wxMenu::InsertCheckItem, 899 wxMenu::InsertRadioItem, 899 wxMenu::InsertSeparator, 899 wxMenu::IsChecked, 899 wxMenu::IsEnabled, 900 wxMenu::Prepend, 900 wxMenu::PrependCheckItem, 900 wxMenu::PrependRadioItem, 901 wxMenu::PrependSeparator, 901 wxMenu::Remove, 901 wxMenu::SetHelpString, 902 wxMenu::SetLabel, 902 wxMenu::SetTitle, 902 wxMenu::UpdateUI, 903 wxMenu::wxMenu, 891 wxMenuBar, 904 wxMenuBar::~wxMenuBar, 904 wxMenuBar::Append, 904 wxMenuBar::Check, 905 wxMenuBar::Enable, 905 wxMenuBar::EnableTop, 906 wxMenuBar::FindItem, 907 wxMenuBar::FindMenu, 906 wxMenuBar::FindMenuItem, 906 wxMenuBar::GetHelpString, 907 wxMenuBar::GetLabel, 907 wxMenuBar::GetLabelTop, 908 wxMenuBar::GetMenu, 908 wxMenuBar::GetMenuCount, 908 wxMenuBar::Insert, 908 wxMenuBar::IsChecked, 909 wxMenuBar::IsEnabled, 909 wxMenuBar::Refresh, 910 wxMenuBar::Remove, 910 wxMenuBar::Replace, 910 wxMenuBar::SetHelpString, 911 wxMenuBar::SetLabel, 911 wxMenuBar::SetLabelTop, 911 wxMenuBar::wxMenuBar, 904 wxMenuEvent, 913 wxMenuEvent::GetMenuId, 913 wxMenuEvent::IsPopup, 913 wxMenuEvent::m_menuId, 913 wxMenuEvent::wxMenuEvent, 913 wxMenuItem, 914 wxMenuItem::~wxMenuItem, 914 wxMenuItem::Check, 915 wxMenuItem::DeleteSubMenu, 915 wxMenuItem::Enable, 915 wxMenuItem::GetBackgroundColour, 915 wxMenuItem::GetBitmap, 915 wxMenuItem::GetFont, 915 wxMenuItem::GetHelp, 915 wxMenuItem::GetId, 915 wxMenuItem::GetKind, 916 wxMenuItem::GetLabel, 916 wxMenuItem::GetLabelFromText, 916 wxMenuItem::GetMarginWidth, 916 wxMenuItem::GetName, 916 wxMenuItem::GetSubMenu, 917 wxMenuItem::GetText, 917 wxMenuItem::GetTextColour, 917 wxMenuItem::IsCheckable, 917 wxMenuItem::IsChecked, 917 wxMenuItem::IsEnabled, 917 wxMenuItem::IsSeparator, 917 wxMenuItem::SetBackgroundColour, 918 wxMenuItem::SetBitmap, 918 wxMenuItem::SetBitmaps, 918 wxMenuItem::SetFont, 918 wxMenuItem::SetHelp, 918 wxMenuItem::SetMarginWidth, 918 wxMenuItem::SetText, 918 wxMenuItem::SetTextColour, 919 wxMenuItem::wxMenuItem, 914 wxMessageBox, 1504 wxMessageDialog, 919 wxMessageDialog overview, 1661 wxMessageDialog::~wxMessageDialog, 920

1785


INDEX
wxMessageDialog::ShowModal, 920 wxMessageDialog::wxMessageDialog, 919 wxMetafile, 921 wxMetafile::~wxMetafile, 921 wxMetafile::Ok, 921 wxMetafile::Play, 921 wxMetafile::SetClipboard, 921 wxMetafile::wxMetafile, 921 wxMetafileDC, 922 wxMetafileDC::~wxMetafileDC, 923 wxMetafileDC::Close, 923 wxMetafileDC::wxMetafileDC, 922 wxMimeTypesManager, 925 wxMimeTypesManager::~wxMimeTypesManager , 925 wxMimeTypesManager::AddFallbacks, 925 wxMimeTypesManager::GetFileTypeFromExtensi on, 925 wxMimeTypesManager::GetFileTypeFromMimeT ype, 925 wxMimeTypesManager::IsOfType, 925 wxMimeTypesManager::ReadMailcap, 926 wxMimeTypesManager::ReadMimeTypes, 926 wxMimeTypesManager::wxMimeTypesManager, 925 wxMiniFrame, 927 wxMiniFrame::~wxMiniFrame, 928 wxMiniFrame::Create, 928 wxMiniFrame::wxMiniFrame, 927 wxMINIMIZE, 534, 874, 880, 926 wxMINIMIZE_BOX, 371, 534, 874, 880, 927 wxMirrorDC, 929 wxMirrorDC::wxMirrorDC, 929 wxMkdir, 1486 wxModule, 930 wxModule::~wxModule, 930 wxModule::CleanupModules, 930 wxModule::Exit, 930 wxModule::Init, 931 wxModule::InitializeModules, 931 wxModule::OnExit, 931 wxModule::OnInit, 931 wxModule::RegisterModule, 931 wxModule::RegisterModules, 931 wxModule::wxModule, 930 wxMouseCaptureChangedEvent, 932 wxMouseCaptureChangedEvent::wxMouseCaptu reChangedEvent, 932 wxMouseEvent, 935 wxMouseEvent::AltDown, 936 wxMouseEvent::Button, 936 wxMouseEvent::ButtonDClick, 936 wxMouseEvent::ButtonDown, 936 wxMouseEvent::ButtonUp, 937 wxMouseEvent::ControlDown, 937 wxMouseEvent::Dragging, 937 wxMouseEvent::Entering, 937 wxMouseEvent::GetButton, 937 wxMouseEvent::GetLinesPerAction, 938 wxMouseEvent::GetLogicalPosition, 938 wxMouseEvent::GetPosition, 938 wxMouseEvent::GetWheelDelta, 938 wxMouseEvent::GetWheelRotation, 938 wxMouseEvent::GetX, 938 wxMouseEvent::GetY, 939 wxMouseEvent::IsButton, 939 wxMouseEvent::IsPageScroll, 939 wxMouseEvent::Leaving, 939 wxMouseEvent::LeftDClick, 939 wxMouseEvent::LeftDown, 939 wxMouseEvent::LeftIsDown, 939 wxMouseEvent::LeftUp, 940 wxMouseEvent::m_altDown, 934 wxMouseEvent::m_controlDown, 934 wxMouseEvent::m_leftDown, 934 wxMouseEvent::m_linesPerAction, 935 wxMouseEvent::m_metaDown, 934 wxMouseEvent::m_middleDown, 934 wxMouseEvent::m_rightDown, 934 wxMouseEvent::m_shiftDown, 934 wxMouseEvent::m_wheelDelta, 935 wxMouseEvent::m_wheelRotation, 935 wxMouseEvent::m_x, 935 wxMouseEvent::m_y, 935 wxMouseEvent::MetaDown, 940 wxMouseEvent::MiddleDClick, 940 wxMouseEvent::MiddleDown, 940 wxMouseEvent::MiddleIsDown, 940 wxMouseEvent::MiddleUp, 940 wxMouseEvent::Moving, 941 wxMouseEvent::RightDClick, 941 wxMouseEvent::RightDown, 941 wxMouseEvent::RightIsDown, 941 wxMouseEvent::RightUp, 941 wxMouseEvent::ShiftDown, 941 wxMouseEvent::wxMouseEvent, 935 wxMoveEvent, 942 wxMoveEvent::GetPosition, 942 wxMoveEvent::wxMoveEvent, 942 wxMultipleChoiceDialog overview, 1662 wxMutex, 944 wxMutex::~wxMutex, 944 wxMutex::Lock, 945 wxMutex::TryLock, 945 wxMutex::Unlock, 945 wxMutex::wxMutex, 944 wxMutexGuiEnter, 1482 wxMutexGuiLeave, 1482 wxMutexLocker, 946 wxMutexLocker::~wxMutexLocker, 946 wxMutexLocker::IsOk, 946 wxMutexLocker::wxMutexLocker, 946 wxNB_BOTTOM, 948 wxNB_FIXEDWIDTH, 948 wxNB_LEFT, 948 wxNB_MULTILINE, 948 wxNB_RIGHT, 948 wxNewId, 1514 wxNO_3D, 372 wxNO_BORDER, 105, 1394 wxNO_FULL_REPAINT_ON_RESIZE, 1394 wxNode<T>::GetData, 947 wxNode<T>::GetNext, 947 wxNode<T>::GetPrevious, 947

1786


INDEX
wxNode<T>::IndexOf, 947 wxNode<T>::SetData, 947 wxNotebook, 949 wxNotebook::~wxNotebook, 950 wxNotebook::AddPage, 950 wxNotebook::AdvanceSelection, 950 wxNotebook::AssignImageList, 951 wxNotebook::Create, 951 wxNotebook::DeleteAllPages, 951 wxNotebook::DeletePage, 951 wxNotebook::GetImageList, 951 wxNotebook::GetPage, 951 wxNotebook::GetPageCount, 952 wxNotebook::GetPageImage, 952 wxNotebook::GetPageText, 952 wxNotebook::GetRowCount, 952 wxNotebook::GetSelection, 952 wxNotebook::HitTest, 952 wxNotebook::InsertPage, 953 wxNotebook::OnSelChange, 954 wxNotebook::RemovePage, 954 wxNotebook::SetImageList, 954 wxNotebook::SetPadding, 954 wxNotebook::SetPageImage, 955 wxNotebook::SetPageSize, 954 wxNotebook::SetPageText, 955 wxNotebook::SetSelection, 955 wxNotebook::wxNotebook, 949 wxNotebookEvent, 956 wxNotebookEvent::GetOldSelection, 956 wxNotebookEvent::GetSelection, 956 wxNotebookEvent::SetOldSelection, 957 wxNotebookEvent::SetSelection, 957 wxNotebookEvent::wxNotebookEvent, 956 wxNotebookSizer, 957 wxNotebookSizer::GetNotebook, 957 wxNotebookSizer::wxNotebookSizer, 957 wxNotifyEvent, 958 wxNotifyEvent::Allow, 958 wxNotifyEvent::IsAllowed, 958 wxNotifyEvent::Veto, 959 wxNotifyEvent::wxNotifyEvent, 958 wxNow, 1535 wxObjArray, 49 wxObjArray::Detach, 51 wxObject, 959 wxObject::~wxObject, 959 wxObject::Dump, 960 wxObject::GetClassInfo, 960 wxObject::GetRefData, 960 wxObject::IsKindOf, 961 wxObject::m_refData, 960 wxObject::operator delete, 962 wxObject::operator new, 962 wxObject::Ref, 961 wxObject::SetRefData, 961 wxObject::UnRef, 962 wxObject::wxObject, 959 wxObjectRefData, 963 wxObjectRefData::~wxObjectRefData, 963 wxObjectRefData::m_count, 963 wxObjectRefData::wxObjectRefData, 963 wxODBC - Basic Step-By-Step Guide, 1685 wxODBC - Compiling, 1684 wxODBC - Configuring your system for ODBC use, 1684 wxODBC - Known Issues, 1694 wxODBC - Sample Code, 1696 wxODBC Where To Start, 1681 wxOnAssert, 1537 wxOpenClipboard, 1512 wxOpenErrorTraverser::OnOpenError, 391 wxOutputStream, 963 wxOutputStream::~wxOutputStream, 963 wxOutputStream::LastWrite, 964 wxOutputStream::PutC, 964 wxOutputStream::SeekO, 964 wxOutputStream::TellO, 964 wxOutputStream::Write, 964 wxOutputStream::wxOutputStream, 963 wxPageSetupDialog, 965 wxPageSetupDialog::~wxPageSetupDialog, 965 wxPageSetupDialog::GetPageSetupData, 965 wxPageSetupDialog::ShowModal, 965 wxPageSetupDialog::wxPageSetupDialog, 965 wxPageSetupDialogData, 966 wxPageSetupDialogData::~wxPageSetupDialogD ata, 966 wxPageSetupDialogData::EnableHelp, 966 wxPageSetupDialogData::EnableMargins, 967 wxPageSetupDialogData::EnableOrientation, 967 wxPageSetupDialogData::EnablePaper, 967 wxPageSetupDialogData::EnablePrinter, 967 wxPageSetupDialogData::GetDefaultInfo, 968 wxPageSetupDialogData::GetDefaultMinMargins, 967 wxPageSetupDialogData::GetEnableHelp, 968 wxPageSetupDialogData::GetEnableMargins, 967 wxPageSetupDialogData::GetEnableOrientation, 967 wxPageSetupDialogData::GetEnablePaper, 968 wxPageSetupDialogData::GetEnablePrinter, 968 wxPageSetupDialogData::GetMarginBottomRight , 968 wxPageSetupDialogData::GetMarginTopLeft, 968 wxPageSetupDialogData::GetMinMarginBottomR ight, 968 wxPageSetupDialogData::GetMinMarginTopLeft, 968 wxPageSetupDialogData::GetPaperId, 969 wxPageSetupDialogData::GetPaperSize, 969 wxPageSetupDialogData::GetPrintData, 969 wxPageSetupDialogData::Ok, 969 wxPageSetupDialogData::operator =, 971 wxPageSetupDialogData::SetDefaultInfo, 969 wxPageSetupDialogData::SetDefaultMinMargins, 969 wxPageSetupDialogData::SetMarginBottomRight , 970 wxPageSetupDialogData::SetMarginTopLeft, 970 wxPageSetupDialogData::SetMinMarginBottomRi ght, 970 wxPageSetupDialogData::SetMinMarginTopLeft,

1787


INDEX
970 wxPageSetupDialogData::SetPaperId, 970 wxPageSetupDialogData::SetPaperSize, 970 wxPageSetupDialogData::SetPrintData, 970 wxPageSetupDialogData::wxPageSetupDialogDa ta, 966 wxPaintDC, 971 wxPaintDC::wxPaintDC, 971 wxPaintEvent, 973 wxPaintEvent::wxPaintEvent, 973 wxPalette, 974 wxPalette::~wxPalette, 974 wxPalette::Create, 974 wxPalette::GetPixel, 975 wxPalette::GetRGB, 976 wxPalette::Ok, 976 wxPalette::operator !=, 977 wxPalette::operator =, 976 wxPalette::operator ==, 977 wxPalette::wxPalette, 973 wxPanel, 978 wxPanel::~wxPanel, 978 wxPanel::Create, 978 wxPanel::GetDefaultItem, 979 wxPanel::InitDialog, 979 wxPanel::OnSysColourChanged, 979 wxPanel::SetDefaultItem, 979 wxPanel::wxPanel, 978 wxPaperSize, 1005 wxPathList, 980 wxPathList::Add, 980 wxPathList::AddEnvList, 980 wxPathList::EnsureFileAccessible, 981 wxPathList::FindAbsoluteValidPath, 981 wxPathList::FindValidPath, 981 wxPathList::Member, 981 wxPathList::wxPathList, 980 wxPathOnly, 1485 wxPCXHandler, 733 wxPen, 982, 983 wxPen::~wxPen, 984 wxPen::GetCap, 984 wxPen::GetColour, 985 wxPen::GetDashes, 985 wxPen::GetJoin, 985 wxPen::GetStipple, 985 wxPen::GetStyle, 986 wxPen::GetWidth, 986 wxPen::Ok, 986 wxPen::operator !=, 988 wxPen::operator =, 988 wxPen::operator ==, 988 wxPen::SetCap, 986 wxPen::SetColour, 986 wxPen::SetDashes, 987 wxPen::SetJoin, 987 wxPen::SetStipple, 987 wxPen::SetStyle, 987 wxPen::SetWidth, 988 wxPen::wxPen, 982 wxPenList, 989 wxPenList::AddPen, 989 wxPenList::FindOrCreatePen, 989 wxPenList::RemovePen, 990 wxPenList::wxPenList, 989 wxPLOT_BUTTON_ALL, 992 wxPLOT_BUTTON_ENLARGE, 992 wxPLOT_BUTTON_MOVE, 992 wxPLOT_BUTTON_ZOOM, 992 wxPLOT_DEFAULT, 992 wxPLOT_X_AXIS, 992 wxPLOT_Y_AXIS, 992 wxPlotCurve, 990 wxPlotCurve::GetEndX, 990 wxPlotCurve::GetEndY, 990 wxPlotCurve::GetOffsetY, 991 wxPlotCurve::GetStartX, 991 wxPlotCurve::GetStartY, 991 wxPlotCurve::GetY, 991 wxPlotCurve::SetEndY, 991 wxPlotCurve::SetOffsetY, 991 wxPlotCurve::SetStartY, 991 wxPlotCurve::wxPlotCurve, 990 wxPlotWindow, 993 wxPlotWindow::~wxPlotWindow, 993 wxPlotWindow::Add, 993 wxPlotWindow::Delete, 994 wxPlotWindow::Enlarge, 994 wxPlotWindow::GetAt, 993 wxPlotWindow::GetCount, 993 wxPlotWindow::GetCurrent, 993 wxPlotWindow::GetUnitsPerValue, 994 wxPlotWindow::GetZoom, 994 wxPlotWindow::Move, 994 wxPlotWindow::RedrawEverything, 995 wxPlotWindow::RedrawXAxis, 995 wxPlotWindow::RedrawYAxis, 995 wxPlotWindow::SetCurrent, 993 wxPlotWindow::SetEnlargeAroundWindowCentre , 995 wxPlotWindow::SetScrollOnThumbRelease, 995 wxPlotWindow::SetUnitsPerValue, 994 wxPlotWindow::SetZoom, 994 wxPlotWindow::wxPlotWindow, 993 wxPNGHandler, 733 wxPNMHandler, 733 wxPoint, 996 wxPoint::wxPoint, 996 wxPoint::x, 996 wxPoint::y, 996 wxPostDelete, 1519 wxPostEvent, 1519 wxPostScriptDC, 997 wxPostScriptDC::GetResolution, 997 wxPostScriptDC::SetResolution, 997 wxPostScriptDC::wxPostScriptDC, 997 wxPreviewCanvas, 998 wxPreviewCanvas::~wxPreviewCanvas, 998 wxPreviewCanvas::OnPaint, 998 wxPreviewCanvas::wxPreviewCanvas, 998 wxPreviewControlBar, 999 wxPreviewControlBar::~wxPreviewControlBar, 999 wxPreviewControlBar::CreateButtons, 999

1788


INDEX
wxPreviewControlBar::GetPrintPreview, 999 wxPreviewControlBar::GetZoomControl, 999 wxPreviewControlBar::SetZoomControl, 1000 wxPreviewControlBar::wxPreviewControlbar, 999 wxPreviewFrame, 1000 wxPreviewFrame::~wxPreviewFrame, 1000 wxPreviewFrame::CreateCanvas, 1001 wxPreviewFrame::CreateControlBar, 1000 wxPreviewFrame::Initialize, 1001 wxPreviewFrame::OnCloseWindow, 1001 wxPreviewFrame::wxPreviewFrame, 1000 wxPrintData, 1002 wxPrintData::~wxPrintData, 1002 wxPrintData::GetCollate, 1002 wxPrintData::GetColour, 1003 wxPrintData::GetDuplex, 1003 wxPrintData::GetNoCopies, 1003 wxPrintData::GetOrientation, 1003 wxPrintData::GetPaperId, 1003 wxPrintData::GetPrinterName, 1003 wxPrintData::GetQuality, 1003 wxPrintData::Ok, 1004 wxPrintData::operator =, 1006 wxPrintData::SetCollate, 1004 wxPrintData::SetColour, 1004 wxPrintData::SetDuplex, 1004 wxPrintData::SetNoCopies, 1004 wxPrintData::SetOrientation, 1004 wxPrintData::SetPaperId, 1005 wxPrintData::SetPrinterName, 1006 wxPrintData::SetQuality, 1006 wxPrintData::wxPrintData, 1002 wxPrintDialog, 1007 wxPrintDialog overview, 1660 wxPrintDialog::~wxPrintDialog, 1007 wxPrintDialog::GetPrintDC, 1008 wxPrintDialog::GetPrintDialogData, 1007 wxPrintDialog::Ok, 1008 wxPrintDialog::ShowModal, 1008 wxPrintDialog::wxPrintDialog, 1007 wxPrintDialogData, 1008, 1009 wxPrintDialogData::~wxprintdialogdata, 1009 wxPrintDialogData::EnableHelp, 1009 wxPrintDialogData::EnablePageNumbers, 1009 wxPrintDialogData::EnablePrintToFile, 1009 wxPrintDialogData::EnableSelection, 1009 wxPrintDialogData::GetAllPages, 1009 wxPrintDialogData::GetCollate, 1009 wxPrintDialogData::GetFromPage, 1010 wxPrintDialogData::GetMaxPage, 1010 wxPrintDialogData::GetMinPage, 1010 wxPrintDialogData::GetNoCopies, 1010 wxPrintDialogData::GetPrintData, 1010 wxPrintDialogData::GetPrintToFile, 1010 wxPrintDialogData::GetSelection, 1010 wxPrintDialogData::GetToPage, 1011 wxPrintDialogData::Ok, 1011 wxPrintDialogData::operator =, 1012 wxPrintDialogData::SetCollate, 1011 wxPrintDialogData::SetFromPage, 1011 wxPrintDialogData::SetMaxPage, 1011 wxPrintDialogData::SetMinPage, 1011 wxPrintDialogData::SetNoCopies, 1011 wxPrintDialogData::SetPrintData, 1012 wxPrintDialogData::SetPrintToFile, 1012 wxPrintDialogData::SetSelection, 1012 wxPrintDialogData::SetSetupDialog, 1012 wxPrintDialogData::SetToPage, 1012 wxPrintDialogData::wxPrintDialogData, 1008 wxPrinter, 1013 wxPrinter::~wxPrinter, 1013 wxPrinter::Abort, 1013 wxPrinter::CreateAbortWindow, 1013 wxPrinter::GetLastError, 1014 wxPrinter::GetPrintDialogData, 1014 wxPrinter::Print, 1014 wxPrinter::PrintDialog, 1014 wxPrinter::ReportError, 1014 wxPrinter::Setup, 1015 wxPrinter::wxPrinter, 1013 wxPrinterDC, 1015 wxPrinterDC::wxPrinterDC, 1015 wxPrintout, 1016 wxPrintout::~wxPrintout, 1016 wxPrintout::GetDC, 1016 wxPrintout::GetPageInfo, 1016 wxPrintout::GetPageSizeMM, 1017 wxPrintout::GetPageSizePixels, 1017 wxPrintout::GetPPIPrinter, 1017 wxPrintout::GetPPIScreen, 1018 wxPrintout::GetTitle, 1018 wxPrintout::HasPage, 1018 wxPrintout::IsPreview, 1018 wxPrintout::OnBeginDocument, 1018 wxPrintout::OnBeginPrinting, 1019 wxPrintout::OnEndDocument, 1019 wxPrintout::OnEndPrinting, 1019 wxPrintout::OnPreparePrinting, 1019 wxPrintout::OnPrintPage, 1019 wxPrintout::wxPrintout, 1016 wxPrintPreview, 1020 wxPrintPreview::~wxPrintPreview, 1020 wxPrintPreview::DrawBlankPage, 1020 wxPrintPreview::GetCanvas, 1021 wxPrintPreview::GetCurrentPage, 1021 wxPrintPreview::GetFrame, 1021 wxPrintPreview::GetMaxPage, 1021 wxPrintPreview::GetMinPage, 1021 wxPrintPreview::GetPrintData, 1021 wxPrintPreview::GetPrintout, 1021 wxPrintPreview::GetPrintoutForPrinting, 1022 wxPrintPreview::Ok, 1022 wxPrintPreview::PaintPage, 1022 wxPrintPreview::Print, 1022 wxPrintPreview::RenderPage, 1022 wxPrintPreview::SetCanvas, 1022 wxPrintPreview::SetCurrentPage, 1023 wxPrintPreview::SetFrame, 1023 wxPrintPreview::SetPrintout, 1023 wxPrintPreview::SetZoom, 1023 wxPrintPreview::wxPrintPreview, 1020 wxPrivateDropTarget, 1023 wxPrivateDropTarget::GetId, 1024 wxPrivateDropTarget::SetId, 1024

1789


INDEX
wxPrivateDropTarget::wxPrivateDropTarget, 1023 wxProcess, 1025 wxProcess::~wxProcess, 1025 wxProcess::CloseOutput, 1025 wxProcess::Detach, 1025 wxProcess::Exists, 1028 wxProcess::GetErrorStream, 1026 wxProcess::GetInputStream, 1026 wxProcess::GetOutputStream, 1026 wxProcess::IsErrorAvailable, 1026 wxProcess::IsInputAvailable, 1026 wxProcess::IsInputOpened, 1027 wxProcess::Kill, 1027 wxProcess::OnTerminate, 1028 wxProcess::Open, 1028 wxProcess::Redirect, 1029 wxProcess::wxProcess, 1025 wxProcessEvent, 1029 wxProcessEvent::GetExitCode, 1030 wxProcessEvent::GetPid, 1030 wxProcessEvent::wxProcessEvent, 1029 wxProgressDialog, 1030 wxProgressDialog::~wxProgressDialog, 1031 wxProgressDialog::Resume, 1031 wxProgressDialog::Update, 1031 wxProgressDialog::wxProgressDialog, 1030 wxProtocol::Abort, 1033 wxProtocol::GetContentType, 1034 wxProtocol::GetError, 1033 wxProtocol::GetInputStream, 1032 wxProtocol::Reconnect, 1032 wxProtocol::SetPassword, 1034 wxProtocol::SetUser, 1034 wxQuantize, 1034 wxQuantize::DoQuantize, 1035 wxQuantize::Quantize, 1034 wxQuantize::wxQuantize, 1034 wxQueryLayoutInfoEvent, 1036 wxQueryLayoutInfoEvent::GetAlignment, 1036 wxQueryLayoutInfoEvent::GetFlags, 1036 wxQueryLayoutInfoEvent::GetOrientation, 1036 wxQueryLayoutInfoEvent::GetRequestedLength, 1037 wxQueryLayoutInfoEvent::GetSize, 1037 wxQueryLayoutInfoEvent::SetAlignment, 1037 wxQueryLayoutInfoEvent::SetFlags, 1037 wxQueryLayoutInfoEvent::SetOrientation, 1037 wxQueryLayoutInfoEvent::SetRequestedLength, 1037 wxQueryLayoutInfoEvent::SetSize, 1038 wxQueryLayoutInfoEvent::wxQueryLayoutInfoEv ent, 1036 wxRA_SPECIFY_COLS, 1038 wxRA_SPECIFY_ROWS, 1038 wxRadioBox, 1038, 1039 wxRadioBox::~wxRadioBox, 1040 wxRadioBox::Create, 1040 wxRadioBox::Enable, 1040 wxRadioBox::FindString, 1041 wxRadioBox::GetCount, 1041 wxRadioBox::GetLabel, 1041 wxRadioBox::GetSelection, 1042 wxRadioBox::GetString, 1042 wxRadioBox::GetStringSelection, 1042 wxRadioBox::Number, 1042 wxRadioBox::SetLabel, 1042 wxRadioBox::SetSelection, 1043 wxRadioBox::SetStringSelection, 1043 wxRadioBox::Show, 1044 wxRadioBox::wxRadioBox, 1038 wxRadioButton, 1045 wxRadioButton::~wxRadioButton, 1046 wxRadioButton::Create, 1046 wxRadioButton::GetValue, 1046 wxRadioButton::SetValue, 1046 wxRadioButton::wxRadioButton, 1045 wxRAISED_BORDER, 1394 wxRB_GROUP, 1044 wxRB_SINGLE, 1044 wxRealPoint, 1047 wxRealPoint::wxRealPoint, 1047 wxRect, 813, 1048 wxRect::Deflate, 1048 wxRect::GetBottom, 1049 wxRect::GetBottomRight, 1049 wxRect::GetHeight, 1049 wxRect::GetLeft, 1049 wxRect::GetPosition, 1049 wxRect::GetRight, 1050 wxRect::GetSize, 1050 wxRect::GetTop, 1050 wxRect::GetTopLeft, 1049 wxRect::GetWidth, 1050 wxRect::GetX, 1050 wxRect::GetY, 1050 wxRect::height, 1048 wxRect::Inflate, 1050 wxRect::Offset, 1051 wxRect::operator !=, 1052 wxRect::operator =, 1052 wxRect::operator ==, 1052 wxRect::SetHeight, 1051 wxRect::SetWidth, 1051 wxRect::SetX, 1052 wxRect::SetY, 1052 wxRect::width, 1048 wxRect::wxRect, 1047 wxRect::x, 1048 wxRect::y, 1048 wxRect:Inside, 1051 wxRect:Intersects, 1051 wxRecursionGuard, 1053 wxRecursionGuard::~wxRecursionGuard, 1053 wxRecursionGuard::IsInside, 1053 wxRecursionGuard::wxRecursionGuard, 1053 wxRegEx, 1056 wxRegEx::~wxRegEx, 1056 wxRegEx::Compile, 1056 wxRegEx::GetMatch, 1056 wxRegEx::IsValid, 1056 wxRegEx::Matches, 1057 wxRegEx::Replace, 1057 wxRegEx::ReplaceAll, 1057

1790


INDEX
wxRegEx::ReplaceFirst, 1057 wxRegEx::wxRegEx, 1056 wxRegion, 1058 wxRegion::~wxRegion, 1059 wxRegion::Clear, 1059 wxRegion::Contains, 1059 wxRegion::ConvertToBitmap, 1059 wxRegion::GetBox, 1059 wxRegion::Intersect, 1060 wxRegion::IsEmpty, 1060 wxRegion::Offset, 1061 wxRegion::operator =, 1062 wxRegion::Subtract, 1060 wxRegion::Union, 1061 wxRegion::wxRegion, 1058 wxRegion::Xor, 1061 wxRegionIterator, 1062, 1063 wxRegionIterator::GetH, 1063 wxRegionIterator::GetHeight, 1063 wxRegionIterator::GetRect, 1063 wxRegionIterator::GetW, 1063 wxRegionIterator::GetWidth, 1063 wxRegionIterator::GetX, 1063 wxRegionIterator::GetY, 1063 wxRegionIterator::HaveRects, 1064 wxRegionIterator::operator ++, 1064 wxRegionIterator::operator bool, 1064 wxRegionIterator::Reset, 1064 wxRegionIterator::wxRegionIterator, 1062 wxRegisterClipboardFormat, 1512 wxRegisterId, 1515 wxRelationship, 763 wxRemoveFile, 1486 wxRenameFile, 1486 wxRendererNative::~wxRendererNative, 1065 wxRendererNative::DrawHeaderButton, 1066 wxRendererNative::DrawSplitterBorder, 1066 wxRendererNative::DrawSplitterSash, 1066 wxRendererNative::DrawTreeItemButton, 1066 wxRendererNative::Get, 1066 wxRendererNative::GetDefault, 1066 wxRendererNative::GetGeneric, 1067 wxRendererNative::GetSplitterParams, 1067 wxRendererNative::GetVersion, 1067 wxRendererNative::Load, 1067 wxRendererNative::Set, 1067 wxRendererVersion::age, 1068 wxRendererVersion::IsCompatible, 1068 wxRendererVersion::version, 1068 wxRESIZE_BORDER, 371, 534, 874, 880, 927 wxRETAINED, 1092 wxRmdir, 1486 wxSafeShowMessage, 1532 wxSafeYield, 1475 wxSashEvent, 1070 wxSashEvent::GetDragRect, 1070 wxSashEvent::GetDragStatus, 1070 wxSashEvent::GetEdge, 1070 wxSashEvent::wxSashEvent, 1070 wxSashLayoutWindow, 1071 wxSashLayoutWindow::~wxSashLayoutWindow, 1072 wxSashLayoutWindow::GetAlignment, 1072 wxSashLayoutWindow::GetOrientation, 1072 wxSashLayoutWindow::OnCalculateLayout, 1072 wxSashLayoutWindow::OnQueryLayoutInfo, 1072 wxSashLayoutWindow::SetAlignment, 1073 wxSashLayoutWindow::SetDefaultSize, 1073 wxSashLayoutWindow::SetOrientation, 1073 wxSashLayoutWindow::wxSashLayoutWindow, 1071 wxSashWindow, 1074 wxSashWindow::~wxSashWindow, 1075 wxSashWindow::GetMaximumSizeX, 1075 wxSashWindow::GetMaximumSizeY, 1076 wxSashWindow::GetMinimumSizeX, 1076 wxSashWindow::GetMinimumSizeY, 1076 wxSashWindow::GetSashVisible, 1075 wxSashWindow::HasBorder, 1076 wxSashWindow::SetMaximumSizeX, 1076 wxSashWindow::SetMaximumSizeY, 1076 wxSashWindow::SetMinimumSizeX, 1077 wxSashWindow::SetMinimumSizeY, 1077 wxSashWindow::SetSashBorder, 1077 wxSashWindow::SetSashVisible, 1077 wxSashWindow::wxSashWindow, 1074 wxSB_HORIZONTAL, 1085 wxSB_VERTICAL, 1085 wxScopedArray, 1080 wxScopedArray::get, 1080 wxScopedArray::operator [], 1080 wxScopedArray::reset, 1080 wxScopedArray::swap, 1081 wxScopedArray::wxScopedArray, 1080 wxScopedPtr::~wxScopedPtr, 1082 wxScopedPtr::get, 1083 wxScopedPtr::operator *, 1083 wxScopedPtr::operator ->, 1083 wxScopedPtr::release, 1082 wxScopedPtr::reset, 1083 wxScopedPtr::swap, 1083 wxScopedPtr::wxScopedPtr, 1082 wxScopedTiedPtr, 1084 wxScopedTiedPtr::~wxScopedTiedPtr, 1084 wxScopedTiedPtr::wxScopedTiedPtr, 1084 wxScreenDC, 1078 wxScreenDC::EndDrawingOnTop, 1079 wxScreenDC::StartDrawingOnTop, 1078 wxScreenDC::wxScreenDC, 1078 wxScrollBar, 1087 wxScrollBar::~wxScrollBar, 1088 wxScrollBar::Create, 1088 wxScrollBar::GetPageSize, 1089 wxScrollBar::GetRange, 1088 wxScrollBar::GetThumbLength, 1089 wxScrollBar::GetThumbPosition, 1089 wxScrollBar::SetScrollbar, 1089 wxScrollBar::SetThumbPosition, 1089 wxScrollBar::wxScrollBar, 1087 wxScrolledWindow, 1092 wxScrolledWindow::~wxScrolledWindow, 1093 wxScrolledWindow::CalcScrolledPosition, 1093 wxScrolledWindow::CalcUnscrolledPosition,

1791


INDEX
1094 wxScrolledWindow::Create, 1094 wxScrolledWindow::EnableScrolling, 1094 wxScrolledWindow::GetScrollPixelsPerUnit, 1095 wxScrolledWindow::GetViewStart, 1095 wxScrolledWindow::GetVirtualSize, 1096 wxScrolledWindow::IsRetained, 1096 wxScrolledWindow::OnDraw, 1097 wxScrolledWindow::PrepareDC, 1097 wxScrolledWindow::Scroll, 1097 wxScrolledWindow::SetScrollbars, 1098 wxScrolledWindow::SetScrollRate, 1099 wxScrolledWindow::SetTargetWindow, 1099 wxScrolledWindow::wxScrolledWindow, 1092 wxScrollEvent, 1102 wxScrollEvent::GetOrientation, 1102 wxScrollEvent::GetPosition, 1102 wxScrollEvent::wxScrollEvent, 1102 wxScrollWinEvent, 1103 wxScrollWinEvent::GetOrientation, 1103 wxScrollWinEvent::GetPosition, 1104 wxScrollWinEvent::wxScrollWinEvent, 1103 wxSemaphore, 1104 wxSemaphore::~wxSemaphore, 1105 wxSemaphore::Post, 1105 wxSemaphore::TryWait, 1105 wxSemaphore::Wait, 1105 wxSemaphore::WaitTimeout, 1106 wxSemaphore::wxSemaphore, 1104 wxServer, 1107 wxServer::Create, 1107 wxServer::OnAcceptConnection, 1107 wxServer::wxServer, 1107 wxSetClipboardData, 1512 wxSetCursor, 1508 wxSetDisplayName, 1519 wxSetEnv, 1541 wxSetPrinterCommand, 1509 wxSetPrinterFile, 1510 wxSetPrinterMode, 1510 wxSetPrinterOptions, 1510 wxSetPrinterOrientation, 1510 wxSetPrinterPreviewCommand, 1510 wxSetPrinterScaling, 1510 wxSetPrinterTranslation, 1510 wxSetWorkingDirectory, 1487 wxShell, 1479 wxShowTip, 1505 wxShutdown, 1479 wxSIMPLE_BORDER, 1394 wxSingleChoiceDialog, 1108 wxSingleChoiceDialog overview, 1661 wxSingleChoiceDialog::~wxSingleChoiceDialog, 1109 wxSingleChoiceDialog::GetSelection, 1109 wxSingleChoiceDialog::GetSelectionClientData, 1109 wxSingleChoiceDialog::GetStringSelection, 1109 wxSingleChoiceDialog::SetSelection, 1110 wxSingleChoiceDialog::ShowModal, 1110 wxSingleChoiceDialog::wxSingleChoiceDialog, 1108 wxSingleInstanceChecker, 1111 wxSingleInstanceChecker::~wxSingleInstanceCh ecker, 1112 wxSingleInstanceChecker::Create, 1111 wxSingleInstanceChecker::IsAnotherRunning, 1112 wxSingleInstanceChecker::wxSingleInstanceChe cker, 1111 wxSize, 1112 wxSize::DecTo, 1112 wxSize::GetHeight, 1113 wxSize::GetWidth, 1113 wxSize::IncTo, 1113 wxSize::operator =, 1114 wxSize::Set, 1113 wxSize::SetHeight, 1113 wxSize::SetWidth, 1113 wxSize::wxSize, 1112 wxSizeEvent, 1114 wxSizeEvent::GetSize, 1115 wxSizeEvent::wxSizeEvent, 1114 wxSizer, 1115 wxSizer::~wxSizer, 1116 wxSizer::Add, 1116 wxSizer::CalcMin, 1117 wxSizer::Detach, 1117 wxSizer::Fit, 1118 wxSizer::FitInside, 1118 wxSizer::GetMinSize, 1119 wxSizer::GetPosition, 1118 wxSizer::GetSize, 1118 wxSizer::Insert, 1119 wxSizer::Layout, 1119 wxSizer::Prepend, 1119 wxSizer::RecalcSizes, 1120 wxSizer::Remove, 1120 wxSizer::SetDimension, 1120 wxSizer::SetItemMinSize, 1121 wxSizer::SetMinSize, 1120 wxSizer::SetSizeHints, 1121 wxSizer::SetVirtualSizeHints, 1121 wxSizer::Show, 1121 wxSizer::wxSizer, 1115 wxSizerItem, 1122 wxSizerItem::~wxSizerItem, 1122 wxSizerItem::CalcMin, 1122 wxSizerItem::DeleteWindows, 1122 wxSizerItem::DetachSizer, 1123 wxSizerItem::GetBorder, 1123 wxSizerItem::GetFlag, 1123 wxSizerItem::GetMinSize, 1123 wxSizerItem::GetPosition, 1123 wxSizerItem::GetProportion, 1123 wxSizerItem::GetRatio, 1123 wxSizerItem::GetSize, 1123 wxSizerItem::GetSizer, 1124 wxSizerItem::GetSpacer, 1124 wxSizerItem::GetUserData, 1124 wxSizerItem::GetWindow, 1124 wxSizerItem::IsShown, 1124 wxSizerItem::IsSizer, 1124 wxSizerItem::IsSpacer, 1124

1792


INDEX
wxSizerItem::IsWindow, 1125 wxSizerItem::SetBorder, 1125 wxSizerItem::SetDimension, 1125 wxSizerItem::SetFlag, 1125 wxSizerItem::SetInitSize, 1125 wxSizerItem::SetProportion, 1125 wxSizerItem::SetRatio, 1125 wxSizerItem::SetSizer, 1126 wxSizerItem::SetSpacer, 1126 wxSizerItem::SetWindow, 1126 wxSizerItem::Show, 1126 wxSizerItem::wxSizerItem, 1122 wxSL_AUTOTICKS, 1127 wxSL_HORIZONTAL, 1127 wxSL_LABELS, 1127 wxSL_LEFT, 1127 wxSL_RIGHT, 1127 wxSL_SELRANGE, 1127 wxSL_TOP, 1127 wxSL_VERTICAL, 1127 wxSleep, 1536 wxSlider, 1129 wxSlider::~wxSlider, 1130 wxSlider::ClearSel, 1130 wxSlider::ClearTicks, 1130 wxSlider::Create, 1131 wxSlider::GetLineSize, 1131 wxSlider::GetMax, 1131 wxSlider::GetMin, 1131 wxSlider::GetPageSize, 1131 wxSlider::GetSelEnd, 1132 wxSlider::GetSelStart, 1132 wxSlider::GetThumbLength, 1132 wxSlider::GetTickFreq, 1132 wxSlider::GetValue, 1133 wxSlider::SetLineSize, 1133 wxSlider::SetPageSize, 1134 wxSlider::SetRange, 1133 wxSlider::SetSelection, 1134 wxSlider::SetThumbLength, 1135 wxSlider::SetTick, 1135 wxSlider::SetTickFreq, 1133 wxSlider::SetValue, 1135 wxSlider::wxSlider, 1129 wxSnprintf, 1494 wxSockAddress, 1136 wxSockAddress::~wxSockAddress, 1136 wxSockAddress::Clear, 1136 wxSockAddress::SockAddrLen, 1136 wxSockAddress::wxSockAddress, 1136 wxSocketBase, 1140 wxSocketBase::~wxSocketBase, 1140 wxSocketBase::Callback, 1140 wxSocketBase::CallbackData, 1140 wxSocketBase::Close, 1141 wxSocketBase::Destroy, 1141 wxSocketBase::Discard, 1141 wxSocketBase::Error, 1142 wxSocketBase::GetClientData, 1142 wxSocketBase::GetFlags, 1142 wxSocketBase::GetLocal, 1142 wxSocketBase::GetPeer, 1142 wxSocketBase::InterruptWait, 1142 wxSocketBase::IsConnected, 1143 wxSocketBase::IsData, 1143 wxSocketBase::IsDisconnected, 1143 wxSocketBase::LastCount, 1143 wxSocketBase::LastError, 1143 wxSocketBase::Notify, 1144 wxSocketBase::Ok, 1144 wxSocketBase::Peek, 1147 wxSocketBase::Read, 1148 wxSocketBase::ReadMsg, 1148 wxSocketBase::RestoreState, 1144 wxSocketBase::SaveState, 1144 wxSocketBase::SetClientData, 1145 wxSocketBase::SetEventHandler, 1145 wxSocketBase::SetFlags, 1145 wxSocketBase::SetNotify, 1146 wxSocketBase::SetTimeout, 1147 wxSocketBase::Unread, 1149 wxSocketBase::Wait, 1150 wxSocketBase::WaitForLost, 1150 wxSocketBase::WaitForRead, 1151 wxSocketBase::WaitForWrite, 1151 wxSocketBase::Write, 1152 wxSocketBase::WriteMsg, 1153 wxSocketBase::wxSocketBase, 1139 wxSocketClient, 1154 wxSocketClient::~wxSocketClient, 1154 wxSocketClient::Connect, 1154 wxSocketClient::WaitOnConnect, 1155 wxSocketClient::wxSocketClient, 1154 wxSocketEvent, 1156 wxSocketEvent::GetClientData, 1156 wxSocketEvent::GetSocket, 1156 wxSocketEvent::GetSocketEvent, 1156 wxSocketEvent::wxSocketEvent, 1156 wxSocketInputStream, 1157 wxSocketInputStream::wxSocketInputStream, 1157 wxSocketOutputStream::wxSocketOutputStream, 1157 wxSocketServer, 1158 wxSocketServer::~wxSocketServer, 1158 wxSocketServer::Accept, 1158 wxSocketServer::AcceptWith, 1159 wxSocketServer::WaitForAccept, 1159 wxSocketServer::wxSocketServer, 1158 wxSortedArray, 49 wxSound, 1391 wxSound::~wxSound, 1392 wxSound::Create, 1392 wxSound::IsOk, 1392 wxSound::IsPlaying, 1392 wxSound::Play, 1392 wxSound::Stop, 1393 wxSound::wxSound, 1391 wxSP_3D, 1172 wxSP_3DBORDER, 1172 wxSP_3DSASH, 1172 wxSP_ARROW_KEYS, 1160, 1164 wxSP_BORDER, 1172 wxSP_HORIZONTAL, 1160

1793


INDEX
wxSP_LIVE_UPDATE, 1172 wxSP_NOBORDER, 1172 wxSP_PERMIT_UNSPLIT, 1172 wxSP_VERTICAL, 1160 wxSP_WRAP, 1160, 1164 wxSpinButton, 1161 wxSpinButton::~wxSpinButton, 1162 wxSpinButton::Create, 1162 wxSpinButton::GetMax, 1162 wxSpinButton::GetMin, 1162 wxSpinButton::GetValue, 1162 wxSpinButton::SetRange, 1163 wxSpinButton::SetValue, 1163 wxSpinButton::wxSpinButton, 1161 wxSpinCtrl, 1164 wxSpinCtrl::Create, 1165 wxSpinCtrl::GetMax, 1166 wxSpinCtrl::GetMin, 1166 wxSpinCtrl::GetValue, 1165 wxSpinCtrl::SetRange, 1166 wxSpinCtrl::SetSelection, 1166 wxSpinCtrl::SetValue, 1165 wxSpinCtrl::wxSpinCtrl, 1164 wxSpinEvent, 1167 wxSpinEvent::GetPosition, 1167 wxSpinEvent::SetPosition, 1167 wxSpinEvent::wxSpinEvent, 1167 wxSplashScreen, 1168 wxSplashScreen::~wxSplashScreen, 1168 wxSplashScreen::GetSplashStyle, 1169 wxSplashScreen::GetSplashWindow, 1169 wxSplashScreen::GetTimeout, 1169 wxSplashScreen::OnCloseWindow, 1168 wxSplashScreen::wxSplashScreen, 1168 wxSplitPath, 1487 wxSplitterEvent, 1170 wxSplitterEvent::GetSashPosition, 1171 wxSplitterEvent::GetWindowBeingRemoved, 1171 wxSplitterEvent::GetX, 1171 wxSplitterEvent::GetY, 1171 wxSplitterEvent::SetSashPosition, 1171 wxSplitterEvent::wxSplitterEvent, 1170 wxSplitterRenderParams::border, 1181 wxSplitterRenderParams::isHotSensitive, 1182 wxSplitterWindow, 1173, 1174 wxSplitterWindow::~wxSplitterWindow, 1174 wxSplitterWindow::Create, 1175 wxSplitterWindow::GetMinimumPaneSize, 1175 wxSplitterWindow::GetSashPosition, 1175 wxSplitterWindow::GetSplitMode, 1175 wxSplitterWindow::GetWindow1, 1175 wxSplitterWindow::GetWindow2, 1175 wxSplitterWindow::Initialize, 1176 wxSplitterWindow::IsSplit, 1176 wxSplitterWindow::OnDoubleClickSash, 1176 wxSplitterWindow::OnSashPositionChange, 1177 wxSplitterWindow::OnUnsplit, 1177 wxSplitterWindow::ReplaceWindow, 1177 wxSplitterWindow::SetMinimumPaneSize, 1178 wxSplitterWindow::SetSashPosition, 1178 wxSplitterWindow::SetSplitMode, 1179 wxSplitterWindow::SplitHorizontally, 1179 wxSplitterWindow::SplitVertically, 1180 wxSplitterWindow::Unsplit, 1181 wxSplitterWindow::wxSplitterWindow, 1173 wxST_NO_AUTORESIZE, 1189 wxST_SIZEGRIP, 1191 wxStartTimer, 1536 wxSTATIC_BORDER, 1394 wxStaticBitmap, 1182 wxStaticBitmap::Create, 1183 wxStaticBitmap::GetBitmap, 1183 wxStaticBitmap::SetBitmap, 1184 wxStaticBitmap::wxStaticBitmap, 1182 wxStaticBox, 1185 wxStaticBox::~wxStaticBox, 1185 wxStaticBox::Create, 1186 wxStaticBox::wxStaticBox, 1185 wxStaticBoxSizer, 1186 wxStaticBoxSizer::GetStaticBox, 1186 wxStaticBoxSizer::wxStaticBoxSizer, 1186 wxStaticCast, 1527, 1528 wxStaticLine, 1187 wxStaticLine::Create, 1188 wxStaticLine::GetDefaultSize, 1188 wxStaticLine::IsVertical, 1188 wxStaticLine::wxStaticLine, 1187 wxStaticText, 1189 wxStaticText::Create, 1190 wxStaticText::GetLabel, 1190 wxStaticText::SetLabel, 1190 wxStaticText::wxStaticText, 1189 wxStatusBar, 1191 wxStatusBar::~wxStatusBar, 1192 wxStatusBar::Create, 1192 wxStatusBar::GetFieldRect, 1192 wxStatusBar::GetFieldsCount, 1193 wxStatusBar::GetStatusText, 1193 wxStatusBar::PopStatusText, 1193 wxStatusBar::PushStatusText, 1193 wxStatusBar::SetFieldsCount, 1193 wxStatusBar::SetMinHeight, 1194 wxStatusBar::SetStatusText, 1194 wxStatusBar::SetStatusWidths, 1194 wxStatusBar::wxStatusBar, 1191 wxSTAY_ON_TOP, 372, 534, 874, 880, 927 wxStopWatch, 1196 wxStopWatch::Pause, 1196 wxStopWatch::Resume, 1196 wxStopWatch::Start, 1196 wxStopWatch::Time, 1196 wxStopWatch::wxStopWatch, 1196 wxStrcmp, 1493 wxStreamBase, 1197 wxStreamBase::~wxStreamBase, 1197 wxStreamBase::GetLastError, 1197 wxStreamBase::GetSize, 1198 wxStreamBase::IsOk, 1197 wxStreamBase::OnSysRead, 1197 wxStreamBase::OnSysSeek, 1198 wxStreamBase::OnSysTell, 1198 wxStreamBase::OnSysWrite, 1198 wxStreamBase::wxStreamBase, 1197

1794


INDEX
wxStreamBuffer, 1199 wxStreamBuffer::~wxStreamBuffer, 1199 wxStreamBuffer::FillBuffer, 1204 wxStreamBuffer::Fixed, 1203 wxStreamBuffer::Flushable, 1203 wxStreamBuffer::FlushBuffer, 1203 wxStreamBuffer::GetBufferEnd, 1202 wxStreamBuffer::GetBufferPos, 1202 wxStreamBuffer::GetBufferStart, 1202 wxStreamBuffer::GetChar, 1200 wxStreamBuffer::GetDataLeft, 1204 wxStreamBuffer::GetIntPosition, 1203 wxStreamBuffer::GetLastAccess, 1203 wxStreamBuffer::PutChar, 1200 wxStreamBuffer::Read, 1199 wxStreamBuffer::ResetBuffer, 1201 wxStreamBuffer::Seek, 1201 wxStreamBuffer::SetBufferIO, 1201 wxStreamBuffer::SetIntPosition, 1203 wxStreamBuffer::Stream, 1204 wxStreamBuffer::Tell, 1201 wxStreamBuffer::Write, 1200 wxStreamBuffer::wxStreamBuffer, 1199 wxStreamToTextRedirector, 1205 wxStreamToTextRedirector::~wxStreamToTextR edirector, 1205 wxStreamToTextRedirector::wxStreamToTextRe director, 1205 wxStricmp, 1493 wxString, 1212, 1213 wxString::~wxString, 1213 wxString::AfterFirst, 1214 wxString::AfterLast, 1214 wxString::Alloc, 1213 wxString::Append, 1214 wxString::BeforeFirst, 1214 wxString::BeforeLast, 1214 wxString::c_str, 1214 wxString::Clear, 1214 wxString::Cmp, 1215 wxString::CmpNoCase, 1215 wxString::CompareTo, 1215 wxString::Contains, 1215 wxString::Empty, 1215 wxString::Find, 1216 wxString::First, 1216 wxString::Format, 1216 wxString::FormatV, 1216 wxString::Freq, 1216 wxString::FromAscii, 1217 wxString::GetChar, 1217 wxString::GetData, 1217 wxString::GetWritableChar, 1217 wxString::GetWriteBuf, 1217 wxString::Index, 1217 wxString::IsAscii, 1218 wxString::IsEmpty, 1218 wxString::IsNull, 1218 wxString::IsNumber, 1218 wxString::IsSameAs, 1218, 1219 wxString::IsWord, 1219 wxString::Last, 1219 wxString::Left, 1219 wxString::Len, 1219 wxString::Length, 1219 wxString::Lower, 1219 wxString::LowerCase, 1220 wxString::MakeLower, 1220 wxString::MakeUpper, 1220 wxString::Matches, 1220 wxString::Mid, 1220 wxString::operator (), 1226 wxString::operator [], 1226 wxString::operator +, 1225 wxString::operator +=, 1225 wxString::operator <<, 1226 wxString::operator =, 1225 wxString::operator >>, 1226 wxString::operator const char*, 1226 wxString::operator!, 1225 wxString::Pad, 1220 wxString::Prepend, 1220 wxString::Printf, 1221 wxString::PrintfV, 1221 wxString::Remove, 1221 wxString::RemoveLast, 1221 wxString::Replace, 1221 wxString::Right, 1222 wxString::SetChar, 1222 wxString::Shrink, 1222 wxString::sprintf, 1222 wxString::StartsWith, 1222 wxString::Strip, 1222 wxString::SubString, 1222 wxString::ToAscii, 1223 wxString::ToDouble, 1223 wxString::ToLong, 1223 wxString::ToULong, 1224 wxString::Trim, 1224 wxString::Truncate, 1224 wxString::UngetWriteBuf, 1224 wxString::Upper, 1224 wxString::UpperCase, 1225 wxString::wxString, 1212 wxStringBuffer, 1228 wxStringBuffer::~wxStringBuffer, 1228 wxStringBuffer::operator wxChar *, 1228 wxStringBuffer::wxStringBuffer, 1228 wxStringClientData, 1228, 1229 wxStringClientData::GetData, 1229 wxStringClientData::SetData, 1229 wxStringClientData::wxStringClientData, 1228 wxStringEq, 1493 wxStringList, 1229 wxStringList::~wxStringList, 1230 wxStringList::Add, 1230 wxStringList::Clear, 1230 wxStringList::Delete, 1230 wxStringList::ListToArray, 1230 wxStringList::Member, 1230 wxStringList::Sort, 1230 wxStringList::wxStringList, 1229 wxStringMatch, 1493 wxStringTokenizer, 1232

1795


INDEX
wxStringTokenizer::CountTokens, 1232 wxStringTokenizer::GetNextToken, 1232 wxStringTokenizer::GetPosition, 1232 wxStringTokenizer::GetString, 1233 wxStringTokenizer::HasMoreTokens, 1232 wxStringTokenizer::SetString, 1233 wxStringTokenizer::wxStringTokenizer, 1232 wxStripMenuCodes, 1520 wxStrlen, 1494 wxSUNKEN_BORDER, 1394 wxSW_3D, 1073 wxSW_3DBORDER, 1073 wxSW_3DSASH, 1073 wxSW_BORDER, 1074 wxSysColourChanged, 1234 wxSysColourChangedEvent::wxSysColourChang ed, 1234 wxSysErrorCode, 1532 wxSysErrorMsg, 1533 wxSYSTEM_MENU, 371, 534, 874, 880, 927 wxSystemOptions, 1234 wxSystemOptions::GetOption, 1235 wxSystemOptions::GetOptionInt, 1235 wxSystemOptions::HasOption, 1235 wxSystemOptions::SetOption, 1235 wxSystemOptions::wxSystemOptions, 1234 wxSystemSettings, 1236 wxSystemSettings::GetColour, 1236 wxSystemSettings::GetFont, 1237 wxSystemSettings::GetMetric, 1238 wxSystemSettings::wxSystemSettings, 1236 wxT, 1494 wxTAB_TRAVERSAL, 1394 wxTabCtrl, 1240 wxTabCtrl::~wxTabCtrl, 1241 wxTabCtrl::Create, 1241 wxTabCtrl::DeleteAllItems, 1241 wxTabCtrl::DeleteItem, 1241 wxTabCtrl::GetCurFocus, 1242 wxTabCtrl::GetImageList, 1242 wxTabCtrl::GetItemCount, 1242 wxTabCtrl::GetItemData, 1242 wxTabCtrl::GetItemImage, 1242 wxTabCtrl::GetItemRect, 1242 wxTabCtrl::GetItemText, 1242 wxTabCtrl::GetRowCount, 1243 wxTabCtrl::GetSelection, 1243 wxTabCtrl::HitTest, 1243 wxTabCtrl::InsertItem, 1244 wxTabCtrl::SetImageList, 1244 wxTabCtrl::SetItemData, 1244 wxTabCtrl::SetItemImage, 1244 wxTabCtrl::SetItemSize, 1245 wxTabCtrl::SetItemText, 1245 wxTabCtrl::SetPadding, 1245 wxTabCtrl::SetSelection, 1245 wxTabCtrl::wxTabCtrl, 1240 wxTabEvent, 1246 wxTabEvent::wxTabEvent, 1246 wxTaskBarIcon, 1247 wxTaskBarIcon::~wxTaskBarIcon, 1247 wxTaskBarIcon::IsIconInstalled, 1247 wxTaskBarIcon::IsOk, 1247 wxTaskBarIcon::PopupMenu, 1247 wxTaskBarIcon::RemoveIcon, 1247 wxTaskBarIcon::SetIcon, 1248 wxTaskBarIcon::wxTaskBarIcon, 1247 wxTB_DOCKABLE, 1317 wxTB_FLAT, 1317 wxTB_HORIZONTAL, 1317 wxTB_HORZ_LAYOUT, 1317 wxTB_HORZ_TEXT, 1317 wxTB_NOALIGN, 1317 wxTB_NODIVIDER, 1317 wxTB_NOICONS, 1317 wxTB_TEXT, 1317 wxTB_VERTICAL, 1317 wxTE_AUTO_URL, 1255 wxTE_CENTRE, 1255 wxTE_DONTWRAP, 1255 wxTE_LEFT, 1255 wxTE_LINEWRAP, 1255 wxTE_MULTILINE, 1255 wxTE_NOHIDESEL, 1255 wxTE_PASSWORD, 1255 wxTE_PROCESS_ENTER, 1255 wxTE_PROCESS_TAB, 1255 wxTE_READONLY, 1255 wxTE_RICH, 1255 wxTE_RICH2, 1255 wxTE_RIGHT, 1255 wxTE_WORDWRAP, 1255 wxTempFile, 1249 wxTempFile::~wxTempFile, 1250 wxTempFile::Commit, 1249 wxTempFile::Discard, 1250 wxTempFile::IsOpened, 1249 wxTempFile::Open, 1249 wxTempFile::Write, 1249 wxTempFile::wxTempFile, 1248, 1249 wxTextAttr, 1251 wxTextAttr::GetAlignment, 1252 wxTextAttr::GetBackgroundColour, 1252 wxTextAttr::GetFlags, 1253 wxTextAttr::GetFont, 1252 wxTextAttr::GetLeftIndent, 1252 wxTextAttr::GetRightIndent, 1252 wxTextAttr::GetTabs, 1252 wxTextAttr::GetTextColour, 1252 wxTextAttr::HasBackgroundColour, 1253 wxTextAttr::HasFont, 1253 wxTextAttr::HasTextColour, 1253 wxTextAttr::IsDefault, 1253 wxTextAttr::SetAlignment, 1253 wxTextAttr::SetBackgroundColour, 1253 wxTextAttr::SetFlags, 1253 wxTextAttr::SetFont, 1254 wxTextAttr::SetLeftIndent, 1254 wxTextAttr::SetRightIndent, 1254 wxTextAttr::SetTabs, 1254 wxTextAttr::SetTextColour, 1254 wxTextAttr::wxTextAttr, 1251 wxTextCtrl, 1258 wxTextCtrl::~wxTextCtrl, 1259

1796


INDEX
wxTextCtrl::AppendText, 1259 wxTextCtrl::CanCopy, 1260 wxTextCtrl::CanCut, 1260 wxTextCtrl::CanPaste, 1260 wxTextCtrl::CanRedo, 1260 wxTextCtrl::CanUndo, 1260 wxTextCtrl::Clear, 1260 wxTextCtrl::Copy, 1260 wxTextCtrl::Create, 1261 wxTextCtrl::Cut, 1261 wxTextCtrl::DiscardEdits, 1261 wxTextCtrl::EmulateKeyPress, 1261 wxTextCtrl::GetDefaultStyle, 1261 wxTextCtrl::GetInsertionPoint, 1262 wxTextCtrl::GetLastPosition, 1262 wxTextCtrl::GetLineLength, 1262 wxTextCtrl::GetLineText, 1262 wxTextCtrl::GetNumberOfLines, 1263 wxTextCtrl::GetRange, 1263 wxTextCtrl::GetSelection, 1263 wxTextCtrl::GetStringSelection, 1264 wxTextCtrl::GetStyle, 1264 wxTextCtrl::GetValue, 1264 wxTextCtrl::HitTest, 1264 wxTextCtrl::IsEditable, 1265 wxTextCtrl::IsModified, 1265 wxTextCtrl::IsMultiLine, 1265 wxTextCtrl::IsSingleLine, 1265 wxTextCtrl::LoadFile, 1265 wxTextCtrl::OnDropFiles, 1266 wxTextCtrl::operator <<, 1272 wxTextCtrl::Paste, 1266 wxTextCtrl::PositionToXY, 1266 wxTextCtrl::Redo, 1267 wxTextCtrl::Remove, 1267 wxTextCtrl::Replace, 1267 wxTextCtrl::SaveFile, 1268 wxTextCtrl::SetDefaultStyle, 1268 wxTextCtrl::SetEditable, 1269 wxTextCtrl::SetInsertionPoint, 1269 wxTextCtrl::SetInsertionPointEnd, 1269 wxTextCtrl::SetMaxLength, 1269 wxTextCtrl::SetSelection, 1270 wxTextCtrl::SetStyle, 1270 wxTextCtrl::SetValue, 1271 wxTextCtrl::ShowPosition, 1271 wxTextCtrl::Undo, 1271 wxTextCtrl::WriteText, 1271 wxTextCtrl::wxTextCtrl, 1258 wxTextCtrl::XYToPosition, 1272 wxTextDataObject, 1273 wxTextDataObject::GetText, 1274 wxTextDataObject::GetTextLength, 1274 wxTextDataObject::SetText, 1274 wxTextDataObject::wxTextDataObject, 1273 wxTextDropTarget, 1274 wxTextDropTarget::OnDrop, 1275 wxTextDropTarget::OnDropText, 1275 wxTextDropTarget::wxTextDropTarget, 1274 wxTextEntryDialog, 1276 wxTextEntryDialog overview, 1661 wxTextEntryDialog::~wxTextEntryDialog, 1276 wxTextEntryDialog::GetValue, 1276 wxTextEntryDialog::SetValue, 1277 wxTextEntryDialog::ShowModal, 1277 wxTextEntryDialog::wxTextEntryDialog, 1276 wxTextFile, 1278 wxTextFile::~wxTextFile, 1278 wxTextFile::AddLine, 1278 wxTextFile::Clear, 1282 wxTextFile::Close, 1279 wxTextFile::Create, 1279 wxTextFile::Eof, 1280 wxTextFile::Exists, 1279 wxTextFile::GetCurrentLine, 1280 wxTextFile::GetEOL, 1280 wxTextFile::GetFirstLine, 1280 wxTextFile::GetLastLine, 1281 wxTextFile::GetLine, 1279 wxTextFile::GetLineCount, 1279 wxTextFile::GetLineType, 1281 wxTextFile::GetName, 1282 wxTextFile::GetNextLine, 1281 wxTextFile::GetPrevLine, 1281 wxTextFile::GoToLine, 1280 wxTextFile::GuessType, 1281 wxTextFile::InsertLine, 1282 wxTextFile::IsOpened, 1279 wxTextFile::Open, 1282 wxTextFile::operator[], 1280 wxTextFile::RemoveLine, 1282 wxTextFile::Write, 1282 wxTextFile::wxTextFile, 1278 wxTextInputStream, 1283 wxTextInputStream::~wxTextInputStream, 1284 wxTextInputStream::Read16, 1284 wxTextInputStream::Read16S, 1285 wxTextInputStream::Read32, 1285 wxTextInputStream::Read32S, 1285 wxTextInputStream::Read8, 1284 wxTextInputStream::Read8S, 1284 wxTextInputStream::ReadChar, 1285 wxTextInputStream::ReadDouble, 1285 wxTextInputStream::ReadLine, 1285 wxTextInputStream::ReadString, 1285 wxTextInputStream::ReadWord, 1286 wxTextInputStream::SetStringSeparators, 1286 wxTextInputStream::wxTextInputStream, 1283 wxTextOutputStream, 1286 wxTextOutputStream::~wxTextOutputStream, 1287 wxTextOutputStream::GetMode, 1287 wxTextOutputStream::SetMode, 1287 wxTextOutputStream::Write16, 1287 wxTextOutputStream::Write32, 1287 wxTextOutputStream::Write8, 1287 wxTextOutputStream::WriteDouble, 1288 wxTextOutputStream::WriteString, 1288 wxTextOutputStream::wxTextOutputStream, 1286 wxTextValidator, 1288 wxTextValidator::~wxTextValidator, 1289 wxTextValidator::Clone, 1289 wxTextValidator::GetExcludeList, 1290

1797


INDEX
wxTextValidator::GetIncludeList, 1290 wxTextValidator::GetStyle, 1290 wxTextValidator::OnChar, 1290 wxTextValidator::SetExcludeList, 1290 wxTextValidator::SetIncludeList, 1290 wxTextValidator::SetStyle, 1290 wxTextValidator::TransferFromWindow, 1290 wxTextValidator::TransferToWindow, 1291 wxTextValidator::Validate, 1291 wxTextValidator::wxTextValidator, 1288 wxTHICK_FRAME, 371, 875, 880, 927 wxThread, 1292 wxThread::~wxThread, 1292 wxThread::~wxThreadHelper, 1299 wxThread::Create, 1292 wxThread::Delete, 1293 wxThread::Entry, 1293 wxThread::Exit, 1293 wxThread::GetCPUCount, 1294 wxThread::GetCurrentId, 1294 wxThread::GetId, 1294 wxThread::GetPriority, 1294 wxThread::IsAlive, 1294 wxThread::IsDetached, 1295 wxThread::IsMain, 1295 wxThread::IsPaused, 1295 wxThread::IsRunning, 1295 wxThread::Kill, 1295 wxThread::OnExit, 1296 wxThread::Pause, 1296 wxThread::Resume, 1297 wxThread::Run, 1296 wxThread::SetConcurrency, 1297 wxThread::SetPriority, 1296 wxThread::Sleep, 1296 wxThread::TestDestroy, 1297 wxThread::This, 1297 wxThread::Wait, 1298 wxThread::wxThread, 1292 wxThread::Yield, 1297 wxThreadHelper, 1298 wxThreadHelper::Create, 1299 wxThreadHelper::Entry, 1299 wxThreadHelper::GetThread, 1299 wxThreadHelper::m_thread, 1299 wxThreadHelper::wxThreadHelper, 1298 wxThreadHelperThread, 1300 wxThreadHelperThread::CallEntry, 1301 wxThreadHelperThread::Entry, 1300 wxThreadHelperThread::m_owner, 1300 wxThreadHelperThread::wxThreadHelperThread, 1300 wxTIFFHandler, 733 wxTimer, 1302 wxTimer::~wxTimer, 1302 wxTimer::GetInterval, 1302 wxTimer::IsOneShot, 1302 wxTimer::IsRunning, 1302 wxTimer::Notify, 1302 wxTimer::SetOwner, 1303 wxTimer::Start, 1303 wxTimer::Stop, 1303 wxTimer::wxTimer, 1302 wxTimerEvent::GetInterval, 1304 wxTimeSpan, 1310 wxTimeSpan::Abs, 1306 wxTimeSpan::Add, 1306 wxTimeSpan::Day, 1306 wxTimeSpan::Days, 1306 wxTimeSpan::Format, 1306 wxTimeSpan::GetDays, 1307 wxTimeSpan::GetHours, 1307 wxTimeSpan::GetMilliseconds, 1307 wxTimeSpan::GetMinutes, 1307 wxTimeSpan::GetSeconds, 1307 wxTimeSpan::GetValue, 1307 wxTimeSpan::GetWeeks, 1308 wxTimeSpan::Hour, 1308 wxTimeSpan::Hours, 1308 wxTimeSpan::IsEqualTo, 1308 wxTimeSpan::IsLongerThan, 1308 wxTimeSpan::IsNegative, 1308 wxTimeSpan::IsNull, 1308 wxTimeSpan::IsPositive, 1309 wxTimeSpan::IsShorterThan, 1309 wxTimeSpan::Minute, 1309 wxTimeSpan::Minutes, 1309 wxTimeSpan::Multiply, 1309 wxTimeSpan::Neg, 1309 wxTimeSpan::Negate, 1309 wxTimeSpan::Second, 1310 wxTimeSpan::Seconds, 1310 wxTimeSpan::Substract, 1310 wxTimeSpan::Week, 1310 wxTimeSpan::Weeks, 1310 wxTimeSpan::wxTimeSpan, 1310 wxTINY_CAPTION_HORIZ, 927 wxTINY_CAPTION_VERT, 927 wxTipProvider, 1311 wxTipProvider::GetTip, 1311 wxTipProvider::PreprocessTip, 1311 wxTipProvider::wxTipProvider, 1311 wxTipWindow, 1312 wxTipWindow::SetBoundingRect, 1313 wxTipWindow::SetTipWindowPtr, 1313 wxTipWindow::wxTipWindow, 1312 wxToggleButton, 1314 wxToggleButton::~wxToggleButton, 1315 wxToggleButton::Create, 1315 wxToggleButton::GetValue, 1315 wxToggleButton::SetValue, 1316 wxToggleButton::wxToggleButton, 1314 wxToolBar, 1318 wxToolBar::~wxToolBar, 1319 wxToolBar::AddCheckTool, 1321 wxToolBar::AddControl, 1319 wxToolBar::AddRadioTool, 1321 wxToolBar::AddSeparator, 1319 wxToolBar::AddTool, 1320 wxToolBar::DeleteTool, 1322 wxToolBar::DeleteToolByPos, 1322 wxToolBar::EnableTool, 1322 wxToolBar::FindById, 1323 wxToolBar::FindControl, 1323

1798


INDEX
wxToolBar::FindToolForPosition, 1323 wxToolBar::GetMargins, 1324 wxToolBar::GetToolBitmapSize, 1324 wxToolBar::GetToolClientData, 1324 wxToolBar::GetToolEnabled, 1324 wxToolBar::GetToolLongHelp, 1325 wxToolBar::GetToolPacking, 1325 wxToolBar::GetToolPos, 1325 wxToolBar::GetToolSeparation, 1325 wxToolBar::GetToolShortHelp, 1326 wxToolBar::GetToolSize, 1323 wxToolBar::GetToolState, 1326 wxToolBar::InsertControl, 1326 wxToolBar::InsertSeparator, 1327 wxToolBar::InsertTool, 1327 wxToolBar::OnLeftClick, 1327 wxToolBar::OnMouseEnter, 1328 wxToolBar::OnRightClick, 1328 wxToolBar::Realize, 1329 wxToolBar::RemoveTool, 1329 wxToolBar::SetMargins, 1329 wxToolBar::SetToolBitmapSize, 1330 wxToolBar::SetToolClientData, 1330 wxToolBar::SetToolLongHelp, 1330 wxToolBar::SetToolPacking, 1331 wxToolBar::SetToolSeparation, 1332 wxToolBar::SetToolShortHelp, 1331 wxToolBar::ToggleTool, 1332 wxToolBar::wxToolBar, 1318 wxToolTip, 1333 wxToolTip::Enable, 1333 wxToolTip::GetTip, 1333 wxToolTip::GetWindow, 1333 wxToolTip::SetDelay, 1333 wxToolTip::SetTip, 1333 wxToolTip::wxToolTip, 1333 wxTR_DEFAULT_STYLE, 1335 wxTR_EDIT_LABELS, 1334 wxTR_EXTENDED, 1335 wxTR_FULL_ROW_HIGHLIGHT, 1334 wxTR_HAS_BUTTONS, 1334 wxTR_HAS_VARIABLE_ROW_HEIGHT, 1334 wxTR_HIDE_ROOT, 1334 wxTR_LINES_AT_ROOT, 1334 wxTR_MULTIPLE, 1335 wxTR_NO_BUTTONS, 1334 wxTR_NO_LINES, 1334 wxTR_ROW_LINES, 1334 wxTR_SINGLE, 1335 wxTR_TWIST_BUTTONS, 1334 wxTrace, 1533 WXTRACE, 1533 wxTraceLevel, 1534 WXTRACELEVEL, 1533 wxTransferFileToStream, 1487 wxTransferStreamToFile, 1487 wxTRANSLATE, 1494 wxTRANSPARENT_WINDOW, 1394 wxTrap, 1540 wxTreeCtrl, 1336, 1339 wxTreeCtrl::~wxTreeCtrl, 1337 wxTreeCtrl::AddRoot, 1337 wxTreeCtrl::AppendItem, 1337 wxTreeCtrl::AssignButtonsImageList, 1338 wxTreeCtrl::AssignImageList, 1338 wxTreeCtrl::AssignStateImageList, 1338 wxTreeCtrl::Collapse, 1338 wxTreeCtrl::CollapseAndReset, 1338 wxTreeCtrl::Create, 1338 wxTreeCtrl::Delete, 1339 wxTreeCtrl::DeleteAllItems, 1339 wxTreeCtrl::DeleteChildren, 1339 wxTreeCtrl::EditLabel, 1339 wxTreeCtrl::EndEditLabel, 1340 wxTreeCtrl::EnsureVisible, 1340 wxTreeCtrl::Expand, 1340 wxTreeCtrl::GetBoundingRect, 1340 wxTreeCtrl::GetButtonsImageList, 1340 wxTreeCtrl::GetChildrenCount, 1341 wxTreeCtrl::GetCount, 1341 wxTreeCtrl::GetEditControl, 1341 wxTreeCtrl::GetFirstChild, 1341 wxTreeCtrl::GetFirstVisibleItem, 1341 wxTreeCtrl::GetImageList, 1342 wxTreeCtrl::GetIndent, 1342 wxTreeCtrl::GetItemBackgroundColour, 1342 wxTreeCtrl::GetItemData, 1342 wxTreeCtrl::GetItemFont, 1343 wxTreeCtrl::GetItemImage, 1343 wxTreeCtrl::GetItemParent, 1344 wxTreeCtrl::GetItemSelectedImage, 1345 wxTreeCtrl::GetItemText, 1343 wxTreeCtrl::GetItemTextColour, 1343 wxTreeCtrl::GetLastChild, 1343 wxTreeCtrl::GetNextChild, 1344 wxTreeCtrl::GetNextSibling, 1344 wxTreeCtrl::GetNextVisible, 1344 wxTreeCtrl::GetParent, 1345 wxTreeCtrl::GetPrevSibling, 1345 wxTreeCtrl::GetPrevVisible, 1345 wxTreeCtrl::GetRootItem, 1345 wxTreeCtrl::GetSelection, 1345 wxTreeCtrl::GetSelections, 1346 wxTreeCtrl::GetStateImageList, 1346 wxTreeCtrl::HitTest, 1346 wxTreeCtrl::InsertItem, 1347 wxTreeCtrl::IsBold, 1347 wxTreeCtrl::IsExpanded, 1347 wxTreeCtrl::IsSelected, 1347 wxTreeCtrl::IsVisible, 1348 wxTreeCtrl::ItemHasChildren, 1348 wxTreeCtrl::OnCompareItems, 1348 wxTreeCtrl::PrependItem, 1348 wxTreeCtrl::ScrollTo, 1348 wxTreeCtrl::SelectItem, 1348 wxTreeCtrl::SetButtonsImageList, 1349 wxTreeCtrl::SetImageList, 1349 wxTreeCtrl::SetIndent, 1349 wxTreeCtrl::SetItemBackgroundColour, 1349 wxTreeCtrl::SetItemBold, 1349 wxTreeCtrl::SetItemData, 1349 wxTreeCtrl::SetItemFont, 1350 wxTreeCtrl::SetItemHasChildren, 1350 wxTreeCtrl::SetItemImage, 1350

1799


INDEX
wxTreeCtrl::SetItemSelectedImage, 1350 wxTreeCtrl::SetItemText, 1351 wxTreeCtrl::SetItemTextColour, 1351 wxTreeCtrl::SetStateImageList, 1351 wxTreeCtrl::SortChildren, 1351 wxTreeCtrl::Toggle, 1351 wxTreeCtrl::ToggleItemSelection, 1352 wxTreeCtrl::Unselect, 1352 wxTreeCtrl::UnselectAll, 1352 wxTreeCtrl::UnselectItem, 1352 wxTreeCtrl::wxTreeCtrl, 1336 wxTreeEvent, 1354 wxTreeEvent::GetItem, 1354 wxTreeEvent::GetKeyCode, 1354 wxTreeEvent::GetKeyEvent, 1354 wxTreeEvent::GetLabel, 1354 wxTreeEvent::GetOldItem, 1355 wxTreeEvent::GetPoint(), 1355 wxTreeEvent::IsEditCancelled(), 1355 wxTreeEvent::SetToolTip, 1355 wxTreeEvent::wxTreeEvent, 1354 wxTreeItemData, 1356 wxTreeItemData::~wxTreeItemData, 1356 wxTreeItemData::GetId, 1356 wxTreeItemData::SetId, 1356 wxTreeItemData::wxTreeItemData, 1356 wxUINT16_SWAP_ALWAYS, 1521 wxUINT16_SWAP_ON_BE, 1521 wxUINT16_SWAP_ON_LE, 1522 wxUINT32_SWAP_ALWAYS, 1521 wxUINT32_SWAP_ON_BE, 1521 wxUINT32_SWAP_ON_LE, 1522 wxULL, 1520 wxUninitialize, 1475 wxUnix2DosFilename, 1485 wxUnsetEnv, 1541 wxUpdateUIEvent, 1358 wxUpdateUIEvent::CanUpdate, 1359 wxUpdateUIEvent::Check, 1359 wxUpdateUIEvent::Enable, 1359 wxUpdateUIEvent::GetChecked, 1360 wxUpdateUIEvent::GetEnabled, 1360 wxUpdateUIEvent::GetMode, 1360 wxUpdateUIEvent::GetSetChecked, 1360 wxUpdateUIEvent::GetSetEnabled, 1360 wxUpdateUIEvent::GetSetText, 1360 wxUpdateUIEvent::GetText, 1360 wxUpdateUIEvent::GetUpdateInterval, 1361 wxUpdateUIEvent::m_checked, 1358 wxUpdateUIEvent::m_enabled, 1358 wxUpdateUIEvent::m_setChecked, 1358 wxUpdateUIEvent::m_setEnabled, 1359 wxUpdateUIEvent::m_setText, 1359 wxUpdateUIEvent::m_text, 1359 wxUpdateUIEvent::ResetUpdateTime, 1361 wxUpdateUIEvent::SetMode, 1361 wxUpdateUIEvent::SetText, 1361 wxUpdateUIEvent::SetUpdateInterval, 1362 wxUpdateUIEvent::wxUpdateUIEvent, 1358 wxURL, 1362 wxURL::~wxURL, 1363 wxURL::ConvertToValidURI, 1364 wxURL::GetError, 1363 wxURL::GetInputStream, 1363 wxURL::GetPath, 1363 wxURL::GetProtocol, 1363 wxURL::GetProtocolName, 1363 wxURL::SetDefaultProxy, 1364 wxURL::SetProxy, 1364 wxURL::wxURL, 1362 wxUsleep, 1536 wxValidator, 1365 wxValidator::~wxValidator, 1365 wxValidator::Clone, 1365 wxValidator::GetWindow, 1366 wxValidator::SetBellOnError, 1366 wxValidator::SetWindow, 1366 wxValidator::TransferFromWindow, 1366 wxValidator::TransferToWindow, 1366 wxValidator::Validate, 1366 wxValidator::wxValidator, 1365 wxVariant, 1367, 1368 wxVariant::~wxVariant, 1368 wxVariant::Append, 1368 wxVariant::ClearList, 1369 wxVariant::Delete, 1369 wxVariant::GetBool, 1369 wxVariant::GetChar, 1369 wxVariant::GetCount, 1369 wxVariant::GetData, 1369 wxVariant::GetDouble, 1369 wxVariant::GetLong, 1369 wxVariant::GetName, 1370 wxVariant::GetString, 1370 wxVariant::GetType, 1370 wxVariant::GetVoidPtr, 1370 wxVariant::GetWxObjectPtr, 1370 wxVariant::Insert, 1370 wxVariant::IsNull, 1370 wxVariant::IsType, 1371 wxVariant::IsValueKindOf, 1371 wxVariant::MakeNull, 1371 wxVariant::MakeString, 1371 wxVariant::Member, 1371 wxVariant::NullList, 1371 wxVariant::operator !=, 1372 wxVariant::operator [], 1373 wxVariant::operator =, 1372 wxVariant::operator ==, 1372 wxVariant::operator char, 1373 wxVariant::operator double, 1373 wxVariant::operator void*, 1374 wxVariant::operator wxString, 1373 wxVariant::SetData, 1371 wxVariant::wxVariant, 1367 wxVariantData, 1374 wxVariantData::Copy, 1374 wxVariantData::Eq, 1374 wxVariantData::GetType, 1375 wxVariantData::GetValueClassInfo, 1375 wxVariantData::Read, 1375 wxVariantData::Write, 1375 wxVariantData::wxVariantData, 1374 wxView, 1376

1800


INDEX
wxView overview, 1664 wxView::~wxView, 1376 wxView::Activate, 1377 wxView::Close, 1377 wxView::GetDocument, 1377 wxView::GetDocumentManager, 1377 wxView::GetFrame, 1377 wxView::GetViewName, 1377 wxView::m_viewDocument, 1376 wxView::m_viewFrame, 1376 wxView::m_viewTypeName, 1376 wxView::OnActivateView, 1378 wxView::OnChangeFilename, 1378 wxView::OnClose, 1378 wxView::OnClosingDocument, 1378 wxView::OnCreate, 1378 wxView::OnCreatePrintout, 1378 wxView::OnUpdate, 1379 wxView::SetDocument, 1379 wxView::SetFrame, 1379 wxView::SetViewName, 1379 wxView::wxView, 1376 wxVListBox, 1380 wxVListBox::Clear, 1380 wxVListBox::Create, 1380 wxVListBox::DeselectAll, 1381 wxVListBox::GetFirstSelected, 1381 wxVListBox::GetItemCount, 1381 wxVListBox::GetMargins, 1381 wxVListBox::GetNextSelected, 1382 wxVListBox::GetSelectedCount, 1382 wxVListBox::GetSelection, 1382 wxVListBox::GetSelectionBackground, 1382 wxVListBox::HasMultipleSelection, 1383 wxVListBox::IsCurrent, 1383 wxVListBox::IsSelected, 1383 wxVListBox::OnDrawBackground, 1383 wxVListBox::OnDrawItem, 1383 wxVListBox::OnDrawSeparator, 1384 wxVListBox::OnMeasureItem, 1384 wxVListBox::Select, 1384 wxVListBox::SelectAll, 1385 wxVListBox::SelectRange, 1385 wxVListBox::SetItemCount, 1385 wxVListBox::SetMargins, 1385 wxVListBox::SetSelection, 1385 wxVListBox::SetSelectionBackground, 1386 wxVListBox::Toggle, 1386 wxVListBox::wxVListBox, 1380 wxVLogDebug, 1531 wxVLogError, 1529 wxVLogFatalError, 1529 wxVLogMessage, 1530 wxVLogStatus, 1530 wxVLogSysError, 1530 wxVLogTrace, 1531 wxVLogVerbose, 1530 wxVLogWarning, 1529 wxVSCROLL, 880, 1394 wxVScrolledWindow, 1387 wxVScrolledWindow::Create, 1388 wxVScrolledWindow::EstimateTotalHeight, 1388 wxVScrolledWindow::GetFirstVisibleLine, 1388 wxVScrolledWindow::GetLastVisibleLine, 1388 wxVScrolledWindow::GetLineCount, 1388 wxVScrolledWindow::HitTest, 1389 wxVScrolledWindow::IsVisible, 1389 wxVScrolledWindow::OnGetLineHeight, 1389 wxVScrolledWindow::OnGetLinesHint, 1389 wxVScrolledWindow::RefreshAll, 1390 wxVScrolledWindow::RefreshLine, 1389 wxVScrolledWindow::RefreshLines, 1390 wxVScrolledWindow::ScrollLines, 1390 wxVScrolledWindow::ScrollPages, 1390 wxVScrolledWindow::ScrollToLine, 1391 wxVScrolledWindow::SetLineCount, 1391 wxVScrolledWindow::wxVScrolledWindow, 1387 wxVsnprintf, 1495 wxWakeUpIdle, 1475 wxWANTS_CHARS, 1394 wxWindow, 1396 wxWindow::~wxWindow, 1396 wxWindow::AddChild, 1397 wxWindow::CaptureMouse, 1397 wxWindow::Center, 1397 wxWindow::CenterOnParent, 1397 wxWindow::CenterOnScreen, 1397 wxWindow::Centre, 1398 wxWindow::CentreOnParent, 1398 wxWindow::CentreOnScreen, 1398 wxWindow::ClearBackground, 1399 wxWindow::ClientToScreen, 1399 wxWindow::Close, 1400 wxWindow::ConvertDialogToPixels, 1400 wxWindow::ConvertPixelsToDialog, 1401 wxWindow::Destroy, 1402 wxWindow::DestroyChildren, 1402 wxWindow::Disable, 1402 wxWindow::DoUpdateWindowUI, 1402 wxWindow::DragAcceptFiles, 1403 wxWindow::Enable, 1403 wxWindow::FindFocus, 1404 wxWindow::FindWindow, 1404 wxWindow::FindWindowById, 1404 wxWindow::FindWindowByLabel, 1405 wxWindow::FindWindowByName, 1404 wxWindow::Fit, 1405 wxWindow::FitInside, 1405 wxWindow::Freeze, 1406 wxWindow::GetAcceleratorTable, 1406 wxWindow::GetAccessible, 1406 wxWindow::GetAdjustedBestSize, 1406 wxWindow::GetBackgroundColour, 1406 wxWindow::GetBestSize, 1407 wxWindow::GetCapture, 1407 wxWindow::GetCaret, 1407 wxWindow::GetCharHeight, 1407 wxWindow::GetCharWidth, 1407 wxWindow::GetChildren, 1407 wxWindow::GetClientSize, 1407 wxWindow::GetConstraints, 1408 wxWindow::GetContainingSizer, 1408 wxWindow::GetCursor, 1408 wxWindow::GetDropTarget, 1409

1801


INDEX
wxWindow::GetEventHandler, 1409 wxWindow::GetExtraStyle, 1409 wxWindow::GetFont, 1409 wxWindow::GetForegroundColour, 1409 wxWindow::GetGrandParent, 1410 wxWindow::GetHandle, 1410 wxWindow::GetHelpText, 1410 wxWindow::GetId, 1410 wxWindow::GetLabel, 1411 wxWindow::GetName, 1411 wxWindow::GetParent, 1411 wxWindow::GetPosition, 1411 wxWindow::GetRect, 1412 wxWindow::GetScrollPos, 1412 wxWindow::GetScrollRange, 1412 wxWindow::GetScrollThumb, 1412 wxWindow::GetSize, 1413 wxWindow::GetSizer, 1413 wxWindow::GetTextExtent, 1414 wxWindow::GetTitle, 1414 wxWindow::GetToolTip, 1415 wxWindow::GetUpdateRegion, 1415 wxWindow::GetValidator, 1415 wxWindow::GetVirtualSize, 1415 wxWindow::GetWindowStyleFlag, 1416 wxWindow::HasCapture, 1416 wxWindow::Hide, 1416 wxWindow::InitDialog, 1416 wxWindow::IsEnabled, 1416 wxWindow::IsExposed, 1416 wxWindow::IsRetained, 1417 wxWindow::IsShown, 1417 wxWindow::IsTopLevel, 1417 wxWindow::Layout, 1417 wxWindow::LineDown, 1418 wxWindow::LineUp, 1418 wxWindow::Lower, 1418 wxWindow::MakeModal, 1418 wxWindow::Move, 1418 wxWindow::OnInternalIdle, 1419 wxWindow::PageDown, 1419 wxWindow::PageUp, 1419 wxWindow::PopEventHandler, 1419 wxWindow::PopupMenu, 1420 wxWindow::PushEventHandler, 1421 wxWindow::Raise, 1421 wxWindow::Refresh, 1421 wxWindow::RefreshRect, 1422 wxWindow::RegisterHotKey, 1422 wxWindow::ReleaseMouse, 1423 wxWindow::RemoveChild, 1423 wxWindow::RemoveEventHandler, 1423 wxWindow::Reparent, 1424 wxWindow::ScreenToClient, 1424 wxWindow::ScrollLines, 1424 wxWindow::ScrollPages, 1425 wxWindow::ScrollWindow, 1425 wxWindow::SetAcceleratorTable, 1426 wxWindow::SetAccessible, 1426 wxWindow::SetAutoLayout, 1426 wxWindow::SetBackgroundColour, 1426 wxWindow::SetCaret, 1427 wxWindow::SetClientSize, 1427 wxWindow::SetConstraints, 1428 wxWindow::SetContainingSizer, 1428 wxWindow::SetCursor, 1428 wxWindow::SetDropTarget, 1429 wxWindow::SetEventHandler, 1429 wxWindow::SetExtraStyle, 1429 wxWindow::SetFocus, 1430 wxWindow::SetFocusFromKbd, 1431 wxWindow::SetFont, 1431 wxWindow::SetForegroundColour, 1431 wxWindow::SetHelpText, 1432 wxWindow::SetId, 1432 wxWindow::SetName, 1432 wxWindow::SetPalette, 1432 wxWindow::SetScrollbar, 1433 wxWindow::SetScrollPos, 1434 wxWindow::SetSize, 1434 wxWindow::SetSizeHints, 1436 wxWindow::SetSizer, 1436 wxWindow::SetSizerAndFit, 1437 wxWindow::SetThemeEnabled, 1437 wxWindow::SetTitle, 1437 wxWindow::SetToolTip, 1438 wxWindow::SetValidator, 1438 wxWindow::SetVirtualSize, 1438 wxWindow::SetVirtualSizeHints, 1438 wxWindow::SetWindowStyle, 1439 wxWindow::SetWindowStyleFlag, 1439 wxWindow::Show, 1439 wxWindow::Thaw, 1440 wxWindow::TransferDataFromWindow, 1440 wxWindow::TransferDataToWindow, 1440 wxWindow::UnregisterHotKey, 1440 wxWindow::Update, 1441 wxWindow::UpdateWindowUI, 1441 wxWindow::Validate, 1442 wxWindow::WarpPointer, 1442 wxWindow::wxWindow, 1395 wxWindowDC, 1443 wxWindowDC::wxWindowDC, 1443 wxWindowDisabler, 1444 wxWindowDisabler::~wxWindowDisabler, 1444 wxWindowDisabler::wxWindowDisabler, 1444 wxWindows 1.xx compatibility functions, 1209 wxWindows classes implemented in wxPython, 1717 wxWindows predefined command identifiers, 1667 wxWizard, 1445 wxWizard::Create, 1446 wxWizard::FitToPage, 1447 wxWizard::GetCurrentPage, 1447 wxWizard::GetPageAreaSizer, 1447 wxWizard::GetPageSize, 1448 wxWizard::HasNextPage, 1448 wxWizard::HasPrevPage, 1448 wxWizard::RunWizard, 1448 wxWizard::SetBorder, 1449 wxWizard::SetPageSize, 1449 wxWizard::wxWizard, 1445 wxWIZARD_EX_HELPBUTTON, 1445

1802


INDEX
wxWizardEvent, 1450 wxWizardEvent::GetDirection, 1450 wxWizardEvent::GetPage, 1450 wxWizardEvent::wxWizardEvent, 1450 wxWizardPage, 1451 wxWizardPage::GetBitmap, 1452 wxWizardPage::GetNext, 1452 wxWizardPage::GetPrev, 1451 wxWizardPage::wxWizardPage, 1451 wxWizardPageSimple, 1453 wxWizardPageSimple::Chain, 1453 wxWizardPageSimple::SetNext, 1453 wxWizardPageSimple::SetPrev, 1453 wxWizardPageSimple::wxWizardPageSimple, 1453 wxWriteResource, 1520 wxWS_EX_BLOCK_EVENTS, 1395, 1430 wxWS_EX_PROCESS_IDLE, 1395, 1430 wxWS_EX_PROCESS_UI_UPDATES, 1395, 1430 wxWS_EX_TRANSIENT, 1395, 1430 wxWS_EX_VALIDATE_RECURSIVELY, 1395, 1430 wxXmlResource, 1454 wxXmlResource::~wxXmlResource, 1455 wxXmlResource::AddHandler, 1455 wxXmlResource::AttachUnknownControl, 1455 wxXmlResource::ClearHandlers, 1455 wxXmlResource::CompareVersion, 1455 wxXmlResource::CreateResFromNode, 1455 wxXmlResource::DoFindResource, 1455 wxXmlResource::FindResource, 1456 wxXmlResource::Get, 1456 wxXmlResource::GetFlags, 1456 wxXmlResource::GetVersion, 1456 wxXmlResource::GetXRCID, 1456 wxXmlResource::InitAllHandlers, 1456 wxXmlResource::Load, 1457 wxXmlResource::LoadBitmap, 1457 wxXmlResource::LoadDialog, 1457 wxXmlResource::LoadFrame, 1457 wxXmlResource::LoadIcon, 1457 wxXmlResource::LoadMenu, 1457 wxXmlResource::LoadMenuBar, 1458 wxXmlResource::LoadPanel, 1458 wxXmlResource::LoadToolBar, 1458 wxXmlResource::Set, 1458 wxXmlResource::SetFlags, 1458 wxXmlResource::UpdateResources, 1458 wxXmlResource::wxXmlResource, 1454 wxXmlResourceHandler, 1459 wxXmlResourceHandler::~wxXmlResourceHandl er, 1459 wxXmlResourceHandler::AddStyle, 1459 wxXmlResourceHandler::AddWindowStyles, 1459 wxXmlResourceHandler::CanHandle, 1460 wxXmlResourceHandler::CreateChildren, 1460 wxXmlResourceHandler::CreateChildrenPrivately , 1460 wxXmlResourceHandler::CreateResFromNode, 1460 wxXmlResourceHandler::CreateResource, 1460 wxXmlResourceHandler::DoCreateResource, 1460 wxXmlResourceHandler::GetBitmap, 1461 wxXmlResourceHandler::GetBool, 1461 wxXmlResourceHandler::GetColour, 1461 wxXmlResourceHandler::GetCurFileSystem, 1461 wxXmlResourceHandler::GetDimension, 1461 wxXmlResourceHandler::GetFont, 1461 wxXmlResourceHandler::GetIcon, 1461 wxXmlResourceHandler::GetID, 1461 wxXmlResourceHandler::GetLong, 1462 wxXmlResourceHandler::GetName, 1462 wxXmlResourceHandler::GetNodeContent, 1462 wxXmlResourceHandler::GetParamNode, 1462 wxXmlResourceHandler::GetParamValue, 1462 wxXmlResourceHandler::GetPosition, 1462 wxXmlResourceHandler::GetSize, 1462 wxXmlResourceHandler::GetStyle, 1463 wxXmlResourceHandler::GetText, 1463 wxXmlResourceHandler::HasParam, 1463 wxXmlResourceHandler::IsOfClass, 1463 wxXmlResourceHandler::SetParentResource, 1463 wxXmlResourceHandler::SetupWindow, 1463 wxXmlResourceHandler::wxXmlResourceHandle r, 1459 wxXPMHandler, 733 wxYield, 1475 wxZipInputStream, 1464 wxZipInputStream::wxZipInputStream, 1464 wxZlibInputStream, 1465 wxZlibInputStream::wxZlibInputStream, 1465 wxZlibOutputStream, 1465 wxZlibOutputStream::wxZlibOutputStream, 1465

--X--
x, 1047 x, 996 x, 1048 Xor, 1061, 1062 XRC C++ sample, 1641 XRC concepts, 1638 XRC file format, 1645 XRC resource file sample, 1643 XToCol, 601 XToEdgeOfCol, 602 XYToPosition, 1272

--Y--
y, 996, 1047 y, 1048 Year, 237 Years, 237 Yield, 42, 1297 YToEdgeOfRow, 602 YToRow, 602

1803


1804


